From db7103ffb49fe3962df13b4e0e5d17da23ef2be9 Mon Sep 17 00:00:00 2001
From: Baha Shaaban <baha.shaaban@securekey.com>
Date: Fri, 24 May 2019 16:14:36 -0400
Subject: [PATCH 3/3] upgrade gossip protos to 2.0

	Since Transient Data backport to Fabric 1.4.1
	depends on trustbloc/fabric-peer-ext, it must
	upgrade to the same gossip protos version.

	Also updated additional files to pass compilation & linter
	including unused references to DCAS and OFFledger
	(these are placeholders for fabric-peer-ext)

Change-Id: I1b5b25b816f044de1a2a2aa257683fedc3056f30
Signed-off-by: Baha Shaaban <baha.shaaban@securekey.com>
---
 bccsp/grep11/client.go                             |   6 +-
 bccsp/grep11/conf.go                               |   2 +-
 bccsp/grep11/impl.go                               |   4 +-
 bccsp/grep11/protos/grep11.pb.go                   |   3 +-
 core/chaincode/exectransaction_test.go             |   2 +-
 core/ledger/kvledger/idstore/idstore.go            |  25 +
 core/ledger/kvledger/idstore/readme.md             |   2 +
 .../txmgmt/rwsetutil/rwset_proto_util_test.go      |   2 +-
 core/ledger/pvtdatastorage/store.go                |   5 -
 core/ledger/util/couchdb/couchdb_ext.go            |  12 +
 core/peer/peer_test.go                             |  11 +-
 discovery/client/api.go                            |   6 +-
 discovery/client/client.go                         |  16 +-
 discovery/client/client_test.go                    |   7 +-
 discovery/client/selection.go                      |   4 +-
 discovery/client/selection_test.go                 |  15 +-
 discovery/cmd/endorsers.go                         |  11 +-
 discovery/cmd/peers_test.go                        |  11 +-
 discovery/service_test.go                          |   5 +-
 discovery/support/gossip/support_test.go           |   3 +-
 discovery/support/mocks/gossip.go                  |  47 +-
 discovery/test/integration_test.go                 |   9 +-
 go.mod                                             |  13 +-
 go.sum                                             |  14 +-
 gossip/comm/ack.go                                 |  12 +-
 gossip/comm/ack_test.go                            |  16 +-
 gossip/comm/comm.go                                |   8 +-
 gossip/comm/comm_impl.go                           |  47 +-
 gossip/comm/comm_test.go                           |  48 +-
 gossip/comm/conn.go                                |  17 +-
 gossip/comm/mock/mock_comm.go                      |  19 +-
 gossip/comm/mock/mock_comm_test.go                 |  13 +-
 gossip/comm/msg.go                                 |  11 +-
 gossip/discovery/discovery.go                      |  15 +-
 gossip/discovery/discovery_impl.go                 |  96 +--
 gossip/discovery/discovery_test.go                 | 145 ++--
 gossip/election/adapter.go                         |   5 +-
 gossip/election/adapter_test.go                    |   7 +-
 gossip/gossip/anchor_test.go                       |  39 +-
 gossip/gossip/certstore.go                         |  15 +-
 gossip/gossip/certstore_test.go                    |  61 +-
 gossip/gossip/channel/channel.go                   |  99 +--
 gossip/gossip/channel/channel_test.go              | 183 ++---
 gossip/gossip/chanstate.go                         |  21 +-
 gossip/gossip/gossip.go                            |   9 +-
 gossip/gossip/gossip_impl.go                       | 132 ++--
 gossip/gossip/gossip_test.go                       |  35 +-
 gossip/gossip/orgs_test.go                         |  35 +-
 gossip/gossip/pull/pullstore.go                    |  93 ++-
 gossip/gossip/pull/pullstore_test.go               |  49 +-
 gossip/privdata/dissemination.go                   |   4 +-
 gossip/privdata/distributor.go                     |  13 +-
 gossip/privdata/distributor_test.go                |   5 +-
 gossip/privdata/pull.go                            |  31 +-
 gossip/privdata/pull_test.go                       |  23 +-
 .../protoext}/compatibility_test.go                |  25 +-
 gossip/protoext/message.go                         | 193 +++++
 gossip/protoext/message_test.go                    | 438 +++++++++++
 gossip/protoext/msgcomparator.go                   | 125 +++
 gossip/protoext/msgcomparator_test.go              | 388 +++++++++
 gossip/protoext/receivedmessage.go                 |  64 ++
 gossip/protoext/signing.go                         | 206 +++++
 gossip/protoext/signing_test.go                    | 420 ++++++++++
 gossip/protoext/stringers.go                       | 124 +++
 gossip/protoext/stringers_test.go                  | 210 +++++
 gossip/service/join_test.go                        |   7 +-
 gossip/state/metrics_test.go                       |   3 +-
 gossip/state/mocks/gossip.go                       |   9 +-
 gossip/state/state.go                              |  33 +-
 gossip/state/state_test.go                         |  67 +-
 gossip/util/msgs.go                                |  14 +-
 gossip/util/msgs_test.go                           |  21 +-
 protos/common/collection.pb.go                     |  99 +--
 protos/common/collection.proto                     |   2 +
 protos/gossip/extensions.go                        | 622 ---------------
 protos/gossip/extensions_test.go                   | 863 ---------------------
 protos/gossip/message.pb.go                        | 422 +++++-----
 protos/gossip/message.proto                        |  11 +-
 protos/gossip/message_test.go                      | 197 -----
 protoutil/blockutils.go                            | 124 +++
 protoutil/blockutils_test.go                       | 206 +++++
 protoutil/chaincodeutils.go                        |  25 +
 protoutil/commonutils.go                           | 339 ++++++++
 protoutil/commonutils_test.go                      | 429 ++++++++++
 protoutil/proputils.go                             | 642 +++++++++++++++
 protoutil/proputils_test.go                        | 665 ++++++++++++++++
 protoutil/readme.md                                |   2 +
 protoutil/txutils.go                               | 453 +++++++++++
 protoutil/txutils_test.go                          | 522 +++++++++++++
 unit-test/run.sh                                   |   1 +
 90 files changed, 6736 insertions(+), 2776 deletions(-)
 create mode 100644 core/ledger/kvledger/idstore/idstore.go
 create mode 100644 core/ledger/kvledger/idstore/readme.md
 create mode 100644 core/ledger/util/couchdb/couchdb_ext.go
 rename {protos/gossip => gossip/protoext}/compatibility_test.go (69%)
 create mode 100644 gossip/protoext/message.go
 create mode 100644 gossip/protoext/message_test.go
 create mode 100644 gossip/protoext/msgcomparator.go
 create mode 100644 gossip/protoext/msgcomparator_test.go
 create mode 100644 gossip/protoext/receivedmessage.go
 create mode 100644 gossip/protoext/signing.go
 create mode 100644 gossip/protoext/signing_test.go
 create mode 100644 gossip/protoext/stringers.go
 create mode 100644 gossip/protoext/stringers_test.go
 delete mode 100644 protos/gossip/extensions.go
 delete mode 100644 protos/gossip/extensions_test.go
 delete mode 100644 protos/gossip/message_test.go
 create mode 100644 protoutil/blockutils.go
 create mode 100644 protoutil/blockutils_test.go
 create mode 100644 protoutil/chaincodeutils.go
 create mode 100644 protoutil/commonutils.go
 create mode 100644 protoutil/commonutils_test.go
 create mode 100644 protoutil/proputils.go
 create mode 100644 protoutil/proputils_test.go
 create mode 100644 protoutil/readme.md
 create mode 100644 protoutil/txutils.go
 create mode 100644 protoutil/txutils_test.go

diff --git a/bccsp/grep11/client.go b/bccsp/grep11/client.go
index ec9499de..50e9d8a5 100644
--- a/bccsp/grep11/client.go
+++ b/bccsp/grep11/client.go
@@ -16,13 +16,13 @@ limitations under the License.
 package grep11
 
 import (
+	"context"
 	"crypto/elliptic"
 	"encoding/asn1"
 	"fmt"
 	"math/big"
 
 	pb "github.com/hyperledger/fabric/bccsp/grep11/protos"
-	"golang.org/x/net/context"
 	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/status"
 )
@@ -105,7 +105,7 @@ func (csp *impl) generateECKey(curve asn1.ObjectIdentifier, ephemeral bool) (*ec
 	var k *pb.GenerateStatus
 	err = csp.reLoad(func() error {
 		var err error
-		k, err = csp.grepClient.GenerateECKey(context.Background(), &pb.GenerateInfo{marshaledOID})
+		k, err = csp.grepClient.GenerateECKey(context.Background(), &pb.GenerateInfo{Oid: marshaledOID})
 		return err
 	})
 
@@ -143,7 +143,7 @@ func (csp *impl) signP11ECDSA(keyBlob []byte, msg []byte) (R, S *big.Int, err er
 	var sig *pb.SignStatus
 	err = csp.reLoad(func() error {
 		var err error
-		sig, err = csp.grepClient.SignP11ECDSA(context.Background(), &pb.SignInfo{keyBlob, msg})
+		sig, err = csp.grepClient.SignP11ECDSA(context.Background(), &pb.SignInfo{PrivKey: keyBlob, Hash: msg})
 		return err
 	})
 
diff --git a/bccsp/grep11/conf.go b/bccsp/grep11/conf.go
index acb74037..1268b449 100644
--- a/bccsp/grep11/conf.go
+++ b/bccsp/grep11/conf.go
@@ -98,7 +98,7 @@ type GREP11Opts struct {
 	FileKeystore *FileKeystoreOpts `mapstructure:"filekeystore,omitempty" json:"filekeystore,omitempty"`
 
 	Address string `mapstructure:"address" json:"library"`
-	Port    string `mapstructure:"port" json:"library"`
+	Port    string `mapstructure:"port" json:"port"`
 
 	SoftVerify bool `mapstructure:"softwareverify,omitempty" json:"softwareverify,omitempty"`
 }
diff --git a/bccsp/grep11/impl.go b/bccsp/grep11/impl.go
index dc12c9be..1e304aef 100644
--- a/bccsp/grep11/impl.go
+++ b/bccsp/grep11/impl.go
@@ -16,11 +16,11 @@ limitations under the License.
 package grep11
 
 import (
+	"context"
 	"crypto/ecdsa"
 	"errors"
 	"fmt"
 
-	"golang.org/x/net/context"
 	"google.golang.org/grpc"
 
 	"time"
@@ -117,7 +117,7 @@ func (csp *impl) connectSession() error {
 		//      when container got moved to different LPAR)
 	}
 
-	r, err := csp.grepManager.Load(context.Background(), &pb.LoadInfo{pin, nonce})
+	r, err := csp.grepManager.Load(context.Background(), &pb.LoadInfo{Pin: pin, Nonce: nonce})
 	if err != nil {
 		return fmt.Errorf("Could not remote-load EP11 library [%s]\n Remote Response: <%+v>", err, r)
 	}
diff --git a/bccsp/grep11/protos/grep11.pb.go b/bccsp/grep11/protos/grep11.pb.go
index 158608f8..04a820cb 100644
--- a/bccsp/grep11/protos/grep11.pb.go
+++ b/bccsp/grep11/protos/grep11.pb.go
@@ -24,7 +24,8 @@ import fmt "fmt"
 import math "math"
 
 import (
-	context "golang.org/x/net/context"
+	"context"
+
 	grpc "google.golang.org/grpc"
 )
 
diff --git a/core/chaincode/exectransaction_test.go b/core/chaincode/exectransaction_test.go
index 9cb40e23..158fbf12 100644
--- a/core/chaincode/exectransaction_test.go
+++ b/core/chaincode/exectransaction_test.go
@@ -59,7 +59,7 @@ import (
 	"github.com/hyperledger/fabric/core/scc/lscc"
 	"github.com/hyperledger/fabric/msp"
 	mspmgmt "github.com/hyperledger/fabric/msp/mgmt"
-	"github.com/hyperledger/fabric/msp/mgmt/testtools"
+	msptesttools "github.com/hyperledger/fabric/msp/mgmt/testtools"
 	"github.com/hyperledger/fabric/protos/common"
 	pb "github.com/hyperledger/fabric/protos/peer"
 	putils "github.com/hyperledger/fabric/protos/utils"
diff --git a/core/ledger/kvledger/idstore/idstore.go b/core/ledger/kvledger/idstore/idstore.go
new file mode 100644
index 00000000..9e22b45f
--- /dev/null
+++ b/core/ledger/kvledger/idstore/idstore.go
@@ -0,0 +1,25 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package idstore
+
+import "github.com/hyperledger/fabric/protos/common"
+
+type IDStore interface {
+	SetUnderConstructionFlag(string) error
+	UnsetUnderConstructionFlag() error
+	GetUnderConstructionFlag() (string, error)
+	CreateLedgerID(ledgerID string, gb *common.Block) error
+	LedgerIDExists(ledgerID string) (bool, error)
+	GetAllLedgerIds() ([]string, error)
+	GetLedgeIDValue(ledgerID string) ([]byte, error)
+	Close()
+}
+
+// not implemented for Fabric 1.4.1
+func OpenIDStore(path string) IDStore {
+	return nil
+}
diff --git a/core/ledger/kvledger/idstore/readme.md b/core/ledger/kvledger/idstore/readme.md
new file mode 100644
index 00000000..8f58e92a
--- /dev/null
+++ b/core/ledger/kvledger/idstore/readme.md
@@ -0,0 +1,2 @@
+idstore was added with an empty OpenStore call
+it has been created for trustbloc/fabric-peer-ext dependency
\ No newline at end of file
diff --git a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util_test.go b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util_test.go
index c7baf57d..2a5922ac 100644
--- a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util_test.go
+++ b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util_test.go
@@ -193,7 +193,7 @@ func sampleCollHashedRwSet(collectionName string) *CollHashedRwSet {
 
 func TestTxPvtRwSetConversion(t *testing.T) {
 	txPvtRwSet := sampleTxPvtRwSet()
-	protoMsg, err := txPvtRwSet.toProtoMsg()
+	protoMsg, err := txPvtRwSet.ToProtoMsg()
 	assert.NoError(t, err)
 	txPvtRwSet1, err := TxPvtRwSetFromProtoMsg(protoMsg)
 	assert.NoError(t, err)
diff --git a/core/ledger/pvtdatastorage/store.go b/core/ledger/pvtdatastorage/store.go
index 73e76dd9..8d06fc7b 100644
--- a/core/ledger/pvtdatastorage/store.go
+++ b/core/ledger/pvtdatastorage/store.go
@@ -100,11 +100,6 @@ func (err *ErrIllegalCall) Error() string {
 	return err.msg
 }
 
-// NewErrIllegalArgs creates an illegal args error
-func NewErrIllegalArgs(msg string) *ErrIllegalArgs {
-	return &ErrIllegalArgs{msg: msg}
-}
-
 // ErrIllegalArgs is to be thrown by a store impl if the args passed are not allowed
 type ErrIllegalArgs struct {
 	msg string
diff --git a/core/ledger/util/couchdb/couchdb_ext.go b/core/ledger/util/couchdb/couchdb_ext.go
new file mode 100644
index 00000000..ceee7809
--- /dev/null
+++ b/core/ledger/util/couchdb/couchdb_ext.go
@@ -0,0 +1,12 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package couchdb
+
+// CreateNewIndexWithRetry added to match Fabric 2.0 but not used in 1.4.1
+func (dbclient *CouchDatabase) CreateNewIndexWithRetry(indexdefinition string, designDoc string) error {
+	return nil
+}
diff --git a/core/peer/peer_test.go b/core/peer/peer_test.go
index 82290674..4539db51 100644
--- a/core/peer/peer_test.go
+++ b/core/peer/peer_test.go
@@ -19,15 +19,16 @@ import (
 	"github.com/hyperledger/fabric/core/chaincode/platforms"
 	"github.com/hyperledger/fabric/core/comm"
 	"github.com/hyperledger/fabric/core/committer/txvalidator"
-	"github.com/hyperledger/fabric/core/deliverservice"
+	deliverclient "github.com/hyperledger/fabric/core/deliverservice"
 	"github.com/hyperledger/fabric/core/deliverservice/blocksprovider"
-	"github.com/hyperledger/fabric/core/handlers/validation/api"
+	validation "github.com/hyperledger/fabric/core/handlers/validation/api"
 	ledgermocks "github.com/hyperledger/fabric/core/ledger/mock"
 	"github.com/hyperledger/fabric/core/mocks/ccprovider"
+	storemocks "github.com/hyperledger/fabric/extensions/mocks"
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/service"
 	"github.com/hyperledger/fabric/msp/mgmt"
-	"github.com/hyperledger/fabric/msp/mgmt/testtools"
+	msptesttools "github.com/hyperledger/fabric/msp/mgmt/testtools"
 	peergossip "github.com/hyperledger/fabric/peer/gossip"
 	"github.com/hyperledger/fabric/peer/gossip/mocks"
 	"github.com/stretchr/testify/assert"
@@ -87,14 +88,14 @@ func TestInitialize(t *testing.T) {
 	cleanup := setupPeerFS(t)
 	defer cleanup()
 
-	Initialize(nil, &ccprovider.MockCcProviderImpl{}, (&mscc.MocksccProviderFactory{}).NewSystemChaincodeProvider(), txvalidator.MapBasedPluginMapper(map[string]validation.PluginFactory{}), nil, &ledgermocks.DeployedChaincodeInfoProvider{}, nil, &disabled.Provider{})
+	Initialize(nil, &ccprovider.MockCcProviderImpl{}, (&mscc.MocksccProviderFactory{}).NewSystemChaincodeProvider(), txvalidator.MapBasedPluginMapper(map[string]validation.PluginFactory{}), nil, &ledgermocks.DeployedChaincodeInfoProvider{}, nil, &disabled.Provider{}, &storemocks.DataProvider{})
 }
 
 func TestCreateChainFromBlock(t *testing.T) {
 	cleanup := setupPeerFS(t)
 	defer cleanup()
 
-	Initialize(nil, &ccprovider.MockCcProviderImpl{}, (&mscc.MocksccProviderFactory{}).NewSystemChaincodeProvider(), txvalidator.MapBasedPluginMapper(map[string]validation.PluginFactory{}), &platforms.Registry{}, &ledgermocks.DeployedChaincodeInfoProvider{}, nil, &disabled.Provider{})
+	Initialize(nil, &ccprovider.MockCcProviderImpl{}, (&mscc.MocksccProviderFactory{}).NewSystemChaincodeProvider(), txvalidator.MapBasedPluginMapper(map[string]validation.PluginFactory{}), &platforms.Registry{}, &ledgermocks.DeployedChaincodeInfoProvider{}, nil, &disabled.Provider{}, &storemocks.DataProvider{})
 	testChainID := fmt.Sprintf("mytestchainid-%d", rand.Int())
 	block, err := configtxtest.MakeGenesisBlock(testChainID)
 	if err != nil {
diff --git a/discovery/client/api.go b/discovery/client/api.go
index 88139b8d..595ab802 100644
--- a/discovery/client/api.go
+++ b/discovery/client/api.go
@@ -7,8 +7,8 @@ SPDX-License-Identifier: Apache-2.0
 package discovery
 
 import (
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/discovery"
-	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
 	"google.golang.org/grpc"
 )
@@ -67,7 +67,7 @@ type Endorsers []*Peer
 // of a certain peer.
 type Peer struct {
 	MSPID            string
-	AliveMessage     *gossip.SignedGossipMessage
-	StateInfoMessage *gossip.SignedGossipMessage
+	AliveMessage     *protoext.SignedGossipMessage
+	StateInfoMessage *protoext.SignedGossipMessage
 	Identity         []byte
 }
diff --git a/discovery/client/client.go b/discovery/client/client.go
index 12a9711c..682b4639 100644
--- a/discovery/client/client.go
+++ b/discovery/client/client.go
@@ -14,8 +14,8 @@ import (
 	"time"
 
 	"github.com/golang/protobuf/proto"
+	gprotoext "github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/discovery"
-	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/msp"
 	"github.com/pkg/errors"
 )
@@ -407,13 +407,13 @@ func peersForChannel(membersRes *discovery.PeerMembershipResult, qt discovery.Qu
 	var peers []*Peer
 	for org, peersOfCurrentOrg := range membersRes.PeersByOrg {
 		for _, peer := range peersOfCurrentOrg.Peers {
-			aliveMsg, err := peer.MembershipInfo.ToGossipMessage()
+			aliveMsg, err := gprotoext.EnvelopeToGossipMessage(peer.MembershipInfo)
 			if err != nil {
 				return nil, errors.Wrap(err, "failed unmarshaling alive message")
 			}
-			var stateInfoMsg *gossip.SignedGossipMessage
+			var stateInfoMsg *gprotoext.SignedGossipMessage
 			if isStateInfoExpected(qt) {
-				stateInfoMsg, err = peer.StateInfo.ToGossipMessage()
+				stateInfoMsg, err = gprotoext.EnvelopeToGossipMessage(peer.StateInfo)
 				if err != nil {
 					return nil, errors.Wrap(err, "failed unmarshaling stateInfo message")
 				}
@@ -525,11 +525,11 @@ func endorser(peer *discovery.Peer, chaincode, channel string) (*Peer, error) {
 	if peer.MembershipInfo == nil || peer.StateInfo == nil {
 		return nil, errors.Errorf("received empty envelope(s) for endorsers for chaincode %s, channel %s", chaincode, channel)
 	}
-	aliveMsg, err := peer.MembershipInfo.ToGossipMessage()
+	aliveMsg, err := gprotoext.EnvelopeToGossipMessage(peer.MembershipInfo)
 	if err != nil {
 		return nil, errors.Wrap(err, "failed unmarshaling gossip envelope to alive message")
 	}
-	stateInfMsg, err := peer.StateInfo.ToGossipMessage()
+	stateInfMsg, err := gprotoext.EnvelopeToGossipMessage(peer.StateInfo)
 	if err != nil {
 		return nil, errors.Wrap(err, "failed unmarshaling gossip envelope to state info message")
 	}
@@ -564,7 +564,7 @@ func NewClient(createConnection Dialer, s Signer, signerCacheSize uint) *Client
 	}
 }
 
-func validateAliveMessage(message *gossip.SignedGossipMessage) error {
+func validateAliveMessage(message *gprotoext.SignedGossipMessage) error {
 	am := message.GetAliveMsg()
 	if am == nil {
 		return errors.New("message isn't an alive message")
@@ -579,7 +579,7 @@ func validateAliveMessage(message *gossip.SignedGossipMessage) error {
 	return nil
 }
 
-func validateStateInfoMessage(message *gossip.SignedGossipMessage) error {
+func validateStateInfoMessage(message *gprotoext.SignedGossipMessage) error {
 	si := message.GetStateInfo()
 	if si == nil {
 		return errors.New("message isn't a stateInfo message")
diff --git a/discovery/client/client_test.go b/discovery/client/client_test.go
index 8fda9b8e..78fae032 100644
--- a/discovery/client/client_test.go
+++ b/discovery/client/client_test.go
@@ -29,6 +29,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/api"
 	gossipcommon "github.com/hyperledger/fabric/gossip/common"
 	gdisc "github.com/hyperledger/fabric/gossip/discovery"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/discovery"
 	"github.com/hyperledger/fabric/protos/gossip"
@@ -716,7 +717,7 @@ func TestAddEndorsersQueryInvalidInput(t *testing.T) {
 
 func TestValidateAliveMessage(t *testing.T) {
 	am := aliveMessage(1)
-	msg, _ := am.ToGossipMessage()
+	msg, _ := protoext.EnvelopeToGossipMessage(am)
 
 	// Scenario I: Valid alive message
 	assert.NoError(t, validateAliveMessage(msg))
@@ -889,7 +890,7 @@ func aliveMessage(id int) *gossip.Envelope {
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg.Envelope
 }
 
@@ -912,7 +913,7 @@ func stateInfoMessageWithHeight(ledgerHeight uint64, chaincodes ...*gossip.Chain
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg.Envelope
 }
 
diff --git a/discovery/client/selection.go b/discovery/client/selection.go
index 0d25eabc..dedc5c99 100644
--- a/discovery/client/selection.go
+++ b/discovery/client/selection.go
@@ -10,6 +10,8 @@ import (
 	"math/rand"
 	"sort"
 	"time"
+
+	"github.com/hyperledger/fabric/gossip/protoext"
 )
 
 // Filter filters and sorts the given endorsers
@@ -98,7 +100,7 @@ func ExcludeByHost(reject func(host string) bool) ExclusionFilter {
 		var internalEndpoint string
 		se := p.AliveMessage.GetSecretEnvelope()
 		if se != nil {
-			internalEndpoint = se.InternalEndpoint()
+			internalEndpoint = protoext.InternalEndpoint(se)
 		}
 		return reject(endpoint) || reject(internalEndpoint)
 	})
diff --git a/discovery/client/selection_test.go b/discovery/client/selection_test.go
index b07edaba..927b7260 100644
--- a/discovery/client/selection_test.go
+++ b/discovery/client/selection_test.go
@@ -10,6 +10,7 @@ import (
 	"testing"
 
 	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
@@ -40,10 +41,10 @@ func TestShuffle(t *testing.T) {
 func TestExclusionAndPriority(t *testing.T) {
 	newPeer := func(i int) *Peer {
 		si := stateInfoWithHeight(uint64(i))
-		am, _ := aliveMessage(i).ToGossipMessage()
+		msg, _ := protoext.EnvelopeToGossipMessage(aliveMessage(i))
 		return &Peer{
 			StateInfoMessage: si,
-			AliveMessage:     am,
+			AliveMessage:     msg,
 		}
 	}
 
@@ -68,9 +69,9 @@ func TestExcludeEndpoints(t *testing.T) {
 		Payload: secret,
 	}
 	am3 := aliveMessage(3)
-	g1, _ := am1.ToGossipMessage()
-	g2, _ := am2.ToGossipMessage()
-	g3, _ := am3.ToGossipMessage()
+	g1, _ := protoext.EnvelopeToGossipMessage(am1)
+	g2, _ := protoext.EnvelopeToGossipMessage(am2)
+	g3, _ := protoext.EnvelopeToGossipMessage(am3)
 	p1 := Peer{
 		AliveMessage: g1,
 	}
@@ -149,7 +150,7 @@ func TestPrioritiesByHeight(t *testing.T) {
 
 }
 
-func stateInfoWithHeight(h uint64) *gossip.SignedGossipMessage {
+func stateInfoWithHeight(h uint64) *protoext.SignedGossipMessage {
 	g := &gossip.GossipMessage{
 		Content: &gossip.GossipMessage_StateInfo{
 			StateInfo: &gossip.StateInfo{
@@ -160,7 +161,7 @@ func stateInfoWithHeight(h uint64) *gossip.SignedGossipMessage {
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg
 }
 
diff --git a/discovery/cmd/endorsers.go b/discovery/cmd/endorsers.go
index cbb07371..2734f236 100644
--- a/discovery/cmd/endorsers.go
+++ b/discovery/cmd/endorsers.go
@@ -15,7 +15,8 @@ import (
 
 	"github.com/golang/protobuf/proto"
 	"github.com/hyperledger/fabric/cmd/common"
-	"github.com/hyperledger/fabric/discovery/client"
+	discovery "github.com/hyperledger/fabric/discovery/client"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	. "github.com/hyperledger/fabric/protos/discovery"
 	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/msp"
@@ -215,11 +216,11 @@ func endpointFromEnvelope(env *gossip.Envelope) string {
 	if env == nil {
 		return ""
 	}
-	aliveMsg, _ := env.ToGossipMessage()
+	aliveMsg, _ := protoext.EnvelopeToGossipMessage(env)
 	if aliveMsg == nil {
 		return ""
 	}
-	if !aliveMsg.IsAliveMsg() {
+	if !protoext.IsAliveMsg(aliveMsg.GossipMessage) {
 		return ""
 	}
 	if aliveMsg.GetAliveMsg().Membership == nil {
@@ -232,11 +233,11 @@ func ledgerHeightFromEnvelope(env *gossip.Envelope) uint64 {
 	if env == nil {
 		return 0
 	}
-	stateInfoMsg, _ := env.ToGossipMessage()
+	stateInfoMsg, _ := protoext.EnvelopeToGossipMessage(env)
 	if stateInfoMsg == nil {
 		return 0
 	}
-	if !stateInfoMsg.IsStateInfoMsg() {
+	if !protoext.IsStateInfoMsg(stateInfoMsg.GossipMessage) {
 		return 0
 	}
 	if stateInfoMsg.GetStateInfo().Properties == nil {
diff --git a/discovery/cmd/peers_test.go b/discovery/cmd/peers_test.go
index 6da3a12d..91767672 100644
--- a/discovery/cmd/peers_test.go
+++ b/discovery/cmd/peers_test.go
@@ -14,8 +14,9 @@ import (
 
 	"github.com/hyperledger/fabric/cmd/common"
 	. "github.com/hyperledger/fabric/discovery/client"
-	"github.com/hyperledger/fabric/discovery/cmd"
+	discovery "github.com/hyperledger/fabric/discovery/cmd"
 	"github.com/hyperledger/fabric/discovery/cmd/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/msp"
 	"github.com/hyperledger/fabric/protos/utils"
@@ -104,7 +105,7 @@ func TestParsePeers(t *testing.T) {
 	}
 }
 
-func aliveMessage(id int) *gossip.SignedGossipMessage {
+func aliveMessage(id int) *protoext.SignedGossipMessage {
 	g := &gossip.GossipMessage{
 		Content: &gossip.GossipMessage_AliveMsg{
 			AliveMsg: &gossip.AliveMessage{
@@ -118,11 +119,11 @@ func aliveMessage(id int) *gossip.SignedGossipMessage {
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg
 }
 
-func stateInfoMessage(height uint64) *gossip.SignedGossipMessage {
+func stateInfoMessage(height uint64) *protoext.SignedGossipMessage {
 	g := &gossip.GossipMessage{
 		Content: &gossip.GossipMessage_StateInfo{
 			StateInfo: &gossip.StateInfo{
@@ -140,6 +141,6 @@ func stateInfoMessage(height uint64) *gossip.SignedGossipMessage {
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg
 }
diff --git a/discovery/service_test.go b/discovery/service_test.go
index 325ec683..49026e61 100644
--- a/discovery/service_test.go
+++ b/discovery/service_test.go
@@ -17,6 +17,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/api"
 	gcommon "github.com/hyperledger/fabric/gossip/common"
 	gdisc "github.com/hyperledger/fabric/gossip/discovery"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/discovery"
 	"github.com/hyperledger/fabric/protos/gossip"
@@ -551,7 +552,7 @@ func stateInfoMsg(id int) gdisc.NetworkMember {
 			StateInfo: si,
 		},
 	}
-	sm, _ := gm.NoopSign()
+	sm, _ := protoext.NoopSign(gm)
 	return gdisc.NetworkMember{
 		PKIid:    pkiID,
 		Envelope: sm.Envelope,
@@ -572,7 +573,7 @@ func aliveMsg(id int) gdisc.NetworkMember {
 			AliveMsg: am,
 		},
 	}
-	sm, _ := gm.NoopSign()
+	sm, _ := protoext.NoopSign(gm)
 	return gdisc.NetworkMember{
 		PKIid:    pkiID,
 		Endpoint: endpoint,
diff --git a/discovery/support/gossip/support_test.go b/discovery/support/gossip/support_test.go
index 9f60b1eb..cda26124 100644
--- a/discovery/support/gossip/support_test.go
+++ b/discovery/support/gossip/support_test.go
@@ -13,6 +13,7 @@ import (
 	"github.com/hyperledger/fabric/discovery/support/mocks"
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
@@ -54,7 +55,7 @@ func TestPeersOfChannel(t *testing.T) {
 			},
 		},
 	}
-	sMsg, _ := stateInfo.NoopSign()
+	sMsg, _ := protoext.NoopSign(stateInfo)
 	g := &mocks.Gossip{}
 	g.SelfChannelInfoReturnsOnCall(0, nil)
 	g.SelfChannelInfoReturnsOnCall(1, sMsg)
diff --git a/discovery/support/mocks/gossip.go b/discovery/support/mocks/gossip.go
index 22535cec..5ae2fb2c 100644
--- a/discovery/support/mocks/gossip.go
+++ b/discovery/support/mocks/gossip.go
@@ -10,6 +10,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/filter"
 	"github.com/hyperledger/fabric/gossip/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
@@ -23,16 +24,16 @@ type Gossip struct {
 	selfMembershipInfoReturnsOnCall map[int]struct {
 		result1 discovery.NetworkMember
 	}
-	SelfChannelInfoStub        func(common.ChainID) *proto.SignedGossipMessage
+	SelfChannelInfoStub        func(common.ChainID) *protoext.SignedGossipMessage
 	selfChannelInfoMutex       sync.RWMutex
 	selfChannelInfoArgsForCall []struct {
 		arg1 common.ChainID
 	}
 	selfChannelInfoReturns struct {
-		result1 *proto.SignedGossipMessage
+		result1 *protoext.SignedGossipMessage
 	}
 	selfChannelInfoReturnsOnCall map[int]struct {
-		result1 *proto.SignedGossipMessage
+		result1 *protoext.SignedGossipMessage
 	}
 	SendStub        func(msg *proto.GossipMessage, peers ...*comm.RemotePeer)
 	sendMutex       sync.RWMutex
@@ -40,10 +41,10 @@ type Gossip struct {
 		msg   *proto.GossipMessage
 		peers []*comm.RemotePeer
 	}
-	SendByCriteriaStub        func(*proto.SignedGossipMessage, gossip.SendCriteria) error
+	SendByCriteriaStub        func(*protoext.SignedGossipMessage, gossip.SendCriteria) error
 	sendByCriteriaMutex       sync.RWMutex
 	sendByCriteriaArgsForCall []struct {
-		arg1 *proto.SignedGossipMessage
+		arg1 *protoext.SignedGossipMessage
 		arg2 gossip.SendCriteria
 	}
 	sendByCriteriaReturns struct {
@@ -108,7 +109,7 @@ type Gossip struct {
 		result1 filter.RoutingFilter
 		result2 error
 	}
-	AcceptStub        func(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	AcceptStub        func(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 	acceptMutex       sync.RWMutex
 	acceptArgsForCall []struct {
 		acceptor    common.MessageAcceptor
@@ -116,11 +117,11 @@ type Gossip struct {
 	}
 	acceptReturns struct {
 		result1 <-chan *proto.GossipMessage
-		result2 <-chan proto.ReceivedMessage
+		result2 <-chan protoext.ReceivedMessage
 	}
 	acceptReturnsOnCall map[int]struct {
 		result1 <-chan *proto.GossipMessage
-		result2 <-chan proto.ReceivedMessage
+		result2 <-chan protoext.ReceivedMessage
 	}
 	JoinChanStub        func(joinMsg api.JoinChannelMessage, chainID common.ChainID)
 	joinChanMutex       sync.RWMutex
@@ -194,7 +195,7 @@ func (fake *Gossip) SelfMembershipInfoReturnsOnCall(i int, result1 discovery.Net
 	}{result1}
 }
 
-func (fake *Gossip) SelfChannelInfo(arg1 common.ChainID) *proto.SignedGossipMessage {
+func (fake *Gossip) SelfChannelInfo(arg1 common.ChainID) *protoext.SignedGossipMessage {
 	fake.selfChannelInfoMutex.Lock()
 	ret, specificReturn := fake.selfChannelInfoReturnsOnCall[len(fake.selfChannelInfoArgsForCall)]
 	fake.selfChannelInfoArgsForCall = append(fake.selfChannelInfoArgsForCall, struct {
@@ -223,22 +224,22 @@ func (fake *Gossip) SelfChannelInfoArgsForCall(i int) common.ChainID {
 	return fake.selfChannelInfoArgsForCall[i].arg1
 }
 
-func (fake *Gossip) SelfChannelInfoReturns(result1 *proto.SignedGossipMessage) {
+func (fake *Gossip) SelfChannelInfoReturns(result1 *protoext.SignedGossipMessage) {
 	fake.SelfChannelInfoStub = nil
 	fake.selfChannelInfoReturns = struct {
-		result1 *proto.SignedGossipMessage
+		result1 *protoext.SignedGossipMessage
 	}{result1}
 }
 
-func (fake *Gossip) SelfChannelInfoReturnsOnCall(i int, result1 *proto.SignedGossipMessage) {
+func (fake *Gossip) SelfChannelInfoReturnsOnCall(i int, result1 *protoext.SignedGossipMessage) {
 	fake.SelfChannelInfoStub = nil
 	if fake.selfChannelInfoReturnsOnCall == nil {
 		fake.selfChannelInfoReturnsOnCall = make(map[int]struct {
-			result1 *proto.SignedGossipMessage
+			result1 *protoext.SignedGossipMessage
 		})
 	}
 	fake.selfChannelInfoReturnsOnCall[i] = struct {
-		result1 *proto.SignedGossipMessage
+		result1 *protoext.SignedGossipMessage
 	}{result1}
 }
 
@@ -267,11 +268,11 @@ func (fake *Gossip) SendArgsForCall(i int) (*proto.GossipMessage, []*comm.Remote
 	return fake.sendArgsForCall[i].msg, fake.sendArgsForCall[i].peers
 }
 
-func (fake *Gossip) SendByCriteria(arg1 *proto.SignedGossipMessage, arg2 gossip.SendCriteria) error {
+func (fake *Gossip) SendByCriteria(arg1 *protoext.SignedGossipMessage, arg2 gossip.SendCriteria) error {
 	fake.sendByCriteriaMutex.Lock()
 	ret, specificReturn := fake.sendByCriteriaReturnsOnCall[len(fake.sendByCriteriaArgsForCall)]
 	fake.sendByCriteriaArgsForCall = append(fake.sendByCriteriaArgsForCall, struct {
-		arg1 *proto.SignedGossipMessage
+		arg1 *protoext.SignedGossipMessage
 		arg2 gossip.SendCriteria
 	}{arg1, arg2})
 	fake.recordInvocation("SendByCriteria", []interface{}{arg1, arg2})
@@ -291,7 +292,7 @@ func (fake *Gossip) SendByCriteriaCallCount() int {
 	return len(fake.sendByCriteriaArgsForCall)
 }
 
-func (fake *Gossip) SendByCriteriaArgsForCall(i int) (*proto.SignedGossipMessage, gossip.SendCriteria) {
+func (fake *Gossip) SendByCriteriaArgsForCall(i int) (*protoext.SignedGossipMessage, gossip.SendCriteria) {
 	fake.sendByCriteriaMutex.RLock()
 	defer fake.sendByCriteriaMutex.RUnlock()
 	return fake.sendByCriteriaArgsForCall[i].arg1, fake.sendByCriteriaArgsForCall[i].arg2
@@ -564,7 +565,7 @@ func (fake *Gossip) PeerFilterReturnsOnCall(i int, result1 filter.RoutingFilter,
 	}{result1, result2}
 }
 
-func (fake *Gossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (fake *Gossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	fake.acceptMutex.Lock()
 	ret, specificReturn := fake.acceptReturnsOnCall[len(fake.acceptArgsForCall)]
 	fake.acceptArgsForCall = append(fake.acceptArgsForCall, struct {
@@ -594,25 +595,25 @@ func (fake *Gossip) AcceptArgsForCall(i int) (common.MessageAcceptor, bool) {
 	return fake.acceptArgsForCall[i].acceptor, fake.acceptArgsForCall[i].passThrough
 }
 
-func (fake *Gossip) AcceptReturns(result1 <-chan *proto.GossipMessage, result2 <-chan proto.ReceivedMessage) {
+func (fake *Gossip) AcceptReturns(result1 <-chan *proto.GossipMessage, result2 <-chan protoext.ReceivedMessage) {
 	fake.AcceptStub = nil
 	fake.acceptReturns = struct {
 		result1 <-chan *proto.GossipMessage
-		result2 <-chan proto.ReceivedMessage
+		result2 <-chan protoext.ReceivedMessage
 	}{result1, result2}
 }
 
-func (fake *Gossip) AcceptReturnsOnCall(i int, result1 <-chan *proto.GossipMessage, result2 <-chan proto.ReceivedMessage) {
+func (fake *Gossip) AcceptReturnsOnCall(i int, result1 <-chan *proto.GossipMessage, result2 <-chan protoext.ReceivedMessage) {
 	fake.AcceptStub = nil
 	if fake.acceptReturnsOnCall == nil {
 		fake.acceptReturnsOnCall = make(map[int]struct {
 			result1 <-chan *proto.GossipMessage
-			result2 <-chan proto.ReceivedMessage
+			result2 <-chan protoext.ReceivedMessage
 		})
 	}
 	fake.acceptReturnsOnCall[i] = struct {
 		result1 <-chan *proto.GossipMessage
-		result2 <-chan proto.ReceivedMessage
+		result2 <-chan protoext.ReceivedMessage
 	}{result1, result2}
 }
 
diff --git a/discovery/test/integration_test.go b/discovery/test/integration_test.go
index bff876c2..3ec075d7 100644
--- a/discovery/test/integration_test.go
+++ b/discovery/test/integration_test.go
@@ -33,7 +33,7 @@ import (
 	"github.com/hyperledger/fabric/common/tools/configtxgen/encoder"
 	genesisconfig "github.com/hyperledger/fabric/common/tools/configtxgen/localconfig"
 	"github.com/hyperledger/fabric/common/util"
-	"github.com/hyperledger/fabric/core/cclifecycle"
+	cc "github.com/hyperledger/fabric/core/cclifecycle"
 	lifecyclemocks "github.com/hyperledger/fabric/core/cclifecycle/mocks"
 	"github.com/hyperledger/fabric/core/comm"
 	"github.com/hyperledger/fabric/core/common/ccprovider"
@@ -48,6 +48,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/api"
 	gcommon "github.com/hyperledger/fabric/gossip/common"
 	gdisc "github.com/hyperledger/fabric/gossip/discovery"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/msp"
 	"github.com/hyperledger/fabric/protos/common"
 	. "github.com/hyperledger/fabric/protos/discovery"
@@ -745,7 +746,7 @@ func peersToTestPeers(peers []*disc.Peer) testPeerSet {
 		pkiID := gcommon.PKIidType(hex.EncodeToString(util.ComputeSHA256(p.Identity)))
 		var stateInfoMember gdisc.NetworkMember
 		if p.StateInfoMessage != nil {
-			stateInfo, _ := p.StateInfoMessage.ToGossipMessage()
+			stateInfo, _ := protoext.EnvelopeToGossipMessage(p.StateInfoMessage.Envelope)
 			stateInfoMember = gdisc.NetworkMember{
 				PKIid:      pkiID,
 				Envelope:   p.StateInfoMessage.Envelope,
@@ -815,7 +816,7 @@ func stateInfoMsg(pkiID gcommon.PKIidType) gdisc.NetworkMember {
 			StateInfo: si,
 		},
 	}
-	sm, _ := gm.NoopSign()
+	sm, _ := protoext.NoopSign(gm)
 	return gdisc.NetworkMember{
 		Properties: si.Properties,
 		PKIid:      pkiID,
@@ -836,7 +837,7 @@ func aliveMsg(pkiID gcommon.PKIidType) gdisc.NetworkMember {
 			AliveMsg: am,
 		},
 	}
-	sm, _ := gm.NoopSign()
+	sm, _ := protoext.NoopSign(gm)
 	return gdisc.NetworkMember{
 		PKIid:    pkiID,
 		Endpoint: string(pkiID),
diff --git a/go.mod b/go.mod
index 0fdbdc13..55cdec12 100644
--- a/go.mod
+++ b/go.mod
@@ -9,9 +9,7 @@ require (
 	github.com/VividCortex/gohistogram v1.0.0 // indirect
 	github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc // indirect
 	github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf // indirect
-	github.com/bluele/gcache v0.0.0-20190301044115-79ae3b2d8680
 	github.com/containerd/continuity v0.0.0-20181003075958-be9bd761db19 // indirect
-	github.com/coreos/etcd v3.3.9+incompatible
 	github.com/coreos/pkg v0.0.0-20180108230652-97fdf19511ea // indirect
 	github.com/davecgh/go-spew v1.1.1
 	github.com/eapache/go-resiliency v1.1.0 // indirect
@@ -28,7 +26,6 @@ require (
 	github.com/gorilla/mux v1.6.2
 	github.com/grpc-ecosystem/go-grpc-middleware v1.0.0
 	github.com/hashicorp/go-version v1.0.0
-	github.com/hashicorp/hcl v1.0.0 // indirect
 	github.com/hyperledger/fabric-amcl v0.0.0-20180903120555-6b78f7a22d95
 	github.com/hyperledger/fabric-lib-go v1.0.0
 	github.com/hyperledger/fabric/extensions v0.0.0
@@ -43,7 +40,6 @@ require (
 	github.com/onsi/ginkgo v1.6.0
 	github.com/onsi/gomega v1.4.2
 	github.com/op/go-logging v0.0.0-20160315200505-970db520ece7
-	github.com/pelletier/go-toml v1.2.0 // indirect
 	github.com/pierrec/lz4 v0.0.0-20180906185208-bb6bfd13c6a2 // indirect
 	github.com/pkg/errors v0.8.1
 	github.com/prometheus/client_golang v0.9.0
@@ -52,7 +48,6 @@ require (
 	github.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d // indirect
 	github.com/rcrowley/go-metrics v0.0.0-20181016184325-3113b8401b8a
 	github.com/sirupsen/logrus v1.1.0 // indirect
-	github.com/spf13/afero v1.2.1 // indirect
 	github.com/spf13/cast v1.2.0 // indirect
 	github.com/spf13/cobra v0.0.3
 	github.com/spf13/jwalterweatherman v1.0.0 // indirect
@@ -84,10 +79,6 @@ replace github.com/docker/docker => github.com/docker/docker v0.0.0-201808271313
 
 replace golang.org/x/crypto => golang.org/x/crypto v0.0.0-20180827131323-e3636079e1a4
 
-replace github.com/hyperledger/fabric/extensions => github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190521162923-e85101b1c766
+replace github.com/hyperledger/fabric/extensions => github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190528231123-9b2d0053a5e4
 
-replace github.com/trustbloc/fabric-peer-ext => github.com/trustbloc/fabric-peer-ext v0.0.0-20190521162923-e85101b1c766
-
-//replace github.com/hyperledger/fabric/extensions => ../../trustbloc/fabric-peer-ext/mod/peer
-
-//replace github.com/trustbloc/fabric-peer-ext => ../../trustbloc/fabric-peer-ext
+replace github.com/trustbloc/fabric-peer-ext => github.com/trustbloc/fabric-peer-ext v0.0.0-20190528231123-9b2d0053a5e4
diff --git a/go.sum b/go.sum
index 6d1edd8d..ffaf68c1 100644
--- a/go.sum
+++ b/go.sum
@@ -26,11 +26,12 @@ github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24
 github.com/bgentry/speakeasy v0.1.0/go.mod h1:+zsyZBPWlz7T6j88CTgSN5bM796AkVf0kBD4zp0CCIs=
 github.com/bluele/gcache v0.0.0-20190301044115-79ae3b2d8680 h1:jk2k2FUNIg9ogv9yFIzjA5NTrJeaAkHev4AFspbmyvo=
 github.com/bluele/gcache v0.0.0-20190301044115-79ae3b2d8680/go.mod h1:8c4/i2VlovMO2gBnHGQPN5EJw+H0lx1u/5p+cgsXtCk=
+github.com/btcsuite/btcutil v0.0.0-20170419141449-a5ecb5d9547a h1:UwuNC3d8iGIAwMyAO92ZGuVQYmdGkWXtQEGZdiIrJQs=
+github.com/btcsuite/btcutil v0.0.0-20170419141449-a5ecb5d9547a/go.mod h1:+5NJ2+qvTyV9exUAL/rxXi3DcLg2Ts+ymUAY5y4NvMg=
 github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
 github.com/containerd/continuity v0.0.0-20180814194400-c7c5070e6f6e/go.mod h1:GL3xCUCBDV3CZiTSEKksMWbLE66hEyuu9qyDOOqM47Y=
 github.com/containerd/continuity v0.0.0-20181003075958-be9bd761db19 h1:HSgjWPBWohO3kHDPwCPUGSLqJjXCjA7ad5057beR2ZU=
 github.com/containerd/continuity v0.0.0-20181003075958-be9bd761db19/go.mod h1:GL3xCUCBDV3CZiTSEKksMWbLE66hEyuu9qyDOOqM47Y=
-github.com/coreos/etcd v3.3.9+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
 github.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
 github.com/coreos/go-systemd v0.0.0-20180511133405-39ca1b05acc7 h1:u9SHYsPQNyt5tgDm3YN7+9dYrpK96E5wFilTFWIDZOM=
 github.com/coreos/go-systemd v0.0.0-20180511133405-39ca1b05acc7/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
@@ -99,7 +100,6 @@ github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgf
 github.com/grpc-ecosystem/grpc-gateway v1.4.1/go.mod h1:RSKVYQBd5MCa4OVpNdGskqpgL2+G+NZTnrVHpWWfpdw=
 github.com/hashicorp/go-version v1.0.0 h1:21MVWPKDphxa7ineQQTrCU5brh7OuVVAzGOCnnCPtE8=
 github.com/hashicorp/go-version v1.0.0/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=
-github.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=
 github.com/hpcloud/tail v1.0.0 h1:nfCOvKYfkgYP8hkirhJocXT2+zOD8yUNjXaWfTlyFKI=
 github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
 github.com/hyperledger/fabric v1.4.1/go.mod h1:tGFAOCT696D3rG0Vofd2dyWYLySHlh0aQjf7Q1HAju0=
@@ -152,7 +152,6 @@ github.com/opencontainers/image-spec v1.0.1 h1:JMemWkRwHx4Zj+fVxWoMCFm/8sYGGrUVo
 github.com/opencontainers/image-spec v1.0.1/go.mod h1:BtxoFyWECRxE4U/7sNtV5W15zMzWCbyJoFRP3s7yZA0=
 github.com/opencontainers/runc v0.1.1 h1:GlxAyO6x8rfZYN9Tt0Kti5a/cP41iuiO2yYT0IJGY8Y=
 github.com/opencontainers/runc v0.1.1/go.mod h1:qT5XzbpPznkRYVz/mWwUaVBUv2rmF59PVA73FjuZG0U=
-github.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=
 github.com/pierrec/lz4 v0.0.0-20180906185208-bb6bfd13c6a2 h1:S4MUQ7zZCj5JPfz2hh2NvdBK6WwJ86juB/+vd7QePts=
 github.com/pierrec/lz4 v0.0.0-20180906185208-bb6bfd13c6a2/go.mod h1:3/3N9NVKO0jef7pBehbT1qWhCMrIgbYNnFAZCqQ5LRc=
 github.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=
@@ -181,7 +180,6 @@ github.com/sirupsen/logrus v1.0.6/go.mod h1:pMByvHTf9Beacp5x1UXfOR9xyW/9antXMhjM
 github.com/sirupsen/logrus v1.1.0 h1:65VZabgUiV9ktjGM5nTq0+YurgTyX+YI2lSSfDjI+qU=
 github.com/sirupsen/logrus v1.1.0/go.mod h1:zrgwTnHtNr00buQ1vSptGe8m1f/BbgsPukg8qsT7A+A=
 github.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=
-github.com/spf13/afero v1.2.1/go.mod h1:9ZxEEn6pIJ8Rxe320qSDBk6AsU0r9pR7Q4OcevTdifk=
 github.com/spf13/cast v1.2.0 h1:HHl1DSRbEQN2i8tJmtS6ViPyHx35+p51amrdsiTCrkg=
 github.com/spf13/cast v1.2.0/go.mod h1:r2rcYCSwa1IExKTDiTfzaxqT2FNHs8hODu4LnUfgKEg=
 github.com/spf13/cobra v0.0.3 h1:ZlrZ4XsMRm04Fr5pSFxBgfND2EBVa1nLpiy1stUsX/8=
@@ -207,10 +205,10 @@ github.com/syndtr/goleveldb v0.0.0-20180815032940-ae2bd5eed72d/go.mod h1:Z4AUp2K
 github.com/tedsuo/ifrit v0.0.0-20180802180643-bea94bb476cc h1:LUUe4cdABGrIJAhl1P1ZpWY76AwukVszFdwkVFVLwIk=
 github.com/tedsuo/ifrit v0.0.0-20180802180643-bea94bb476cc/go.mod h1:eyZnKCc955uh98WQvzOm0dgAeLnf2O0Rz0LPoC5ze+0=
 github.com/tmc/grpc-websocket-proxy v0.0.0-20170815181823-89b8d40f7ca8/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=
-github.com/trustbloc/fabric-peer-ext v0.0.0-20190521162923-e85101b1c766 h1:8JCqNy4axsRfKZ6SDR+pNBIxZmDR5BDGWkQ2Uh4Bfk0=
-github.com/trustbloc/fabric-peer-ext v0.0.0-20190521162923-e85101b1c766/go.mod h1:iCK/9BGKwgGghd49gKiZuj8M5/oF9TEIuXi2xdWxARw=
-github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190521162923-e85101b1c766 h1:37PEc6OPnTs7W7TWM1Ht+fdQ3q7CMH541pya86fPEF8=
-github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190521162923-e85101b1c766/go.mod h1:FS/JZ44vp5uSBuMaD0zCyilOAdQuyCfDoGUscj+ngfI=
+github.com/trustbloc/fabric-peer-ext v0.0.0-20190528231123-9b2d0053a5e4 h1:jc+YAMYAfpTbs6jLRXM3gt7pvHJryZTSYCfoASjqoDQ=
+github.com/trustbloc/fabric-peer-ext v0.0.0-20190528231123-9b2d0053a5e4/go.mod h1:8chTtto3TQYM5wxox915j4Rr3ZbkB10eHCKRqATF70c=
+github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190528231123-9b2d0053a5e4 h1:/XeRyoLuyshcJrciQ5aUHT40TwPcY3GntXUHYiYk9lk=
+github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190528231123-9b2d0053a5e4/go.mod h1:AZAS2bv+VPiYazIJhQmwnHvS3LKXTQCld2Ph7qk3uZ8=
 github.com/ugorji/go v1.1.1/go.mod h1:hnLbHMwcvSihnDhEfx2/BzKp2xb0Y+ErdfYcrs9tkJQ=
 github.com/urfave/cli v1.18.0/go.mod h1:70zkFmudgCuE/ngEzBv17Jvp/497gISqfk5gWijbERA=
 github.com/vishvananda/netlink v1.0.0 h1:bqNY2lgheFIu1meHUFSH3d7vG93AFyqg3oGbJCOJgSM=
diff --git a/gossip/comm/ack.go b/gossip/comm/ack.go
index 62c1febf..7d871b63 100644
--- a/gossip/comm/ack.go
+++ b/gossip/comm/ack.go
@@ -8,11 +8,11 @@ package comm
 
 import (
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
-	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
-type sendFunc func(peer *RemotePeer, msg *proto.SignedGossipMessage)
+type sendFunc func(peer *RemotePeer, msg *protoext.SignedGossipMessage)
 type waitFunc func(*RemotePeer) error
 
 type ackSendOperation struct {
@@ -27,7 +27,7 @@ func newAckSendOperation(snd sendFunc, waitForAck waitFunc) *ackSendOperation {
 	}
 }
 
-func (aso *ackSendOperation) send(msg *proto.SignedGossipMessage, minAckNum int, peers ...*RemotePeer) []SendResult {
+func (aso *ackSendOperation) send(msg *protoext.SignedGossipMessage, minAckNum int, peers ...*RemotePeer) []SendResult {
 	successAcks := 0
 	results := []SendResult{}
 
@@ -61,9 +61,9 @@ func (aso *ackSendOperation) send(msg *proto.SignedGossipMessage, minAckNum int,
 	return results
 }
 
-func interceptAcks(nextHandler handler, remotePeerID common.PKIidType, pubSub *util.PubSub) func(*proto.SignedGossipMessage) {
-	return func(m *proto.SignedGossipMessage) {
-		if m.IsAck() {
+func interceptAcks(nextHandler handler, remotePeerID common.PKIidType, pubSub *util.PubSub) func(*protoext.SignedGossipMessage) {
+	return func(m *protoext.SignedGossipMessage) {
+		if protoext.IsAck(m.GossipMessage) {
 			topic := topicForAck(m.Nonce, remotePeerID)
 			pubSub.Publish(topic, m.GetAck())
 			return
diff --git a/gossip/comm/ack_test.go b/gossip/comm/ack_test.go
index 55a9b28e..6d5bb06c 100644
--- a/gossip/comm/ack_test.go
+++ b/gossip/comm/ack_test.go
@@ -12,6 +12,7 @@ import (
 	"time"
 
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -20,12 +21,12 @@ import (
 func TestInterceptAcks(t *testing.T) {
 	pubsub := util.NewPubSub()
 	pkiID := common.PKIidType("pkiID")
-	msgs := make(chan *proto.SignedGossipMessage, 1)
-	handlerFunc := func(message *proto.SignedGossipMessage) {
+	msgs := make(chan *protoext.SignedGossipMessage, 1)
+	handlerFunc := func(message *protoext.SignedGossipMessage) {
 		msgs <- message
 	}
 	wrappedHandler := interceptAcks(handlerFunc, pkiID, pubsub)
-	ack := &proto.SignedGossipMessage{
+	ack := &protoext.SignedGossipMessage{
 		GossipMessage: &proto.GossipMessage{
 			Nonce: 1,
 			Content: &proto.GossipMessage_Ack{
@@ -42,7 +43,7 @@ func TestInterceptAcks(t *testing.T) {
 	assert.NoError(t, err)
 
 	// Test none acks are just forwarded
-	notAck := &proto.SignedGossipMessage{
+	notAck := &protoext.SignedGossipMessage{
 		GossipMessage: &proto.GossipMessage{
 			Nonce: 2,
 			Content: &proto.GossipMessage_DataMsg{
@@ -71,15 +72,16 @@ func TestAck(t *testing.T) {
 	defer comm4.Stop()
 
 	acceptData := func(o interface{}) bool {
-		return o.(proto.ReceivedMessage).GetGossipMessage().IsDataMsg()
+		m := o.(protoext.ReceivedMessage).GetGossipMessage()
+		return protoext.IsDataMsg(m.GossipMessage)
 	}
 
-	ack := func(c <-chan proto.ReceivedMessage) {
+	ack := func(c <-chan protoext.ReceivedMessage) {
 		msg := <-c
 		msg.Ack(nil)
 	}
 
-	nack := func(c <-chan proto.ReceivedMessage) {
+	nack := func(c <-chan protoext.ReceivedMessage) {
 		msg := <-c
 		msg.Ack(errors.New("Failed processing message because reasons"))
 	}
diff --git a/gossip/comm/comm.go b/gossip/comm/comm.go
index f231622b..e5c75d25 100644
--- a/gossip/comm/comm.go
+++ b/gossip/comm/comm.go
@@ -13,7 +13,7 @@ import (
 
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/common"
-	proto "github.com/hyperledger/fabric/protos/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 )
 
 // Comm is an object that enables to communicate with other peers
@@ -24,10 +24,10 @@ type Comm interface {
 	GetPKIid() common.PKIidType
 
 	// Send sends a message to remote peers
-	Send(msg *proto.SignedGossipMessage, peers ...*RemotePeer)
+	Send(msg *protoext.SignedGossipMessage, peers ...*RemotePeer)
 
 	// SendWithAck sends a message to remote peers, waiting for acknowledgement from minAck of them, or until a certain timeout expires
-	SendWithAck(msg *proto.SignedGossipMessage, timeout time.Duration, minAck int, peers ...*RemotePeer) AggregatedSendResult
+	SendWithAck(msg *protoext.SignedGossipMessage, timeout time.Duration, minAck int, peers ...*RemotePeer) AggregatedSendResult
 
 	// Probe probes a remote node and returns nil if its responsive,
 	// and an error if it's not.
@@ -39,7 +39,7 @@ type Comm interface {
 
 	// Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.
 	// Each message from the channel can be used to send a reply back to the sender
-	Accept(common.MessageAcceptor) <-chan proto.ReceivedMessage
+	Accept(common.MessageAcceptor) <-chan protoext.ReceivedMessage
 
 	// PresumedDead returns a read-only channel for node endpoints that are suspected to be offline
 	PresumedDead() <-chan common.PKIidType
diff --git a/gossip/comm/comm_impl.go b/gossip/comm/comm_impl.go
index fdfe721e..cdcf4428 100644
--- a/gossip/comm/comm_impl.go
+++ b/gossip/comm/comm_impl.go
@@ -21,6 +21,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/identity"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -70,7 +71,7 @@ func NewCommInstance(s *grpc.Server, certs *common.TLSCertificates, idStore iden
 		deadEndpoints:  make(chan common.PKIidType, 100),
 		stopping:       int32(0),
 		exitChan:       make(chan struct{}),
-		subscriptions:  make([]chan proto.ReceivedMessage, 0),
+		subscriptions:  make([]chan protoext.ReceivedMessage, 0),
 		tlsCerts:       certs,
 		metrics:        commMetrics,
 		dialTimeout:    config.DialTimeout,
@@ -115,7 +116,7 @@ type commImpl struct {
 	lock           *sync.Mutex
 	exitChan       chan struct{}
 	stopWG         sync.WaitGroup
-	subscriptions  []chan proto.ReceivedMessage
+	subscriptions  []chan protoext.ReceivedMessage
 	stopping       int32
 	metrics        *metrics.CommMetrics
 	dialTimeout    time.Duration
@@ -129,7 +130,7 @@ func (c *commImpl) createConnection(endpoint string, expectedPKIID common.PKIidT
 	var cc *grpc.ClientConn
 	var stream proto.Gossip_GossipStreamClient
 	var pkiID common.PKIidType
-	var connInfo *proto.ConnectionInfo
+	var connInfo *protoext.ConnectionInfo
 	var dialOpts []grpc.DialOption
 
 	c.logger.Debug("Entering", endpoint, expectedPKIID)
@@ -187,7 +188,7 @@ func (c *commImpl) createConnection(endpoint string, expectedPKIID common.PKIidT
 			conn.logger = c.logger
 			conn.cancel = cancel
 
-			h := func(m *proto.SignedGossipMessage) {
+			h := func(m *protoext.SignedGossipMessage) {
 				c.logger.Debug("Got message:", m)
 				c.msgPublisher.DeMultiplex(&ReceivedMessageImpl{
 					conn:                conn,
@@ -206,20 +207,20 @@ func (c *commImpl) createConnection(endpoint string, expectedPKIID common.PKIidT
 	return nil, errors.WithStack(err)
 }
 
-func (c *commImpl) Send(msg *proto.SignedGossipMessage, peers ...*RemotePeer) {
+func (c *commImpl) Send(msg *protoext.SignedGossipMessage, peers ...*RemotePeer) {
 	if c.isStopping() || len(peers) == 0 {
 		return
 	}
 	c.logger.Debug("Entering, sending", msg, "to ", len(peers), "peers")
 
 	for _, peer := range peers {
-		go func(peer *RemotePeer, msg *proto.SignedGossipMessage) {
+		go func(peer *RemotePeer, msg *protoext.SignedGossipMessage) {
 			c.sendToEndpoint(peer, msg, nonBlockingSend)
 		}(peer, msg)
 	}
 }
 
-func (c *commImpl) sendToEndpoint(peer *RemotePeer, msg *proto.SignedGossipMessage, shouldBlock blockingBehavior) {
+func (c *commImpl) sendToEndpoint(peer *RemotePeer, msg *protoext.SignedGossipMessage, shouldBlock blockingBehavior) {
 	if c.isStopping() {
 		return
 	}
@@ -310,9 +311,9 @@ func (c *commImpl) Handshake(remotePeer *RemotePeer) (api.PeerIdentityType, erro
 	return connInfo.Identity, nil
 }
 
-func (c *commImpl) Accept(acceptor common.MessageAcceptor) <-chan proto.ReceivedMessage {
+func (c *commImpl) Accept(acceptor common.MessageAcceptor) <-chan protoext.ReceivedMessage {
 	genericChan := c.msgPublisher.AddChannel(acceptor)
-	specificChan := make(chan proto.ReceivedMessage, 10)
+	specificChan := make(chan protoext.ReceivedMessage, 10)
 
 	if c.isStopping() {
 		c.logger.Warning("Accept() called but comm module is stopping, returning empty channel")
@@ -394,12 +395,12 @@ func extractRemoteAddress(stream stream) string {
 	return remoteAddress
 }
 
-func (c *commImpl) authenticateRemotePeer(stream stream, initiator bool) (*proto.ConnectionInfo, error) {
+func (c *commImpl) authenticateRemotePeer(stream stream, initiator bool) (*protoext.ConnectionInfo, error) {
 	ctx := stream.Context()
 	remoteAddress := extractRemoteAddress(stream)
 	remoteCertHash := extractCertificateHashFromContext(ctx)
 	var err error
-	var cMsg *proto.SignedGossipMessage
+	var cMsg *protoext.SignedGossipMessage
 	useTLS := c.tlsCerts != nil
 	var selfCertHash []byte
 
@@ -451,11 +452,11 @@ func (c *commImpl) authenticateRemotePeer(stream stream, initiator bool) (*proto
 		return nil, err
 	}
 
-	connInfo := &proto.ConnectionInfo{
+	connInfo := &protoext.ConnectionInfo{
 		ID:       receivedMsg.PkiId,
 		Identity: receivedMsg.Identity,
 		Endpoint: remoteAddress,
-		Auth: &proto.AuthInfo{
+		Auth: &protoext.AuthInfo{
 			Signature:  m.Signature,
 			SignedData: m.Payload,
 		},
@@ -486,7 +487,7 @@ func (c *commImpl) authenticateRemotePeer(stream stream, initiator bool) (*proto
 }
 
 // SendWithAck sends a message to remote peers, waiting for acknowledgement from minAck of them, or until a certain timeout expires
-func (c *commImpl) SendWithAck(msg *proto.SignedGossipMessage, timeout time.Duration, minAck int, peers ...*RemotePeer) AggregatedSendResult {
+func (c *commImpl) SendWithAck(msg *protoext.SignedGossipMessage, timeout time.Duration, minAck int, peers ...*RemotePeer) AggregatedSendResult {
 	if len(peers) == 0 {
 		return nil
 	}
@@ -496,7 +497,7 @@ func (c *commImpl) SendWithAck(msg *proto.SignedGossipMessage, timeout time.Dura
 	// between different invocations
 	msg.Nonce = util.RandomUInt64()
 	// Replace the envelope in the message to update the NONCE
-	msg, err = msg.NoopSign()
+	msg, err = protoext.NoopSign(msg.GossipMessage)
 
 	if c.isStopping() || err != nil {
 		if err == nil {
@@ -512,7 +513,7 @@ func (c *commImpl) SendWithAck(msg *proto.SignedGossipMessage, timeout time.Dura
 		return results
 	}
 	c.logger.Debug("Entering, sending", msg, "to ", len(peers), "peers")
-	sndFunc := func(peer *RemotePeer, msg *proto.SignedGossipMessage) {
+	sndFunc := func(peer *RemotePeer, msg *protoext.SignedGossipMessage) {
 		c.sendToEndpoint(peer, msg, blockingSend)
 	}
 	// Subscribe to acks
@@ -555,7 +556,7 @@ func (c *commImpl) GossipStream(stream proto.Gossip_GossipStreamServer) error {
 
 	conn := c.connStore.onConnected(stream, connInfo, c.metrics)
 
-	h := func(m *proto.SignedGossipMessage) {
+	h := func(m *protoext.SignedGossipMessage) {
 		c.msgPublisher.DeMultiplex(&ReceivedMessageImpl{
 			conn:                conn,
 			lock:                conn,
@@ -587,13 +588,13 @@ func (c *commImpl) disconnect(pkiID common.PKIidType) {
 	c.connStore.closeByPKIid(pkiID)
 }
 
-func readWithTimeout(stream interface{}, timeout time.Duration, address string) (*proto.SignedGossipMessage, error) {
-	incChan := make(chan *proto.SignedGossipMessage, 1)
+func readWithTimeout(stream interface{}, timeout time.Duration, address string) (*protoext.SignedGossipMessage, error) {
+	incChan := make(chan *protoext.SignedGossipMessage, 1)
 	errChan := make(chan error, 1)
 	go func() {
 		if srvStr, isServerStr := stream.(proto.Gossip_GossipStreamServer); isServerStr {
 			if m, err := srvStr.Recv(); err == nil {
-				msg, err := m.ToGossipMessage()
+				msg, err := protoext.EnvelopeToGossipMessage(m)
 				if err != nil {
 					errChan <- err
 					return
@@ -602,7 +603,7 @@ func readWithTimeout(stream interface{}, timeout time.Duration, address string)
 			}
 		} else if clStr, isClientStr := stream.(proto.Gossip_GossipStreamClient); isClientStr {
 			if m, err := clStr.Recv(); err == nil {
-				msg, err := m.ToGossipMessage()
+				msg, err := protoext.EnvelopeToGossipMessage(m)
 				if err != nil {
 					errChan <- err
 					return
@@ -623,7 +624,7 @@ func readWithTimeout(stream interface{}, timeout time.Duration, address string)
 	}
 }
 
-func (c *commImpl) createConnectionMsg(pkiID common.PKIidType, certHash []byte, cert api.PeerIdentityType, signer proto.Signer) (*proto.SignedGossipMessage, error) {
+func (c *commImpl) createConnectionMsg(pkiID common.PKIidType, certHash []byte, cert api.PeerIdentityType, signer protoext.Signer) (*protoext.SignedGossipMessage, error) {
 	m := &proto.GossipMessage{
 		Tag:   proto.GossipMessage_EMPTY,
 		Nonce: 0,
@@ -635,7 +636,7 @@ func (c *commImpl) createConnectionMsg(pkiID common.PKIidType, certHash []byte,
 			},
 		},
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	_, err := sMsg.Sign(signer)
diff --git a/gossip/comm/comm_test.go b/gossip/comm/comm_test.go
index 812dc75e..9a94087c 100644
--- a/gossip/comm/comm_test.go
+++ b/gossip/comm/comm_test.go
@@ -29,6 +29,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/identity"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -164,7 +165,7 @@ func newCommInstance(t *testing.T, sec *naiveSecProvider) (c Comm, port int) {
 	return comm, port
 }
 
-type msgMutator func(*proto.SignedGossipMessage) *proto.SignedGossipMessage
+type msgMutator func(*protoext.SignedGossipMessage) *protoext.SignedGossipMessage
 
 type tlsType int
 
@@ -174,7 +175,7 @@ const (
 	mutualTLS
 )
 
-func handshaker(port int, endpoint string, comm Comm, t *testing.T, connMutator msgMutator, connType tlsType) <-chan proto.ReceivedMessage {
+func handshaker(port int, endpoint string, comm Comm, t *testing.T, connMutator msgMutator, connType tlsType) <-chan protoext.ReceivedMessage {
 	c := &commImpl{}
 	cert := GenerateCertificatesOrPanic()
 	tlsCfg := &tls.Config{
@@ -226,7 +227,7 @@ func handshaker(port int, endpoint string, comm Comm, t *testing.T, connMutator
 		return acceptChan
 	}
 	assert.NoError(t, err, "%v", err)
-	msg, err = envelope.ToGossipMessage()
+	msg, err = protoext.EnvelopeToGossipMessage(envelope)
 	assert.NoError(t, err, "%v", err)
 	assert.Equal(t, []byte(target), msg.GetConn().PkiId)
 	assert.Equal(t, extractCertificateHashFromContext(stream.Context()), msg.GetConn().TlsCertHash)
@@ -251,7 +252,8 @@ func TestMutualParallelSendWithAck(t *testing.T) {
 	defer comm2.Stop()
 
 	acceptData := func(o interface{}) bool {
-		return o.(proto.ReceivedMessage).GetGossipMessage().IsDataMsg()
+		m := o.(protoext.ReceivedMessage).GetGossipMessage()
+		return protoext.IsDataMsg(m.GossipMessage)
 	}
 
 	inc1 := comm1.Accept(acceptData)
@@ -299,10 +301,10 @@ func TestHandshake(t *testing.T) {
 		mac.Write(msg)
 		return mac.Sum(nil), nil
 	}
-	mutator := func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator := func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		return msg
 	}
-	assertPositivePath := func(msg proto.ReceivedMessage, endpoint string) {
+	assertPositivePath := func(msg protoext.ReceivedMessage, endpoint string) {
 		expectedPKIID := common.PKIidType(endpoint)
 		assert.Equal(t, expectedPKIID, msg.GetConnectionInfo().ID)
 		assert.Equal(t, api.PeerIdentityType(endpoint), msg.GetConnectionInfo().Identity)
@@ -321,7 +323,7 @@ func TestHandshake(t *testing.T) {
 	}, naiveSec, disabledMetrics, testCommConfig)
 	go s.Serve(ll)
 	assert.NoError(t, err)
-	var msg proto.ReceivedMessage
+	var msg protoext.ReceivedMessage
 
 	_, tempEndpoint, tempL := getAvailablePort(t)
 	acceptChan := handshaker(port, tempEndpoint, inst, t, mutator, none)
@@ -364,7 +366,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, signature is wrong
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.Signature = append(msg.Signature, 0)
 		return msg
 	}
@@ -375,7 +377,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, the PKIid doesn't match the identity
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.GetConn().PkiId = []byte(tempEndpoint)
 		// Sign the message again
 		msg.Sign(signer)
@@ -390,7 +392,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, the cert hash isn't what is expected
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.GetConn().TlsCertHash = append(msg.GetConn().TlsCertHash, 0)
 		msg.Sign(signer)
 		return msg
@@ -402,7 +404,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, no PKI-ID was sent
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.GetConn().PkiId = nil
 		msg.Sign(signer)
 		return msg
@@ -414,7 +416,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, connection message is of a different type
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.Content = &proto.GossipMessage_Empty{
 			Empty: &proto.Empty{},
 		}
@@ -428,7 +430,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, the peer didn't respond to the handshake in due time
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		time.Sleep(time.Second * 5)
 		return msg
 	}
@@ -447,7 +449,7 @@ func TestBasic(t *testing.T) {
 	m1 := comm1.Accept(acceptAll)
 	m2 := comm2.Accept(acceptAll)
 	out := make(chan uint64, 2)
-	reader := func(ch <-chan proto.ReceivedMessage) {
+	reader := func(ch <-chan protoext.ReceivedMessage) {
 		m := <-ch
 		out <- m.GetGossipMessage().Nonce
 	}
@@ -537,7 +539,7 @@ func TestProdConstructor(t *testing.T) {
 	m1 := comm1.Accept(acceptAll)
 	m2 := comm2.Accept(acceptAll)
 	out := make(chan uint64, 2)
-	reader := func(ch <-chan proto.ReceivedMessage) {
+	reader := func(ch <-chan protoext.ReceivedMessage) {
 		m := <-ch
 		out <- m.GetGossipMessage().Nonce
 	}
@@ -608,7 +610,7 @@ func TestCloseConn(t *testing.T) {
 	msg2Send.GetDataMsg().Payload = &proto.Payload{
 		Data: make([]byte, 1024*1024),
 	}
-	msg2Send.NoopSign()
+	protoext.NoopSign(msg2Send.GossipMessage)
 	for i := 0; i < DefRecvBuffSize; i++ {
 		err := stream.Send(msg2Send.Envelope)
 		if err != nil {
@@ -753,11 +755,11 @@ func TestAccept(t *testing.T) {
 	comm2, _ := newCommInstance(t, naiveSec)
 
 	evenNONCESelector := func(m interface{}) bool {
-		return m.(proto.ReceivedMessage).GetGossipMessage().Nonce%2 == 0
+		return m.(protoext.ReceivedMessage).GetGossipMessage().Nonce%2 == 0
 	}
 
 	oddNONCESelector := func(m interface{}) bool {
-		return m.(proto.ReceivedMessage).GetGossipMessage().Nonce%2 != 0
+		return m.(protoext.ReceivedMessage).GetGossipMessage().Nonce%2 != 0
 	}
 
 	evenNONCES := comm1.Accept(evenNONCESelector)
@@ -769,7 +771,7 @@ func TestAccept(t *testing.T) {
 	out := make(chan uint64, DefRecvBuffSize)
 	sem := make(chan struct{}, 0)
 
-	readIntoSlice := func(a *[]uint64, ch <-chan proto.ReceivedMessage) {
+	readIntoSlice := func(a *[]uint64, ch <-chan protoext.ReceivedMessage) {
 		for m := range ch {
 			*a = append(*a, m.GetGossipMessage().Nonce)
 			out <- m.GetGossipMessage().Nonce
@@ -810,7 +812,7 @@ func TestReConnections(t *testing.T) {
 	comm1, port1 := newCommInstance(t, naiveSec)
 	comm2, port2 := newCommInstance(t, naiveSec)
 
-	reader := func(out chan uint64, in <-chan proto.ReceivedMessage) {
+	reader := func(out chan uint64, in <-chan protoext.ReceivedMessage) {
 		for {
 			msg := <-in
 			if msg == nil {
@@ -928,14 +930,14 @@ func TestPresumedDead(t *testing.T) {
 	}
 }
 
-func createGossipMsg() *proto.SignedGossipMessage {
-	msg, _ := (&proto.GossipMessage{
+func createGossipMsg() *protoext.SignedGossipMessage {
+	msg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Tag:   proto.GossipMessage_EMPTY,
 		Nonce: uint64(rand.Int()),
 		Content: &proto.GossipMessage_DataMsg{
 			DataMsg: &proto.DataMessage{},
 		},
-	}).NoopSign()
+	})
 	return msg
 }
 
diff --git a/gossip/comm/conn.go b/gossip/comm/conn.go
index 102b8990..ecb7766d 100644
--- a/gossip/comm/conn.go
+++ b/gossip/comm/conn.go
@@ -14,6 +14,7 @@ import (
 
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -21,7 +22,7 @@ import (
 	"google.golang.org/grpc"
 )
 
-type handler func(message *proto.SignedGossipMessage)
+type handler func(message *protoext.SignedGossipMessage)
 
 type blockingBehavior bool
 
@@ -165,7 +166,7 @@ func (cs *connectionStore) shutdown() {
 }
 
 func (cs *connectionStore) onConnected(serverStream proto.Gossip_GossipStreamServer,
-	connInfo *proto.ConnectionInfo, metrics *metrics.CommMetrics) *connection {
+	connInfo *protoext.ConnectionInfo, metrics *metrics.CommMetrics) *connection {
 	cs.Lock()
 	defer cs.Unlock()
 
@@ -176,7 +177,7 @@ func (cs *connectionStore) onConnected(serverStream proto.Gossip_GossipStreamSer
 	return cs.registerConn(connInfo, serverStream, metrics)
 }
 
-func (cs *connectionStore) registerConn(connInfo *proto.ConnectionInfo,
+func (cs *connectionStore) registerConn(connInfo *protoext.ConnectionInfo,
 	serverStream proto.Gossip_GossipStreamServer, metrics *metrics.CommMetrics) *connection {
 	conn := newConnection(nil, nil, nil, serverStream, metrics, cs.config)
 	conn.pkiID = connInfo.ID
@@ -221,7 +222,7 @@ type connection struct {
 	recvBuffSize int
 	metrics      *metrics.CommMetrics
 	cancel       context.CancelFunc
-	info         *proto.ConnectionInfo
+	info         *protoext.ConnectionInfo
 	outBuff      chan *msgSending
 	logger       util.Logger                     // logger
 	pkiID        common.PKIidType                // pkiID of the remote endpoint
@@ -267,7 +268,7 @@ func (conn *connection) toDie() bool {
 	return atomic.LoadInt32(&(conn.stopFlag)) == int32(1)
 }
 
-func (conn *connection) send(msg *proto.SignedGossipMessage, onErr func(error), shouldBlock blockingBehavior) {
+func (conn *connection) send(msg *protoext.SignedGossipMessage, onErr func(error), shouldBlock blockingBehavior) {
 	if conn.toDie() {
 		conn.logger.Debug("Aborting send() to ", conn.info.Endpoint, "because connection is closing")
 		return
@@ -293,7 +294,7 @@ func (conn *connection) send(msg *proto.SignedGossipMessage, onErr func(error),
 
 func (conn *connection) serviceConnection() error {
 	errChan := make(chan error, 1)
-	msgChan := make(chan *proto.SignedGossipMessage, conn.recvBuffSize)
+	msgChan := make(chan *protoext.SignedGossipMessage, conn.recvBuffSize)
 	quit := make(chan struct{})
 	// Call stream.Recv() asynchronously in readFromStream(),
 	// and wait for either the Recv() call to end,
@@ -349,7 +350,7 @@ func (conn *connection) drainOutputBuffer() {
 	}
 }
 
-func (conn *connection) readFromStream(errChan chan error, quit chan struct{}, msgChan chan *proto.SignedGossipMessage) {
+func (conn *connection) readFromStream(errChan chan error, quit chan struct{}, msgChan chan *protoext.SignedGossipMessage) {
 	for !conn.toDie() {
 		stream := conn.getStream()
 		if stream == nil {
@@ -368,7 +369,7 @@ func (conn *connection) readFromStream(errChan chan error, quit chan struct{}, m
 			return
 		}
 		conn.metrics.ReceivedMessages.Add(1)
-		msg, err := envelope.ToGossipMessage()
+		msg, err := protoext.EnvelopeToGossipMessage(envelope)
 		if err != nil {
 			errChan <- err
 			conn.logger.Warningf("Got error, aborting: %v", err)
diff --git a/gossip/comm/mock/mock_comm.go b/gossip/comm/mock/mock_comm.go
index 27eda29a..a64a65bd 100644
--- a/gossip/comm/mock/mock_comm.go
+++ b/gossip/comm/mock/mock_comm.go
@@ -12,6 +12,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/comm"
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
@@ -39,7 +40,7 @@ type packetMock struct {
 type channelMock struct {
 	accept common.MessageAcceptor
 
-	channel chan proto.ReceivedMessage
+	channel chan protoext.ReceivedMessage
 }
 
 type commMock struct {
@@ -77,7 +78,7 @@ func NewCommMock(id string, members map[string]*socketMock) comm.Comm {
 
 // Respond sends a GossipMessage to the origin from which this ReceivedMessage was sent from
 func (packet *packetMock) Respond(msg *proto.GossipMessage) {
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	packet.src.socket <- &packetMock{
 		src: packet.dst,
 		dst: packet.src,
@@ -97,13 +98,13 @@ func (packet *packetMock) GetSourceEnvelope() *proto.Envelope {
 }
 
 // GetGossipMessage returns the underlying GossipMessage
-func (packet *packetMock) GetGossipMessage() *proto.SignedGossipMessage {
-	return packet.msg.(*proto.SignedGossipMessage)
+func (packet *packetMock) GetGossipMessage() *protoext.SignedGossipMessage {
+	return packet.msg.(*protoext.SignedGossipMessage)
 }
 
 // GetConnectionInfo returns information about the remote peer
 // that sent the message
-func (packet *packetMock) GetConnectionInfo() *proto.ConnectionInfo {
+func (packet *packetMock) GetConnectionInfo() *protoext.ConnectionInfo {
 	return nil
 }
 
@@ -140,7 +141,7 @@ func (mock *commMock) GetPKIid() common.PKIidType {
 }
 
 // Send sends a message to remote peers
-func (mock *commMock) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (mock *commMock) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	for _, peer := range peers {
 		logger.Debug("Sending message to peer ", peer.Endpoint, "from ", mock.id)
 		mock.members[peer.Endpoint].socket <- &packetMock{
@@ -151,7 +152,7 @@ func (mock *commMock) Send(msg *proto.SignedGossipMessage, peers ...*comm.Remote
 	}
 }
 
-func (mock *commMock) SendWithAck(_ *proto.SignedGossipMessage, _ time.Duration, _ int, _ ...*comm.RemotePeer) comm.AggregatedSendResult {
+func (mock *commMock) SendWithAck(_ *protoext.SignedGossipMessage, _ time.Duration, _ int, _ ...*comm.RemotePeer) comm.AggregatedSendResult {
 	panic("not implemented")
 }
 
@@ -169,8 +170,8 @@ func (mock *commMock) Handshake(peer *comm.RemotePeer) (api.PeerIdentityType, er
 
 // Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.
 // Each message from the channel can be used to send a reply back to the sender
-func (mock *commMock) Accept(accept common.MessageAcceptor) <-chan proto.ReceivedMessage {
-	ch := make(chan proto.ReceivedMessage)
+func (mock *commMock) Accept(accept common.MessageAcceptor) <-chan protoext.ReceivedMessage {
+	ch := make(chan protoext.ReceivedMessage)
 	mock.acceptors = append(mock.acceptors, &channelMock{accept, ch})
 	return ch
 }
diff --git a/gossip/comm/mock/mock_comm_test.go b/gossip/comm/mock/mock_comm_test.go
index 8f521872..843b5e12 100644
--- a/gossip/comm/mock/mock_comm_test.go
+++ b/gossip/comm/mock/mock_comm_test.go
@@ -11,6 +11,7 @@ import (
 
 	"github.com/hyperledger/fabric/gossip/comm"
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
@@ -27,19 +28,19 @@ func TestMockComm(t *testing.T) {
 	defer comm1.Stop()
 
 	msgCh := comm1.Accept(func(message interface{}) bool {
-		return message.(proto.ReceivedMessage).GetGossipMessage().GetStateRequest() != nil ||
-			message.(proto.ReceivedMessage).GetGossipMessage().GetStateResponse() != nil
+		return message.(protoext.ReceivedMessage).GetGossipMessage().GetStateRequest() != nil ||
+			message.(protoext.ReceivedMessage).GetGossipMessage().GetStateResponse() != nil
 	})
 
 	comm2 := NewCommMock(second.endpoint, members)
 	defer comm2.Stop()
 
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Content: &proto.GossipMessage_StateRequest{StateRequest: &proto.RemoteStateRequest{
 			StartSeqNum: 1,
 			EndSeqNum:   3,
 		}},
-	}).NoopSign()
+	})
 	comm2.Send(sMsg, &comm.RemotePeer{Endpoint: "first", PKIID: common.PKIidType("first")})
 
 	msg := <-msgCh
@@ -64,7 +65,7 @@ func TestMockComm_PingPong(t *testing.T) {
 	rcvChA := peerA.Accept(all)
 	rcvChB := peerB.Accept(all)
 
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Content: &proto.GossipMessage_DataMsg{
 			DataMsg: &proto.DataMessage{
 				Payload: &proto.Payload{
@@ -72,7 +73,7 @@ func TestMockComm_PingPong(t *testing.T) {
 					Data:   []byte("Ping"),
 				},
 			}},
-	}).NoopSign()
+	})
 	peerA.Send(sMsg, &comm.RemotePeer{Endpoint: "peerB", PKIID: common.PKIidType("peerB")})
 
 	msg := <-rcvChB
diff --git a/gossip/comm/msg.go b/gossip/comm/msg.go
index 283a528b..2f29a5b3 100644
--- a/gossip/comm/msg.go
+++ b/gossip/comm/msg.go
@@ -9,16 +9,17 @@ package comm
 import (
 	"sync"
 
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
 )
 
 // ReceivedMessageImpl is an implementation of ReceivedMessage
 type ReceivedMessageImpl struct {
-	*proto.SignedGossipMessage
+	*protoext.SignedGossipMessage
 	lock     sync.Locker
 	conn     *connection
-	connInfo *proto.ConnectionInfo
+	connInfo *protoext.ConnectionInfo
 }
 
 // GetSourceEnvelope Returns the Envelope the ReceivedMessage was
@@ -29,7 +30,7 @@ func (m *ReceivedMessageImpl) GetSourceEnvelope() *proto.Envelope {
 
 // Respond sends a msg to the source that sent the ReceivedMessageImpl
 func (m *ReceivedMessageImpl) Respond(msg *proto.GossipMessage) {
-	sMsg, err := msg.NoopSign()
+	sMsg, err := protoext.NoopSign(msg)
 	if err != nil {
 		err = errors.WithStack(err)
 		m.conn.logger.Errorf("Failed creating SignedGossipMessage: %+v", err)
@@ -39,13 +40,13 @@ func (m *ReceivedMessageImpl) Respond(msg *proto.GossipMessage) {
 }
 
 // GetGossipMessage returns the inner GossipMessage
-func (m *ReceivedMessageImpl) GetGossipMessage() *proto.SignedGossipMessage {
+func (m *ReceivedMessageImpl) GetGossipMessage() *protoext.SignedGossipMessage {
 	return m.SignedGossipMessage
 }
 
 // GetConnectionInfo returns information about the remote peer
 // that send the message
-func (m *ReceivedMessageImpl) GetConnectionInfo() *proto.ConnectionInfo {
+func (m *ReceivedMessageImpl) GetConnectionInfo() *protoext.ConnectionInfo {
 	return m.connInfo
 }
 
diff --git a/gossip/discovery/discovery.go b/gossip/discovery/discovery.go
index 675eb96f..08ab8fea 100644
--- a/gossip/discovery/discovery.go
+++ b/gossip/discovery/discovery.go
@@ -10,13 +10,14 @@ import (
 	"fmt"
 
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
 // CryptoService is an interface that the discovery expects to be implemented and passed on creation
 type CryptoService interface {
 	// ValidateAliveMsg validates that an Alive message is authentic
-	ValidateAliveMsg(message *proto.SignedGossipMessage) bool
+	ValidateAliveMsg(message *protoext.SignedGossipMessage) bool
 
 	// SignMessage signs a message
 	SignMessage(m *proto.GossipMessage, internalEndpoint string) *proto.Envelope
@@ -24,12 +25,12 @@ type CryptoService interface {
 
 // EnvelopeFilter may or may not remove part of the Envelope
 // that the given SignedGossipMessage originates from.
-type EnvelopeFilter func(message *proto.SignedGossipMessage) *proto.Envelope
+type EnvelopeFilter func(message *protoext.SignedGossipMessage) *proto.Envelope
 
 // Sieve defines the messages that are allowed to be sent to some remote peer,
 // based on some criteria.
 // Returns whether the sieve permits sending a given message.
-type Sieve func(message *proto.SignedGossipMessage) bool
+type Sieve func(message *protoext.SignedGossipMessage) bool
 
 // DisclosurePolicy defines which messages a given remote peer
 // is eligible of knowing about, and also what is it eligible
@@ -45,17 +46,17 @@ type DisclosurePolicy func(remotePeer *NetworkMember) (Sieve, EnvelopeFilter)
 // CommService is an interface that the discovery expects to be implemented and passed on creation
 type CommService interface {
 	// Gossip gossips a message
-	Gossip(msg *proto.SignedGossipMessage)
+	Gossip(msg *protoext.SignedGossipMessage)
 
 	// SendToPeer sends to a given peer a message.
 	// The nonce can be anything since the communication module handles the nonce itself
-	SendToPeer(peer *NetworkMember, msg *proto.SignedGossipMessage)
+	SendToPeer(peer *NetworkMember, msg *protoext.SignedGossipMessage)
 
 	// Ping probes a remote peer and returns if it's responsive or not
 	Ping(peer *NetworkMember) bool
 
 	// Accept returns a read-only channel for membership messages sent from remote peers
-	Accept() <-chan proto.ReceivedMessage
+	Accept() <-chan protoext.ReceivedMessage
 
 	// PresumedDead returns a read-only channel for peers that are presumed to be dead
 	PresumedDead() <-chan common.PKIidType
@@ -65,7 +66,7 @@ type CommService interface {
 
 	// Forward sends message to the next hop, excluding the hop
 	// from which message was initially received
-	Forward(msg proto.ReceivedMessage)
+	Forward(msg protoext.ReceivedMessage)
 }
 
 // NetworkMember is a peer's representation
diff --git a/gossip/discovery/discovery_impl.go b/gossip/discovery/discovery_impl.go
index 6900210d..852af113 100644
--- a/gossip/discovery/discovery_impl.go
+++ b/gossip/discovery/discovery_impl.go
@@ -18,6 +18,7 @@ import (
 
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/gossip/msgstore"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -56,7 +57,7 @@ type gossipDiscoveryImpl struct {
 	id2Member        map[string]*NetworkMember // all known members
 	aliveMembership  *util.MembershipStore
 	deadMembership   *util.MembershipStore
-	selfAliveMessage *proto.SignedGossipMessage
+	selfAliveMessage *protoext.SignedGossipMessage
 
 	msgStore *aliveMsgStore
 
@@ -164,13 +165,13 @@ func (d *gossipDiscoveryImpl) Connect(member NetworkMember, id identifier) {
 				d.logger.Warningf("Failed creating membership request: %+v", errors.WithStack(err))
 				continue
 			}
-			req, err := m.NoopSign()
+			req, err := protoext.NoopSign(m)
 			if err != nil {
 				d.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 				continue
 			}
 			req.Nonce = util.RandomUInt64()
-			req, err = req.NoopSign()
+			req, err = protoext.NoopSign(req.GossipMessage)
 			if err != nil {
 				d.logger.Warningf("Failed adding NONCE to SignedGossipMessage %+v", errors.WithStack(err))
 				continue
@@ -209,7 +210,7 @@ func (d *gossipDiscoveryImpl) validateSelfConfig() {
 	d.port = int(myPort)
 }
 
-func (d *gossipDiscoveryImpl) sendUntilAcked(peer *NetworkMember, message *proto.SignedGossipMessage) {
+func (d *gossipDiscoveryImpl) sendUntilAcked(peer *NetworkMember, message *protoext.SignedGossipMessage) {
 	nonce := message.Nonce
 	for i := 0; i < maxConnectionAttempts && !d.toDie(); i++ {
 		sub := d.pubsub.Subscribe(fmt.Sprintf("%d", nonce), time.Second*5)
@@ -231,7 +232,7 @@ func (d *gossipDiscoveryImpl) InitiateSync(peerNum int) {
 		d.logger.Warningf("Failed creating membership request: %+v", errors.WithStack(err))
 		return
 	}
-	memReq, err := m.NoopSign()
+	memReq, err := protoext.NoopSign(m)
 	if err != nil {
 		d.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -249,7 +250,7 @@ func (d *gossipDiscoveryImpl) InitiateSync(peerNum int) {
 		pulledPeer := aliveMembersAsSlice[i].GetAliveMsg().Membership
 		var internalEndpoint string
 		if aliveMembersAsSlice[i].Envelope.SecretEnvelope != nil {
-			internalEndpoint = aliveMembersAsSlice[i].Envelope.SecretEnvelope.InternalEndpoint()
+			internalEndpoint = protoext.InternalEndpoint(aliveMembersAsSlice[i].Envelope.SecretEnvelope)
 		}
 		netMember := &NetworkMember{
 			Endpoint:         pulledPeer.Endpoint,
@@ -305,7 +306,7 @@ func (d *gossipDiscoveryImpl) handleMessages() {
 	}
 }
 
-func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
+func (d *gossipDiscoveryImpl) handleMsgFromComm(msg protoext.ReceivedMessage) {
 	if msg == nil {
 		return
 	}
@@ -319,7 +320,7 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 	defer d.logger.Debug("Exiting")
 
 	if memReq := m.GetMemReq(); memReq != nil {
-		selfInfoGossipMsg, err := memReq.SelfInformation.ToGossipMessage()
+		selfInfoGossipMsg, err := protoext.EnvelopeToGossipMessage(memReq.SelfInformation)
 		if err != nil {
 			d.logger.Warningf("Failed deserializing GossipMessage from envelope: %+v", errors.WithStack(err))
 			return
@@ -335,7 +336,7 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 
 		var internalEndpoint string
 		if m.Envelope.SecretEnvelope != nil {
-			internalEndpoint = m.Envelope.SecretEnvelope.InternalEndpoint()
+			internalEndpoint = protoext.InternalEndpoint(m.Envelope.SecretEnvelope)
 		}
 
 		// Sending a membership response to a peer may block this routine
@@ -345,7 +346,7 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 		return
 	}
 
-	if m.IsAliveMsg() {
+	if protoext.IsAliveMsg(m.GossipMessage) {
 		if !d.msgStore.CheckValid(m) || !d.crypt.ValidateAliveMsg(m) {
 			return
 		}
@@ -363,12 +364,12 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 	if memResp := m.GetMemRes(); memResp != nil {
 		d.pubsub.Publish(fmt.Sprintf("%d", m.Nonce), m.Nonce)
 		for _, env := range memResp.Alive {
-			am, err := env.ToGossipMessage()
+			am, err := protoext.EnvelopeToGossipMessage(env)
 			if err != nil {
 				d.logger.Warningf("Membership response contains an invalid message from an online peer:%+v", errors.WithStack(err))
 				return
 			}
-			if !am.IsAliveMsg() {
+			if !protoext.IsAliveMsg(am.GossipMessage) {
 				d.logger.Warning("Expected alive message, got", am, "instead")
 				return
 			}
@@ -379,7 +380,7 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 		}
 
 		for _, env := range memResp.Dead {
-			dm, err := env.ToGossipMessage()
+			dm, err := protoext.EnvelopeToGossipMessage(env)
 			if err != nil {
 				d.logger.Warningf("Membership response contains an invalid message from an offline peer %+v", errors.WithStack(err))
 				return
@@ -390,13 +391,13 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 				continue
 			}
 
-			newDeadMembers := []*proto.SignedGossipMessage{}
+			newDeadMembers := []*protoext.SignedGossipMessage{}
 			d.lock.RLock()
 			if _, known := d.id2Member[string(dm.GetAliveMsg().Membership.PkiId)]; !known {
 				newDeadMembers = append(newDeadMembers, dm)
 			}
 			d.lock.RUnlock()
-			d.learnNewMembers([]*proto.SignedGossipMessage{}, newDeadMembers)
+			d.learnNewMembers([]*protoext.SignedGossipMessage{}, newDeadMembers)
 		}
 	}
 }
@@ -411,7 +412,7 @@ func (d *gossipDiscoveryImpl) sendMemResponse(targetMember *proto.Member, intern
 		InternalEndpoint: internalEndpoint,
 	}
 
-	var aliveMsg *proto.SignedGossipMessage
+	var aliveMsg *protoext.SignedGossipMessage
 	var err error
 	d.lock.RLock()
 	aliveMsg = d.selfAliveMessage
@@ -433,13 +434,13 @@ func (d *gossipDiscoveryImpl) sendMemResponse(targetMember *proto.Member, intern
 
 	defer d.logger.Debug("Exiting, replying with", memResp)
 
-	msg, err := (&proto.GossipMessage{
+	msg, err := protoext.NoopSign(&proto.GossipMessage{
 		Tag:   proto.GossipMessage_EMPTY,
 		Nonce: nonce,
 		Content: &proto.GossipMessage_MemRes{
 			MemRes: memResp,
 		},
-	}).NoopSign()
+	})
 	if err != nil {
 		err = errors.WithStack(err)
 		d.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
@@ -448,7 +449,7 @@ func (d *gossipDiscoveryImpl) sendMemResponse(targetMember *proto.Member, intern
 	d.comm.SendToPeer(targetPeer, msg)
 }
 
-func (d *gossipDiscoveryImpl) createMembershipResponse(aliveMsg *proto.SignedGossipMessage, targetMember *NetworkMember) *proto.MembershipResponse {
+func (d *gossipDiscoveryImpl) createMembershipResponse(aliveMsg *protoext.SignedGossipMessage, targetMember *NetworkMember) *proto.MembershipResponse {
 	shouldBeDisclosed, omitConcealedFields := d.disclosurePolicy(targetMember)
 
 	if !shouldBeDisclosed(aliveMsg) {
@@ -482,7 +483,7 @@ func (d *gossipDiscoveryImpl) createMembershipResponse(aliveMsg *proto.SignedGos
 	}
 }
 
-func (d *gossipDiscoveryImpl) handleAliveMessage(m *proto.SignedGossipMessage) {
+func (d *gossipDiscoveryImpl) handleAliveMessage(m *protoext.SignedGossipMessage) {
 	d.logger.Debug("Entering", m)
 	defer d.logger.Debug("Exiting")
 
@@ -499,7 +500,7 @@ func (d *gossipDiscoveryImpl) handleAliveMessage(m *proto.SignedGossipMessage) {
 	d.lock.RUnlock()
 
 	if !known {
-		d.learnNewMembers([]*proto.SignedGossipMessage{m}, []*proto.SignedGossipMessage{})
+		d.learnNewMembers([]*protoext.SignedGossipMessage{m}, []*protoext.SignedGossipMessage{})
 		return
 	}
 
@@ -534,7 +535,7 @@ func (d *gossipDiscoveryImpl) handleAliveMessage(m *proto.SignedGossipMessage) {
 
 	if isAlive {
 		if before(lastAliveTS, ts) {
-			d.learnExistingMembers([]*proto.SignedGossipMessage{m})
+			d.learnExistingMembers([]*protoext.SignedGossipMessage{m})
 		} else if !same(lastAliveTS, ts) {
 			d.logger.Debug(m.GetAliveMsg().Membership, "lastAliveTS:", lastAliveTS, "but got ts:", ts)
 		}
@@ -543,7 +544,7 @@ func (d *gossipDiscoveryImpl) handleAliveMessage(m *proto.SignedGossipMessage) {
 	// else, ignore the message because it is too old
 }
 
-func (d *gossipDiscoveryImpl) isSentByMe(m *proto.SignedGossipMessage) bool {
+func (d *gossipDiscoveryImpl) isSentByMe(m *protoext.SignedGossipMessage) bool {
 	pkiID := m.GetAliveMsg().Membership.PkiId
 	if !equalPKIid(pkiID, d.self.PKIid) {
 		return false
@@ -552,8 +553,11 @@ func (d *gossipDiscoveryImpl) isSentByMe(m *proto.SignedGossipMessage) bool {
 	diffExternalEndpoint := d.self.Endpoint != m.GetAliveMsg().Membership.Endpoint
 	var diffInternalEndpoint bool
 	secretEnvelope := m.GetSecretEnvelope()
-	if secretEnvelope != nil && secretEnvelope.InternalEndpoint() != "" {
-		diffInternalEndpoint = secretEnvelope.InternalEndpoint() != d.self.InternalEndpoint
+	if secretEnvelope != nil {
+		internalEndpoint := protoext.InternalEndpoint(secretEnvelope)
+		if internalEndpoint != "" {
+			diffInternalEndpoint = internalEndpoint != d.self.InternalEndpoint
+		}
 	}
 	if diffInternalEndpoint || diffExternalEndpoint {
 		d.logger.Error("Bad configuration detected: Received AliveMessage from a peer with the same PKI-ID as myself:", m.GossipMessage)
@@ -561,7 +565,7 @@ func (d *gossipDiscoveryImpl) isSentByMe(m *proto.SignedGossipMessage) bool {
 	return true
 }
 
-func (d *gossipDiscoveryImpl) resurrectMember(am *proto.SignedGossipMessage, t proto.PeerTime) {
+func (d *gossipDiscoveryImpl) resurrectMember(am *protoext.SignedGossipMessage, t proto.PeerTime) {
 	d.logger.Debug("Entering, AliveMessage:", am, "t:", t)
 	defer d.logger.Debug("Exiting")
 	d.lock.Lock()
@@ -580,7 +584,7 @@ func (d *gossipDiscoveryImpl) resurrectMember(am *proto.SignedGossipMessage, t p
 		internalEndpoint = prevNetMem.InternalEndpoint
 	}
 	if am.Envelope.SecretEnvelope != nil {
-		internalEndpoint = am.Envelope.SecretEnvelope.InternalEndpoint()
+		internalEndpoint = protoext.InternalEndpoint(am.Envelope.SecretEnvelope)
 	}
 
 	d.id2Member[string(pkiID)] = &NetworkMember{
@@ -592,7 +596,7 @@ func (d *gossipDiscoveryImpl) resurrectMember(am *proto.SignedGossipMessage, t p
 
 	delete(d.deadLastTS, string(pkiID))
 	d.deadMembership.Remove(common.PKIidType(pkiID))
-	d.aliveMembership.Put(common.PKIidType(pkiID), &proto.SignedGossipMessage{GossipMessage: am.GossipMessage, Envelope: am.Envelope})
+	d.aliveMembership.Put(common.PKIidType(pkiID), &protoext.SignedGossipMessage{GossipMessage: am.GossipMessage, Envelope: am.Envelope})
 }
 
 func (d *gossipDiscoveryImpl) periodicalReconnectToDead() {
@@ -626,7 +630,7 @@ func (d *gossipDiscoveryImpl) sendMembershipRequest(member *NetworkMember, inclu
 		d.logger.Warningf("Failed creating membership request: %+v", errors.WithStack(err))
 		return
 	}
-	req, err := m.NoopSign()
+	req, err := protoext.NoopSign(m)
 	if err != nil {
 		d.logger.Errorf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -774,13 +778,13 @@ func (d *gossipDiscoveryImpl) aliveMsgAndInternalEndpoint() (*proto.GossipMessag
 	return msg, internalEndpoint
 }
 
-func (d *gossipDiscoveryImpl) createSignedAliveMessage(includeInternalEndpoint bool) (*proto.SignedGossipMessage, error) {
+func (d *gossipDiscoveryImpl) createSignedAliveMessage(includeInternalEndpoint bool) (*protoext.SignedGossipMessage, error) {
 	msg, internalEndpoint := d.aliveMsgAndInternalEndpoint()
 	envp := d.crypt.SignMessage(msg, internalEndpoint)
 	if envp == nil {
 		return nil, errors.New("Failed signing message")
 	}
-	signedMsg := &proto.SignedGossipMessage{
+	signedMsg := &protoext.SignedGossipMessage{
 		GossipMessage: msg,
 		Envelope:      envp,
 	}
@@ -792,7 +796,7 @@ func (d *gossipDiscoveryImpl) createSignedAliveMessage(includeInternalEndpoint b
 	return signedMsg, nil
 }
 
-func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*proto.SignedGossipMessage) {
+func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*protoext.SignedGossipMessage) {
 	d.logger.Debugf("Entering: learnedMembers={%v}", aliveArr)
 	defer d.logger.Debug("Exiting")
 
@@ -812,7 +816,7 @@ func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*proto.SignedGossi
 			internalEndpoint = prevNetMem.InternalEndpoint
 		}
 		if m.Envelope.SecretEnvelope != nil {
-			internalEndpoint = m.Envelope.SecretEnvelope.InternalEndpoint()
+			internalEndpoint = protoext.InternalEndpoint(m.Envelope.SecretEnvelope)
 		}
 
 		// update member's data
@@ -839,7 +843,7 @@ func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*proto.SignedGossi
 
 			if am := d.aliveMembership.MsgByID(m.GetAliveMsg().Membership.PkiId); am == nil {
 				d.logger.Debug("Adding", am, "to aliveMembership")
-				msg := &proto.SignedGossipMessage{GossipMessage: m.GossipMessage, Envelope: am.Envelope}
+				msg := &protoext.SignedGossipMessage{GossipMessage: m.GossipMessage, Envelope: am.Envelope}
 				d.aliveMembership.Put(m.GetAliveMsg().Membership.PkiId, msg)
 			} else {
 				d.logger.Debug("Replacing", am, "in aliveMembership")
@@ -850,7 +854,7 @@ func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*proto.SignedGossi
 	}
 }
 
-func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*proto.SignedGossipMessage, deadMembers []*proto.SignedGossipMessage) {
+func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*protoext.SignedGossipMessage, deadMembers []*protoext.SignedGossipMessage) {
 	d.logger.Debugf("Entering: learnedMembers={%v}, deadMembers={%v}", aliveMembers, deadMembers)
 	defer d.logger.Debugf("Exiting")
 
@@ -867,7 +871,7 @@ func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*proto.SignedGossip
 			seqNum:   am.GetAliveMsg().Timestamp.SeqNum,
 		}
 
-		d.aliveMembership.Put(am.GetAliveMsg().Membership.PkiId, &proto.SignedGossipMessage{GossipMessage: am.GossipMessage, Envelope: am.Envelope})
+		d.aliveMembership.Put(am.GetAliveMsg().Membership.PkiId, &protoext.SignedGossipMessage{GossipMessage: am.GossipMessage, Envelope: am.Envelope})
 		d.logger.Debugf("Learned about a new alive member: %v", am)
 	}
 
@@ -881,12 +885,12 @@ func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*proto.SignedGossip
 			seqNum:   dm.GetAliveMsg().Timestamp.SeqNum,
 		}
 
-		d.deadMembership.Put(dm.GetAliveMsg().Membership.PkiId, &proto.SignedGossipMessage{GossipMessage: dm.GossipMessage, Envelope: dm.Envelope})
+		d.deadMembership.Put(dm.GetAliveMsg().Membership.PkiId, &protoext.SignedGossipMessage{GossipMessage: dm.GossipMessage, Envelope: dm.Envelope})
 		d.logger.Debugf("Learned about a new dead member: %v", dm)
 	}
 
 	// update the member in any case
-	for _, a := range [][]*proto.SignedGossipMessage{aliveMembers, deadMembers} {
+	for _, a := range [][]*protoext.SignedGossipMessage{aliveMembers, deadMembers} {
 		for _, m := range a {
 			member := m.GetAliveMsg()
 			if member == nil {
@@ -896,7 +900,7 @@ func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*proto.SignedGossip
 
 			var internalEndpoint string
 			if m.Envelope.SecretEnvelope != nil {
-				internalEndpoint = m.Envelope.SecretEnvelope.InternalEndpoint()
+				internalEndpoint = protoext.InternalEndpoint(m.Envelope.SecretEnvelope)
 			}
 
 			if prevNetMem := d.id2Member[string(member.Membership.PkiId)]; prevNetMem != nil {
@@ -955,7 +959,7 @@ func (d *gossipDiscoveryImpl) UpdateEndpoint(endpoint string) {
 func (d *gossipDiscoveryImpl) Self() NetworkMember {
 	var env *proto.Envelope
 	msg, _ := d.aliveMsgAndInternalEndpoint()
-	sMsg, err := msg.NoopSign()
+	sMsg, err := protoext.NoopSign(msg)
 	if err != nil {
 		d.logger.Warning("Failed creating SignedGossipMessage:", err)
 	} else {
@@ -1011,14 +1015,14 @@ type aliveMsgStore struct {
 }
 
 func newAliveMsgStore(d *gossipDiscoveryImpl) *aliveMsgStore {
-	policy := proto.NewGossipMessageComparator(0)
+	policy := protoext.NewGossipMessageComparator(0)
 	trigger := func(m interface{}) {}
 	aliveMsgTTL := d.aliveExpirationTimeout * msgExpirationFactor
 	externalLock := func() { d.lock.Lock() }
 	externalUnlock := func() { d.lock.Unlock() }
 	callback := func(m interface{}) {
-		msg := m.(*proto.SignedGossipMessage)
-		if !msg.IsAliveMsg() {
+		msg := m.(*protoext.SignedGossipMessage)
+		if !protoext.IsAliveMsg(msg.GossipMessage) {
 			return
 		}
 		id := msg.GetAliveMsg().Membership.PkiId
@@ -1036,14 +1040,16 @@ func newAliveMsgStore(d *gossipDiscoveryImpl) *aliveMsgStore {
 }
 
 func (s *aliveMsgStore) Add(msg interface{}) bool {
-	if !msg.(*proto.SignedGossipMessage).IsAliveMsg() {
+	m := msg.(*protoext.SignedGossipMessage)
+	if !protoext.IsAliveMsg(m.GossipMessage) {
 		panic(fmt.Sprint("Msg ", msg, " is not AliveMsg"))
 	}
 	return s.MessageStore.Add(msg)
 }
 
 func (s *aliveMsgStore) CheckValid(msg interface{}) bool {
-	if !msg.(*proto.SignedGossipMessage).IsAliveMsg() {
+	m := msg.(*protoext.SignedGossipMessage)
+	if !protoext.IsAliveMsg(m.GossipMessage) {
 		panic(fmt.Sprint("Msg ", msg, " is not AliveMsg"))
 	}
 	return s.MessageStore.CheckValid(msg)
diff --git a/gossip/discovery/discovery_test.go b/gossip/discovery/discovery_test.go
index d7ee548f..bb7e5b85 100644
--- a/gossip/discovery/discovery_test.go
+++ b/gossip/discovery/discovery_test.go
@@ -24,6 +24,7 @@ import (
 	protoG "github.com/golang/protobuf/proto"
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/gossip/msgstore"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -47,15 +48,15 @@ func init() {
 }
 
 type dummyReceivedMessage struct {
-	msg  *proto.SignedGossipMessage
-	info *proto.ConnectionInfo
+	msg  *protoext.SignedGossipMessage
+	info *protoext.ConnectionInfo
 }
 
 func (*dummyReceivedMessage) Respond(msg *proto.GossipMessage) {
 	panic("implement me")
 }
 
-func (rm *dummyReceivedMessage) GetGossipMessage() *proto.SignedGossipMessage {
+func (rm *dummyReceivedMessage) GetGossipMessage() *protoext.SignedGossipMessage {
 	return rm.msg
 }
 
@@ -63,7 +64,7 @@ func (*dummyReceivedMessage) GetSourceEnvelope() *proto.Envelope {
 	panic("implement me")
 }
 
-func (rm *dummyReceivedMessage) GetConnectionInfo() *proto.ConnectionInfo {
+func (rm *dummyReceivedMessage) GetConnectionInfo() *protoext.ConnectionInfo {
 	return rm.info
 }
 
@@ -72,7 +73,7 @@ func (*dummyReceivedMessage) Ack(err error) {
 }
 
 type dummyCommModule struct {
-	validatedMessages chan *proto.SignedGossipMessage
+	validatedMessages chan *protoext.SignedGossipMessage
 	msgsReceived      uint32
 	msgsSent          uint32
 	id                string
@@ -81,14 +82,14 @@ type dummyCommModule struct {
 	streams           map[string]proto.Gossip_GossipStreamClient
 	conns             map[string]*grpc.ClientConn
 	lock              *sync.RWMutex
-	incMsgs           chan proto.ReceivedMessage
+	incMsgs           chan protoext.ReceivedMessage
 	lastSeqs          map[string]uint64
 	shouldGossip      bool
 	mock              *mock.Mock
 }
 
 type gossipInstance struct {
-	msgInterceptor func(*proto.SignedGossipMessage)
+	msgInterceptor func(*protoext.SignedGossipMessage)
 	comm           *dummyCommModule
 	Discovery
 	gRGCserv      *grpc.Server
@@ -99,7 +100,7 @@ type gossipInstance struct {
 	port          int
 }
 
-func (comm *dummyCommModule) ValidateAliveMsg(am *proto.SignedGossipMessage) bool {
+func (comm *dummyCommModule) ValidateAliveMsg(am *protoext.SignedGossipMessage) bool {
 	comm.lock.RLock()
 	c := comm.validatedMessages
 	comm.lock.RUnlock()
@@ -110,14 +111,14 @@ func (comm *dummyCommModule) ValidateAliveMsg(am *proto.SignedGossipMessage) boo
 	return true
 }
 
-func (comm *dummyCommModule) recordValidation(validatedMessages chan *proto.SignedGossipMessage) {
+func (comm *dummyCommModule) recordValidation(validatedMessages chan *protoext.SignedGossipMessage) {
 	comm.lock.Lock()
 	defer comm.lock.Unlock()
 	comm.validatedMessages = validatedMessages
 }
 
 func (comm *dummyCommModule) SignMessage(am *proto.GossipMessage, internalEndpoint string) *proto.Envelope {
-	am.NoopSign()
+	protoext.NoopSign(am)
 
 	secret := &proto.Secret{
 		Content: &proto.Secret_InternalEndpoint{
@@ -127,13 +128,13 @@ func (comm *dummyCommModule) SignMessage(am *proto.GossipMessage, internalEndpoi
 	signer := func(msg []byte) ([]byte, error) {
 		return nil, nil
 	}
-	s, _ := am.NoopSign()
+	s, _ := protoext.NoopSign(am)
 	env := s.Envelope
-	env.SignSecret(signer, secret)
+	protoext.SignSecret(env, signer, secret)
 	return env
 }
 
-func (comm *dummyCommModule) Gossip(msg *proto.SignedGossipMessage) {
+func (comm *dummyCommModule) Gossip(msg *protoext.SignedGossipMessage) {
 	if !comm.shouldGossip {
 		return
 	}
@@ -144,7 +145,7 @@ func (comm *dummyCommModule) Gossip(msg *proto.SignedGossipMessage) {
 	}
 }
 
-func (comm *dummyCommModule) Forward(msg proto.ReceivedMessage) {
+func (comm *dummyCommModule) Forward(msg protoext.ReceivedMessage) {
 	if !comm.shouldGossip {
 		return
 	}
@@ -155,7 +156,7 @@ func (comm *dummyCommModule) Forward(msg proto.ReceivedMessage) {
 	}
 }
 
-func (comm *dummyCommModule) SendToPeer(peer *NetworkMember, msg *proto.SignedGossipMessage) {
+func (comm *dummyCommModule) SendToPeer(peer *NetworkMember, msg *protoext.SignedGossipMessage) {
 	comm.lock.RLock()
 	_, exists := comm.streams[peer.Endpoint]
 	mock := comm.mock
@@ -172,7 +173,7 @@ func (comm *dummyCommModule) SendToPeer(peer *NetworkMember, msg *proto.SignedGo
 		}
 	}
 	comm.lock.Lock()
-	s, _ := msg.NoopSign()
+	s, _ := protoext.NoopSign(msg.GossipMessage)
 	comm.streams[peer.Endpoint].Send(s.Envelope)
 	comm.lock.Unlock()
 	atomic.AddUint32(&comm.msgsSent, 1)
@@ -206,7 +207,7 @@ func (comm *dummyCommModule) Ping(peer *NetworkMember) bool {
 	return true
 }
 
-func (comm *dummyCommModule) Accept() <-chan proto.ReceivedMessage {
+func (comm *dummyCommModule) Accept() <-chan protoext.ReceivedMessage {
 	return comm.incMsgs
 }
 
@@ -264,7 +265,7 @@ func (g *gossipInstance) GossipStream(stream proto.Gossip_GossipStreamServer) er
 			return err
 		}
 		lgr := g.Discovery.(*gossipDiscoveryImpl).logger
-		gMsg, err := envelope.ToGossipMessage()
+		gMsg, err := protoext.EnvelopeToGossipMessage(envelope)
 		if err != nil {
 			lgr.Warning("Failed deserializing GossipMessage from envelope:", err)
 			continue
@@ -274,7 +275,7 @@ func (g *gossipInstance) GossipStream(stream proto.Gossip_GossipStreamServer) er
 		lgr.Debug(g.Discovery.Self().Endpoint, "Got message:", gMsg)
 		g.comm.incMsgs <- &dummyReceivedMessage{
 			msg: gMsg,
-			info: &proto.ConnectionInfo{
+			info: &protoext.ConnectionInfo{
 				ID: common.PKIidType("testID"),
 			},
 		}
@@ -286,7 +287,7 @@ func (g *gossipInstance) GossipStream(stream proto.Gossip_GossipStreamServer) er
 	}
 }
 
-func (g *gossipInstance) tryForwardMessage(msg *proto.SignedGossipMessage) {
+func (g *gossipInstance) tryForwardMessage(msg *protoext.SignedGossipMessage) {
 	g.comm.lock.Lock()
 
 	aliveMsg := msg.GetAliveMsg()
@@ -333,9 +334,9 @@ func (g *gossipInstance) Ping(context.Context, *proto.Empty) (*proto.Empty, erro
 }
 
 var noopPolicy = func(remotePeer *NetworkMember) (Sieve, EnvelopeFilter) {
-	return func(msg *proto.SignedGossipMessage) bool {
+	return func(msg *protoext.SignedGossipMessage) bool {
 			return true
-		}, func(message *proto.SignedGossipMessage) *proto.Envelope {
+		}, func(message *protoext.SignedGossipMessage) *proto.Envelope {
 			return message.Envelope
 		}
 }
@@ -353,14 +354,14 @@ func createDiscoveryInstanceWithNoGossipWithDisclosurePolicy(port int, id string
 }
 
 func createDiscoveryInstanceThatGossips(port int, id string, bootstrapPeers []string, shouldGossip bool, pol DisclosurePolicy) *gossipInstance {
-	return createDiscoveryInstanceThatGossipsWithInterceptors(port, id, bootstrapPeers, shouldGossip, pol, func(_ *proto.SignedGossipMessage) {})
+	return createDiscoveryInstanceThatGossipsWithInterceptors(port, id, bootstrapPeers, shouldGossip, pol, func(_ *protoext.SignedGossipMessage) {})
 }
 
-func createDiscoveryInstanceThatGossipsWithInterceptors(port int, id string, bootstrapPeers []string, shouldGossip bool, pol DisclosurePolicy, f func(*proto.SignedGossipMessage)) *gossipInstance {
+func createDiscoveryInstanceThatGossipsWithInterceptors(port int, id string, bootstrapPeers []string, shouldGossip bool, pol DisclosurePolicy, f func(*protoext.SignedGossipMessage)) *gossipInstance {
 	comm := &dummyCommModule{
 		conns:        make(map[string]*grpc.ClientConn),
 		streams:      make(map[string]proto.Gossip_GossipStreamClient),
-		incMsgs:      make(chan proto.ReceivedMessage, 1000),
+		incMsgs:      make(chan protoext.ReceivedMessage, 1000),
 		presumeDead:  make(chan common.PKIidType, 10000),
 		id:           id,
 		detectedDead: make(chan string, 10000),
@@ -453,14 +454,14 @@ func TestNetworkMemberString(t *testing.T) {
 func TestBadInput(t *testing.T) {
 	inst := createDiscoveryInstance(2048, fmt.Sprintf("d%d", 0), []string{})
 	inst.Discovery.(*gossipDiscoveryImpl).handleMsgFromComm(nil)
-	s, _ := (&proto.GossipMessage{
+	s, _ := protoext.NoopSign(&proto.GossipMessage{
 		Content: &proto.GossipMessage_DataMsg{
 			DataMsg: &proto.DataMessage{},
 		},
-	}).NoopSign()
+	})
 	inst.Discovery.(*gossipDiscoveryImpl).handleMsgFromComm(&dummyReceivedMessage{
 		msg: s,
-		info: &proto.ConnectionInfo{
+		info: &protoext.ConnectionInfo{
 			ID: common.PKIidType("testID"),
 		},
 	})
@@ -470,7 +471,7 @@ func TestConnect(t *testing.T) {
 	t.Parallel()
 	nodeNum := 10
 	instances := []*gossipInstance{}
-	firstSentMemReqMsgs := make(chan *proto.SignedGossipMessage, nodeNum)
+	firstSentMemReqMsgs := make(chan *protoext.SignedGossipMessage, nodeNum)
 	for i := 0; i < nodeNum; i++ {
 		inst := createDiscoveryInstance(7611+i, fmt.Sprintf("d%d", i), []string{})
 
@@ -478,9 +479,9 @@ func TestConnect(t *testing.T) {
 		inst.comm.mock = &mock.Mock{}
 		inst.comm.mock.On("SendToPeer", mock.Anything, mock.Anything).Run(func(arguments mock.Arguments) {
 			inst := inst
-			msg := arguments.Get(1).(*proto.SignedGossipMessage)
+			msg := arguments.Get(1).(*protoext.SignedGossipMessage)
 			if req := msg.GetMemReq(); req != nil {
-				selfMsg, _ := req.SelfInformation.ToGossipMessage()
+				selfMsg, _ := protoext.EnvelopeToGossipMessage(req.SelfInformation)
 				firstSentMemReqMsgs <- selfMsg
 				inst.comm.lock.Lock()
 				inst.comm.mock = nil
@@ -506,10 +507,10 @@ func TestConnect(t *testing.T) {
 
 	discInst := instances[rand.Intn(len(instances))].Discovery.(*gossipDiscoveryImpl)
 	mr, _ := discInst.createMembershipRequest(true)
-	am, _ := mr.GetMemReq().SelfInformation.ToGossipMessage()
+	am, _ := protoext.EnvelopeToGossipMessage(mr.GetMemReq().SelfInformation)
 	assert.NotNil(t, am.SecretEnvelope)
 	mr2, _ := discInst.createMembershipRequest(false)
-	am, _ = mr2.GetMemReq().SelfInformation.ToGossipMessage()
+	am, _ = protoext.EnvelopeToGossipMessage(mr2.GetMemReq().SelfInformation)
 	assert.Nil(t, am.SecretEnvelope)
 	stopInstances(t, instances)
 	assert.Len(t, firstSentMemReqMsgs, 10)
@@ -529,30 +530,30 @@ func TestValidation(t *testing.T) {
 	//   2.2) once alive messages enter the message store, reception of them via membership responses
 	//        doesn't trigger validation, but via membership requests - do.
 
-	wrapReceivedMessage := func(msg *proto.SignedGossipMessage) proto.ReceivedMessage {
+	wrapReceivedMessage := func(msg *protoext.SignedGossipMessage) protoext.ReceivedMessage {
 		return &dummyReceivedMessage{
 			msg: msg,
-			info: &proto.ConnectionInfo{
+			info: &protoext.ConnectionInfo{
 				ID: common.PKIidType("testID"),
 			},
 		}
 	}
 
-	requestMessagesReceived := make(chan *proto.SignedGossipMessage, 100)
-	responseMessagesReceived := make(chan *proto.SignedGossipMessage, 100)
-	aliveMessagesReceived := make(chan *proto.SignedGossipMessage, 5000)
+	requestMessagesReceived := make(chan *protoext.SignedGossipMessage, 100)
+	responseMessagesReceived := make(chan *protoext.SignedGossipMessage, 100)
+	aliveMessagesReceived := make(chan *protoext.SignedGossipMessage, 5000)
 
 	var membershipRequest atomic.Value
 	var membershipResponseWithAlivePeers atomic.Value
 	var membershipResponseWithDeadPeers atomic.Value
 
-	recordMembershipRequest := func(req *proto.SignedGossipMessage) {
-		msg, _ := req.GetMemReq().SelfInformation.ToGossipMessage()
+	recordMembershipRequest := func(req *protoext.SignedGossipMessage) {
+		msg, _ := protoext.EnvelopeToGossipMessage(req.GetMemReq().SelfInformation)
 		membershipRequest.Store(req)
 		requestMessagesReceived <- msg
 	}
 
-	recordMembershipResponse := func(res *proto.SignedGossipMessage) {
+	recordMembershipResponse := func(res *protoext.SignedGossipMessage) {
 		memRes := res.GetMemRes()
 		if len(memRes.GetAlive()) > 0 {
 			membershipResponseWithAlivePeers.Store(res)
@@ -563,7 +564,7 @@ func TestValidation(t *testing.T) {
 		responseMessagesReceived <- res
 	}
 
-	interceptor := func(msg *proto.SignedGossipMessage) {
+	interceptor := func(msg *protoext.SignedGossipMessage) {
 		if memReq := msg.GetMemReq(); memReq != nil {
 			recordMembershipRequest(msg)
 			return
@@ -619,9 +620,9 @@ func TestValidation(t *testing.T) {
 		p4 := createDiscoveryInstance(4678, "p1", nil)
 		defer p4.Stop()
 		// Record messages validated
-		validatedMessages := make(chan *proto.SignedGossipMessage, 5000)
+		validatedMessages := make(chan *protoext.SignedGossipMessage, 5000)
 		p4.comm.recordValidation(validatedMessages)
-		tmpMsgs := make(chan *proto.SignedGossipMessage, 5000)
+		tmpMsgs := make(chan *protoext.SignedGossipMessage, 5000)
 		// Replay the messages sent to p1 into p4, and also save them into a temporary channel
 		for msg := range aliveMessagesReceived {
 			p4.comm.incMsgs <- wrapReceivedMessage(msg)
@@ -629,7 +630,7 @@ func TestValidation(t *testing.T) {
 		}
 
 		// Simulate the messages received by p4 into the message store
-		policy := proto.NewGossipMessageComparator(0)
+		policy := protoext.NewGossipMessageComparator(0)
 		msgStore := msgstore.NewMessageStore(policy, func(_ interface{}) {})
 		close(tmpMsgs)
 		for msg := range tmpMsgs {
@@ -643,8 +644,8 @@ func TestValidation(t *testing.T) {
 		assert.Empty(t, validatedMessages)
 	})
 
-	req := membershipRequest.Load().(*proto.SignedGossipMessage)
-	res := membershipResponseWithDeadPeers.Load().(*proto.SignedGossipMessage)
+	req := membershipRequest.Load().(*protoext.SignedGossipMessage)
+	res := membershipResponseWithDeadPeers.Load().(*protoext.SignedGossipMessage)
 	// Ensure the membership response contains both alive and dead peers
 	assert.Len(t, res.GetMemRes().GetAlive(), 2)
 	assert.Len(t, res.GetMemRes().GetDead(), 1)
@@ -653,7 +654,7 @@ func TestValidation(t *testing.T) {
 		name                  string
 		expectedAliveMessages int
 		port                  int
-		message               *proto.SignedGossipMessage
+		message               *protoext.SignedGossipMessage
 		shouldBeReValidated   bool
 	}{
 		{
@@ -676,7 +677,7 @@ func TestValidation(t *testing.T) {
 			p := createDiscoveryInstance(testCase.port, "p", nil)
 			defer p.Stop()
 			// Record messages validated
-			validatedMessages := make(chan *proto.SignedGossipMessage, testCase.expectedAliveMessages)
+			validatedMessages := make(chan *protoext.SignedGossipMessage, testCase.expectedAliveMessages)
 			p.comm.recordValidation(validatedMessages)
 
 			p.comm.incMsgs <- wrapReceivedMessage(testCase.message)
@@ -791,7 +792,7 @@ func TestSelf(t *testing.T) {
 	inst := createDiscoveryInstance(13463, "d1", []string{})
 	defer inst.Stop()
 	env := inst.Self().Envelope
-	sMsg, err := env.ToGossipMessage()
+	sMsg, err := protoext.EnvelopeToGossipMessage(env)
 	assert.NoError(t, err)
 	member := sMsg.GetAliveMsg().Membership
 	assert.Equal(t, "localhost:13463", member.Endpoint)
@@ -1056,7 +1057,7 @@ func discPolForPeer(selfPort int) DisclosurePolicy {
 	return func(remotePeer *NetworkMember) (Sieve, EnvelopeFilter) {
 		targetPortStr := strings.Split(remotePeer.Endpoint, ":")[1]
 		targetPort, _ := strconv.ParseInt(targetPortStr, 10, 64)
-		return func(msg *proto.SignedGossipMessage) bool {
+		return func(msg *protoext.SignedGossipMessage) bool {
 				portOfAliveMsgStr := strings.Split(msg.GetAliveMsg().Membership.Endpoint, ":")[1]
 				portOfAliveMsg, _ := strconv.ParseInt(portOfAliveMsgStr, 10, 64)
 
@@ -1069,7 +1070,7 @@ func discPolForPeer(selfPort int) DisclosurePolicy {
 
 				// Else, expose peers with even ids to other peers with even ids
 				return portOfAliveMsg%2 == 0 && targetPort%2 == 0
-			}, func(msg *proto.SignedGossipMessage) *proto.Envelope {
+			}, func(msg *protoext.SignedGossipMessage) *proto.Envelope {
 				envelope := protoG.Clone(msg.Envelope).(*proto.Envelope)
 				if selfPort < 8615 && targetPort >= 8615 {
 					envelope.SecretEnvelope = nil
@@ -1138,7 +1139,7 @@ func TestMsgStoreExpiration(t *testing.T) {
 					return false
 				}
 				for _, am := range downCastInst.msgStore.Get() {
-					m := am.(*proto.SignedGossipMessage).GetAliveMsg()
+					m := am.(*protoext.SignedGossipMessage).GetAliveMsg()
 					if bytes.Equal(m.Membership.PkiId, downInst.discoveryImpl().self.PKIid) {
 						downCastInst.lock.RUnlock()
 						return false
@@ -1174,9 +1175,9 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 	bootPeers := []string{}
 	peersNum := 3
 	instances := []*gossipInstance{}
-	aliveMsgs := []*proto.SignedGossipMessage{}
-	newAliveMsgs := []*proto.SignedGossipMessage{}
-	memReqMsgs := []*proto.SignedGossipMessage{}
+	aliveMsgs := []*protoext.SignedGossipMessage{}
+	newAliveMsgs := []*protoext.SignedGossipMessage{}
+	memReqMsgs := []*protoext.SignedGossipMessage{}
 	memRespMsgs := make(map[int][]*proto.MembershipResponse)
 
 	for i := 0; i < peersNum; i++ {
@@ -1188,7 +1189,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 	// Creating MembershipRequest messages
 	for i := 0; i < peersNum; i++ {
 		memReqMsg, _ := instances[i].discoveryImpl().createMembershipRequest(true)
-		sMsg, _ := memReqMsg.NoopSign()
+		sMsg, _ := protoext.NoopSign(memReqMsg)
 		memReqMsgs = append(memReqMsgs, sMsg)
 	}
 	// Creating Alive messages
@@ -1211,14 +1212,14 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		for k := 0; k < peersNum; k++ {
 			instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 				msg: aliveMsgs[k],
-				info: &proto.ConnectionInfo{
+				info: &protoext.ConnectionInfo{
 					ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 				},
 			})
 		}
 	}
 
-	checkExistence := func(instances []*gossipInstance, msgs []*proto.SignedGossipMessage, index int, i int, step string) {
+	checkExistence := func(instances []*gossipInstance, msgs []*protoext.SignedGossipMessage, index int, i int, step string) {
 		_, exist := instances[index].discoveryImpl().aliveLastTS[string(instances[i].discoveryImpl().self.PKIid)]
 		assert.True(t, exist, fmt.Sprint(step, " Data from alive msg ", i, " doesn't exist in aliveLastTS of discovery inst ", index))
 
@@ -1230,7 +1231,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		assert.Contains(t, instances[index].discoveryImpl().msgStore.Get(), msgs[i], fmt.Sprint(step, " Alive msg ", i, "not stored in store of discovery inst ", index))
 	}
 
-	checkAliveMsgExist := func(instances []*gossipInstance, msgs []*proto.SignedGossipMessage, index int, step string) {
+	checkAliveMsgExist := func(instances []*gossipInstance, msgs []*protoext.SignedGossipMessage, index int, step string) {
 		instances[index].discoveryImpl().lock.RLock()
 		defer instances[index].discoveryImpl().lock.RUnlock()
 		repeatForFiltered(peersNum,
@@ -1278,7 +1279,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		for k := 0; k < peersNum; k++ {
 			instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 				msg: newAliveMsgs[k],
-				info: &proto.ConnectionInfo{
+				info: &protoext.ConnectionInfo{
 					ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 				},
 			})
@@ -1290,7 +1291,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		checkAliveMsgExist(instances, newAliveMsgs, i, "[Step 2 - proccesing aliveMsg]")
 	}
 
-	checkAliveMsgNotExist := func(instances []*gossipInstance, msgs []*proto.SignedGossipMessage, index int, step string) {
+	checkAliveMsgNotExist := func(instances []*gossipInstance, msgs []*protoext.SignedGossipMessage, index int, step string) {
 		instances[index].discoveryImpl().lock.RLock()
 		defer instances[index].discoveryImpl().lock.RUnlock()
 		assert.Empty(t, instances[index].discoveryImpl().aliveLastTS, fmt.Sprint(step, " Data from alive msg still exists in aliveLastTS of discovery inst ", index))
@@ -1318,7 +1319,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 			func(k int) {
 				instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 					msg: memReqMsgs[k],
-					info: &proto.ConnectionInfo{
+					info: &protoext.ConnectionInfo{
 						ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 					},
 				})
@@ -1335,7 +1336,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		for k := 0; k < peersNum; k++ {
 			instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 				msg: aliveMsgs[k],
-				info: &proto.ConnectionInfo{
+				info: &protoext.ConnectionInfo{
 					ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 				},
 			})
@@ -1352,16 +1353,16 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 	for i := 0; i < peersNum; i++ {
 		respForPeer := memRespMsgs[i]
 		for _, msg := range respForPeer {
-			sMsg, _ := (&proto.GossipMessage{
+			sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 				Tag:   proto.GossipMessage_EMPTY,
 				Nonce: uint64(0),
 				Content: &proto.GossipMessage_MemRes{
 					MemRes: msg,
 				},
-			}).NoopSign()
+			})
 			instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 				msg: sMsg,
-				info: &proto.ConnectionInfo{
+				info: &protoext.ConnectionInfo{
 					ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 				},
 			})
@@ -1385,8 +1386,8 @@ func TestAliveMsgStore(t *testing.T) {
 	bootPeers := []string{}
 	peersNum := 2
 	instances := []*gossipInstance{}
-	aliveMsgs := []*proto.SignedGossipMessage{}
-	memReqMsgs := []*proto.SignedGossipMessage{}
+	aliveMsgs := []*protoext.SignedGossipMessage{}
+	memReqMsgs := []*protoext.SignedGossipMessage{}
 
 	for i := 0; i < peersNum; i++ {
 		id := fmt.Sprintf("d%d", i)
@@ -1397,7 +1398,7 @@ func TestAliveMsgStore(t *testing.T) {
 	// Creating MembershipRequest messages
 	for i := 0; i < peersNum; i++ {
 		memReqMsg, _ := instances[i].discoveryImpl().createMembershipRequest(true)
-		sMsg, _ := memReqMsg.NoopSign()
+		sMsg, _ := protoext.NoopSign(memReqMsg)
 		memReqMsgs = append(memReqMsgs, sMsg)
 	}
 	// Creating Alive messages
@@ -1431,9 +1432,9 @@ func TestAliveMsgStore(t *testing.T) {
 func TestMemRespDisclosurePol(t *testing.T) {
 	t.Parallel()
 	pol := func(remotePeer *NetworkMember) (Sieve, EnvelopeFilter) {
-		return func(_ *proto.SignedGossipMessage) bool {
+		return func(_ *protoext.SignedGossipMessage) bool {
 				return remotePeer.Endpoint == "localhost:7880"
-			}, func(m *proto.SignedGossipMessage) *proto.Envelope {
+			}, func(m *protoext.SignedGossipMessage) *proto.Envelope {
 				return m.Envelope
 			}
 	}
diff --git a/gossip/election/adapter.go b/gossip/election/adapter.go
index 8a2c3f80..3c725a12 100644
--- a/gossip/election/adapter.go
+++ b/gossip/election/adapter.go
@@ -14,6 +14,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
@@ -50,7 +51,7 @@ type gossip interface {
 	// If passThrough is false, the messages are processed by the gossip layer beforehand.
 	// If passThrough is true, the gossip layer doesn't intervene and the messages
 	// can be used to send a reply back to the sender
-	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 
 	// Gossip sends a message to other peers to the network
 	Gossip(msg *proto.GossipMessage)
@@ -100,7 +101,7 @@ func (ai *adapterImpl) Accept() <-chan Msg {
 	adapterCh, _ := ai.gossip.Accept(func(message interface{}) bool {
 		// Get only leadership org and channel messages
 		return message.(*proto.GossipMessage).Tag == proto.GossipMessage_CHAN_AND_ORG &&
-			message.(*proto.GossipMessage).IsLeadershipMsg() &&
+			protoext.IsLeadershipMsg(message.(*proto.GossipMessage)) &&
 			bytes.Equal(message.(*proto.GossipMessage).Channel, ai.channel)
 	}, false)
 
diff --git a/gossip/election/adapter_test.go b/gossip/election/adapter_test.go
index 9d3d4dc4..41a97ff5 100644
--- a/gossip/election/adapter_test.go
+++ b/gossip/election/adapter_test.go
@@ -19,6 +19,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -55,7 +56,7 @@ func TestAdapterImpl_CreateMessage(t *testing.T) {
 		metrics.NewGossipMetrics(&disabled.Provider{}).ElectionMetrics)
 	msg := adapter.CreateMessage(true)
 
-	if !msg.(*msgImpl).msg.IsLeadershipMsg() {
+	if !protoext.IsLeadershipMsg(msg.(*msgImpl).msg) {
 		t.Error("Newly created message should be LeadershipMsg")
 	}
 
@@ -65,7 +66,7 @@ func TestAdapterImpl_CreateMessage(t *testing.T) {
 
 	msg = adapter.CreateMessage(false)
 
-	if !msg.(*msgImpl).msg.IsLeadershipMsg() {
+	if !protoext.IsLeadershipMsg(msg.(*msgImpl).msg) {
 		t.Error("Newly created message should be LeadershipMsg")
 	}
 
@@ -195,7 +196,7 @@ func (g *peerMockGossip) Peers() []discovery.NetworkMember {
 	return res
 }
 
-func (g *peerMockGossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (g *peerMockGossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	ch := make(chan *proto.GossipMessage, 100)
 	g.acceptorLock.Lock()
 	g.acceptors = append(g.acceptors, &mockAcceptor{
diff --git a/gossip/gossip/anchor_test.go b/gossip/gossip/anchor_test.go
index 1484a0e7..0df8227a 100644
--- a/gossip/gossip/anchor_test.go
+++ b/gossip/gossip/anchor_test.go
@@ -20,6 +20,7 @@ import (
 	"github.com/hyperledger/fabric/core/comm"
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	utilgossip "github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -47,7 +48,7 @@ func (p *peerMock) GossipStream(stream proto.Gossip_GossipStreamServer) error {
 		if err != nil {
 			return err
 		}
-		gMsg, err := envelope.ToGossipMessage()
+		gMsg, err := protoext.EnvelopeToGossipMessage(envelope)
 		if err != nil {
 			panic(err)
 		}
@@ -89,7 +90,7 @@ func newPeerMockWithGRPC(port int, gRPCServer *comm.GRPCServer, certs *common.TL
 	return p
 }
 
-func (p *peerMock) connEstablishMsg(pkiID common.PKIidType, hash []byte, cert api.PeerIdentityType) *proto.SignedGossipMessage {
+func (p *peerMock) connEstablishMsg(pkiID common.PKIidType, hash []byte, cert api.PeerIdentityType) *protoext.SignedGossipMessage {
 	m := &proto.GossipMessage{
 		Tag:   proto.GossipMessage_EMPTY,
 		Nonce: 0,
@@ -101,7 +102,7 @@ func (p *peerMock) connEstablishMsg(pkiID common.PKIidType, hash []byte, cert ap
 			},
 		},
 	}
-	gMsg := &proto.SignedGossipMessage{
+	gMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	gMsg.Sign((&configurableCryptoService{}).Sign)
@@ -113,16 +114,16 @@ func (p *peerMock) stop() {
 }
 
 type receivedMsg struct {
-	*proto.SignedGossipMessage
+	*protoext.SignedGossipMessage
 	stream proto.Gossip_GossipStreamServer
 }
 
-func (msg *receivedMsg) respond(message *proto.SignedGossipMessage) {
+func (msg *receivedMsg) respond(message *protoext.SignedGossipMessage) {
 	msg.stream.Send(message.Envelope)
 }
 
-func memResp(nonce uint64, endpoint string) *proto.SignedGossipMessage {
-	fakePeerAliveMsg := &proto.SignedGossipMessage{
+func memResp(nonce uint64, endpoint string) *protoext.SignedGossipMessage {
+	fakePeerAliveMsg := &protoext.SignedGossipMessage{
 		GossipMessage: &proto.GossipMessage{
 			Tag: proto.GossipMessage_EMPTY,
 			Content: &proto.GossipMessage_AliveMsg{
@@ -142,18 +143,16 @@ func memResp(nonce uint64, endpoint string) *proto.SignedGossipMessage {
 	}
 
 	m, _ := fakePeerAliveMsg.Sign((&configurableCryptoService{}).Sign)
-	sMsg, _ := (&proto.SignedGossipMessage{
-		GossipMessage: &proto.GossipMessage{
-			Tag:   proto.GossipMessage_EMPTY,
-			Nonce: nonce,
-			Content: &proto.GossipMessage_MemRes{
-				MemRes: &proto.MembershipResponse{
-					Alive: []*proto.Envelope{m},
-					Dead:  []*proto.Envelope{},
-				},
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
+		Tag:   proto.GossipMessage_EMPTY,
+		Nonce: nonce,
+		Content: &proto.GossipMessage_MemRes{
+			MemRes: &proto.MembershipResponse{
+				Alive: []*proto.Envelope{m},
+				Dead:  []*proto.Envelope{},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
@@ -212,9 +211,9 @@ func TestAnchorPeer(t *testing.T) {
 		}
 		assert.True(t, index > 0)
 		req := m.GetMemReq()
-		am, err := req.SelfInformation.ToGossipMessage()
+		am, err := protoext.EnvelopeToGossipMessage(req.SelfInformation)
 		assert.NoError(t, err)
-		assert.NotEmpty(t, am.GetSecretEnvelope().InternalEndpoint())
+		assert.NotEmpty(t, protoext.InternalEndpoint(am.GetSecretEnvelope()))
 		m.respond(memResp(m.Nonce, fmt.Sprintf("127.0.0.1:%d", port3)))
 	}
 
@@ -224,7 +223,7 @@ func TestAnchorPeer(t *testing.T) {
 		}
 		assert.True(t, index > 0)
 		req := m.GetMemReq()
-		am, err := req.SelfInformation.ToGossipMessage()
+		am, err := protoext.EnvelopeToGossipMessage(req.SelfInformation)
 		assert.NoError(t, err)
 		assert.Nil(t, am.GetSecretEnvelope())
 		m.respond(memResp(m.Nonce, fmt.Sprintf("127.0.0.1:%d", port4)))
diff --git a/gossip/gossip/certstore.go b/gossip/gossip/certstore.go
index 520d4023..73a1274e 100644
--- a/gossip/gossip/certstore.go
+++ b/gossip/gossip/certstore.go
@@ -14,6 +14,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/gossip/pull"
 	"github.com/hyperledger/fabric/gossip/identity"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -49,7 +50,7 @@ func newCertStore(puller pull.Mediator, idMapper identity.Mapper, selfIdentity a
 		certStore.logger.Panicf("Failed creating self identity message: %+v", errors.WithStack(err))
 	}
 	puller.Add(selfIDMsg)
-	puller.RegisterMsgHook(pull.RequestMsgType, func(_ []string, msgs []*proto.SignedGossipMessage, _ proto.ReceivedMessage) {
+	puller.RegisterMsgHook(pull.RequestMsgType, func(_ []string, msgs []*protoext.SignedGossipMessage, _ protoext.ReceivedMessage) {
 		for _, msg := range msgs {
 			pkiID := common.PKIidType(msg.GetPeerIdentity().PkiId)
 			cert := api.PeerIdentityType(msg.GetPeerIdentity().Cert)
@@ -61,15 +62,15 @@ func newCertStore(puller pull.Mediator, idMapper identity.Mapper, selfIdentity a
 	return certStore
 }
 
-func (cs *certStore) handleMessage(msg proto.ReceivedMessage) {
+func (cs *certStore) handleMessage(msg protoext.ReceivedMessage) {
 	if update := msg.GetGossipMessage().GetDataUpdate(); update != nil {
 		for _, env := range update.Data {
-			m, err := env.ToGossipMessage()
+			m, err := protoext.EnvelopeToGossipMessage(env)
 			if err != nil {
 				cs.logger.Warningf("Data update contains an invalid message: %+v", errors.WithStack(err))
 				return
 			}
-			if !m.IsIdentityMsg() {
+			if !protoext.IsIdentityMsg(m.GossipMessage) {
 				cs.logger.Warning("Got a non-identity message:", m, "aborting")
 				return
 			}
@@ -82,7 +83,7 @@ func (cs *certStore) handleMessage(msg proto.ReceivedMessage) {
 	cs.pull.HandleMessage(msg)
 }
 
-func (cs *certStore) validateIdentityMsg(msg *proto.SignedGossipMessage) error {
+func (cs *certStore) validateIdentityMsg(msg *protoext.SignedGossipMessage) error {
 	idMsg := msg.GetPeerIdentity()
 	if idMsg == nil {
 		return errors.Errorf("Identity empty: %+v", msg)
@@ -107,7 +108,7 @@ func (cs *certStore) validateIdentityMsg(msg *proto.SignedGossipMessage) error {
 	return cs.mcs.ValidateIdentity(api.PeerIdentityType(idMsg.Cert))
 }
 
-func (cs *certStore) createIdentityMessage() (*proto.SignedGossipMessage, error) {
+func (cs *certStore) createIdentityMessage() (*protoext.SignedGossipMessage, error) {
 	pi := &proto.PeerIdentity{
 		Cert:     cs.selfIdentity,
 		Metadata: nil,
@@ -124,7 +125,7 @@ func (cs *certStore) createIdentityMessage() (*proto.SignedGossipMessage, error)
 	signer := func(msg []byte) ([]byte, error) {
 		return cs.idMapper.Sign(msg)
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	_, err := sMsg.Sign(signer)
diff --git a/gossip/gossip/certstore_test.go b/gossip/gossip/certstore_test.go
index af3a2aaa..6d0f9655 100644
--- a/gossip/gossip/certstore_test.go
+++ b/gossip/gossip/certstore_test.go
@@ -20,6 +20,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/algo"
 	"github.com/hyperledger/fabric/gossip/gossip/pull"
 	"github.com/hyperledger/fabric/gossip/identity"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -42,7 +43,7 @@ type pullerMock struct {
 }
 
 type sentMsg struct {
-	msg *proto.SignedGossipMessage
+	msg *protoext.SignedGossipMessage
 	mock.Mock
 }
 
@@ -61,11 +62,11 @@ func (s *sentMsg) Respond(msg *proto.GossipMessage) {
 	s.Called(msg)
 }
 
-func (s *sentMsg) GetGossipMessage() *proto.SignedGossipMessage {
+func (s *sentMsg) GetGossipMessage() *protoext.SignedGossipMessage {
 	return s.msg
 }
 
-func (s *sentMsg) GetConnectionInfo() *proto.ConnectionInfo {
+func (s *sentMsg) GetConnectionInfo() *protoext.ConnectionInfo {
 	return nil
 }
 
@@ -73,7 +74,7 @@ type senderMock struct {
 	mock.Mock
 }
 
-func (s *senderMock) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (s *senderMock) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	s.Called(msg, peers)
 }
 
@@ -87,7 +88,7 @@ func (m *membershipSvcMock) GetMembership() []discovery.NetworkMember {
 }
 
 func TestCertStoreBadSignature(t *testing.T) {
-	badSignature := func(nonce uint64) proto.ReceivedMessage {
+	badSignature := func(nonce uint64) protoext.ReceivedMessage {
 		return createUpdateMessage(nonce, createBadlySignedUpdateMessage())
 	}
 	pm, cs, _ := createObjects(badSignature, nil)
@@ -97,7 +98,7 @@ func TestCertStoreBadSignature(t *testing.T) {
 }
 
 func TestCertStoreMismatchedIdentity(t *testing.T) {
-	mismatchedIdentity := func(nonce uint64) proto.ReceivedMessage {
+	mismatchedIdentity := func(nonce uint64) protoext.ReceivedMessage {
 		return createUpdateMessage(nonce, createMismatchedUpdateMessage())
 	}
 
@@ -108,7 +109,7 @@ func TestCertStoreMismatchedIdentity(t *testing.T) {
 }
 
 func TestCertStoreShouldSucceed(t *testing.T) {
-	totallyFineIdentity := func(nonce uint64) proto.ReceivedMessage {
+	totallyFineIdentity := func(nonce uint64) protoext.ReceivedMessage {
 		return createUpdateMessage(nonce, createValidUpdateMessage())
 	}
 
@@ -123,13 +124,13 @@ func TestCertRevocation(t *testing.T) {
 		cs.revokedPkiIDS = map[string]struct{}{}
 	}()
 
-	totallyFineIdentity := func(nonce uint64) proto.ReceivedMessage {
+	totallyFineIdentity := func(nonce uint64) protoext.ReceivedMessage {
 		return createUpdateMessage(nonce, createValidUpdateMessage())
 	}
 
 	askedForIdentity := make(chan struct{}, 1)
 
-	pm, cStore, sender := createObjects(totallyFineIdentity, func(message *proto.SignedGossipMessage) {
+	pm, cStore, sender := createObjects(totallyFineIdentity, func(message *protoext.SignedGossipMessage) {
 		askedForIdentity <- struct{}{}
 	})
 	defer cStore.stop()
@@ -146,7 +147,7 @@ func TestCertRevocation(t *testing.T) {
 	l := sync.Mutex{}
 	sender.Mock = mock.Mock{}
 	sender.On("Send", mock.Anything, mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
 		l.Lock()
 		defer l.Unlock()
 
@@ -162,7 +163,7 @@ func TestCertRevocation(t *testing.T) {
 					},
 				},
 			}
-			sMsg, _ := dig.NoopSign()
+			sMsg, _ := protoext.NoopSign(dig)
 			go cStore.handleMessage(&sentMsg{msg: sMsg})
 		}
 
@@ -229,8 +230,8 @@ func TestCertExpiration(t *testing.T) {
 	// Make the channel bigger than needed so goroutines won't get stuck
 	identitiesGotViaPull := make(chan struct{}, identities2Detect+100)
 	acceptIdentityPullMsgs := func(o interface{}) bool {
-		m := o.(proto.ReceivedMessage).GetGossipMessage()
-		if m.IsPullMsg() && m.IsDigestMsg() {
+		m := o.(protoext.ReceivedMessage).GetGossipMessage()
+		if protoext.IsPullMsg(m.GossipMessage) && protoext.IsDigestMsg(m.GossipMessage) {
 			for _, dig := range m.GetDataDig().Digests {
 				if bytes.Equal(dig, []byte(fmt.Sprintf("127.0.0.1:%d", port0))) {
 					identitiesGotViaPull <- struct{}{}
@@ -251,7 +252,7 @@ func TestCertExpiration(t *testing.T) {
 }
 
 func testCertificateUpdate(t *testing.T, shouldSucceed bool, certStore *certStore) {
-	msg, _ := (&proto.GossipMessage{
+	msg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Channel: []byte(""),
 		Tag:     proto.GossipMessage_EMPTY,
 		Content: &proto.GossipMessage_Hello{
@@ -261,7 +262,7 @@ func testCertificateUpdate(t *testing.T, shouldSucceed bool, certStore *certStor
 				MsgType:  proto.PullMsgType_IDENTITY_MSG,
 			},
 		},
-	}).NoopSign()
+	})
 	hello := &sentMsg{
 		msg: msg,
 	}
@@ -284,7 +285,7 @@ func testCertificateUpdate(t *testing.T, shouldSucceed bool, certStore *certStor
 	}
 }
 
-func createMismatchedUpdateMessage() *proto.SignedGossipMessage {
+func createMismatchedUpdateMessage() *protoext.SignedGossipMessage {
 	peeridentity := &proto.PeerIdentity{
 		// This PKI-ID is different than the cert, and the mapping between
 		// certificate to PKI-ID in this test is simply the identity function.
@@ -303,14 +304,14 @@ func createMismatchedUpdateMessage() *proto.SignedGossipMessage {
 			PeerIdentity: peeridentity,
 		},
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	sMsg.Sign(signer)
 	return sMsg
 }
 
-func createBadlySignedUpdateMessage() *proto.SignedGossipMessage {
+func createBadlySignedUpdateMessage() *protoext.SignedGossipMessage {
 	peeridentity := &proto.PeerIdentity{
 		PkiId: []byte("C"),
 		Cert:  []byte("C"),
@@ -328,7 +329,7 @@ func createBadlySignedUpdateMessage() *proto.SignedGossipMessage {
 			PeerIdentity: peeridentity,
 		},
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	sMsg.Sign(signer)
@@ -341,7 +342,7 @@ func createBadlySignedUpdateMessage() *proto.SignedGossipMessage {
 	return sMsg
 }
 
-func createValidUpdateMessage() *proto.SignedGossipMessage {
+func createValidUpdateMessage() *protoext.SignedGossipMessage {
 	peeridentity := &proto.PeerIdentity{
 		PkiId: []byte("B"),
 		Cert:  []byte("B"),
@@ -358,14 +359,14 @@ func createValidUpdateMessage() *proto.SignedGossipMessage {
 			PeerIdentity: peeridentity,
 		},
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	sMsg.Sign(signer)
 	return sMsg
 }
 
-func createUpdateMessage(nonce uint64, idMsg *proto.SignedGossipMessage) proto.ReceivedMessage {
+func createUpdateMessage(nonce uint64, idMsg *protoext.SignedGossipMessage) protoext.ReceivedMessage {
 	update := &proto.GossipMessage{
 		Tag: proto.GossipMessage_EMPTY,
 		Content: &proto.GossipMessage_DataUpdate{
@@ -376,11 +377,11 @@ func createUpdateMessage(nonce uint64, idMsg *proto.SignedGossipMessage) proto.R
 			},
 		},
 	}
-	sMsg, _ := update.NoopSign()
+	sMsg, _ := protoext.NoopSign(update)
 	return &sentMsg{msg: sMsg}
 }
 
-func createDigest(nonce uint64) proto.ReceivedMessage {
+func createDigest(nonce uint64) protoext.ReceivedMessage {
 	digest := &proto.GossipMessage{
 		Tag: proto.GossipMessage_EMPTY,
 		Content: &proto.GossipMessage_DataDig{
@@ -391,13 +392,13 @@ func createDigest(nonce uint64) proto.ReceivedMessage {
 			},
 		},
 	}
-	sMsg, _ := digest.NoopSign()
+	sMsg, _ := protoext.NoopSign(digest)
 	return &sentMsg{msg: sMsg}
 }
 
-func createObjects(updateFactory func(uint64) proto.ReceivedMessage, msgCons proto.MsgConsumer) (pull.Mediator, *certStore, *senderMock) {
+func createObjects(updateFactory func(uint64) protoext.ReceivedMessage, msgCons pull.MsgConsumer) (pull.Mediator, *certStore, *senderMock) {
 	if msgCons == nil {
-		msgCons = func(_ *proto.SignedGossipMessage) {}
+		msgCons = func(_ *protoext.SignedGossipMessage) {}
 	}
 	shortenedWaitTime := time.Millisecond * 300
 	config := pull.Config{
@@ -420,11 +421,11 @@ func createObjects(updateFactory func(uint64) proto.ReceivedMessage, msgCons pro
 	var certStore *certStore
 	adapter := &pull.PullAdapter{
 		Sndr: sender,
-		MsgCons: func(msg *proto.SignedGossipMessage) {
+		MsgCons: func(msg *protoext.SignedGossipMessage) {
 			certStore.idMapper.Put(msg.GetPeerIdentity().PkiId, msg.GetPeerIdentity().Cert)
 			msgCons(msg)
 		},
-		IdExtractor: func(msg *proto.SignedGossipMessage) string {
+		IdExtractor: func(msg *protoext.SignedGossipMessage) string {
 			return string(msg.GetPeerIdentity().PkiId)
 		},
 		MemSvc: memberSvc,
@@ -443,7 +444,7 @@ func createObjects(updateFactory func(uint64) proto.ReceivedMessage, msgCons pro
 	sentDataReq := false
 	l := sync.Mutex{}
 	sender.On("Send", mock.Anything, mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
 		l.Lock()
 		defer l.Unlock()
 
diff --git a/gossip/gossip/channel/channel.go b/gossip/gossip/channel/channel.go
index 69bda314..2306899a 100644
--- a/gossip/gossip/channel/channel.go
+++ b/gossip/gossip/channel/channel.go
@@ -26,6 +26,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/msgstore"
 	"github.com/hyperledger/fabric/gossip/gossip/pull"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -54,7 +55,7 @@ type Config struct {
 // GossipChannel defines an object that deals with all channel-related messages
 type GossipChannel interface {
 	// Self returns a StateInfoMessage about the peer
-	Self() *proto.SignedGossipMessage
+	Self() *protoext.SignedGossipMessage
 
 	// GetPeers returns a list of peers with metadata as published by them
 	GetPeers() []discovery.NetworkMember
@@ -82,10 +83,10 @@ type GossipChannel interface {
 	EligibleForChannel(member discovery.NetworkMember) bool
 
 	// HandleMessage processes a message sent by a remote peer
-	HandleMessage(proto.ReceivedMessage)
+	HandleMessage(protoext.ReceivedMessage)
 
 	// AddToMsgStore adds a given GossipMessage to the message store
-	AddToMsgStore(msg *proto.SignedGossipMessage)
+	AddToMsgStore(msg *protoext.SignedGossipMessage)
 
 	// ConfigureChannel (re)configures the list of organizations
 	// that are eligible to be in the channel
@@ -101,16 +102,16 @@ type GossipChannel interface {
 // Adapter enables the gossipChannel
 // to communicate with gossipServiceImpl.
 type Adapter interface {
-	Sign(msg *proto.GossipMessage) (*proto.SignedGossipMessage, error)
+	Sign(msg *proto.GossipMessage) (*protoext.SignedGossipMessage, error)
 
 	// GetConf returns the configuration that this GossipChannel will posses
 	GetConf() Config
 
 	// Gossip gossips a message in the channel
-	Gossip(message *proto.SignedGossipMessage)
+	Gossip(message *protoext.SignedGossipMessage)
 
 	// Forward sends a message to the next hops
-	Forward(message proto.ReceivedMessage)
+	Forward(message protoext.ReceivedMessage)
 
 	// DeMultiplex de-multiplexes an item to subscribers
 	DeMultiplex(interface{})
@@ -122,11 +123,11 @@ type Adapter interface {
 	Lookup(PKIID common.PKIidType) *discovery.NetworkMember
 
 	// Send sends a message to a list of peers
-	Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer)
+	Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer)
 
 	// ValidateStateInfoMessage returns an error if a message
 	// hasn't been signed correctly, nil otherwise.
-	ValidateStateInfoMessage(message *proto.SignedGossipMessage) error
+	ValidateStateInfoMessage(message *protoext.SignedGossipMessage) error
 
 	// GetOrgOfPeer returns the organization ID of a given peer PKI-ID
 	GetOrgOfPeer(pkiID common.PKIidType) api.OrgIdentityType
@@ -144,7 +145,7 @@ type gossipChannel struct {
 	pkiID                     common.PKIidType
 	selfOrg                   api.OrgIdentityType
 	stopChan                  chan struct{}
-	stateInfoMsg              *proto.SignedGossipMessage
+	stateInfoMsg              *protoext.SignedGossipMessage
 	orgs                      []api.OrgIdentityType
 	joinMsg                   api.JoinChannelMessage
 	blockMsgStore             msgstore.MessageStore
@@ -203,12 +204,12 @@ func NewGossipChannel(pkiID common.PKIidType, org api.OrgIdentityType, mcs api.M
 
 	gc.memFilter = &membershipFilter{adapter: gc.Adapter, gossipChannel: gc}
 
-	comparator := proto.NewGossipMessageComparator(adapter.GetConf().MaxBlockCountToStore)
+	comparator := protoext.NewGossipMessageComparator(adapter.GetConf().MaxBlockCountToStore)
 
 	gc.blocksPuller = gc.createBlockPuller()
 
 	seqNumFromMsg := func(m interface{}) string {
-		return fmt.Sprintf("%d", m.(*proto.SignedGossipMessage).GetDataMsg().Payload.SeqNum)
+		return fmt.Sprintf("%d", m.(*protoext.SignedGossipMessage).GetDataMsg().Payload.SeqNum)
 	}
 	gc.blockMsgStore = msgstore.NewMessageStoreExpirable(comparator, func(m interface{}) {
 		gc.logger.Debugf("Removing %s from the message store", seqNumFromMsg(m))
@@ -219,10 +220,10 @@ func NewGossipChannel(pkiID common.PKIidType, org api.OrgIdentityType, mcs api.M
 	})
 
 	hashPeerExpiredInMembership := func(o interface{}) bool {
-		pkiID := o.(*proto.SignedGossipMessage).GetStateInfo().PkiId
+		pkiID := o.(*protoext.SignedGossipMessage).GetStateInfo().PkiId
 		return gc.Lookup(pkiID) == nil
 	}
-	verifyStateInfoMsg := func(msg *proto.SignedGossipMessage, orgs ...api.OrgIdentityType) bool {
+	verifyStateInfoMsg := func(msg *protoext.SignedGossipMessage, orgs ...api.OrgIdentityType) bool {
 		si := msg.GetStateInfo()
 		// No point in verifying ourselves
 		if bytes.Equal(gc.pkiID, si.PkiId) {
@@ -267,7 +268,7 @@ func NewGossipChannel(pkiID common.PKIidType, org api.OrgIdentityType, mcs api.M
 	gc.stateInfoMsgStore = newStateInfoCache(gc.GetConf().StateInfoCacheSweepInterval, hashPeerExpiredInMembership, verifyStateInfoMsg)
 
 	ttl := adapter.GetConf().MsgExpirationTimeout
-	pol := proto.NewGossipMessageComparator(0)
+	pol := protoext.NewGossipMessageComparator(0)
 
 	gc.leaderMsgStore = msgstore.NewMessageStoreExpirable(pol, msgstore.Noop, ttl, nil, nil, nil)
 
@@ -321,7 +322,7 @@ func (gc *gossipChannel) periodicalInvocation(fn func(), c <-chan time.Time) {
 }
 
 // Self returns a StateInfoMessage about the peer
-func (gc *gossipChannel) Self() *proto.SignedGossipMessage {
+func (gc *gossipChannel) Self() *protoext.SignedGossipMessage {
 	gc.RLock()
 	defer gc.RUnlock()
 	return gc.stateInfoMsg
@@ -417,7 +418,7 @@ func (gc *gossipChannel) createBlockPuller() pull.Mediator {
 			ResponseWaitTime: gc.GetConf().ResponseWaitTime,
 		},
 	}
-	seqNumFromMsg := func(msg *proto.SignedGossipMessage) string {
+	seqNumFromMsg := func(msg *protoext.SignedGossipMessage) string {
 		dataMsg := msg.GetDataMsg()
 		if dataMsg == nil || dataMsg.Payload == nil {
 			gc.logger.Warning("Non-data block or with no payload")
@@ -429,7 +430,7 @@ func (gc *gossipChannel) createBlockPuller() pull.Mediator {
 		Sndr:        gc,
 		MemSvc:      gc.memFilter,
 		IdExtractor: seqNumFromMsg,
-		MsgCons: func(msg *proto.SignedGossipMessage) {
+		MsgCons: func(msg *protoext.SignedGossipMessage) {
 			gc.DeMultiplex(msg)
 		},
 	}
@@ -516,8 +517,8 @@ func (gc *gossipChannel) EligibleForChannel(member discovery.NetworkMember) bool
 }
 
 // AddToMsgStore adds a given GossipMessage to the message store
-func (gc *gossipChannel) AddToMsgStore(msg *proto.SignedGossipMessage) {
-	if msg.IsDataMsg() {
+func (gc *gossipChannel) AddToMsgStore(msg *protoext.SignedGossipMessage) {
+	if protoext.IsDataMsg(msg.GossipMessage) {
 		gc.Lock()
 		defer gc.Unlock()
 		added := gc.blockMsgStore.Add(msg)
@@ -527,7 +528,7 @@ func (gc *gossipChannel) AddToMsgStore(msg *proto.SignedGossipMessage) {
 		}
 	}
 
-	if msg.IsStateInfoMsg() {
+	if protoext.IsStateInfoMsg(msg.GossipMessage) {
 		gc.stateInfoMsgStore.Add(msg)
 	}
 }
@@ -558,13 +559,13 @@ func (gc *gossipChannel) ConfigureChannel(joinMsg api.JoinChannelMessage) {
 }
 
 // HandleMessage processes a message sent by a remote peer
-func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
+func (gc *gossipChannel) HandleMessage(msg protoext.ReceivedMessage) {
 	if !gc.verifyMsg(msg) {
 		gc.logger.Warning("Failed verifying message:", msg.GetGossipMessage().GossipMessage)
 		return
 	}
 	m := msg.GetGossipMessage()
-	if !m.IsChannelRestricted() {
+	if !protoext.IsChannelRestricted(m.GossipMessage) {
 		gc.logger.Warning("Got message", msg.GetGossipMessage(), "but it's not a per-channel message, discarding it")
 		return
 	}
@@ -579,20 +580,20 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 		return
 	}
 
-	if m.IsStateInfoPullRequestMsg() {
+	if protoext.IsStateInfoPullRequestMsg(m.GossipMessage) {
 		msg.Respond(gc.createStateInfoSnapshot(orgID))
 		return
 	}
 
-	if m.IsStateInfoSnapshot() {
+	if protoext.IsStateInfoSnapshot(m.GossipMessage) {
 		gc.handleStateInfSnapshot(m.GossipMessage, msg.GetConnectionInfo().ID)
 		return
 	}
 
-	if m.IsDataMsg() || m.IsStateInfoMsg() {
+	if protoext.IsDataMsg(m.GossipMessage) || protoext.IsStateInfoMsg(m.GossipMessage) {
 		added := false
 
-		if m.IsDataMsg() {
+		if protoext.IsDataMsg(m.GossipMessage) {
 			if m.GetDataMsg().Payload == nil {
 				gc.logger.Warning("Payload is empty, got it from", msg.GetConnectionInfo().ID)
 				return
@@ -626,7 +627,7 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 		return
 	}
 
-	if m.IsPullMsg() && m.GetPullMsgType() == proto.PullMsgType_BLOCK_MSG {
+	if protoext.IsPullMsg(m.GossipMessage) && protoext.GetPullMsgType(m.GossipMessage) == proto.PullMsgType_BLOCK_MSG {
 		if gc.hasLeftChannel() {
 			gc.logger.Info("Received Pull message from", msg.GetConnectionInfo().Endpoint, "but left the channel", string(gc.chainID))
 			return
@@ -641,15 +642,15 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 			gc.logger.Warning(msg.GetConnectionInfo(), "isn't eligible for pulling blocks of", string(gc.chainID))
 			return
 		}
-		if m.IsDataUpdate() {
+		if protoext.IsDataUpdate(m.GossipMessage) {
 			// Iterate over the envelopes, and filter out blocks
 			// that we already have in the blockMsgStore, or blocks that
 			// are too far in the past.
-			var msgs []*proto.SignedGossipMessage
+			var msgs []*protoext.SignedGossipMessage
 			var items []*proto.Envelope
 			filteredEnvelopes := []*proto.Envelope{}
 			for _, item := range m.GetDataUpdate().Data {
-				gMsg, err := item.ToGossipMessage()
+				gMsg, err := protoext.EnvelopeToGossipMessage(item)
 				if err != nil {
 					gc.logger.Warningf("Data update contains an invalid message: %+v", errors.WithStack(err))
 					return
@@ -689,7 +690,7 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 		gc.blocksPuller.HandleMessage(msg)
 	}
 
-	if m.IsLeadershipMsg() {
+	if protoext.IsLeadershipMsg(m.GossipMessage) {
 		// Handling leadership message
 		added := gc.leaderMsgStore.Add(m)
 		if added {
@@ -701,12 +702,12 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 func (gc *gossipChannel) handleStateInfSnapshot(m *proto.GossipMessage, sender common.PKIidType) {
 	chanName := string(gc.chainID)
 	for _, envelope := range m.GetStateSnapshot().Elements {
-		stateInf, err := envelope.ToGossipMessage()
+		stateInf, err := protoext.EnvelopeToGossipMessage(envelope)
 		if err != nil {
 			gc.logger.Warningf("Channel %s : StateInfo snapshot contains an invalid message: %+v", chanName, errors.WithStack(err))
 			return
 		}
-		if !stateInf.IsStateInfoMsg() {
+		if !protoext.IsStateInfoMsg(stateInf.GossipMessage) {
 			gc.logger.Warning("Channel", chanName, ": Element of StateInfoSnapshot isn't a StateInfoMessage:",
 				stateInf, "message sent from", sender)
 			return
@@ -748,7 +749,7 @@ func (gc *gossipChannel) handleStateInfSnapshot(m *proto.GossipMessage, sender c
 }
 
 func (gc *gossipChannel) verifyBlock(msg *proto.GossipMessage, sender common.PKIidType) bool {
-	if !msg.IsDataMsg() {
+	if !protoext.IsDataMsg(msg) {
 		gc.logger.Warning("Received from ", sender, "a DataUpdate message that contains a non-block GossipMessage:", msg)
 		return false
 	}
@@ -772,7 +773,7 @@ func (gc *gossipChannel) createStateInfoSnapshot(requestersOrg api.OrgIdentityTy
 	rawElements := gc.stateInfoMsgStore.Get()
 	elements := []*proto.Envelope{}
 	for _, rawEl := range rawElements {
-		msg := rawEl.(*proto.SignedGossipMessage)
+		msg := rawEl.(*protoext.SignedGossipMessage)
 		orgOfCurrentMsg := gc.GetOrgOfPeer(msg.GetStateInfo().PkiId)
 		// If we're in the same org as the requester, or the message belongs to a foreign org
 		// don't do any filtering
@@ -800,7 +801,7 @@ func (gc *gossipChannel) createStateInfoSnapshot(requestersOrg api.OrgIdentityTy
 	}
 }
 
-func (gc *gossipChannel) verifyMsg(msg proto.ReceivedMessage) bool {
+func (gc *gossipChannel) verifyMsg(msg protoext.ReceivedMessage) bool {
 	if msg == nil {
 		gc.logger.Warning("Messsage is nil")
 		return false
@@ -816,7 +817,7 @@ func (gc *gossipChannel) verifyMsg(msg proto.ReceivedMessage) bool {
 		return false
 	}
 
-	if m.IsStateInfoMsg() {
+	if protoext.IsStateInfoMsg(m.GossipMessage) {
 		si := m.GetStateInfo()
 		expectedMAC := GenerateMAC(si.PkiId, gc.chainID)
 		if !bytes.Equal(expectedMAC, si.Channel_MAC) {
@@ -826,7 +827,7 @@ func (gc *gossipChannel) verifyMsg(msg proto.ReceivedMessage) bool {
 		return true
 	}
 
-	if m.IsStateInfoPullRequestMsg() {
+	if protoext.IsStateInfoPullRequestMsg(m.GossipMessage) {
 		sipr := m.GetStateInfoPullReq()
 		expectedMAC := GenerateMAC(msg.GetConnectionInfo().ID, gc.chainID)
 		if !bytes.Equal(expectedMAC, sipr.Channel_MAC) {
@@ -843,8 +844,8 @@ func (gc *gossipChannel) verifyMsg(msg proto.ReceivedMessage) bool {
 	return true
 }
 
-func (gc *gossipChannel) createStateInfoRequest() (*proto.SignedGossipMessage, error) {
-	return (&proto.GossipMessage{
+func (gc *gossipChannel) createStateInfoRequest() (*protoext.SignedGossipMessage, error) {
+	return protoext.NoopSign(&proto.GossipMessage{
 		Tag:   proto.GossipMessage_CHAN_OR_ORG,
 		Nonce: 0,
 		Content: &proto.GossipMessage_StateInfoPullReq{
@@ -852,7 +853,7 @@ func (gc *gossipChannel) createStateInfoRequest() (*proto.SignedGossipMessage, e
 				Channel_MAC: GenerateMAC(gc.pkiID, gc.chainID),
 			},
 		},
-	}).NoopSign()
+	})
 }
 
 // UpdateLedgerHeight updates the ledger height the peer
@@ -887,7 +888,7 @@ func (gc *gossipChannel) UpdateChaincodes(chaincodes []*proto.Chaincode) {
 
 // UpdateStateInfo updates this channel's StateInfo message
 // that is periodically published
-func (gc *gossipChannel) updateStateInfo(msg *proto.SignedGossipMessage) {
+func (gc *gossipChannel) updateStateInfo(msg *protoext.SignedGossipMessage) {
 	gc.stateInfoMsgStore.Add(msg)
 	gc.ledgerHeight = msg.GetStateInfo().Properties.LedgerHeight
 	gc.stateInfoMsg = msg
@@ -926,7 +927,7 @@ func (gc *gossipChannel) updateProperties(ledgerHeight uint64, chaincodes []*pro
 
 func newStateInfoCache(sweepInterval time.Duration, hasExpired func(interface{}) bool, verifyFunc membershipPredicate) *stateInfoCache {
 	membershipStore := util.NewMembershipStore()
-	pol := proto.NewGossipMessageComparator(0)
+	pol := protoext.NewGossipMessageComparator(0)
 
 	s := &stateInfoCache{
 		verify:          verifyFunc,
@@ -934,7 +935,7 @@ func newStateInfoCache(sweepInterval time.Duration, hasExpired func(interface{})
 		stopChan:        make(chan struct{}),
 	}
 	invalidationTrigger := func(m interface{}) {
-		pkiID := m.(*proto.SignedGossipMessage).GetStateInfo().PkiId
+		pkiID := m.(*protoext.SignedGossipMessage).GetStateInfo().PkiId
 		membershipStore.Remove(pkiID)
 	}
 	s.MessageStore = msgstore.NewMessageStore(pol, invalidationTrigger)
@@ -955,7 +956,7 @@ func newStateInfoCache(sweepInterval time.Duration, hasExpired func(interface{})
 // membershipPredicate receives a StateInfoMessage and optionally a slice of organization identifiers
 // and returns whether the peer that signed the given StateInfoMessage is eligible
 // to the channel or not
-type membershipPredicate func(msg *proto.SignedGossipMessage, orgs ...api.OrgIdentityType) bool
+type membershipPredicate func(msg *protoext.SignedGossipMessage, orgs ...api.OrgIdentityType) bool
 
 // stateInfoCache is actually a messageStore
 // that also indexes messages that are added
@@ -969,7 +970,7 @@ type stateInfoCache struct {
 
 func (cache *stateInfoCache) validate(orgs []api.OrgIdentityType) {
 	for _, m := range cache.Get() {
-		msg := m.(*proto.SignedGossipMessage)
+		msg := m.(*protoext.SignedGossipMessage)
 		if !cache.verify(msg, orgs...) {
 			cache.delete(msg)
 		}
@@ -979,7 +980,7 @@ func (cache *stateInfoCache) validate(orgs []api.OrgIdentityType) {
 // Add attempts to add the given message to the stateInfoCache,
 // and if the message was added, also indexes it.
 // Message must be a StateInfo message.
-func (cache *stateInfoCache) Add(msg *proto.SignedGossipMessage) bool {
+func (cache *stateInfoCache) Add(msg *protoext.SignedGossipMessage) bool {
 	if !cache.MessageStore.CheckValid(msg) {
 		return false
 	}
@@ -994,9 +995,9 @@ func (cache *stateInfoCache) Add(msg *proto.SignedGossipMessage) bool {
 	return added
 }
 
-func (cache *stateInfoCache) delete(msg *proto.SignedGossipMessage) {
+func (cache *stateInfoCache) delete(msg *protoext.SignedGossipMessage) {
 	cache.Purge(func(o interface{}) bool {
-		pkiID := o.(*proto.SignedGossipMessage).GetStateInfo().PkiId
+		pkiID := o.(*protoext.SignedGossipMessage).GetStateInfo().PkiId
 		return bytes.Equal(pkiID, msg.GetStateInfo().PkiId)
 	})
 	cache.Remove(msg.GetStateInfo().PkiId)
diff --git a/gossip/gossip/channel/channel_test.go b/gossip/gossip/channel/channel_test.go
index dfab7ed5..69002814 100644
--- a/gossip/gossip/channel/channel_test.go
+++ b/gossip/gossip/channel/channel_test.go
@@ -26,6 +26,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -155,7 +156,7 @@ func (cs *cryptoService) ValidateIdentity(peerIdentity api.PeerIdentityType) err
 
 type receivedMsg struct {
 	PKIID common.PKIidType
-	msg   *proto.SignedGossipMessage
+	msg   *protoext.SignedGossipMessage
 	mock.Mock
 }
 
@@ -165,7 +166,7 @@ func (m *receivedMsg) GetSourceEnvelope() *proto.Envelope {
 	return m.msg.Envelope
 }
 
-func (m *receivedMsg) GetGossipMessage() *proto.SignedGossipMessage {
+func (m *receivedMsg) GetGossipMessage() *protoext.SignedGossipMessage {
 	return m.msg
 }
 
@@ -178,8 +179,8 @@ func (m *receivedMsg) Ack(err error) {
 
 }
 
-func (m *receivedMsg) GetConnectionInfo() *proto.ConnectionInfo {
-	return &proto.ConnectionInfo{
+func (m *receivedMsg) GetConnectionInfo() *protoext.ConnectionInfo {
+	return &protoext.ConnectionInfo{
 		ID: m.PKIID,
 	}
 }
@@ -188,8 +189,8 @@ type gossipAdapterMock struct {
 	mock.Mock
 }
 
-func (ga *gossipAdapterMock) Sign(msg *proto.GossipMessage) (*proto.SignedGossipMessage, error) {
-	return msg.NoopSign()
+func (ga *gossipAdapterMock) Sign(msg *proto.GossipMessage) (*protoext.SignedGossipMessage, error) {
+	return protoext.NoopSign(msg)
 }
 
 func (ga *gossipAdapterMock) GetConf() Config {
@@ -197,11 +198,11 @@ func (ga *gossipAdapterMock) GetConf() Config {
 	return args.Get(0).(Config)
 }
 
-func (ga *gossipAdapterMock) Gossip(msg *proto.SignedGossipMessage) {
+func (ga *gossipAdapterMock) Gossip(msg *protoext.SignedGossipMessage) {
 	ga.Called(msg)
 }
 
-func (ga *gossipAdapterMock) Forward(msg proto.ReceivedMessage) {
+func (ga *gossipAdapterMock) Forward(msg protoext.ReceivedMessage) {
 	ga.Called(msg)
 }
 
@@ -229,7 +230,7 @@ func (ga *gossipAdapterMock) Lookup(PKIID common.PKIidType) *discovery.NetworkMe
 	return args.Get(0).(*discovery.NetworkMember)
 }
 
-func (ga *gossipAdapterMock) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (ga *gossipAdapterMock) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	// Ensure we have configured Send prior
 	if !ga.wasMocked("Send") {
 		return
@@ -237,7 +238,7 @@ func (ga *gossipAdapterMock) Send(msg *proto.SignedGossipMessage, peers ...*comm
 	ga.Called(msg, peers)
 }
 
-func (ga *gossipAdapterMock) ValidateStateInfoMessage(msg *proto.SignedGossipMessage) error {
+func (ga *gossipAdapterMock) ValidateStateInfoMessage(msg *protoext.SignedGossipMessage) error {
 	args := ga.Called(msg)
 	if args.Get(0) == nil {
 		return nil
@@ -312,7 +313,7 @@ func TestSelf(t *testing.T) {
 	gc.UpdateLedgerHeight(1)
 	gMsg := gc.Self().GossipMessage
 	env := gc.Self().Envelope
-	sMsg, _ := env.ToGossipMessage()
+	sMsg, _ := protoext.EnvelopeToGossipMessage(env)
 	assert.True(t, gproto.Equal(gMsg, sMsg.GossipMessage))
 	assert.Equal(t, gMsg.GetStateInfo().Properties.LedgerHeight, uint64(1))
 	assert.Equal(t, gMsg.GetStateInfo().PkiId, []byte("1"))
@@ -355,17 +356,17 @@ func TestMsgStoreNotExpire(t *testing.T) {
 	gc.HandleMessage(&receivedMsg{PKIID: pkiID2, msg: createStateInfoMsg(1, pkiID2, channelA)})
 	gc.HandleMessage(&receivedMsg{PKIID: pkiID3, msg: createStateInfoMsg(1, pkiID3, channelA)})
 
-	simulateStateInfoRequest := func(pkiID []byte, outChan chan *proto.SignedGossipMessage) {
+	simulateStateInfoRequest := func(pkiID []byte, outChan chan *protoext.SignedGossipMessage) {
 		sentMessages := make(chan *proto.GossipMessage, 1)
 		// Ensure we respond to stateInfoSnapshot requests with valid MAC
-		s, _ := (&proto.GossipMessage{
+		s, _ := protoext.NoopSign(&proto.GossipMessage{
 			Tag: proto.GossipMessage_CHAN_OR_ORG,
 			Content: &proto.GossipMessage_StateInfoPullReq{
 				StateInfoPullReq: &proto.StateInfoPullRequest{
 					Channel_MAC: GenerateMAC(pkiID, channelA),
 				},
 			},
-		}).NoopSign()
+		})
 		snapshotReq := &receivedMsg{
 			PKIID: pkiID,
 			msg:   s,
@@ -380,18 +381,18 @@ func TestMsgStoreNotExpire(t *testing.T) {
 			t.Fatal("Haven't received a state info snapshot on time")
 		case msg := <-sentMessages:
 			for _, el := range msg.GetStateSnapshot().Elements {
-				sMsg, err := el.ToGossipMessage()
+				sMsg, err := protoext.EnvelopeToGossipMessage(el)
 				assert.NoError(t, err)
 				outChan <- sMsg
 			}
 		}
 	}
 
-	c := make(chan *proto.SignedGossipMessage, 3)
+	c := make(chan *protoext.SignedGossipMessage, 3)
 	simulateStateInfoRequest(pkiID2, c)
 	assert.Len(t, c, 3)
 
-	c = make(chan *proto.SignedGossipMessage, 3)
+	c = make(chan *protoext.SignedGossipMessage, 3)
 	simulateStateInfoRequest(pkiID3, c)
 	assert.Len(t, c, 3)
 
@@ -403,11 +404,11 @@ func TestMsgStoreNotExpire(t *testing.T) {
 	// the test
 	time.Sleep(conf.StateInfoCacheSweepInterval * 2)
 
-	c = make(chan *proto.SignedGossipMessage, 3)
+	c = make(chan *protoext.SignedGossipMessage, 3)
 	simulateStateInfoRequest(pkiID2, c)
 	assert.Len(t, c, 2)
 
-	c = make(chan *proto.SignedGossipMessage, 3)
+	c = make(chan *protoext.SignedGossipMessage, 3)
 	simulateStateInfoRequest(pkiID3, c)
 	assert.Len(t, c, 2)
 }
@@ -444,8 +445,8 @@ func TestLeaveChannel(t *testing.T) {
 	configureAdapter(adapter, members...)
 	gc := NewGossipChannel(common.PKIidType("p0"), orgInChannelA, cs, channelA, adapter, jcm, disabledMetrics)
 	adapter.On("Send", mock.Anything, mock.Anything).Run(func(arguments mock.Arguments) {
-		msg := arguments.Get(0).(*proto.SignedGossipMessage)
-		if msg.IsPullMsg() {
+		msg := arguments.Get(0).(*protoext.SignedGossipMessage)
+		if protoext.IsPullMsg(msg.GossipMessage) {
 			helloPullWG.Done()
 			assert.False(t, gc.(*gossipChannel).hasLeftChannel())
 		}
@@ -492,7 +493,7 @@ func TestChannelPeriodicalPublishStateInfo(t *testing.T) {
 	t.Parallel()
 	ledgerHeight := 5
 	receivedMsg := int32(0)
-	stateInfoReceptionChan := make(chan *proto.SignedGossipMessage, 1)
+	stateInfoReceptionChan := make(chan *protoext.SignedGossipMessage, 1)
 
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
@@ -506,7 +507,7 @@ func TestChannelPeriodicalPublishStateInfo(t *testing.T) {
 		}
 
 		atomic.StoreInt32(&receivedMsg, int32(1))
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
 		stateInfoReceptionChan <- msg
 	})
 
@@ -514,7 +515,7 @@ func TestChannelPeriodicalPublishStateInfo(t *testing.T) {
 	gc.UpdateLedgerHeight(uint64(ledgerHeight))
 	defer gc.Stop()
 
-	var msg *proto.SignedGossipMessage
+	var msg *protoext.SignedGossipMessage
 	select {
 	case <-time.After(time.Second * 5):
 		t.Fatal("Haven't sent stateInfo on time")
@@ -557,19 +558,19 @@ func TestChannelMsgStoreEviction(t *testing.T) {
 	wg.Add(int(totalPhases))
 
 	adapter.On("Send", mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
-		msg := args.Get(0).(*proto.SignedGossipMessage)
+		msg := args.Get(0).(*protoext.SignedGossipMessage)
 		// Ignore all other messages sent like StateInfo messages
-		if !msg.IsPullMsg() {
+		if !protoext.IsPullMsg(msg.GossipMessage) {
 			return
 		}
 		// Stop the pull when we reach the final phase
-		if atomic.LoadUint64(&phaseNum) == totalPhases && msg.IsHelloMsg() {
+		if atomic.LoadUint64(&phaseNum) == totalPhases && protoext.IsHelloMsg(msg.GossipMessage) {
 			return
 		}
 
 		start := atomic.LoadUint64(&phaseNum) * msgsPerPhase
 		end := start + msgsPerPhase
-		if msg.IsHelloMsg() {
+		if protoext.IsHelloMsg(msg.GossipMessage) {
 			// Advance phase
 			atomic.AddUint64(&phaseNum, uint64(1))
 		}
@@ -580,7 +581,7 @@ func TestChannelMsgStoreEviction(t *testing.T) {
 		pullPhase(args)
 
 		// If we finished the last phase, save the sequence to be used later for inspection
-		if msg.IsDataReq() && atomic.LoadUint64(&phaseNum) == totalPhases {
+		if protoext.IsDataReq(msg.GossipMessage) && atomic.LoadUint64(&phaseNum) == totalPhases {
 			for _, seq := range currSeq {
 				lastPullPhase <- seq
 			}
@@ -595,7 +596,7 @@ func TestChannelMsgStoreEviction(t *testing.T) {
 	helloMsg := createHelloMsg(pkiIDInOrg1)
 	helloMsg.On("Respond", mock.Anything).Run(func(arg mock.Arguments) {
 		msg := arg.Get(0).(*proto.GossipMessage)
-		if !msg.IsDigestMsg() {
+		if !protoext.IsDigestMsg(msg) {
 			return
 		}
 		msgSentFromPullMediator <- msg
@@ -613,7 +614,7 @@ func TestChannelMsgStoreEviction(t *testing.T) {
 	assert.Len(t, msgSentFromPullMediator, 1)
 	msg := <-msgSentFromPullMediator
 	// It's a digest and not anything else, like an update
-	assert.True(t, msg.IsDigestMsg())
+	assert.True(t, protoext.IsDigestMsg(msg))
 	assert.Len(t, msg.GetDataDig().Digests, adapter.GetConf().MaxBlockCountToStore+1)
 	// Check that the last sequences are kept.
 	// Since we checked the length, it proves that the old blocks were discarded, since we had much more
@@ -627,18 +628,18 @@ func TestChannelPull(t *testing.T) {
 	t.Parallel()
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
-	receivedBlocksChan := make(chan *proto.SignedGossipMessage, 2)
+	receivedBlocksChan := make(chan *protoext.SignedGossipMessage, 2)
 	adapter := new(gossipAdapterMock)
 	configureAdapter(adapter, discovery.NetworkMember{PKIid: pkiIDInOrg1})
 	adapter.On("Gossip", mock.Anything)
 	adapter.On("Forward", mock.Anything)
 	adapter.On("DeMultiplex", mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
-		if !msg.IsDataMsg() {
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
+		if !protoext.IsDataMsg(msg.GossipMessage) {
 			return
 		}
 		// The peer is supposed to de-multiplex 2 ledger blocks
-		assert.True(t, msg.IsDataMsg())
+		assert.True(t, protoext.IsDataMsg(msg.GossipMessage))
 		receivedBlocksChan <- msg
 	})
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
@@ -697,8 +698,8 @@ func TestChannelPullAccessControl(t *testing.T) {
 
 	sentHello := int32(0)
 	adapter.On("Send", mock.Anything, mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
-		if !msg.IsHelloMsg() {
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
+		if !protoext.IsHelloMsg(msg.GossipMessage) {
 			return
 		}
 		atomic.StoreInt32(&sentHello, int32(1))
@@ -906,7 +907,7 @@ func TestChannelAddToMessageStore(t *testing.T) {
 
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
-	demuxedMsgs := make(chan *proto.SignedGossipMessage, 1)
+	demuxedMsgs := make(chan *protoext.SignedGossipMessage, 1)
 	adapter := new(gossipAdapterMock)
 	configureAdapter(adapter)
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
@@ -914,7 +915,7 @@ func TestChannelAddToMessageStore(t *testing.T) {
 	adapter.On("Forward", mock.Anything)
 	adapter.On("Send", mock.Anything, mock.Anything)
 	adapter.On("DeMultiplex", mock.Anything).Run(func(arg mock.Arguments) {
-		demuxedMsgs <- arg.Get(0).(*proto.SignedGossipMessage)
+		demuxedMsgs <- arg.Get(0).(*protoext.SignedGossipMessage)
 	})
 
 	// Check that adding a message of a bad type doesn't crash the program
@@ -959,7 +960,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
-	demuxedMsgs := make(chan *proto.SignedGossipMessage, 1)
+	demuxedMsgs := make(chan *protoext.SignedGossipMessage, 1)
 	adapter := new(gossipAdapterMock)
 	configureAdapter(adapter)
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
@@ -967,7 +968,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 	adapter.On("Forward", mock.Anything)
 	adapter.On("Send", mock.Anything, mock.Anything)
 	adapter.On("DeMultiplex", mock.Anything).Run(func(arg mock.Arguments) {
-		demuxedMsgs <- arg.Get(0).(*proto.SignedGossipMessage)
+		demuxedMsgs <- arg.Get(0).(*protoext.SignedGossipMessage)
 	})
 	respondedChan := make(chan *proto.GossipMessage, 1)
 	messageRelayer := func(arg mock.Arguments) {
@@ -993,7 +994,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 	case <-time.After(time.Second):
 		t.Fatal("Haven't responded to hello message within a time period")
 	case msg := <-respondedChan:
-		if msg.IsDigestMsg() {
+		if protoext.IsDigestMsg(msg) {
 			assert.Equal(t, 1, len(msg.GetDataDig().Digests), "Number of digests returned by channel blockPuller incorrect")
 		} else {
 			t.Fatal("Not correct pull msg type in response - expect digest")
@@ -1037,7 +1038,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 	case <-time.After(time.Second):
 		t.Fatal("Haven't responded to hello message within a time period")
 	case msg := <-respondedChan:
-		if msg.IsDigestMsg() {
+		if protoext.IsDigestMsg(msg) {
 			assert.Equal(t, 1, len(msg.GetDataDig().Digests), "Number of digests returned by channel blockPuller incorrect")
 		} else {
 			t.Fatal("Not correct pull msg type in response - expect digest")
@@ -1049,7 +1050,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 
 func TestChannelBadBlocks(t *testing.T) {
 	t.Parallel()
-	receivedMessages := make(chan *proto.SignedGossipMessage, 1)
+	receivedMessages := make(chan *protoext.SignedGossipMessage, 1)
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
 	adapter := new(gossipAdapterMock)
@@ -1059,7 +1060,7 @@ func TestChannelBadBlocks(t *testing.T) {
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
 
 	adapter.On("DeMultiplex", mock.Anything).Run(func(args mock.Arguments) {
-		receivedMessages <- args.Get(0).(*proto.SignedGossipMessage)
+		receivedMessages <- args.Get(0).(*protoext.SignedGossipMessage)
 	})
 
 	// Send a valid block
@@ -1102,9 +1103,9 @@ func TestChannelPulledBadBlocks(t *testing.T) {
 	wg.Add(1)
 
 	changeChan := func(env *proto.Envelope) {
-		sMsg, _ := env.ToGossipMessage()
+		sMsg, _ := protoext.EnvelopeToGossipMessage(env)
 		sMsg.Channel = []byte("B")
-		sMsg, _ = sMsg.NoopSign()
+		sMsg, _ = protoext.NoopSign(sMsg.GossipMessage)
 		env.Payload = sMsg.Payload
 	}
 
@@ -1150,9 +1151,9 @@ func TestChannelPulledBadBlocks(t *testing.T) {
 	var wg3 sync.WaitGroup
 	wg3.Add(1)
 	emptyBlock := func(env *proto.Envelope) {
-		sMsg, _ := env.ToGossipMessage()
+		sMsg, _ := protoext.EnvelopeToGossipMessage(env)
 		sMsg.GossipMessage.GetDataMsg().Payload = nil
-		sMsg, _ = sMsg.NoopSign()
+		sMsg, _ = protoext.NoopSign(sMsg.GossipMessage)
 		env.Payload = sMsg.Payload
 	}
 	pullPhase3 := simulatePullPhase(gc, t, &wg3, emptyBlock, 10, 11)
@@ -1175,9 +1176,9 @@ func TestChannelPulledBadBlocks(t *testing.T) {
 	var wg4 sync.WaitGroup
 	wg4.Add(1)
 	nonBlockMsg := func(env *proto.Envelope) {
-		sMsg, _ := env.ToGossipMessage()
+		sMsg, _ := protoext.EnvelopeToGossipMessage(env)
 		sMsg.Content = createHelloMsg(pkiIDInOrg1).GetGossipMessage().Content
-		sMsg, _ = sMsg.NoopSign()
+		sMsg, _ = protoext.NoopSign(sMsg.GossipMessage)
 		env.Payload = sMsg.Payload
 	}
 	pullPhase4 := simulatePullPhase(gc, t, &wg4, nonBlockMsg, 10, 11)
@@ -1219,7 +1220,7 @@ func TestChannelStateInfoSnapshot(t *testing.T) {
 	// Ensure we ignore stateInfo snapshots with StateInfo messages with wrong MACs
 	sim := createStateInfoMsg(4, pkiIDInOrg1, channelA)
 	sim.GetStateInfo().Channel_MAC = append(sim.GetStateInfo().Channel_MAC, 1)
-	sim, _ = sim.NoopSign()
+	sim, _ = protoext.NoopSign(sim.GossipMessage)
 	gc.HandleMessage(&receivedMsg{PKIID: pkiIDInOrg1, msg: stateInfoSnapshotForChannel(channelA, sim)})
 	assert.Empty(t, gc.GetPeers())
 
@@ -1233,14 +1234,14 @@ func TestChannelStateInfoSnapshot(t *testing.T) {
 	assert.Equal(t, 4, int(gc.GetPeers()[0].Properties.LedgerHeight))
 
 	// Check we don't respond to stateInfoSnapshot requests with wrong MAC
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfoPullReq{
 			StateInfoPullReq: &proto.StateInfoPullRequest{
 				Channel_MAC: append(GenerateMAC(pkiIDInOrg1, channelA), 1),
 			},
 		},
-	}).NoopSign()
+	})
 	snapshotReq := &receivedMsg{
 		PKIID: pkiIDInOrg1,
 		msg:   sMsg,
@@ -1257,14 +1258,14 @@ func TestChannelStateInfoSnapshot(t *testing.T) {
 	}
 
 	// Ensure we respond to stateInfoSnapshot requests with valid MAC
-	sMsg, _ = (&proto.GossipMessage{
+	sMsg, _ = protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfoPullReq{
 			StateInfoPullReq: &proto.StateInfoPullRequest{
 				Channel_MAC: GenerateMAC(pkiIDInOrg1, channelA),
 			},
 		},
-	}).NoopSign()
+	})
 	snapshotReq = &receivedMsg{
 		PKIID: pkiIDInOrg1,
 		msg:   sMsg,
@@ -1280,7 +1281,7 @@ func TestChannelStateInfoSnapshot(t *testing.T) {
 	case msg := <-sentMessages:
 		elements := msg.GetStateSnapshot().Elements
 		assert.Len(t, elements, 1)
-		sMsg, err := elements[0].ToGossipMessage()
+		sMsg, err := protoext.EnvelopeToGossipMessage(elements[0])
 		assert.NoError(t, err)
 		assert.Equal(t, 4, int(sMsg.GetStateInfo().Properties.LedgerHeight))
 	}
@@ -1327,14 +1328,14 @@ func TestInterOrgExternalEndpointDisclosure(t *testing.T) {
 
 	// Check that we only return StateInfo messages of peers with external endpoints
 	// to peers of other orgs
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfoPullReq{
 			StateInfoPullReq: &proto.StateInfoPullRequest{
 				Channel_MAC: GenerateMAC(pkiID3, channelA),
 			},
 		},
-	}).NoopSign()
+	})
 	snapshotReq := &receivedMsg{
 		PKIID: pkiID3,
 		msg:   sMsg,
@@ -1350,8 +1351,8 @@ func TestInterOrgExternalEndpointDisclosure(t *testing.T) {
 	case msg := <-sentMessages:
 		elements := msg.GetStateSnapshot().Elements
 		assert.Len(t, elements, 2)
-		m1, _ := elements[0].ToGossipMessage()
-		m2, _ := elements[1].ToGossipMessage()
+		m1, _ := protoext.EnvelopeToGossipMessage(elements[0])
+		m2, _ := protoext.EnvelopeToGossipMessage(elements[1])
 		pkiIDs := [][]byte{m1.GetStateInfo().PkiId, m2.GetStateInfo().PkiId}
 		assert.Contains(t, pkiIDs, []byte(pkiID1))
 		assert.Contains(t, pkiIDs, []byte(pkiID3))
@@ -1359,14 +1360,14 @@ func TestInterOrgExternalEndpointDisclosure(t *testing.T) {
 
 	// Check that we return all StateInfo messages to peers in our organization, regardless
 	// if the peers from foreign organizations have external endpoints or not
-	sMsg, _ = (&proto.GossipMessage{
+	sMsg, _ = protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfoPullReq{
 			StateInfoPullReq: &proto.StateInfoPullRequest{
 				Channel_MAC: GenerateMAC(pkiID2, channelA),
 			},
 		},
-	}).NoopSign()
+	})
 	snapshotReq = &receivedMsg{
 		PKIID: pkiID2,
 		msg:   sMsg,
@@ -1382,9 +1383,9 @@ func TestInterOrgExternalEndpointDisclosure(t *testing.T) {
 	case msg := <-sentMessages:
 		elements := msg.GetStateSnapshot().Elements
 		assert.Len(t, elements, 3)
-		m1, _ := elements[0].ToGossipMessage()
-		m2, _ := elements[1].ToGossipMessage()
-		m3, _ := elements[2].ToGossipMessage()
+		m1, _ := protoext.EnvelopeToGossipMessage(elements[0])
+		m2, _ := protoext.EnvelopeToGossipMessage(elements[1])
+		m3, _ := protoext.EnvelopeToGossipMessage(elements[2])
 		pkiIDs := [][]byte{m1.GetStateInfo().PkiId, m2.GetStateInfo().PkiId, m3.GetStateInfo().PkiId}
 		assert.Contains(t, pkiIDs, []byte(pkiID1))
 		assert.Contains(t, pkiIDs, []byte(pkiID2))
@@ -1701,7 +1702,7 @@ func TestChannelGetPeers(t *testing.T) {
 	assert.Equal(t, pkiIDInOrg1, gc.GetPeers()[0].PKIid)
 
 	// Ensure envelope from GetPeers is valid
-	gMsg, _ := gc.GetPeers()[0].Envelope.ToGossipMessage()
+	gMsg, _ := protoext.EnvelopeToGossipMessage(gc.GetPeers()[0].Envelope)
 	assert.Equal(t, []byte(pkiIDInOrg1), gMsg.GetStateInfo().PkiId)
 
 	gc.HandleMessage(&receivedMsg{msg: createStateInfoMsg(10, pkiIDInOrg1ButNotEligible, channelA), PKIID: pkiIDInOrg1ButNotEligible})
@@ -1788,18 +1789,18 @@ func TestChannelPullWithDigestsFilter(t *testing.T) {
 	t.Parallel()
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
-	receivedBlocksChan := make(chan *proto.SignedGossipMessage, 2)
+	receivedBlocksChan := make(chan *protoext.SignedGossipMessage, 2)
 	adapter := new(gossipAdapterMock)
 	configureAdapter(adapter, discovery.NetworkMember{PKIid: pkiIDInOrg1})
 	adapter.On("Gossip", mock.Anything)
 	adapter.On("Forward", mock.Anything)
 	adapter.On("DeMultiplex", mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
-		if !msg.IsDataMsg() {
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
+		if !protoext.IsDataMsg(msg.GossipMessage) {
 			return
 		}
 		// The peer is supposed to de-multiplex 1 ledger block
-		assert.True(t, msg.IsDataMsg())
+		assert.True(t, protoext.IsDataMsg(msg.GossipMessage))
 		receivedBlocksChan <- msg
 	})
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
@@ -1823,7 +1824,7 @@ func TestChannelPullWithDigestsFilter(t *testing.T) {
 
 }
 
-func createDataUpdateMsg(nonce uint64, seqs ...uint64) *proto.SignedGossipMessage {
+func createDataUpdateMsg(nonce uint64, seqs ...uint64) *protoext.SignedGossipMessage {
 	msg := &proto.GossipMessage{
 		Nonce:   0,
 		Channel: []byte(channelA),
@@ -1839,7 +1840,7 @@ func createDataUpdateMsg(nonce uint64, seqs ...uint64) *proto.SignedGossipMessag
 	for _, seq := range seqs {
 		msg.GetDataUpdate().Data = append(msg.GetDataUpdate().Data, createDataMsg(seq, channelA).Envelope)
 	}
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	return sMsg
 }
 
@@ -1855,12 +1856,12 @@ func createHelloMsg(PKIID common.PKIidType) *receivedMsg {
 			},
 		},
 	}
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	return &receivedMsg{msg: sMsg, PKIID: PKIID}
 }
 
-func dataMsgOfChannel(seqnum uint64, channel common.ChainID) *proto.SignedGossipMessage {
-	sMsg, _ := (&proto.GossipMessage{
+func dataMsgOfChannel(seqnum uint64, channel common.ChainID) *protoext.SignedGossipMessage {
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Channel: []byte(channel),
 		Nonce:   0,
 		Tag:     proto.GossipMessage_CHAN_AND_ORG,
@@ -1872,12 +1873,12 @@ func dataMsgOfChannel(seqnum uint64, channel common.ChainID) *proto.SignedGossip
 				},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
-func createStateInfoMsg(ledgerHeight int, pkiID common.PKIidType, channel common.ChainID) *proto.SignedGossipMessage {
-	sMsg, _ := (&proto.GossipMessage{
+func createStateInfoMsg(ledgerHeight int, pkiID common.PKIidType, channel common.ChainID) *protoext.SignedGossipMessage {
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfo{
 			StateInfo: &proto.StateInfo{
@@ -1889,16 +1890,16 @@ func createStateInfoMsg(ledgerHeight int, pkiID common.PKIidType, channel common
 				},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
-func stateInfoSnapshotForChannel(chainID common.ChainID, stateInfoMsgs ...*proto.SignedGossipMessage) *proto.SignedGossipMessage {
+func stateInfoSnapshotForChannel(chainID common.ChainID, stateInfoMsgs ...*protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 	envelopes := make([]*proto.Envelope, len(stateInfoMsgs))
 	for i, sim := range stateInfoMsgs {
 		envelopes[i] = sim.Envelope
 	}
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Channel: chainID,
 		Tag:     proto.GossipMessage_CHAN_OR_ORG,
 		Nonce:   0,
@@ -1907,12 +1908,12 @@ func stateInfoSnapshotForChannel(chainID common.ChainID, stateInfoMsgs ...*proto
 				Elements: envelopes,
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
-func createDataMsg(seqnum uint64, channel common.ChainID) *proto.SignedGossipMessage {
-	sMsg, _ := (&proto.GossipMessage{
+func createDataMsg(seqnum uint64, channel common.ChainID) *protoext.SignedGossipMessage {
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Nonce:   0,
 		Tag:     proto.GossipMessage_CHAN_AND_ORG,
 		Channel: []byte(channel),
@@ -1924,7 +1925,7 @@ func createDataMsg(seqnum uint64, channel common.ChainID) *proto.SignedGossipMes
 				},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
@@ -1937,13 +1938,13 @@ func simulatePullPhaseWithVariableDigest(gc GossipChannel, t *testing.T, wg *syn
 	var sentHello bool
 	var sentReq bool
 	return func(args mock.Arguments) {
-		msg := args.Get(0).(*proto.SignedGossipMessage)
+		msg := args.Get(0).(*protoext.SignedGossipMessage)
 		l.Lock()
 		defer l.Unlock()
-		if msg.IsHelloMsg() && !sentHello {
+		if protoext.IsHelloMsg(msg.GossipMessage) && !sentHello {
 			sentHello = true
 			// Simulate a digest message an imaginary peer responds to the hello message sent
-			sMsg, _ := (&proto.GossipMessage{
+			sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 				Tag:     proto.GossipMessage_CHAN_AND_ORG,
 				Channel: []byte(channelA),
 				Content: &proto.GossipMessage_DataDig{
@@ -1953,14 +1954,14 @@ func simulatePullPhaseWithVariableDigest(gc GossipChannel, t *testing.T, wg *syn
 						Nonce:   msg.GetHello().Nonce,
 					},
 				},
-			}).NoopSign()
+			})
 			digestMsg := &receivedMsg{
 				PKIID: pkiIDInOrg1,
 				msg:   sMsg,
 			}
 			go gc.HandleMessage(digestMsg)
 		}
-		if msg.IsDataReq() && !sentReq {
+		if protoext.IsDataReq(msg.GossipMessage) && !sentReq {
 			sentReq = true
 			dataReq := msg.GetDataReq()
 			for _, expectedDigest := range util.StringsToBytes(resultDigestSeqs) {
diff --git a/gossip/gossip/chanstate.go b/gossip/gossip/chanstate.go
index befe8ebe..ea6b45dc 100644
--- a/gossip/gossip/chanstate.go
+++ b/gossip/gossip/chanstate.go
@@ -17,6 +17,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/gossip/channel"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
@@ -43,8 +44,8 @@ func (cs *channelState) isStopping() bool {
 	return atomic.LoadInt32(&cs.stopping) == int32(1)
 }
 
-func (cs *channelState) lookupChannelForMsg(msg proto.ReceivedMessage) channel.GossipChannel {
-	if msg.GetGossipMessage().IsStateInfoPullRequestMsg() {
+func (cs *channelState) lookupChannelForMsg(msg protoext.ReceivedMessage) channel.GossipChannel {
+	if protoext.IsStateInfoPullRequestMsg(msg.GetGossipMessage().GossipMessage) {
 		sipr := msg.GetGossipMessage().GetStateInfoPullReq()
 		mac := sipr.Channel_MAC
 		pkiID := msg.GetConnectionInfo().ID
@@ -54,7 +55,7 @@ func (cs *channelState) lookupChannelForMsg(msg proto.ReceivedMessage) channel.G
 }
 
 func (cs *channelState) lookupChannelForGossipMsg(msg *proto.GossipMessage) channel.GossipChannel {
-	if !msg.IsStateInfoMsg() {
+	if !protoext.IsStateInfoMsg(msg) {
 		// If we reached here then the message isn't:
 		// 1) StateInfoPullRequest
 		// 2) StateInfo
@@ -134,25 +135,25 @@ func (ga *gossipAdapterImpl) GetConf() channel.Config {
 	}
 }
 
-func (ga *gossipAdapterImpl) Sign(msg *proto.GossipMessage) (*proto.SignedGossipMessage, error) {
+func (ga *gossipAdapterImpl) Sign(msg *proto.GossipMessage) (*protoext.SignedGossipMessage, error) {
 	signer := func(msg []byte) ([]byte, error) {
 		return ga.mcs.Sign(msg)
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: msg,
 	}
 	e, err := sMsg.Sign(signer)
 	if err != nil {
 		return nil, err
 	}
-	return &proto.SignedGossipMessage{
+	return &protoext.SignedGossipMessage{
 		Envelope:      e,
 		GossipMessage: msg,
 	}, nil
 }
 
 // Gossip gossips a message
-func (ga *gossipAdapterImpl) Gossip(msg *proto.SignedGossipMessage) {
+func (ga *gossipAdapterImpl) Gossip(msg *protoext.SignedGossipMessage) {
 	ga.gossipServiceImpl.emitter.Add(&emittedGossipMessage{
 		SignedGossipMessage: msg,
 		filter: func(_ common.PKIidType) bool {
@@ -162,20 +163,20 @@ func (ga *gossipAdapterImpl) Gossip(msg *proto.SignedGossipMessage) {
 }
 
 // Forward sends message to the next hops
-func (ga *gossipAdapterImpl) Forward(msg proto.ReceivedMessage) {
+func (ga *gossipAdapterImpl) Forward(msg protoext.ReceivedMessage) {
 	ga.gossipServiceImpl.emitter.Add(&emittedGossipMessage{
 		SignedGossipMessage: msg.GetGossipMessage(),
 		filter:              msg.GetConnectionInfo().ID.IsNotSameFilter,
 	})
 }
 
-func (ga *gossipAdapterImpl) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (ga *gossipAdapterImpl) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	ga.gossipServiceImpl.comm.Send(msg, peers...)
 }
 
 // ValidateStateInfoMessage returns error if a message isn't valid
 // nil otherwise
-func (ga *gossipAdapterImpl) ValidateStateInfoMessage(msg *proto.SignedGossipMessage) error {
+func (ga *gossipAdapterImpl) ValidateStateInfoMessage(msg *protoext.SignedGossipMessage) error {
 	return ga.gossipServiceImpl.validateStateInfoMsg(msg)
 }
 
diff --git a/gossip/gossip/gossip.go b/gossip/gossip/gossip.go
index a429a303..75f5e170 100644
--- a/gossip/gossip/gossip.go
+++ b/gossip/gossip/gossip.go
@@ -15,6 +15,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/filter"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
@@ -25,13 +26,13 @@ type Gossip interface {
 	SelfMembershipInfo() discovery.NetworkMember
 
 	// SelfChannelInfo returns the peer's latest StateInfo message of a given channel
-	SelfChannelInfo(common.ChainID) *proto.SignedGossipMessage
+	SelfChannelInfo(common.ChainID) *protoext.SignedGossipMessage
 
 	// Send sends a message to remote peers
 	Send(msg *proto.GossipMessage, peers ...*comm.RemotePeer)
 
 	// SendByCriteria sends a given message to all peers that match the given SendCriteria
-	SendByCriteria(*proto.SignedGossipMessage, SendCriteria) error
+	SendByCriteria(*protoext.SignedGossipMessage, SendCriteria) error
 
 	// GetPeers returns the NetworkMembers considered alive
 	Peers() []discovery.NetworkMember
@@ -63,7 +64,7 @@ type Gossip interface {
 	// If passThrough is false, the messages are processed by the gossip layer beforehand.
 	// If passThrough is true, the gossip layer doesn't intervene and the messages
 	// can be used to send a reply back to the sender
-	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 
 	// JoinChan makes the Gossip instance join a channel
 	JoinChan(joinMsg api.JoinChannelMessage, chainID common.ChainID)
@@ -88,7 +89,7 @@ type Gossip interface {
 // emittedGossipMessage encapsulates signed gossip message to compose
 // with routing filter to be used while message is forwarded
 type emittedGossipMessage struct {
-	*proto.SignedGossipMessage
+	*protoext.SignedGossipMessage
 	filter func(id common.PKIidType) bool
 }
 
diff --git a/gossip/gossip/gossip_impl.go b/gossip/gossip/gossip_impl.go
index 25da402d..bd479f84 100644
--- a/gossip/gossip/gossip_impl.go
+++ b/gossip/gossip/gossip_impl.go
@@ -27,6 +27,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/pull"
 	"github.com/hyperledger/fabric/gossip/identity"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -146,7 +147,7 @@ func NewGossipService(conf *Config, s *grpc.Server, sa api.SecurityAdvisor,
 }
 
 func (g *gossipServiceImpl) newStateInfoMsgStore() msgstore.MessageStore {
-	pol := proto.NewGossipMessageComparator(0)
+	pol := protoext.NewGossipMessageComparator(0)
 	return msgstore.NewMessageStoreExpirable(pol,
 		msgstore.Noop,
 		g.conf.PublishStateInfoInterval*100,
@@ -300,14 +301,14 @@ func (g *gossipServiceImpl) start() {
 	go g.handlePresumedDead()
 
 	msgSelector := func(msg interface{}) bool {
-		gMsg, isGossipMsg := msg.(proto.ReceivedMessage)
+		gMsg, isGossipMsg := msg.(protoext.ReceivedMessage)
 		if !isGossipMsg {
 			return false
 		}
 
 		isConn := gMsg.GetGossipMessage().GetConn() != nil
 		isEmpty := gMsg.GetGossipMessage().GetEmpty() != nil
-		isPrivateData := gMsg.GetGossipMessage().IsPrivateDataMsg()
+		isPrivateData := protoext.IsPrivateDataMsg(gMsg.GetGossipMessage().GossipMessage)
 
 		return !(isConn || isEmpty || isPrivateData)
 	}
@@ -319,7 +320,7 @@ func (g *gossipServiceImpl) start() {
 	g.logger.Info("Gossip instance", g.conf.ID, "started")
 }
 
-func (g *gossipServiceImpl) acceptMessages(incMsgs <-chan proto.ReceivedMessage) {
+func (g *gossipServiceImpl) acceptMessages(incMsgs <-chan protoext.ReceivedMessage) {
 	defer g.logger.Debug("Exiting")
 	defer g.stopSignal.Done()
 	for {
@@ -333,7 +334,7 @@ func (g *gossipServiceImpl) acceptMessages(incMsgs <-chan proto.ReceivedMessage)
 	}
 }
 
-func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
+func (g *gossipServiceImpl) handleMessage(m protoext.ReceivedMessage) {
 	if g.toDie() {
 		return
 	}
@@ -352,11 +353,11 @@ func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
 		return
 	}
 
-	if msg.IsChannelRestricted() {
+	if protoext.IsChannelRestricted(msg.GossipMessage) {
 		if gc := g.chanState.lookupChannelForMsg(m); gc == nil {
 			// If we're not in the channel, we should still forward to peers of our org
 			// in case it's a StateInfo message
-			if g.isInMyorg(discovery.NetworkMember{PKIid: m.GetConnectionInfo().ID}) && msg.IsStateInfoMsg() {
+			if g.isInMyorg(discovery.NetworkMember{PKIid: m.GetConnectionInfo().ID}) && protoext.IsStateInfoMsg(msg.GossipMessage) {
 				if g.stateInfoMsgStore.Add(msg) {
 					g.emitter.Add(&emittedGossipMessage{
 						SignedGossipMessage: msg,
@@ -368,7 +369,7 @@ func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
 				g.logger.Debug("No such channel", msg.Channel, "discarding message", msg)
 			}
 		} else {
-			if m.GetGossipMessage().IsLeadershipMsg() {
+			if protoext.IsLeadershipMsg(m.GetGossipMessage().GossipMessage) {
 				if err := g.validateLeadershipMessage(m.GetGossipMessage()); err != nil {
 					g.logger.Warningf("Failed validating LeaderElection message: %+v", errors.WithStack(err))
 					return
@@ -383,12 +384,12 @@ func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
 		// It's a membership request, check its self information
 		// matches the sender
 		if m.GetGossipMessage().GetMemReq() != nil {
-			sMsg, err := m.GetGossipMessage().GetMemReq().SelfInformation.ToGossipMessage()
+			sMsg, err := protoext.EnvelopeToGossipMessage(m.GetGossipMessage().GetMemReq().SelfInformation)
 			if err != nil {
 				g.logger.Warningf("Got membership request with invalid selfInfo: %+v", errors.WithStack(err))
 				return
 			}
-			if !sMsg.IsAliveMsg() {
+			if !protoext.IsAliveMsg(sMsg.GossipMessage) {
 				g.logger.Warning("Got membership request with selfInfo that isn't an AliveMessage")
 				return
 			}
@@ -400,12 +401,12 @@ func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
 		g.forwardDiscoveryMsg(m)
 	}
 
-	if msg.IsPullMsg() && msg.GetPullMsgType() == proto.PullMsgType_IDENTITY_MSG {
+	if protoext.IsPullMsg(msg.GossipMessage) && protoext.GetPullMsgType(msg.GossipMessage) == proto.PullMsgType_IDENTITY_MSG {
 		g.certStore.handleMessage(m)
 	}
 }
 
-func (g *gossipServiceImpl) forwardDiscoveryMsg(msg proto.ReceivedMessage) {
+func (g *gossipServiceImpl) forwardDiscoveryMsg(msg protoext.ReceivedMessage) {
 	defer func() { // can be closed while shutting down
 		recover()
 	}()
@@ -415,13 +416,13 @@ func (g *gossipServiceImpl) forwardDiscoveryMsg(msg proto.ReceivedMessage) {
 
 // validateMsg checks the signature of the message if exists,
 // and also checks that the tag matches the message type
-func (g *gossipServiceImpl) validateMsg(msg proto.ReceivedMessage) bool {
-	if err := msg.GetGossipMessage().IsTagLegal(); err != nil {
+func (g *gossipServiceImpl) validateMsg(msg protoext.ReceivedMessage) bool {
+	if err := protoext.IsTagLegal(msg.GetGossipMessage().GossipMessage); err != nil {
 		g.logger.Warningf("Tag of %v isn't legal: %v", msg.GetGossipMessage(), errors.WithStack(err))
 		return false
 	}
 
-	if msg.GetGossipMessage().IsStateInfoMsg() {
+	if protoext.IsStateInfoMsg(msg.GetGossipMessage().GossipMessage) {
 		if err := g.validateStateInfoMsg(msg.GetGossipMessage()); err != nil {
 			g.logger.Warningf("StateInfo message %v is found invalid: %v", msg, err)
 			return false
@@ -462,24 +463,24 @@ func (g *gossipServiceImpl) gossipBatch(msgs []*emittedGossipMessage) {
 	var leadershipMsgs []*emittedGossipMessage
 
 	isABlock := func(o interface{}) bool {
-		return o.(*emittedGossipMessage).IsDataMsg()
+		return protoext.IsDataMsg(o.(*emittedGossipMessage).GossipMessage)
 	}
 	isAStateInfoMsg := func(o interface{}) bool {
-		return o.(*emittedGossipMessage).IsStateInfoMsg()
+		return protoext.IsStateInfoMsg(o.(*emittedGossipMessage).GossipMessage)
 	}
 	aliveMsgsWithNoEndpointAndInOurOrg := func(o interface{}) bool {
 		msg := o.(*emittedGossipMessage)
-		if !msg.IsAliveMsg() {
+		if !protoext.IsAliveMsg(msg.GossipMessage) {
 			return false
 		}
 		member := msg.GetAliveMsg().Membership
 		return member.Endpoint == "" && g.isInMyorg(discovery.NetworkMember{PKIid: member.PkiId})
 	}
 	isOrgRestricted := func(o interface{}) bool {
-		return aliveMsgsWithNoEndpointAndInOurOrg(o) || o.(*emittedGossipMessage).IsOrgRestricted()
+		return aliveMsgsWithNoEndpointAndInOurOrg(o) || protoext.IsOrgRestricted(o.(*emittedGossipMessage).GossipMessage)
 	}
 	isLeadershipMsg := func(o interface{}) bool {
-		return o.(*emittedGossipMessage).IsLeadershipMsg()
+		return protoext.IsLeadershipMsg(o.(*emittedGossipMessage).GossipMessage)
 	}
 
 	// Gossip blocks
@@ -520,7 +521,7 @@ func (g *gossipServiceImpl) gossipBatch(msgs []*emittedGossipMessage) {
 
 	// Finally, gossip the remaining messages
 	for _, msg := range msgs {
-		if !msg.IsAliveMsg() {
+		if !protoext.IsAliveMsg(msg.GossipMessage) {
 			g.logger.Error("Unknown message type", msg)
 			continue
 		}
@@ -533,11 +534,11 @@ func (g *gossipServiceImpl) gossipBatch(msgs []*emittedGossipMessage) {
 	}
 }
 
-func (g *gossipServiceImpl) sendAndFilterSecrets(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (g *gossipServiceImpl) sendAndFilterSecrets(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	for _, peer := range peers {
 		// Prevent forwarding alive messages of external organizations
 		// to peers that have no external endpoints
-		aliveMsgFromDiffOrg := msg.IsAliveMsg() && !g.isInMyorg(discovery.NetworkMember{PKIid: msg.GetAliveMsg().Membership.PkiId})
+		aliveMsgFromDiffOrg := protoext.IsAliveMsg(msg.GossipMessage) && !g.isInMyorg(discovery.NetworkMember{PKIid: msg.GetAliveMsg().Membership.PkiId})
 		if aliveMsgFromDiffOrg && !g.hasExternalEndpoint(peer.PKIID) {
 			continue
 		}
@@ -579,7 +580,7 @@ func (g *gossipServiceImpl) gossipInChan(messages []*emittedGossipMessage, chanR
 		// For leadership messages we will select all peers that pass routing factory - e.g. all peers in channel and org
 		membership := g.disc.GetMembership()
 		var peers2Send []*comm.RemotePeer
-		if messagesOfChannel[0].IsLeadershipMsg() {
+		if protoext.IsLeadershipMsg(messagesOfChannel[0].GossipMessage) {
 			peers2Send = filter.SelectPeers(len(membership), membership, chanRoutingFactory(gc))
 		} else {
 			peers2Send = filter.SelectPeers(g.conf.PropagatePeerNum, membership, chanRoutingFactory(gc))
@@ -610,7 +611,7 @@ func (g *gossipServiceImpl) IdentityInfo() api.PeerIdentitySet {
 }
 
 // SendByCriteria sends a given message to all peers that match the given SendCriteria
-func (g *gossipServiceImpl) SendByCriteria(msg *proto.SignedGossipMessage, criteria SendCriteria) error {
+func (g *gossipServiceImpl) SendByCriteria(msg *protoext.SignedGossipMessage, criteria SendCriteria) error {
 	if criteria.MaxPeers == 0 {
 		return nil
 	}
@@ -656,17 +657,17 @@ func (g *gossipServiceImpl) SendByCriteria(msg *proto.SignedGossipMessage, crite
 func (g *gossipServiceImpl) Gossip(msg *proto.GossipMessage) {
 	// Educate developers to Gossip messages with the right tags.
 	// See IsTagLegal() for wanted behavior.
-	if err := msg.IsTagLegal(); err != nil {
+	if err := protoext.IsTagLegal(msg); err != nil {
 		panic(errors.WithStack(err))
 	}
 
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: msg,
 	}
 
 	var err error
-	if sMsg.IsDataMsg() {
-		sMsg, err = sMsg.NoopSign()
+	if protoext.IsDataMsg(sMsg.GossipMessage) {
+		sMsg, err = protoext.NoopSign(sMsg.GossipMessage)
 	} else {
 		_, err = sMsg.Sign(func(msg []byte) ([]byte, error) {
 			return g.mcs.Sign(msg)
@@ -678,13 +679,13 @@ func (g *gossipServiceImpl) Gossip(msg *proto.GossipMessage) {
 		return
 	}
 
-	if msg.IsChannelRestricted() {
+	if protoext.IsChannelRestricted(msg) {
 		gc := g.chanState.getGossipChannelByChainID(msg.Channel)
 		if gc == nil {
 			g.logger.Warning("Failed obtaining gossipChannel of", msg.Channel, "aborting")
 			return
 		}
-		if msg.IsDataMsg() {
+		if protoext.IsDataMsg(msg) {
 			gc.AddToMsgStore(sMsg)
 		}
 	}
@@ -702,7 +703,7 @@ func (g *gossipServiceImpl) Gossip(msg *proto.GossipMessage) {
 
 // Send sends a message to remote peers
 func (g *gossipServiceImpl) Send(msg *proto.GossipMessage, peers ...*comm.RemotePeer) {
-	m, err := msg.NoopSign()
+	m, err := protoext.NoopSign(msg)
 	if err != nil {
 		g.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -733,7 +734,7 @@ func (g *gossipServiceImpl) SelfMembershipInfo() discovery.NetworkMember {
 }
 
 // SelfChannelInfo returns the peer's latest StateInfo message of a given channel
-func (g *gossipServiceImpl) SelfChannelInfo(chain common.ChainID) *proto.SignedGossipMessage {
+func (g *gossipServiceImpl) SelfChannelInfo(chain common.ChainID) *protoext.SignedGossipMessage {
 	ch := g.chanState.getGossipChannelByChainID(chain)
 	if ch == nil {
 		return nil
@@ -800,7 +801,7 @@ func (g *gossipServiceImpl) UpdateChaincodes(chaincodes []*proto.Chaincode, chai
 // If passThrough is false, the messages are processed by the gossip layer beforehand.
 // If passThrough is true, the gossip layer doesn't intervene and the messages
 // can be used to send a reply back to the sender
-func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	if passThrough {
 		return nil, g.comm.Accept(acceptor)
 	}
@@ -808,7 +809,7 @@ func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough
 		if o, isGossipMsg := o.(*proto.GossipMessage); isGossipMsg {
 			return acceptor(o)
 		}
-		if o, isSignedMsg := o.(*proto.SignedGossipMessage); isSignedMsg {
+		if o, isSignedMsg := o.(*protoext.SignedGossipMessage); isSignedMsg {
 			sMsg := o
 			return acceptor(sMsg.GossipMessage)
 		}
@@ -827,7 +828,7 @@ func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough
 				if m == nil {
 					return
 				}
-				outCh <- m.(*proto.SignedGossipMessage).GossipMessage
+				outCh <- m.(*protoext.SignedGossipMessage).GossipMessage
 			}
 		}
 	}()
@@ -835,7 +836,7 @@ func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough
 }
 
 func selectOnlyDiscoveryMessages(m interface{}) bool {
-	msg, isGossipMsg := m.(proto.ReceivedMessage)
+	msg, isGossipMsg := m.(protoext.ReceivedMessage)
 	if !isGossipMsg {
 		return false
 	}
@@ -852,7 +853,7 @@ func (g *gossipServiceImpl) newDiscoveryAdapter() *discoveryAdapter {
 	return &discoveryAdapter{
 		c:        g.comm,
 		stopping: int32(0),
-		gossipFunc: func(msg *proto.SignedGossipMessage) {
+		gossipFunc: func(msg *protoext.SignedGossipMessage) {
 			if g.conf.PropagateIterations == 0 {
 				return
 			}
@@ -863,7 +864,7 @@ func (g *gossipServiceImpl) newDiscoveryAdapter() *discoveryAdapter {
 				},
 			})
 		},
-		forwardFunc: func(message proto.ReceivedMessage) {
+		forwardFunc: func(message protoext.ReceivedMessage) {
 			if g.conf.PropagateIterations == 0 {
 				return
 			}
@@ -872,7 +873,7 @@ func (g *gossipServiceImpl) newDiscoveryAdapter() *discoveryAdapter {
 				filter:              message.GetConnectionInfo().ID.IsNotSameFilter,
 			})
 		},
-		incChan:          make(chan proto.ReceivedMessage),
+		incChan:          make(chan protoext.ReceivedMessage),
 		presumedDead:     g.presumedDead,
 		disclosurePolicy: g.disclosurePolicy,
 	}
@@ -884,9 +885,9 @@ type discoveryAdapter struct {
 	stopping         int32
 	c                comm.Comm
 	presumedDead     chan common.PKIidType
-	incChan          chan proto.ReceivedMessage
-	gossipFunc       func(message *proto.SignedGossipMessage)
-	forwardFunc      func(message proto.ReceivedMessage)
+	incChan          chan protoext.ReceivedMessage
+	gossipFunc       func(message *protoext.SignedGossipMessage)
+	forwardFunc      func(message protoext.ReceivedMessage)
 	disclosurePolicy discovery.DisclosurePolicy
 }
 
@@ -899,7 +900,7 @@ func (da *discoveryAdapter) toDie() bool {
 	return atomic.LoadInt32(&da.stopping) == int32(1)
 }
 
-func (da *discoveryAdapter) Gossip(msg *proto.SignedGossipMessage) {
+func (da *discoveryAdapter) Gossip(msg *protoext.SignedGossipMessage) {
 	if da.toDie() {
 		return
 	}
@@ -907,7 +908,7 @@ func (da *discoveryAdapter) Gossip(msg *proto.SignedGossipMessage) {
 	da.gossipFunc(msg)
 }
 
-func (da *discoveryAdapter) Forward(msg proto.ReceivedMessage) {
+func (da *discoveryAdapter) Forward(msg protoext.ReceivedMessage) {
 	if da.toDie() {
 		return
 	}
@@ -915,14 +916,14 @@ func (da *discoveryAdapter) Forward(msg proto.ReceivedMessage) {
 	da.forwardFunc(msg)
 }
 
-func (da *discoveryAdapter) SendToPeer(peer *discovery.NetworkMember, msg *proto.SignedGossipMessage) {
+func (da *discoveryAdapter) SendToPeer(peer *discovery.NetworkMember, msg *protoext.SignedGossipMessage) {
 	if da.toDie() {
 		return
 	}
 	// Check membership requests for peers that we know of their PKI-ID.
 	// The only peers we don't know about their PKI-IDs are bootstrap peers.
 	if memReq := msg.GetMemReq(); memReq != nil && len(peer.PKIid) != 0 {
-		selfMsg, err := memReq.SelfInformation.ToGossipMessage()
+		selfMsg, err := protoext.EnvelopeToGossipMessage(memReq.SelfInformation)
 		if err != nil {
 			// Shouldn't happen
 			panic(errors.Wrapf(err, "Tried to send a membership request with a malformed AliveMessage"))
@@ -945,10 +946,7 @@ func (da *discoveryAdapter) SendToPeer(peer *discovery.NetworkMember, msg *proto
 			MemReq: memReq,
 		}
 		// Update the envelope of the outer message, no need to sign (point2point)
-		msg, err = (&proto.SignedGossipMessage{
-			GossipMessage: msgCopy,
-		}).NoopSign()
-
+		msg, err = protoext.NoopSign(msgCopy)
 		if err != nil {
 			return
 		}
@@ -963,7 +961,7 @@ func (da *discoveryAdapter) Ping(peer *discovery.NetworkMember) bool {
 	return err == nil
 }
 
-func (da *discoveryAdapter) Accept() <-chan proto.ReceivedMessage {
+func (da *discoveryAdapter) Accept() <-chan protoext.ReceivedMessage {
 	return da.incChan
 }
 
@@ -998,7 +996,7 @@ func (g *gossipServiceImpl) newDiscoverySecurityAdapter() *discoverySecurityAdap
 }
 
 // validateAliveMsg validates that an Alive message is authentic
-func (sa *discoverySecurityAdapter) ValidateAliveMsg(m *proto.SignedGossipMessage) bool {
+func (sa *discoverySecurityAdapter) ValidateAliveMsg(m *protoext.SignedGossipMessage) bool {
 	am := m.GetAliveMsg()
 	if am == nil || am.Membership == nil || am.Membership.PkiId == nil || !m.IsSigned() {
 		sa.logger.Warning("Invalid alive message:", m)
@@ -1036,10 +1034,10 @@ func (sa *discoverySecurityAdapter) SignMessage(m *proto.GossipMessage, internal
 	signer := func(msg []byte) ([]byte, error) {
 		return sa.mcs.Sign(msg)
 	}
-	if m.IsAliveMsg() && time.Now().Before(sa.includeIdentityPeriod) {
+	if protoext.IsAliveMsg(m) && time.Now().Before(sa.includeIdentityPeriod) {
 		m.GetAliveMsg().Identity = sa.identity
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	e, err := sMsg.Sign(signer)
@@ -1051,7 +1049,7 @@ func (sa *discoverySecurityAdapter) SignMessage(m *proto.GossipMessage, internal
 	if internalEndpoint == "" {
 		return e
 	}
-	e.SignSecret(signer, &proto.Secret{
+	protoext.SignSecret(e, signer, &proto.Secret{
 		Content: &proto.Secret_InternalEndpoint{
 			InternalEndpoint: internalEndpoint,
 		},
@@ -1059,7 +1057,7 @@ func (sa *discoverySecurityAdapter) SignMessage(m *proto.GossipMessage, internal
 	return e
 }
 
-func (sa *discoverySecurityAdapter) validateAliveMsgSignature(m *proto.SignedGossipMessage, identity api.PeerIdentityType) bool {
+func (sa *discoverySecurityAdapter) validateAliveMsgSignature(m *protoext.SignedGossipMessage, identity api.PeerIdentityType) bool {
 	am := m.GetAliveMsg()
 	// At this point we got the certificate of the peer, proceed to verifying the AliveMessage
 	verifier := func(peerIdentity []byte, signature, message []byte) error {
@@ -1090,14 +1088,14 @@ func (g *gossipServiceImpl) createCertStorePuller() pull.Mediator {
 			ResponseWaitTime: g.conf.ResponseWaitTime,
 		},
 	}
-	pkiIDFromMsg := func(msg *proto.SignedGossipMessage) string {
+	pkiIDFromMsg := func(msg *protoext.SignedGossipMessage) string {
 		identityMsg := msg.GetPeerIdentity()
 		if identityMsg == nil || identityMsg.PkiId == nil {
 			return ""
 		}
 		return fmt.Sprintf("%s", string(identityMsg.PkiId))
 	}
-	certConsumer := func(msg *proto.SignedGossipMessage) {
+	certConsumer := func(msg *protoext.SignedGossipMessage) {
 		idMsg := msg.GetPeerIdentity()
 		if idMsg == nil || idMsg.Cert == nil || idMsg.PkiId == nil {
 			g.logger.Warning("Invalid PeerIdentity:", idMsg)
@@ -1119,7 +1117,7 @@ func (g *gossipServiceImpl) createCertStorePuller() pull.Mediator {
 	return pull.NewPullMediator(conf, adapter)
 }
 
-func (g *gossipServiceImpl) sameOrgOrOurOrgPullFilter(msg proto.ReceivedMessage) func(string) bool {
+func (g *gossipServiceImpl) sameOrgOrOurOrgPullFilter(msg protoext.ReceivedMessage) func(string) bool {
 	peersOrg := g.secAdvisor.OrgByPeerIdentity(msg.GetConnectionInfo().Identity)
 	if len(peersOrg) == 0 {
 		g.logger.Warning("Failed determining organization of", msg.GetConnectionInfo())
@@ -1204,7 +1202,7 @@ func (g *gossipServiceImpl) getOrgOfPeer(PKIID common.PKIidType) api.OrgIdentity
 	return g.secAdvisor.OrgByPeerIdentity(cert)
 }
 
-func (g *gossipServiceImpl) validateLeadershipMessage(msg *proto.SignedGossipMessage) error {
+func (g *gossipServiceImpl) validateLeadershipMessage(msg *protoext.SignedGossipMessage) error {
 	pkiID := msg.GetLeadershipMsg().PkiId
 	if len(pkiID) == 0 {
 		return errors.New("Empty PKI-ID")
@@ -1218,7 +1216,7 @@ func (g *gossipServiceImpl) validateLeadershipMessage(msg *proto.SignedGossipMes
 	})
 }
 
-func (g *gossipServiceImpl) validateStateInfoMsg(msg *proto.SignedGossipMessage) error {
+func (g *gossipServiceImpl) validateStateInfoMsg(msg *protoext.SignedGossipMessage) error {
 	verifier := func(identity []byte, signature, message []byte) error {
 		pkiID := g.idMapper.GetPKIidOfCert(api.PeerIdentityType(identity))
 		if pkiID == nil {
@@ -1238,15 +1236,15 @@ func (g *gossipServiceImpl) disclosurePolicy(remotePeer *discovery.NetworkMember
 
 	if len(remotePeerOrg) == 0 {
 		g.logger.Warning("Cannot determine organization of", remotePeer)
-		return func(msg *proto.SignedGossipMessage) bool {
+		return func(msg *protoext.SignedGossipMessage) bool {
 				return false
-			}, func(msg *proto.SignedGossipMessage) *proto.Envelope {
+			}, func(msg *protoext.SignedGossipMessage) *proto.Envelope {
 				return msg.Envelope
 			}
 	}
 
-	return func(msg *proto.SignedGossipMessage) bool {
-			if !msg.IsAliveMsg() {
+	return func(msg *protoext.SignedGossipMessage) bool {
+			if !protoext.IsAliveMsg(msg.GossipMessage) {
 				g.logger.Panic("Programming error, this should be used only on alive messages")
 			}
 			org := g.getOrgOfPeer(msg.GetAliveMsg().Membership.PkiId)
@@ -1268,7 +1266,7 @@ func (g *gossipServiceImpl) disclosurePolicy(remotePeer *discovery.NetworkMember
 			// Pass the alive message only if the alive message is in the same org as the remote peer
 			// or the message has an external endpoint, and the remote peer also has one
 			return bytes.Equal(org, remotePeerOrg) || msg.GetAliveMsg().Membership.Endpoint != "" && remotePeer.Endpoint != ""
-		}, func(msg *proto.SignedGossipMessage) *proto.Envelope {
+		}, func(msg *protoext.SignedGossipMessage) *proto.Envelope {
 			envelope := protoG.Clone(msg.Envelope).(*proto.Envelope)
 			if !bytes.Equal(g.selfOrg, remotePeerOrg) {
 				envelope.SecretEnvelope = nil
diff --git a/gossip/gossip/gossip_test.go b/gossip/gossip/gossip_test.go
index f2a62293..cdc4c3ae 100644
--- a/gossip/gossip/gossip_test.go
+++ b/gossip/gossip/gossip_test.go
@@ -31,6 +31,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/channel"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -90,7 +91,7 @@ func acceptData(m interface{}) bool {
 
 func acceptLeadershp(message interface{}) bool {
 	validMsg := message.(*proto.GossipMessage).Tag == proto.GossipMessage_CHAN_AND_ORG &&
-		message.(*proto.GossipMessage).IsLeadershipMsg()
+		protoext.IsLeadershipMsg(message.(*proto.GossipMessage))
 
 	return validMsg
 }
@@ -676,7 +677,7 @@ func TestNoMessagesSelfLoop(t *testing.T) {
 	// Wait until both peers get connected
 	waitUntilOrFail(t, checkPeersMembership(t, []Gossip{peer}, 1))
 	_, commCh := boot.Accept(func(msg interface{}) bool {
-		return msg.(proto.ReceivedMessage).GetGossipMessage().IsDataMsg()
+		return protoext.IsDataMsg(msg.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}, true)
 
 	wg := sync.WaitGroup{}
@@ -684,13 +685,13 @@ func TestNoMessagesSelfLoop(t *testing.T) {
 
 	// Make sure sending peer is not getting his own
 	// message back
-	go func(ch <-chan proto.ReceivedMessage) {
+	go func(ch <-chan protoext.ReceivedMessage) {
 		defer wg.Done()
 		for {
 			select {
 			case msg := <-ch:
 				{
-					if msg.GetGossipMessage().IsDataMsg() {
+					if protoext.IsDataMsg(msg.GetGossipMessage().GossipMessage) {
 						t.Fatal("Should not receive data message back, got", msg)
 					}
 				}
@@ -986,27 +987,27 @@ func TestMembershipRequestSpoofing(t *testing.T) {
 	waitUntilOrFail(t, checkPeersMembership(t, []Gossip{g2, g3}, 1))
 	// Obtain an alive message from p3
 	_, aliveMsgChan := g2.Accept(func(o interface{}) bool {
-		msg := o.(proto.ReceivedMessage).GetGossipMessage()
+		msg := o.(protoext.ReceivedMessage).GetGossipMessage()
 		// Make sure we get an AliveMessage and it's about g3
-		return msg.IsAliveMsg() && bytes.Equal(msg.GetAliveMsg().Membership.PkiId, []byte(endpoint2))
+		return protoext.IsAliveMsg(msg.GossipMessage) && bytes.Equal(msg.GetAliveMsg().Membership.PkiId, []byte(endpoint2))
 	}, true)
 	aliveMsg := <-aliveMsgChan
 
 	// Obtain channel for messages from g1 to g2
 	_, g1ToG2 := g2.Accept(func(o interface{}) bool {
-		connInfo := o.(proto.ReceivedMessage).GetConnectionInfo()
+		connInfo := o.(protoext.ReceivedMessage).GetConnectionInfo()
 		return bytes.Equal([]byte(endpoint0), connInfo.ID)
 	}, true)
 
 	// Obtain channel for messages from g1 to g3
 	_, g1ToG3 := g3.Accept(func(o interface{}) bool {
-		connInfo := o.(proto.ReceivedMessage).GetConnectionInfo()
+		connInfo := o.(protoext.ReceivedMessage).GetConnectionInfo()
 		return bytes.Equal([]byte(endpoint0), connInfo.ID)
 	}, true)
 
 	// Now, create a membership request message
-	memRequestSpoofFactory := func(aliveMsgEnv *proto.Envelope) *proto.SignedGossipMessage {
-		sMsg, _ := (&proto.GossipMessage{
+	memRequestSpoofFactory := func(aliveMsgEnv *proto.Envelope) *protoext.SignedGossipMessage {
+		sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 			Tag:   proto.GossipMessage_EMPTY,
 			Nonce: uint64(0),
 			Content: &proto.GossipMessage_MemReq{
@@ -1015,7 +1016,7 @@ func TestMembershipRequestSpoofing(t *testing.T) {
 					Known:           [][]byte{},
 				},
 			},
-		}).NoopSign()
+		})
 		return sMsg
 	}
 	spoofedMemReq := memRequestSpoofFactory(aliveMsg.GetSourceEnvelope())
@@ -1278,7 +1279,7 @@ func TestSendByCriteria(t *testing.T) {
 		p.UpdateLedgerHeight(1, common.ChainID("A"))
 	}
 	defer stopPeers(peers)
-	msg, _ := createDataMsg(1, []byte{}, common.ChainID("A")).NoopSign()
+	msg, _ := protoext.NoopSign(createDataMsg(1, []byte{}, common.ChainID("A")))
 
 	// We send without specifying maximum peers,
 	// which sets it to the zero value, and
@@ -1335,12 +1336,12 @@ func TestSendByCriteria(t *testing.T) {
 	// We retry the test above, but this time the peers acknowledge
 	// Peers now ack
 	acceptDataMsgs := func(m interface{}) bool {
-		return m.(proto.ReceivedMessage).GetGossipMessage().IsDataMsg()
+		return protoext.IsDataMsg(m.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}
 	_, ackChan2 := g2.Accept(acceptDataMsgs, true)
 	_, ackChan3 := g3.Accept(acceptDataMsgs, true)
 	_, ackChan4 := g4.Accept(acceptDataMsgs, true)
-	ack := func(c <-chan proto.ReceivedMessage) {
+	ack := func(c <-chan protoext.ReceivedMessage) {
 		msg := <-c
 		msg.Ack(nil)
 	}
@@ -1352,7 +1353,7 @@ func TestSendByCriteria(t *testing.T) {
 	assert.NoError(t, err)
 
 	// We send to 3 peers, but 2 out of 3 peers acknowledge with an error
-	nack := func(c <-chan proto.ReceivedMessage) {
+	nack := func(c <-chan protoext.ReceivedMessage) {
 		msg := <-c
 		msg.Ack(fmt.Errorf("uh oh"))
 	}
@@ -1366,7 +1367,7 @@ func TestSendByCriteria(t *testing.T) {
 	// We try to send to either g2 or g3, but neither would ack us, so we would fail.
 	// However - what we actually check in this test is that we send to peers according to the
 	// filter passed in the criteria
-	failOnAckRequest := func(c <-chan proto.ReceivedMessage, peerId int) {
+	failOnAckRequest := func(c <-chan protoext.ReceivedMessage, peerId int) {
 		msg := <-c
 		if msg == nil {
 			return
@@ -1392,7 +1393,7 @@ func TestSendByCriteria(t *testing.T) {
 	// this property is respected - and only 1 peer receives a message, and not both
 	criteria.MaxPeers = 1
 	// invoke f() in case message has been received
-	waitForMessage := func(c <-chan proto.ReceivedMessage, f func()) {
+	waitForMessage := func(c <-chan protoext.ReceivedMessage, f func()) {
 		select {
 		case msg := <-c:
 			if msg == nil {
diff --git a/gossip/gossip/orgs_test.go b/gossip/gossip/orgs_test.go
index c48a85c5..740a32bb 100644
--- a/gossip/gossip/orgs_test.go
+++ b/gossip/gossip/orgs_test.go
@@ -23,6 +23,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/algo"
 	"github.com/hyperledger/fabric/gossip/gossip/channel"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -397,9 +398,9 @@ func TestConfidentiality(t *testing.T) {
 	var wg sync.WaitGroup
 
 	msgSelector := func(o interface{}) bool {
-		msg := o.(proto.ReceivedMessage).GetGossipMessage()
-		identitiesPull := msg.IsPullMsg() && msg.GetPullMsgType() == proto.PullMsgType_IDENTITY_MSG
-		return msg.IsAliveMsg() || msg.IsStateInfoMsg() || msg.IsStateInfoSnapshot() || msg.GetMemRes() != nil || identitiesPull
+		msg := o.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage
+		identitiesPull := protoext.IsPullMsg(msg) && protoext.GetPullMsgType(msg) == proto.PullMsgType_IDENTITY_MSG
+		return protoext.IsAliveMsg(msg) || protoext.IsStateInfoMsg(msg) || protoext.IsStateInfoSnapshot(msg) || msg.GetMemRes() != nil || identitiesPull
 	}
 	// Listen to all peers membership messages and forward them to the inspection channel
 	// where they will be inspected, and the test would fail if a confidentiality violation is found
@@ -408,7 +409,7 @@ func TestConfidentiality(t *testing.T) {
 		_, msgs := p.Accept(msgSelector, true)
 		peerNetMember := p.(*gossipGRPC).gossipServiceImpl.selfNetworkMember()
 		targetORg := string(cs.OrgByPeerIdentity(api.PeerIdentityType(peerNetMember.InternalEndpoint)))
-		go func(targetOrg string, msgs <-chan proto.ReceivedMessage) {
+		go func(targetOrg string, msgs <-chan protoext.ReceivedMessage) {
 			defer wg.Done()
 			for receivedMsg := range msgs {
 				m := &msg{
@@ -517,16 +518,16 @@ func expectedMembershipSize(peersInOrg, externalEndpointsInOrg int, org string,
 }
 
 func extractOrgsFromMsg(msg *proto.GossipMessage, sec api.SecurityAdvisor) []string {
-	if msg.IsAliveMsg() {
+	if protoext.IsAliveMsg(msg) {
 		return []string{string(sec.OrgByPeerIdentity(api.PeerIdentityType(msg.GetAliveMsg().Membership.PkiId)))}
 	}
 
 	orgs := map[string]struct{}{}
 
-	if msg.IsPullMsg() {
-		if msg.IsDigestMsg() || msg.IsDataReq() {
+	if protoext.IsPullMsg(msg) {
+		if protoext.IsDigestMsg(msg) || protoext.IsDataReq(msg) {
 			var digests []string
-			if msg.IsDigestMsg() {
+			if protoext.IsDigestMsg(msg) {
 				digests = util.BytesToStrings(msg.GetDataDig().Digests)
 			} else {
 				digests = util.BytesToStrings(msg.GetDataReq().Digests)
@@ -538,9 +539,9 @@ func extractOrgsFromMsg(msg *proto.GossipMessage, sec api.SecurityAdvisor) []str
 			}
 		}
 
-		if msg.IsDataUpdate() {
+		if protoext.IsDataUpdate(msg) {
 			for _, identityMsg := range msg.GetDataUpdate().Data {
-				gMsg, _ := identityMsg.ToGossipMessage()
+				gMsg, _ := protoext.EnvelopeToGossipMessage(identityMsg)
 				id := string(gMsg.GetPeerIdentity().Cert)
 				org := sec.OrgByPeerIdentity(api.PeerIdentityType(id))
 				orgs[string(org)] = struct{}{}
@@ -552,7 +553,7 @@ func extractOrgsFromMsg(msg *proto.GossipMessage, sec api.SecurityAdvisor) []str
 		alive := msg.GetMemRes().Alive
 		dead := msg.GetMemRes().Dead
 		for _, envp := range append(alive, dead...) {
-			msg, _ := envp.ToGossipMessage()
+			msg, _ := protoext.EnvelopeToGossipMessage(envp)
 			orgs[string(sec.OrgByPeerIdentity(api.PeerIdentityType(msg.GetAliveMsg().Membership.PkiId)))] = struct{}{}
 		}
 	}
@@ -571,7 +572,7 @@ func inspectMsgs(t *testing.T, msgChan chan *msg, sec api.SecurityAdvisor, peers
 		if msg.src == msg.dst {
 			continue
 		}
-		if msg.IsStateInfoMsg() || msg.IsStateInfoSnapshot() {
+		if protoext.IsStateInfoMsg(msg.GossipMessage) || protoext.IsStateInfoSnapshot(msg.GossipMessage) {
 			inspectStateInfoMsg(t, msg, peersWithExternalEndpoints)
 			continue
 		}
@@ -594,12 +595,12 @@ func inspectMsgs(t *testing.T, msgChan chan *msg, sec api.SecurityAdvisor, peers
 
 		// If this is an identity snapshot, make sure that only identities of peers
 		// with external endpoints pass between the organizations.
-		isIdentityPull := msg.IsPullMsg() && msg.GetPullMsgType() == proto.PullMsgType_IDENTITY_MSG
-		if !(isIdentityPull && msg.IsDataUpdate()) {
+		isIdentityPull := protoext.IsPullMsg(msg.GossipMessage) && protoext.GetPullMsgType(msg.GossipMessage) == proto.PullMsgType_IDENTITY_MSG
+		if !(isIdentityPull && protoext.IsDataUpdate(msg.GossipMessage)) {
 			continue
 		}
 		for _, envp := range msg.GetDataUpdate().Data {
-			identityMsg, _ := envp.ToGossipMessage()
+			identityMsg, _ := protoext.EnvelopeToGossipMessage(envp)
 			pkiID := identityMsg.GetPeerIdentity().PkiId
 			_, hasExternalEndpoint := peersWithExternalEndpoints[string(pkiID)]
 			assert.True(t, hasExternalEndpoint,
@@ -609,7 +610,7 @@ func inspectMsgs(t *testing.T, msgChan chan *msg, sec api.SecurityAdvisor, peers
 }
 
 func inspectStateInfoMsg(t *testing.T, m *msg, peersWithExternalEndpoints map[string]struct{}) {
-	if m.IsStateInfoMsg() {
+	if protoext.IsStateInfoMsg(m.GossipMessage) {
 		pkiID := m.GetStateInfo().PkiId
 		_, hasExternalEndpoint := peersWithExternalEndpoints[string(pkiID)]
 		assert.True(t, hasExternalEndpoint, "peer %s has no external endpoint but crossed an org", string(pkiID))
@@ -617,7 +618,7 @@ func inspectStateInfoMsg(t *testing.T, m *msg, peersWithExternalEndpoints map[st
 	}
 
 	for _, envp := range m.GetStateSnapshot().Elements {
-		msg, _ := envp.ToGossipMessage()
+		msg, _ := protoext.EnvelopeToGossipMessage(envp)
 		pkiID := msg.GetStateInfo().PkiId
 		_, hasExternalEndpoint := peersWithExternalEndpoints[string(pkiID)]
 		assert.True(t, hasExternalEndpoint, "peer %s has no external endpoint but crossed an org", string(pkiID))
diff --git a/gossip/gossip/pull/pullstore.go b/gossip/gossip/pull/pullstore.go
index 64ef02f2..f061d3ba 100644
--- a/gossip/gossip/pull/pullstore.go
+++ b/gossip/gossip/pull/pullstore.go
@@ -7,6 +7,7 @@ SPDX-License-Identifier: Apache-2.0
 package pull
 
 import (
+	"encoding/hex"
 	"sync"
 	"time"
 
@@ -14,7 +15,9 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/gossip/algo"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
+	"github.com/hyperledger/fabric/protos/gossip"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
 	"go.uber.org/zap/zapcore"
@@ -32,12 +35,12 @@ const (
 type MsgType int
 
 // MessageHook defines a function that will run after a certain pull message is received
-type MessageHook func(itemIDs []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage)
+type MessageHook func(itemIDs []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage)
 
 // Sender sends messages to remote peers
 type Sender interface {
 	// Send sends a message to a list of remote peers
-	Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer)
+	Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer)
 }
 
 // MembershipService obtains membership information of alive peers
@@ -62,24 +65,30 @@ type IngressDigestFilter func(digestMsg *proto.DataDigest) *proto.DataDigest
 
 // EgressDigestFilter filters digests to be sent to a remote peer, that
 // sent a hello with the following message
-type EgressDigestFilter func(helloMsg proto.ReceivedMessage) func(digestItem string) bool
+type EgressDigestFilter func(helloMsg protoext.ReceivedMessage) func(digestItem string) bool
 
 // byContext converts this EgressDigFilter to an algo.DigestFilter
 func (df EgressDigestFilter) byContext() algo.DigestFilter {
 	return func(context interface{}) func(digestItem string) bool {
 		return func(digestItem string) bool {
-			return df(context.(proto.ReceivedMessage))(digestItem)
+			return df(context.(protoext.ReceivedMessage))(digestItem)
 		}
 	}
 }
 
+// MsgConsumer invokes code given a SignedGossipMessage
+type MsgConsumer func(message *protoext.SignedGossipMessage)
+
+// IdentifierExtractor extracts from a SignedGossipMessage an identifier
+type IdentifierExtractor func(*protoext.SignedGossipMessage) string
+
 // PullAdapter defines methods of the pullStore to interact
 // with various modules of gossip
 type PullAdapter struct {
 	Sndr             Sender
 	MemSvc           MembershipService
-	IdExtractor      proto.IdentifierExtractor
-	MsgCons          proto.MsgConsumer
+	IdExtractor      IdentifierExtractor
+	MsgCons          MsgConsumer
 	EgressDigFilter  EgressDigestFilter
 	IngressDigFilter IngressDigestFilter
 }
@@ -98,14 +107,14 @@ type Mediator interface {
 	RegisterMsgHook(MsgType, MessageHook)
 
 	// Add adds a GossipMessage to the Mediator
-	Add(*proto.SignedGossipMessage)
+	Add(*protoext.SignedGossipMessage)
 
 	// Remove removes a GossipMessage from the Mediator with a matching digest,
 	// if such a message exits
 	Remove(digest string)
 
 	// HandleMessage handles a message from some remote peer
-	HandleMessage(msg proto.ReceivedMessage)
+	HandleMessage(msg protoext.ReceivedMessage)
 }
 
 // pullMediatorImpl is an implementation of Mediator
@@ -115,7 +124,7 @@ type pullMediatorImpl struct {
 	msgType2Hook map[MsgType][]MessageHook
 	config       Config
 	logger       util.Logger
-	itemID2Msg   map[string]*proto.SignedGossipMessage
+	itemID2Msg   map[string]*protoext.SignedGossipMessage
 	engine       *algo.PullEngine
 }
 
@@ -123,7 +132,7 @@ type pullMediatorImpl struct {
 func NewPullMediator(config Config, adapter *PullAdapter) Mediator {
 	egressDigFilter := adapter.EgressDigFilter
 
-	acceptAllFilter := func(_ proto.ReceivedMessage) func(string) bool {
+	acceptAllFilter := func(_ protoext.ReceivedMessage) func(string) bool {
 		return func(_ string) bool {
 			return true
 		}
@@ -138,7 +147,7 @@ func NewPullMediator(config Config, adapter *PullAdapter) Mediator {
 		msgType2Hook: make(map[MsgType][]MessageHook),
 		config:       config,
 		logger:       util.GetLogger(util.PullLogger, config.ID),
-		itemID2Msg:   make(map[string]*proto.SignedGossipMessage),
+		itemID2Msg:   make(map[string]*protoext.SignedGossipMessage),
 	}
 
 	p.engine = algo.NewPullEngineWithFilter(p, config.PullInterval, egressDigFilter.byContext(), config.PullEngineConfig)
@@ -153,12 +162,12 @@ func NewPullMediator(config Config, adapter *PullAdapter) Mediator {
 
 }
 
-func (p *pullMediatorImpl) HandleMessage(m proto.ReceivedMessage) {
-	if m.GetGossipMessage() == nil || !m.GetGossipMessage().IsPullMsg() {
+func (p *pullMediatorImpl) HandleMessage(m protoext.ReceivedMessage) {
+	if m.GetGossipMessage() == nil || !protoext.IsPullMsg(m.GetGossipMessage().GossipMessage) {
 		return
 	}
 	msg := m.GetGossipMessage()
-	msgType := msg.GetPullMsgType()
+	msgType := protoext.GetPullMsgType(msg.GossipMessage)
 	if msgType != p.config.MsgType {
 		return
 	}
@@ -166,7 +175,7 @@ func (p *pullMediatorImpl) HandleMessage(m proto.ReceivedMessage) {
 	p.logger.Debug(msg)
 
 	itemIDs := []string{}
-	items := []*proto.SignedGossipMessage{}
+	items := []*protoext.SignedGossipMessage{}
 	var pullMsgType MsgType
 
 	if helloMsg := msg.GetHello(); helloMsg != nil {
@@ -186,10 +195,10 @@ func (p *pullMediatorImpl) HandleMessage(m proto.ReceivedMessage) {
 	}
 	if res := msg.GetDataUpdate(); res != nil {
 		itemIDs = make([]string, len(res.Data))
-		items = make([]*proto.SignedGossipMessage, len(res.Data))
+		items = make([]*protoext.SignedGossipMessage, len(res.Data))
 		pullMsgType = ResponseMsgType
 		for i, pulledMsg := range res.Data {
-			msg, err := pulledMsg.ToGossipMessage()
+			msg, err := protoext.EnvelopeToGossipMessage(pulledMsg)
 			if err != nil {
 				p.logger.Warningf("Data update contains an invalid message: %+v", errors.WithStack(err))
 				return
@@ -224,7 +233,7 @@ func (p *pullMediatorImpl) RegisterMsgHook(pullMsgType MsgType, hook MessageHook
 }
 
 // Add adds a GossipMessage to the store
-func (p *pullMediatorImpl) Add(msg *proto.SignedGossipMessage) {
+func (p *pullMediatorImpl) Add(msg *protoext.SignedGossipMessage) {
 	p.Lock()
 	defer p.Unlock()
 	itemID := p.IdExtractor(msg)
@@ -270,7 +279,7 @@ func (p *pullMediatorImpl) Hello(dest string, nonce uint64) {
 	}
 
 	p.logger.Debug("Sending", p.config.MsgType, "hello to", dest)
-	sMsg, err := helloMsg.NoopSign()
+	sMsg, err := protoext.NoopSign(helloMsg)
 	if err != nil {
 		p.logger.Errorf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -293,12 +302,12 @@ func (p *pullMediatorImpl) SendDigest(digest []string, nonce uint64, context int
 			},
 		},
 	}
-	remotePeer := context.(proto.ReceivedMessage).GetConnectionInfo()
+	remotePeer := context.(protoext.ReceivedMessage).GetConnectionInfo()
 	if p.logger.IsEnabledFor(zapcore.DebugLevel) {
-		p.logger.Debug("Sending", p.config.MsgType, "digest:", digMsg.GetDataDig().FormattedDigests(), "to", remotePeer)
+		p.logger.Debug("Sending", p.config.MsgType, "digest:", formattedDigests(digMsg.GetDataDig()), "to", remotePeer)
 	}
 
-	context.(proto.ReceivedMessage).Respond(digMsg)
+	context.(protoext.ReceivedMessage).Respond(digMsg)
 }
 
 // SendReq sends an array of items to a certain remote PullEngine identified
@@ -317,9 +326,9 @@ func (p *pullMediatorImpl) SendReq(dest string, items []string, nonce uint64) {
 		},
 	}
 	if p.logger.IsEnabledFor(zapcore.DebugLevel) {
-		p.logger.Debug("Sending", req.GetDataReq().FormattedDigests(), "to", dest)
+		p.logger.Debug("Sending", formattedDigests(req.GetDataReq()), "to", dest)
 	}
-	sMsg, err := req.NoopSign()
+	sMsg, err := protoext.NoopSign(req)
 	if err != nil {
 		p.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -349,9 +358,9 @@ func (p *pullMediatorImpl) SendRes(items []string, context interface{}, nonce ui
 			},
 		},
 	}
-	remotePeer := context.(proto.ReceivedMessage).GetConnectionInfo()
+	remotePeer := context.(protoext.ReceivedMessage).GetConnectionInfo()
 	p.logger.Debug("Sending", len(returnedUpdate.GetDataUpdate().Data), p.config.MsgType, "items to", remotePeer)
-	context.(proto.ReceivedMessage).Respond(returnedUpdate)
+	context.(protoext.ReceivedMessage).Respond(returnedUpdate)
 }
 
 func (p *pullMediatorImpl) peersWithEndpoints(endpoints ...string) []*comm.RemotePeer {
@@ -389,3 +398,35 @@ func SelectEndpoints(k int, peerPool []discovery.NetworkMember) []*comm.RemotePe
 	}
 	return endpoints
 }
+
+// typeDigster normalizes the common digest operations needed to format them
+// for log messages.
+type typedDigester interface {
+	GetMsgType() gossip.PullMsgType
+	GetDigests() [][]byte
+}
+
+func formattedDigests(dd typedDigester) []string {
+	switch dd.GetMsgType() {
+	case gossip.PullMsgType_IDENTITY_MSG:
+		return digestsToHex(dd.GetDigests())
+	default:
+		return digestsAsStrings(dd.GetDigests())
+	}
+}
+
+func digestsAsStrings(digests [][]byte) []string {
+	a := make([]string, len(digests))
+	for i, dig := range digests {
+		a[i] = string(dig)
+	}
+	return a
+}
+
+func digestsToHex(digests [][]byte) []string {
+	a := make([]string, len(digests))
+	for i, dig := range digests {
+		a[i] = hex.EncodeToString(dig)
+	}
+	return a
+}
diff --git a/gossip/gossip/pull/pullstore_test.go b/gossip/gossip/pull/pullstore_test.go
index 6c158ee3..15bd422e 100644
--- a/gossip/gossip/pull/pullstore_test.go
+++ b/gossip/gossip/pull/pullstore_test.go
@@ -18,6 +18,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/comm"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/gossip/algo"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -33,7 +34,7 @@ func init() {
 
 type pullMsg struct {
 	respondChan chan *pullMsg
-	msg         *proto.SignedGossipMessage
+	msg         *protoext.SignedGossipMessage
 }
 
 // GetSourceMessage Returns the SignedGossipMessage the ReceivedMessage was
@@ -43,18 +44,18 @@ func (pm *pullMsg) GetSourceEnvelope() *proto.Envelope {
 }
 
 func (pm *pullMsg) Respond(msg *proto.GossipMessage) {
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	pm.respondChan <- &pullMsg{
 		msg:         sMsg,
 		respondChan: pm.respondChan,
 	}
 }
 
-func (pm *pullMsg) GetGossipMessage() *proto.SignedGossipMessage {
+func (pm *pullMsg) GetGossipMessage() *protoext.SignedGossipMessage {
 	return pm.msg
 }
 
-func (pm *pullMsg) GetConnectionInfo() *proto.ConnectionInfo {
+func (pm *pullMsg) GetConnectionInfo() *protoext.ConnectionInfo {
 	return nil
 }
 
@@ -74,7 +75,7 @@ type pullInstance struct {
 	config        Config
 }
 
-func (p *pullInstance) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (p *pullInstance) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	for _, peer := range peers {
 		m := &pullMsg{
 			respondChan: p.msgChan,
@@ -115,7 +116,7 @@ func (p *pullInstance) stop() {
 	p.stopChan <- struct{}{}
 }
 
-func (p *pullInstance) wrapPullMsg(msg *proto.SignedGossipMessage) proto.ReceivedMessage {
+func (p *pullInstance) wrapPullMsg(msg *protoext.SignedGossipMessage) protoext.ReceivedMessage {
 	return &pullMsg{
 		msg:         msg,
 		respondChan: p.msgChan,
@@ -150,7 +151,7 @@ func createPullInstanceWithFilters(endpoint string, peer2PullInst map[string]*pu
 			ResponseWaitTime: time.Duration(300) * time.Millisecond,
 		},
 	}
-	seqNumFromMsg := func(msg *proto.SignedGossipMessage) string {
+	seqNumFromMsg := func(msg *protoext.SignedGossipMessage) string {
 		dataMsg := msg.GetDataMsg()
 		if dataMsg == nil {
 			return ""
@@ -160,7 +161,7 @@ func createPullInstanceWithFilters(endpoint string, peer2PullInst map[string]*pu
 		}
 		return fmt.Sprintf("%d", dataMsg.Payload.SeqNum)
 	}
-	blockConsumer := func(msg *proto.SignedGossipMessage) {
+	blockConsumer := func(msg *protoext.SignedGossipMessage) {
 		inst.items.Add(msg.GetDataMsg().Payload.SeqNum)
 	}
 	inst.pullAdapter = &PullAdapter{
@@ -197,7 +198,7 @@ func TestRegisterMsgHook(t *testing.T) {
 
 	for _, msgType := range []MsgType{HelloMsgType, DigestMsgType, RequestMsgType, ResponseMsgType} {
 		mType := msgType
-		inst1.mediator.RegisterMsgHook(mType, func(_ []string, items []*proto.SignedGossipMessage, _ proto.ReceivedMessage) {
+		inst1.mediator.RegisterMsgHook(mType, func(_ []string, items []*protoext.SignedGossipMessage, _ protoext.ReceivedMessage) {
 			receivedMsgTypes.Add(mType)
 		})
 	}
@@ -217,8 +218,8 @@ func TestFilter(t *testing.T) {
 	eq := func(a interface{}, b interface{}) bool {
 		return a == b
 	}
-	df := func(msg proto.ReceivedMessage) func(string) bool {
-		if msg.GetGossipMessage().IsDataReq() {
+	df := func(msg protoext.ReceivedMessage) func(string) bool {
+		if protoext.IsDataReq(msg.GetGossipMessage().GossipMessage) {
 			req := msg.GetGossipMessage().GetDataReq()
 			return func(item string) bool {
 				return util.IndexInSlice(util.BytesToStrings(req.Digests), item, eq) != -1
@@ -288,22 +289,22 @@ func TestAddAndRemove(t *testing.T) {
 	wg.Add(4)
 
 	// Make sure there is a Hello message
-	inst1.mediator.RegisterMsgHook(HelloMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(HelloMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		wg.Done()
 	})
 
 	// Instance 1 answering with digest
-	inst2.mediator.RegisterMsgHook(DigestMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst2.mediator.RegisterMsgHook(DigestMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		wg.Done()
 	})
 
 	// Instance 2 requesting missing items
-	inst1.mediator.RegisterMsgHook(RequestMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(RequestMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		wg.Done()
 	})
 
 	// Instance 1 sends missing item
-	inst2.mediator.RegisterMsgHook(ResponseMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst2.mediator.RegisterMsgHook(ResponseMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		wg.Done()
 	})
 
@@ -329,7 +330,7 @@ func TestDigestsFilters(t *testing.T) {
 	defer inst1.stop()
 	defer inst2.stop()
 
-	inst1.mediator.RegisterMsgHook(DigestMsgType, func(itemIds []string, _ []*proto.SignedGossipMessage, _ proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(DigestMsgType, func(itemIds []string, _ []*protoext.SignedGossipMessage, _ protoext.ReceivedMessage) {
 		if atomic.LoadInt32(&inst1ReceivedDigest) == int32(1) {
 			return
 		}
@@ -348,7 +349,7 @@ func TestDigestsFilters(t *testing.T) {
 	inst2.mediator.Add(dataMsg(3))
 
 	// inst1 sends hello to inst2
-	sMsg, _ := helloMsg().NoopSign()
+	sMsg, _ := protoext.NoopSign(helloMsg())
 	inst2.mediator.HandleMessage(inst1.wrapPullMsg(sMsg))
 
 	// inst2 is expected to send digest to inst1
@@ -373,7 +374,7 @@ func TestHandleMessage(t *testing.T) {
 	inst1ReceivedDigest := int32(0)
 	inst1ReceivedResponse := int32(0)
 
-	inst1.mediator.RegisterMsgHook(DigestMsgType, func(itemIds []string, _ []*proto.SignedGossipMessage, _ proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(DigestMsgType, func(itemIds []string, _ []*protoext.SignedGossipMessage, _ protoext.ReceivedMessage) {
 		if atomic.LoadInt32(&inst1ReceivedDigest) == int32(1) {
 			return
 		}
@@ -381,7 +382,7 @@ func TestHandleMessage(t *testing.T) {
 		assert.True(t, len(itemIds) == 3)
 	})
 
-	inst1.mediator.RegisterMsgHook(ResponseMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(ResponseMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		if atomic.LoadInt32(&inst1ReceivedResponse) == int32(1) {
 			return
 		}
@@ -390,14 +391,14 @@ func TestHandleMessage(t *testing.T) {
 	})
 
 	// inst1 sends hello to inst2
-	sMsg, _ := helloMsg().NoopSign()
+	sMsg, _ := protoext.NoopSign(helloMsg())
 	inst2.mediator.HandleMessage(inst1.wrapPullMsg(sMsg))
 
 	// inst2 is expected to send digest to inst1
 	waitUntilOrFail(t, func() bool { return atomic.LoadInt32(&inst1ReceivedDigest) == int32(1) })
 
 	// inst1 sends request to inst2
-	sMsg, _ = reqMsg("0", "1", "2").NoopSign()
+	sMsg, _ = protoext.NoopSign(reqMsg("0", "1", "2"))
 	inst2.mediator.HandleMessage(inst1.wrapPullMsg(sMsg))
 
 	// inst2 is expected to send response to inst1
@@ -420,8 +421,8 @@ func waitUntilOrFail(t *testing.T, pred func() bool) {
 	assert.Fail(t, "Timeout expired!")
 }
 
-func dataMsg(seqNum int) *proto.SignedGossipMessage {
-	sMsg, _ := (&proto.GossipMessage{
+func dataMsg(seqNum int) *protoext.SignedGossipMessage {
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Nonce: 0,
 		Tag:   proto.GossipMessage_EMPTY,
 		Content: &proto.GossipMessage_DataMsg{
@@ -432,7 +433,7 @@ func dataMsg(seqNum int) *proto.SignedGossipMessage {
 				},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
diff --git a/gossip/privdata/dissemination.go b/gossip/privdata/dissemination.go
index 1672bca9..f6466551 100644
--- a/gossip/privdata/dissemination.go
+++ b/gossip/privdata/dissemination.go
@@ -9,12 +9,12 @@ package privdata
 import (
 	"github.com/hyperledger/fabric/core/common/privdata"
 	extdissemination "github.com/hyperledger/fabric/extensions/collections/dissemination"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/common"
-	protog "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/ledger/rwset"
 )
 
-func (d *distributorImpl) disseminationPlanForExt(ns string, rwSet *rwset.CollectionPvtReadWriteSet, colCP *common.CollectionConfig, colAP privdata.CollectionAccessPolicy, pvtDataMsg *protog.SignedGossipMessage) ([]*dissemination, error) {
+func (d *distributorImpl) disseminationPlanForExt(ns string, rwSet *rwset.CollectionPvtReadWriteSet, colCP *common.CollectionConfig, colAP privdata.CollectionAccessPolicy, pvtDataMsg *protoext.SignedGossipMessage) ([]*dissemination, error) {
 	dissPlan, handled, err := extdissemination.ComputeDisseminationPlan(d.chainID, ns, rwSet, colCP, colAP, pvtDataMsg, d.gossipAdapter)
 	if err != nil {
 		return nil, err
diff --git a/gossip/privdata/distributor.go b/gossip/privdata/distributor.go
index cb4d7a53..1b5015b7 100644
--- a/gossip/privdata/distributor.go
+++ b/gossip/privdata/distributor.go
@@ -22,6 +22,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/filter"
 	gossip2 "github.com/hyperledger/fabric/gossip/gossip"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	"github.com/hyperledger/fabric/msp"
 	"github.com/hyperledger/fabric/protos/common"
@@ -34,7 +35,7 @@ import (
 // gossipAdapter an adapter for API's required from gossip module
 type gossipAdapter interface {
 	// SendByCriteria sends a given message to all peers that match the given SendCriteria
-	SendByCriteria(message *proto.SignedGossipMessage, criteria gossip2.SendCriteria) error
+	SendByCriteria(message *protoext.SignedGossipMessage, criteria gossip2.SendCriteria) error
 
 	// PeerFilter receives a SubChannelSelectionCriteria and returns a RoutingFilter that selects
 	// only peer identities that match the given criteria, and that they published their channel participation
@@ -129,7 +130,7 @@ func (d *distributorImpl) Distribute(txID string, privData *transientstore.TxPvt
 }
 
 type dissemination struct {
-	msg      *proto.SignedGossipMessage
+	msg      *protoext.SignedGossipMessage
 	criteria gossip2.SendCriteria
 }
 
@@ -204,7 +205,7 @@ func (d *distributorImpl) getCollectionConfig(config *common.CollectionConfigPac
 	return nil, errors.New(fmt.Sprint("no configuration for collection", collection.CollectionName, "found"))
 }
 
-func (d *distributorImpl) disseminationPlanForMsg(colAP privdata.CollectionAccessPolicy, colFilter privdata.Filter, pvtDataMsg *proto.SignedGossipMessage) ([]*dissemination, error) {
+func (d *distributorImpl) disseminationPlanForMsg(colAP privdata.CollectionAccessPolicy, colFilter privdata.Filter, pvtDataMsg *protoext.SignedGossipMessage) ([]*dissemination, error) {
 	var disseminationPlan []*dissemination
 
 	routingFilter, err := d.gossipAdapter.PeerFilter(gossipCommon.ChainID(d.chainID), func(signature api.PeerSignature) bool {
@@ -245,7 +246,7 @@ func (d *distributorImpl) disseminationPlanForMsg(colAP privdata.CollectionAcces
 			}
 			disseminationPlan = append(disseminationPlan, &dissemination{
 				criteria: sc,
-				msg: &proto.SignedGossipMessage{
+				msg: &protoext.SignedGossipMessage{
 					Envelope:      proto2.Clone(pvtDataMsg.Envelope).(*proto.Envelope),
 					GossipMessage: proto2.Clone(pvtDataMsg.GossipMessage).(*proto.GossipMessage),
 				},
@@ -345,7 +346,7 @@ func (d *distributorImpl) reportSendDuration(startTime time.Time) {
 func (d *distributorImpl) createPrivateDataMessage(txID, namespace string,
 	collection *rwset.CollectionPvtReadWriteSet,
 	ccp *common.CollectionConfigPackage,
-	blkHt uint64) (*proto.SignedGossipMessage, error) {
+	blkHt uint64) (*protoext.SignedGossipMessage, error) {
 	msg := &proto.GossipMessage{
 		Channel: []byte(d.chainID),
 		Nonce:   util.RandomUInt64(),
@@ -364,7 +365,7 @@ func (d *distributorImpl) createPrivateDataMessage(txID, namespace string,
 		},
 	}
 
-	pvtDataMsg, err := msg.NoopSign()
+	pvtDataMsg, err := protoext.NoopSign(msg)
 	if err != nil {
 		return nil, err
 	}
diff --git a/gossip/privdata/distributor_test.go b/gossip/privdata/distributor_test.go
index 1753b822..8bf1221d 100644
--- a/gossip/privdata/distributor_test.go
+++ b/gossip/privdata/distributor_test.go
@@ -19,6 +19,7 @@ import (
 	gossip2 "github.com/hyperledger/fabric/gossip/gossip"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/transientstore"
@@ -87,7 +88,7 @@ func (g *gossipMock) PeersOfChannel(chainID gcommon.ChainID) []discovery.Network
 	return g.Called(chainID).Get(0).([]discovery.NetworkMember)
 }
 
-func (g *gossipMock) SendByCriteria(message *proto.SignedGossipMessage, criteria gossip2.SendCriteria) error {
+func (g *gossipMock) SendByCriteria(message *protoext.SignedGossipMessage, criteria gossip2.SendCriteria) error {
 	args := g.Called(message, criteria)
 	if args.Get(0) != nil {
 		return args.Get(0).(error)
@@ -141,7 +142,7 @@ func TestDistributor(t *testing.T) {
 	})
 
 	g.On("SendByCriteria", mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
-		msg := args.Get(0).(*proto.SignedGossipMessage)
+		msg := args.Get(0).(*protoext.SignedGossipMessage)
 		sendCriteria := args.Get(1).(gossip2.SendCriteria)
 		sendings <- struct {
 			*proto.PrivatePayload
diff --git a/gossip/privdata/pull.go b/gossip/privdata/pull.go
index 2965d876..8b19e504 100644
--- a/gossip/privdata/pull.go
+++ b/gossip/privdata/pull.go
@@ -8,12 +8,14 @@ package privdata
 
 import (
 	"bytes"
+	"encoding/hex"
 	"fmt"
 	"math"
 	"math/rand"
 	"sync"
 	"time"
 
+	commonutil "github.com/hyperledger/fabric/common/util"
 	"github.com/hyperledger/fabric/core/common/privdata"
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/comm"
@@ -22,9 +24,11 @@ import (
 	"github.com/hyperledger/fabric/gossip/filter"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	privdatacommon "github.com/hyperledger/fabric/gossip/privdata/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	fcommon "github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
+	protoutil "github.com/hyperledger/fabric/protos/utils"
 	"github.com/pkg/errors"
 	"go.uber.org/zap/zapcore"
 )
@@ -62,14 +66,14 @@ type gossip interface {
 	// If passThrough is false, the messages are processed by the gossip layer beforehand.
 	// If passThrough is true, the gossip layer doesn't intervene and the messages
 	// can be used to send a reply back to the sender
-	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 }
 
 type puller struct {
 	metrics       *metrics.PrivdataMetrics
 	pubSub        *util.PubSub
 	stopChan      chan struct{}
-	msgChan       <-chan proto.ReceivedMessage
+	msgChan       <-chan protoext.ReceivedMessage
 	channel       string
 	cs            privdata.CollectionStore
 	btlPullMargin uint64
@@ -93,11 +97,11 @@ func NewPuller(metrics *metrics.PrivdataMetrics, cs privdata.CollectionStore, g
 		CollectionAccessFactory: factory,
 	}
 	_, p.msgChan = p.Accept(func(o interface{}) bool {
-		msg := o.(proto.ReceivedMessage).GetGossipMessage()
+		msg := o.(protoext.ReceivedMessage).GetGossipMessage()
 		if !bytes.Equal(msg.Channel, []byte(p.channel)) {
 			return false
 		}
-		return msg.IsPrivateDataMsg()
+		return protoext.IsPrivateDataMsg(msg.GossipMessage)
 	}, true)
 	go p.listen()
 	return p
@@ -124,7 +128,7 @@ func (p *puller) listen() {
 	}
 }
 
-func (p *puller) handleRequest(message proto.ReceivedMessage) {
+func (p *puller) handleRequest(message protoext.ReceivedMessage) {
 	logger.Debug("Got", message.GetGossipMessage(), "from", message.GetConnectionInfo().Endpoint)
 	message.Respond(&proto.GossipMessage{
 		Channel: []byte(p.channel),
@@ -138,7 +142,7 @@ func (p *puller) handleRequest(message proto.ReceivedMessage) {
 	})
 }
 
-func (p *puller) createResponse(message proto.ReceivedMessage) []*proto.PvtDataElement {
+func (p *puller) createResponse(message protoext.ReceivedMessage) []*proto.PvtDataElement {
 	authInfo := message.GetConnectionInfo().Auth
 	var returned []*proto.PvtDataElement
 	connectionEndpoint := message.GetConnectionInfo().Endpoint
@@ -177,7 +181,7 @@ func groupDigestsByBlockNum(digests []*proto.PvtDataDigest) map[uint64][]*proto.
 	return results
 }
 
-func (p *puller) handleResponse(message proto.ReceivedMessage) {
+func (p *puller) handleResponse(message protoext.ReceivedMessage) {
 	msg := message.GetGossipMessage().GetPrivateRes()
 	logger.Debug("Got", msg, "from", message.GetConnectionInfo().Endpoint)
 	for _, el := range msg.Elements {
@@ -185,7 +189,7 @@ func (p *puller) handleResponse(message proto.ReceivedMessage) {
 			logger.Warning("Got nil digest from", message.GetConnectionInfo().Endpoint, "aborting")
 			return
 		}
-		hash, err := el.Digest.Hash()
+		hash, err := hashDigest(el.Digest)
 		if err != nil {
 			logger.Warning("Failed hashing digest from", message.GetConnectionInfo().Endpoint, "aborting")
 			return
@@ -194,6 +198,15 @@ func (p *puller) handleResponse(message proto.ReceivedMessage) {
 	}
 }
 
+// hashDigest returns the SHA256 representation of the PvtDataDigest's bytes
+func hashDigest(dig *proto.PvtDataDigest) (string, error) {
+	b, err := protoutil.Marshal(dig)
+	if err != nil {
+		return "", err
+	}
+	return hex.EncodeToString(commonutil.ComputeSHA256(b)), nil
+}
+
 func (p *puller) waitForMembership() []discovery.NetworkMember {
 	polIteration := 0
 	for {
@@ -342,7 +355,7 @@ func (p *puller) scatterRequests(peersDigestMapping peer2Digests) []util.Subscri
 
 		// Subscribe to all digests prior to sending them
 		for _, dig := range msg.GetPrivateReq().Digests {
-			hash, err := dig.Hash()
+			hash, err := hashDigest(dig)
 			if err != nil {
 				// Shouldn't happen as we just built this message ourselves
 				logger.Warning("Failed creating digest", err)
diff --git a/gossip/privdata/pull_test.go b/gossip/privdata/pull_test.go
index 4091ae4d..11a57c29 100644
--- a/gossip/privdata/pull_test.go
+++ b/gossip/privdata/pull_test.go
@@ -25,6 +25,7 @@ import (
 	gmetricsmocks "github.com/hyperledger/fabric/gossip/metrics/mocks"
 	privdatacommon "github.com/hyperledger/fabric/gossip/privdata/common"
 	"github.com/hyperledger/fabric/gossip/privdata/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	fcommon "github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
@@ -165,9 +166,9 @@ func (dr *dataRetrieverMock) CollectionRWSet(dig []*proto.PvtDataDigest, blockNu
 }
 
 type receivedMsg struct {
-	responseChan chan proto.ReceivedMessage
+	responseChan chan protoext.ReceivedMessage
 	*comm.RemotePeer
-	*proto.SignedGossipMessage
+	*protoext.SignedGossipMessage
 }
 
 func (msg *receivedMsg) Ack(_ error) {
@@ -175,11 +176,11 @@ func (msg *receivedMsg) Ack(_ error) {
 }
 
 func (msg *receivedMsg) Respond(message *proto.GossipMessage) {
-	m, _ := message.NoopSign()
+	m, _ := protoext.NoopSign(message)
 	msg.responseChan <- &receivedMsg{SignedGossipMessage: m, RemotePeer: &comm.RemotePeer{}}
 }
 
-func (msg *receivedMsg) GetGossipMessage() *proto.SignedGossipMessage {
+func (msg *receivedMsg) GetGossipMessage() *protoext.SignedGossipMessage {
 	return msg.SignedGossipMessage
 }
 
@@ -187,10 +188,10 @@ func (msg *receivedMsg) GetSourceEnvelope() *proto.Envelope {
 	panic("implement me")
 }
 
-func (msg *receivedMsg) GetConnectionInfo() *proto.ConnectionInfo {
-	return &proto.ConnectionInfo{
+func (msg *receivedMsg) GetConnectionInfo() *protoext.ConnectionInfo {
+	return &protoext.ConnectionInfo{
 		Identity: api.PeerIdentityType(msg.RemotePeer.PKIID),
-		Auth: &proto.AuthInfo{
+		Auth: &protoext.AuthInfo{
 			SignedData: []byte{},
 			Signature:  []byte{},
 		},
@@ -199,14 +200,14 @@ func (msg *receivedMsg) GetConnectionInfo() *proto.ConnectionInfo {
 
 type mockGossip struct {
 	mock.Mock
-	msgChan chan proto.ReceivedMessage
+	msgChan chan protoext.ReceivedMessage
 	id      *comm.RemotePeer
 	network *gossipNetwork
 }
 
 func newMockGossip(id *comm.RemotePeer) *mockGossip {
 	return &mockGossip{
-		msgChan: make(chan proto.ReceivedMessage),
+		msgChan: make(chan protoext.ReceivedMessage),
 		id:      id,
 	}
 }
@@ -229,7 +230,7 @@ func (g *mockGossip) PeerFilter(channel common.ChainID, messagePredicate api.Sub
 }
 
 func (g *mockGossip) Send(msg *proto.GossipMessage, peers ...*comm.RemotePeer) {
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	for _, peer := range g.network.peers {
 		if bytes.Equal(peer.id.PKIID, peers[0].PKIID) {
 			peer.msgChan <- &receivedMsg{
@@ -246,7 +247,7 @@ func (g *mockGossip) PeersOfChannel(common.ChainID) []discovery.NetworkMember {
 	return g.Called().Get(0).([]discovery.NetworkMember)
 }
 
-func (g *mockGossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (g *mockGossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	return nil, g.msgChan
 }
 
diff --git a/protos/gossip/compatibility_test.go b/gossip/protoext/compatibility_test.go
similarity index 69%
rename from protos/gossip/compatibility_test.go
rename to gossip/protoext/compatibility_test.go
index 8afe99ef..e1d8c9ad 100644
--- a/protos/gossip/compatibility_test.go
+++ b/gossip/protoext/compatibility_test.go
@@ -4,20 +4,22 @@ Copyright IBM Corp. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
 */
 
-package gossip
+package protoext_test
 
 import (
 	"encoding/hex"
 	"testing"
 
 	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/gossip/protoext"
+	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
 
-var digestMsg = &GossipMessage{
+var digestMsg = &gossip.GossipMessage{
 	Channel: []byte("mychannel"),
-	Content: &GossipMessage_DataDig{
-		DataDig: &DataDigest{
+	Content: &gossip.GossipMessage_DataDig{
+		DataDig: &gossip.DataDigest{
 			Digests: [][]byte{
 				{255},
 				{255, 255},
@@ -29,10 +31,10 @@ var digestMsg = &GossipMessage{
 	},
 }
 
-var requestMsg = &GossipMessage{
+var requestMsg = &gossip.GossipMessage{
 	Channel: []byte("mychannel"),
-	Content: &GossipMessage_DataReq{
-		DataReq: &DataRequest{
+	Content: &gossip.GossipMessage_DataReq{
+		DataReq: &gossip.DataRequest{
 			Digests: [][]byte{
 				{255},
 				{255, 255},
@@ -52,18 +54,15 @@ const (
 func TestUnmarshalV12Digests(t *testing.T) {
 	// This test ensures that digests of data digest messages and data requests
 	// that originated from fabric v1.3 can be successfully parsed by v1.2
-	for msgBytes, expectedMsg := range map[string]*GossipMessage{
+	for msgBytes, expectedMsg := range map[string]*gossip.GossipMessage{
 		v12DataDigestBytes:  digestMsg,
 		v12DataRequestBytes: requestMsg,
 	} {
 		var err error
-		v13Envelope := &Envelope{}
+		v13Envelope := &gossip.Envelope{}
 		v13Envelope.Payload, err = hex.DecodeString(msgBytes)
 		assert.NoError(t, err)
-		sMsg := &SignedGossipMessage{
-			Envelope: v13Envelope,
-		}
-		v13Digest, err := sMsg.ToGossipMessage()
+		v13Digest, err := protoext.EnvelopeToGossipMessage(v13Envelope)
 		assert.NoError(t, err)
 		assert.True(t, proto.Equal(expectedMsg, v13Digest.GossipMessage))
 	}
diff --git a/gossip/protoext/message.go b/gossip/protoext/message.go
new file mode 100644
index 00000000..5509a898
--- /dev/null
+++ b/gossip/protoext/message.go
@@ -0,0 +1,193 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext
+
+import (
+	"fmt"
+
+	"github.com/hyperledger/fabric/protos/gossip"
+)
+
+// IsAliveMsg returns whether this GossipMessage is an AliveMessage
+func IsAliveMsg(m *gossip.GossipMessage) bool {
+	return m.GetAliveMsg() != nil
+}
+
+// IsDataMsg returns whether this GossipMessage is a data message
+func IsDataMsg(m *gossip.GossipMessage) bool {
+	return m.GetDataMsg() != nil
+}
+
+// IsStateInfoPullRequestMsg returns whether this GossipMessage is a stateInfoPullRequest
+func IsStateInfoPullRequestMsg(m *gossip.GossipMessage) bool {
+	return m.GetStateInfoPullReq() != nil
+}
+
+// IsStateInfoSnapshot returns whether this GossipMessage is a stateInfo snapshot
+func IsStateInfoSnapshot(m *gossip.GossipMessage) bool {
+	return m.GetStateSnapshot() != nil
+}
+
+// IsStateInfoMsg returns whether this GossipMessage is a stateInfo message
+func IsStateInfoMsg(m *gossip.GossipMessage) bool {
+	return m.GetStateInfo() != nil
+}
+
+// IsPullMsg returns whether this GossipMessage is a message that belongs
+// to the pull mechanism
+func IsPullMsg(m *gossip.GossipMessage) bool {
+	return m.GetDataReq() != nil || m.GetDataUpdate() != nil ||
+		m.GetHello() != nil || m.GetDataDig() != nil
+}
+
+// IsRemoteStateMessage returns whether this GossipMessage is related to state synchronization
+func IsRemoteStateMessage(m *gossip.GossipMessage) bool {
+	return m.GetStateRequest() != nil || m.GetStateResponse() != nil
+}
+
+// GetPullMsgType returns the phase of the pull mechanism this GossipMessage belongs to
+// for example: Hello, Digest, etc.
+// If this isn't a pull message, PullMsgType_UNDEFINED is returned.
+func GetPullMsgType(m *gossip.GossipMessage) gossip.PullMsgType {
+	if helloMsg := m.GetHello(); helloMsg != nil {
+		return helloMsg.MsgType
+	}
+
+	if digMsg := m.GetDataDig(); digMsg != nil {
+		return digMsg.MsgType
+	}
+
+	if reqMsg := m.GetDataReq(); reqMsg != nil {
+		return reqMsg.MsgType
+	}
+
+	if resMsg := m.GetDataUpdate(); resMsg != nil {
+		return resMsg.MsgType
+	}
+
+	return gossip.PullMsgType_UNDEFINED
+}
+
+// IsChannelRestricted returns whether this GossipMessage should be routed
+// only in its channel
+func IsChannelRestricted(m *gossip.GossipMessage) bool {
+	return m.Tag == gossip.GossipMessage_CHAN_AND_ORG || m.Tag == gossip.GossipMessage_CHAN_ONLY || m.Tag == gossip.GossipMessage_CHAN_OR_ORG
+}
+
+// IsOrgRestricted returns whether this GossipMessage should be routed only
+// inside the organization
+func IsOrgRestricted(m *gossip.GossipMessage) bool {
+	return m.Tag == gossip.GossipMessage_CHAN_AND_ORG || m.Tag == gossip.GossipMessage_ORG_ONLY
+}
+
+// IsIdentityMsg returns whether this GossipMessage is an identity message
+func IsIdentityMsg(m *gossip.GossipMessage) bool {
+	return m.GetPeerIdentity() != nil
+}
+
+// IsDataReq returns whether this GossipMessage is a data request message
+func IsDataReq(m *gossip.GossipMessage) bool {
+	return m.GetDataReq() != nil
+}
+
+// IsPrivateDataMsg returns whether this message is related to private data
+func IsPrivateDataMsg(m *gossip.GossipMessage) bool {
+	return m.GetPrivateReq() != nil || m.GetPrivateRes() != nil || m.GetPrivateData() != nil
+}
+
+// IsAck returns whether this GossipMessage is an acknowledgement
+func IsAck(m *gossip.GossipMessage) bool {
+	return m.GetAck() != nil
+}
+
+// IsDataUpdate returns whether this GossipMessage is a data update message
+func IsDataUpdate(m *gossip.GossipMessage) bool {
+	return m.GetDataUpdate() != nil
+}
+
+// IsHelloMsg returns whether this GossipMessage is a hello message
+func IsHelloMsg(m *gossip.GossipMessage) bool {
+	return m.GetHello() != nil
+}
+
+// IsDigestMsg returns whether this GossipMessage is a digest message
+func IsDigestMsg(m *gossip.GossipMessage) bool {
+	return m.GetDataDig() != nil
+}
+
+// IsLeadershipMsg returns whether this GossipMessage is a leadership (leader election) message
+func IsLeadershipMsg(m *gossip.GossipMessage) bool {
+	return m.GetLeadershipMsg() != nil
+}
+
+// IsTagLegal checks the GossipMessage tags and inner type
+// and returns an error if the tag doesn't match the type.
+func IsTagLegal(m *gossip.GossipMessage) error {
+	if m.Tag == gossip.GossipMessage_UNDEFINED {
+		return fmt.Errorf("Undefined tag")
+	}
+	if IsDataMsg(m) {
+		if m.Tag != gossip.GossipMessage_CHAN_AND_ORG {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_AND_ORG)])
+		}
+		return nil
+	}
+
+	if IsAliveMsg(m) || m.GetMemReq() != nil || m.GetMemRes() != nil {
+		if m.Tag != gossip.GossipMessage_EMPTY {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_EMPTY)])
+		}
+		return nil
+	}
+
+	if IsIdentityMsg(m) {
+		if m.Tag != gossip.GossipMessage_ORG_ONLY {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_ORG_ONLY)])
+		}
+		return nil
+	}
+
+	if IsPullMsg(m) {
+		switch GetPullMsgType(m) {
+		case gossip.PullMsgType_BLOCK_MSG:
+			if m.Tag != gossip.GossipMessage_CHAN_AND_ORG {
+				return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_AND_ORG)])
+			}
+			return nil
+		case gossip.PullMsgType_IDENTITY_MSG:
+			if m.Tag != gossip.GossipMessage_EMPTY {
+				return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_EMPTY)])
+			}
+			return nil
+		default:
+			return fmt.Errorf("Invalid PullMsgType: %s", gossip.PullMsgType_name[int32(GetPullMsgType(m))])
+		}
+	}
+
+	if IsStateInfoMsg(m) || IsStateInfoPullRequestMsg(m) || IsStateInfoSnapshot(m) || IsRemoteStateMessage(m) {
+		if m.Tag != gossip.GossipMessage_CHAN_OR_ORG {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_OR_ORG)])
+		}
+		return nil
+	}
+
+	if IsLeadershipMsg(m) {
+		if m.Tag != gossip.GossipMessage_CHAN_AND_ORG {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_AND_ORG)])
+		}
+		return nil
+	}
+
+	if m.GetCollDataReq() != nil || m.GetCollDataRes() != nil {
+		if m.Tag != gossip.GossipMessage_CHAN_ONLY {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_ONLY)])
+		}
+		return nil
+	}
+
+	return fmt.Errorf("Unknown message type: %v", m)
+}
diff --git a/gossip/protoext/message_test.go b/gossip/protoext/message_test.go
new file mode 100644
index 00000000..f10358d1
--- /dev/null
+++ b/gossip/protoext/message_test.go
@@ -0,0 +1,438 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext_test
+
+import (
+	"testing"
+
+	"github.com/hyperledger/fabric/gossip/protoext"
+	"github.com/hyperledger/fabric/protos/gossip"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestCheckGossipMessageTypes(t *testing.T) {
+	var msg *gossip.GossipMessage
+
+	// Create State info pull request
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_StateInfoPullReq{
+			StateInfoPullReq: &gossip.StateInfoPullRequest{
+				Channel_MAC: []byte{17},
+			},
+		},
+	}
+	assert.True(t, protoext.IsStateInfoPullRequestMsg(msg))
+
+	// Create alive message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_AliveMsg{
+			AliveMsg: &gossip.AliveMessage{
+				Identity: []byte("peerID"),
+				Membership: &gossip.Member{
+					PkiId:    []byte("pkiID"),
+					Metadata: []byte{17},
+					Endpoint: "localhost",
+				},
+				Timestamp: &gossip.PeerTime{
+					SeqNum: 1,
+					IncNum: 1,
+				},
+			},
+		},
+	}
+	assert.True(t, protoext.IsAliveMsg(msg))
+
+	// Create gossip data message
+	msg = &gossip.GossipMessage{
+		Content: dataMessage(1, []byte{1, 2, 3, 4, 5}),
+	}
+	assert.True(t, protoext.IsDataMsg(msg))
+
+	// Create data request message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_DataReq{
+			DataReq: &gossip.DataRequest{
+				MsgType: gossip.PullMsgType_UNDEFINED,
+				Nonce:   0,
+				Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+			},
+		},
+	}
+	assert.True(t, protoext.IsDataReq(msg))
+	assert.True(t, protoext.IsPullMsg(msg))
+
+	// Create data request message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_DataDig{
+			DataDig: &gossip.DataDigest{
+				MsgType: gossip.PullMsgType_UNDEFINED,
+				Nonce:   0,
+				Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+			},
+		},
+	}
+	assert.True(t, protoext.IsDigestMsg(msg))
+	assert.True(t, protoext.IsPullMsg(msg))
+
+	// Create data update message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_DataUpdate{
+			DataUpdate: &gossip.DataUpdate{
+				MsgType: gossip.PullMsgType_UNDEFINED,
+				Nonce:   0,
+				Data:    []*gossip.Envelope{envelopes()[0]},
+			},
+		},
+	}
+	assert.True(t, protoext.IsDataUpdate(msg))
+	assert.True(t, protoext.IsPullMsg(msg))
+
+	// Create gossip hello message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_Hello{
+			Hello: &gossip.GossipHello{
+				MsgType: gossip.PullMsgType_UNDEFINED,
+				Nonce:   0,
+			},
+		},
+	}
+	assert.True(t, protoext.IsHelloMsg(msg))
+	assert.True(t, protoext.IsPullMsg(msg))
+
+	// Create state request message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_StateRequest{
+			StateRequest: &gossip.RemoteStateRequest{
+				StartSeqNum: 1,
+				EndSeqNum:   10,
+			},
+		},
+	}
+	assert.True(t, protoext.IsRemoteStateMessage(msg))
+
+	// Create state response message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_StateResponse{
+			StateResponse: &gossip.RemoteStateResponse{
+				Payloads: []*gossip.Payload{{
+					SeqNum: 1,
+					Data:   []byte{1, 2, 3, 4, 5},
+				}},
+			},
+		},
+	}
+	assert.True(t, protoext.IsRemoteStateMessage(msg))
+}
+
+func TestGossipPullMessageType(t *testing.T) {
+	var msg *gossip.GossipMessage
+
+	// Create gossip hello message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_Hello{
+			Hello: &gossip.GossipHello{
+				MsgType: gossip.PullMsgType_BLOCK_MSG,
+				Nonce:   0,
+			},
+		},
+	}
+	assert.True(t, protoext.IsHelloMsg(msg))
+	assert.True(t, protoext.IsPullMsg(msg))
+	assert.Equal(t, protoext.GetPullMsgType(msg), gossip.PullMsgType_BLOCK_MSG)
+
+	// Create data request message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_DataDig{
+			DataDig: &gossip.DataDigest{
+				MsgType: gossip.PullMsgType_IDENTITY_MSG,
+				Nonce:   0,
+				Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+			},
+		},
+	}
+	assert.True(t, protoext.IsDigestMsg(msg))
+	assert.True(t, protoext.IsPullMsg(msg))
+	assert.Equal(t, protoext.GetPullMsgType(msg), gossip.PullMsgType_IDENTITY_MSG)
+
+	// Create data request message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_DataReq{
+			DataReq: &gossip.DataRequest{
+				MsgType: gossip.PullMsgType_BLOCK_MSG,
+				Nonce:   0,
+				Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+			},
+		},
+	}
+	assert.True(t, protoext.IsDataReq(msg))
+	assert.True(t, protoext.IsPullMsg(msg))
+	assert.Equal(t, protoext.GetPullMsgType(msg), gossip.PullMsgType_BLOCK_MSG)
+
+	// Create data update message
+	msg = &gossip.GossipMessage{
+		Content: &gossip.GossipMessage_DataUpdate{
+			DataUpdate: &gossip.DataUpdate{
+				MsgType: gossip.PullMsgType_IDENTITY_MSG,
+				Nonce:   0,
+				Data:    []*gossip.Envelope{envelopes()[0]},
+			},
+		},
+	}
+	assert.True(t, protoext.IsDataUpdate(msg))
+	assert.True(t, protoext.IsPullMsg(msg))
+	assert.Equal(t, protoext.GetPullMsgType(msg), gossip.PullMsgType_IDENTITY_MSG)
+
+	// Create gossip data message
+	msg = &gossip.GossipMessage{
+		Content: dataMessage(1, []byte{1, 2, 3, 4, 5}),
+	}
+	assert.True(t, protoext.IsDataMsg(msg))
+	assert.Equal(t, protoext.GetPullMsgType(msg), gossip.PullMsgType_UNDEFINED)
+}
+
+func TestGossipMessageDataMessageTagType(t *testing.T) {
+	var msg *gossip.GossipMessage
+
+	msg = &gossip.GossipMessage{
+		Tag:     gossip.GossipMessage_CHAN_AND_ORG,
+		Content: dataMessage(1, []byte{1}),
+	}
+	assert.True(t, protoext.IsChannelRestricted(msg))
+	assert.True(t, protoext.IsOrgRestricted(msg))
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag:     gossip.GossipMessage_EMPTY,
+		Content: dataMessage(1, []byte{1}),
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag:     gossip.GossipMessage_UNDEFINED,
+		Content: dataMessage(1, []byte{1}),
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag:     gossip.GossipMessage_ORG_ONLY,
+		Content: dataMessage(1, []byte{1}),
+	}
+	assert.False(t, protoext.IsChannelRestricted(msg))
+	assert.True(t, protoext.IsOrgRestricted(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag:     gossip.GossipMessage_CHAN_OR_ORG,
+		Content: dataMessage(1, []byte{1}),
+	}
+	assert.True(t, protoext.IsChannelRestricted(msg))
+	assert.False(t, protoext.IsOrgRestricted(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag:     gossip.GossipMessage_EMPTY,
+		Content: dataMessage(1, []byte{1}),
+	}
+	assert.False(t, protoext.IsChannelRestricted(msg))
+	assert.False(t, protoext.IsOrgRestricted(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag:     gossip.GossipMessage_UNDEFINED,
+		Content: dataMessage(1, []byte{1}),
+	}
+	assert.False(t, protoext.IsChannelRestricted(msg))
+	assert.False(t, protoext.IsOrgRestricted(msg))
+}
+
+func TestGossipMessageAliveMessageTagType(t *testing.T) {
+	var msg *gossip.GossipMessage
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_EMPTY,
+		Content: &gossip.GossipMessage_AliveMsg{
+			AliveMsg: &gossip.AliveMessage{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_ORG_ONLY,
+		Content: &gossip.GossipMessage_AliveMsg{
+			AliveMsg: &gossip.AliveMessage{},
+		},
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+}
+
+func TestGossipMessageMembershipMessageTagType(t *testing.T) {
+	var msg *gossip.GossipMessage
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_EMPTY,
+		Content: &gossip.GossipMessage_MemReq{
+			MemReq: &gossip.MembershipRequest{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_EMPTY,
+		Content: &gossip.GossipMessage_MemRes{
+			MemRes: &gossip.MembershipResponse{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+}
+
+func TestGossipMessageIdentityMessageTagType(t *testing.T) {
+	var msg *gossip.GossipMessage
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_ORG_ONLY,
+		Content: &gossip.GossipMessage_PeerIdentity{
+			PeerIdentity: &gossip.PeerIdentity{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_EMPTY,
+		Content: &gossip.GossipMessage_PeerIdentity{
+			PeerIdentity: &gossip.PeerIdentity{},
+		},
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+}
+
+func TestGossipMessagePullMessageTagType(t *testing.T) {
+	var msg *gossip.GossipMessage
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_CHAN_AND_ORG,
+		Content: &gossip.GossipMessage_DataReq{
+			DataReq: &gossip.DataRequest{
+				MsgType: gossip.PullMsgType_BLOCK_MSG,
+			},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_EMPTY,
+		Content: &gossip.GossipMessage_DataReq{
+			DataReq: &gossip.DataRequest{
+				MsgType: gossip.PullMsgType_BLOCK_MSG,
+			},
+		},
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_EMPTY,
+		Content: &gossip.GossipMessage_DataDig{
+			DataDig: &gossip.DataDigest{
+				MsgType: gossip.PullMsgType_IDENTITY_MSG,
+			},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_ORG_ONLY,
+		Content: &gossip.GossipMessage_DataDig{
+			DataDig: &gossip.DataDigest{
+				MsgType: gossip.PullMsgType_IDENTITY_MSG,
+			},
+		},
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_ORG_ONLY,
+		Content: &gossip.GossipMessage_DataDig{
+			DataDig: &gossip.DataDigest{
+				MsgType: gossip.PullMsgType_UNDEFINED,
+			},
+		},
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+}
+
+func TestGossipMessageStateInfoMessageTagType(t *testing.T) {
+	var msg *gossip.GossipMessage
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_CHAN_OR_ORG,
+		Content: &gossip.GossipMessage_StateInfo{
+			StateInfo: &gossip.StateInfo{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_CHAN_OR_ORG,
+		Content: &gossip.GossipMessage_StateInfoPullReq{
+			StateInfoPullReq: &gossip.StateInfoPullRequest{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_CHAN_OR_ORG,
+		Content: &gossip.GossipMessage_StateResponse{
+			StateResponse: &gossip.RemoteStateResponse{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_CHAN_OR_ORG,
+		Content: &gossip.GossipMessage_StateRequest{
+			StateRequest: &gossip.RemoteStateRequest{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_CHAN_OR_ORG,
+		Content: &gossip.GossipMessage_StateSnapshot{
+			StateSnapshot: &gossip.StateInfoSnapshot{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_EMPTY,
+		Content: &gossip.GossipMessage_StateInfo{
+			StateInfo: &gossip.StateInfo{},
+		},
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+}
+
+func TestGossipMessageLeadershipMessageTagType(t *testing.T) {
+	var msg *gossip.GossipMessage
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_CHAN_AND_ORG,
+		Content: &gossip.GossipMessage_LeadershipMsg{
+			LeadershipMsg: &gossip.LeadershipMessage{},
+		},
+	}
+	assert.NoError(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag: gossip.GossipMessage_CHAN_OR_ORG, Content: &gossip.GossipMessage_LeadershipMsg{
+			LeadershipMsg: &gossip.LeadershipMessage{},
+		},
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+
+	msg = &gossip.GossipMessage{
+		Tag:     gossip.GossipMessage_CHAN_OR_ORG,
+		Content: &gossip.GossipMessage_Empty{},
+	}
+	assert.Error(t, protoext.IsTagLegal(msg))
+}
diff --git a/gossip/protoext/msgcomparator.go b/gossip/protoext/msgcomparator.go
new file mode 100644
index 00000000..6a706103
--- /dev/null
+++ b/gossip/protoext/msgcomparator.go
@@ -0,0 +1,125 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext
+
+import (
+	"bytes"
+
+	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/protos/gossip"
+)
+
+// NewGossipMessageComparator creates a MessageReplacingPolicy given a maximum number of blocks to hold
+func NewGossipMessageComparator(dataBlockStorageSize int) common.MessageReplacingPolicy {
+	return (&msgComparator{dataBlockStorageSize: dataBlockStorageSize}).getMsgReplacingPolicy()
+}
+
+type msgComparator struct {
+	dataBlockStorageSize int
+}
+
+func (mc *msgComparator) getMsgReplacingPolicy() common.MessageReplacingPolicy {
+	return func(this interface{}, that interface{}) common.InvalidationResult {
+		return mc.invalidationPolicy(this, that)
+	}
+}
+
+func (mc *msgComparator) invalidationPolicy(this interface{}, that interface{}) common.InvalidationResult {
+	thisMsg := this.(*SignedGossipMessage)
+	thatMsg := that.(*SignedGossipMessage)
+
+	if IsAliveMsg(thisMsg.GossipMessage) && IsAliveMsg(thatMsg.GossipMessage) {
+		return aliveInvalidationPolicy(thisMsg.GetAliveMsg(), thatMsg.GetAliveMsg())
+	}
+
+	if IsDataMsg(thisMsg.GossipMessage) && IsDataMsg(thatMsg.GossipMessage) {
+		return mc.dataInvalidationPolicy(thisMsg.GetDataMsg(), thatMsg.GetDataMsg())
+	}
+
+	if IsStateInfoMsg(thisMsg.GossipMessage) && IsStateInfoMsg(thatMsg.GossipMessage) {
+		return mc.stateInvalidationPolicy(thisMsg.GetStateInfo(), thatMsg.GetStateInfo())
+	}
+
+	if IsIdentityMsg(thisMsg.GossipMessage) && IsIdentityMsg(thatMsg.GossipMessage) {
+		return mc.identityInvalidationPolicy(thisMsg.GetPeerIdentity(), thatMsg.GetPeerIdentity())
+	}
+
+	if IsLeadershipMsg(thisMsg.GossipMessage) && IsLeadershipMsg(thatMsg.GossipMessage) {
+		return leaderInvalidationPolicy(thisMsg.GetLeadershipMsg(), thatMsg.GetLeadershipMsg())
+	}
+
+	return common.MessageNoAction
+}
+
+func (mc *msgComparator) stateInvalidationPolicy(thisStateMsg *gossip.StateInfo, thatStateMsg *gossip.StateInfo) common.InvalidationResult {
+	if !bytes.Equal(thisStateMsg.PkiId, thatStateMsg.PkiId) {
+		return common.MessageNoAction
+	}
+	return compareTimestamps(thisStateMsg.Timestamp, thatStateMsg.Timestamp)
+}
+
+func (mc *msgComparator) identityInvalidationPolicy(thisIdentityMsg *gossip.PeerIdentity, thatIdentityMsg *gossip.PeerIdentity) common.InvalidationResult {
+	if bytes.Equal(thisIdentityMsg.PkiId, thatIdentityMsg.PkiId) {
+		return common.MessageInvalidated
+	}
+
+	return common.MessageNoAction
+}
+
+func (mc *msgComparator) dataInvalidationPolicy(thisDataMsg *gossip.DataMessage, thatDataMsg *gossip.DataMessage) common.InvalidationResult {
+	if thisDataMsg.Payload.SeqNum == thatDataMsg.Payload.SeqNum {
+		return common.MessageInvalidated
+	}
+
+	diff := abs(thisDataMsg.Payload.SeqNum, thatDataMsg.Payload.SeqNum)
+	if diff <= uint64(mc.dataBlockStorageSize) {
+		return common.MessageNoAction
+	}
+
+	if thisDataMsg.Payload.SeqNum > thatDataMsg.Payload.SeqNum {
+		return common.MessageInvalidates
+	}
+	return common.MessageInvalidated
+}
+
+func aliveInvalidationPolicy(thisMsg *gossip.AliveMessage, thatMsg *gossip.AliveMessage) common.InvalidationResult {
+	if !bytes.Equal(thisMsg.Membership.PkiId, thatMsg.Membership.PkiId) {
+		return common.MessageNoAction
+	}
+
+	return compareTimestamps(thisMsg.Timestamp, thatMsg.Timestamp)
+}
+
+func leaderInvalidationPolicy(thisMsg *gossip.LeadershipMessage, thatMsg *gossip.LeadershipMessage) common.InvalidationResult {
+	if !bytes.Equal(thisMsg.PkiId, thatMsg.PkiId) {
+		return common.MessageNoAction
+	}
+
+	return compareTimestamps(thisMsg.Timestamp, thatMsg.Timestamp)
+}
+
+func compareTimestamps(thisTS *gossip.PeerTime, thatTS *gossip.PeerTime) common.InvalidationResult {
+	if thisTS.IncNum == thatTS.IncNum {
+		if thisTS.SeqNum > thatTS.SeqNum {
+			return common.MessageInvalidates
+		}
+
+		return common.MessageInvalidated
+	}
+	if thisTS.IncNum < thatTS.IncNum {
+		return common.MessageInvalidated
+	}
+	return common.MessageInvalidates
+}
+
+// abs returns abs(a-b)
+func abs(a, b uint64) uint64 {
+	if a > b {
+		return a - b
+	}
+	return b - a
+}
diff --git a/gossip/protoext/msgcomparator_test.go b/gossip/protoext/msgcomparator_test.go
new file mode 100644
index 00000000..bf5c1dcb
--- /dev/null
+++ b/gossip/protoext/msgcomparator_test.go
@@ -0,0 +1,388 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext_test
+
+import (
+	"testing"
+
+	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
+	"github.com/hyperledger/fabric/protos/gossip"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestAliveMessageNoActionTaken(t *testing.T) {
+	comparator := protoext.NewGossipMessageComparator(1)
+
+	sMsg1 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_AliveMsg{
+				AliveMsg: &gossip.AliveMessage{
+					Membership: &gossip.Member{
+						Endpoint: "localhost",
+						Metadata: []byte{1, 2, 3, 4, 5},
+						PkiId:    []byte{17},
+					},
+					Timestamp: &gossip.PeerTime{
+						IncNum: 1,
+						SeqNum: 1,
+					},
+					Identity: []byte("peerID1"),
+				},
+			},
+		},
+	}
+
+	sMsg2 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_AliveMsg{
+				AliveMsg: &gossip.AliveMessage{
+					Membership: &gossip.Member{
+						Endpoint: "localhost",
+						Metadata: []byte{1, 2, 3, 4, 5},
+						PkiId:    []byte{15},
+					},
+					Timestamp: &gossip.PeerTime{
+						IncNum: 2,
+						SeqNum: 2,
+					},
+					Identity: []byte("peerID1"),
+				},
+			},
+		},
+	}
+
+	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageNoAction)
+}
+
+func TestStateInfoMessageNoActionTaken(t *testing.T) {
+	comparator := protoext.NewGossipMessageComparator(1)
+
+	// msg1 and msg2 have same channel mac, while different pkid, while
+	// msg and msg3 same pkid and different channel mac
+
+	sMsg1 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: stateInfoMessage(1, 1, []byte{17}, []byte{17, 13}),
+		},
+	}
+	sMsg2 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: stateInfoMessage(1, 1, []byte{13}, []byte{17, 13}),
+		},
+	}
+
+	// We only should compare comparable messages, e.g. message from same peer
+	// In any other cases no invalidation should be taken.
+	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageNoAction)
+}
+
+func TestStateInfoMessagesInvalidation(t *testing.T) {
+	comparator := protoext.NewGossipMessageComparator(1)
+
+	sMsg1 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: stateInfoMessage(1, 1, []byte{17}, []byte{17}),
+		},
+	}
+	sMsg2 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: stateInfoMessage(1, 1, []byte{17}, []byte{17}),
+		},
+	}
+	sMsg3 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: stateInfoMessage(1, 2, []byte{17}, []byte{17}),
+		},
+	}
+	sMsg4 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: stateInfoMessage(2, 1, []byte{17}, []byte{17}),
+		},
+	}
+
+	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageInvalidated)
+
+	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg3, sMsg1), common.MessageInvalidates)
+
+	assert.Equal(t, comparator(sMsg1, sMsg4), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg4, sMsg1), common.MessageInvalidates)
+
+	assert.Equal(t, comparator(sMsg3, sMsg4), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg4, sMsg3), common.MessageInvalidates)
+}
+
+func TestAliveMessageInvalidation(t *testing.T) {
+	comparator := protoext.NewGossipMessageComparator(1)
+
+	sMsg1 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_AliveMsg{
+				AliveMsg: &gossip.AliveMessage{
+					Membership: &gossip.Member{
+						Endpoint: "localhost",
+						Metadata: []byte{1, 2, 3, 4, 5},
+						PkiId:    []byte{17},
+					},
+					Timestamp: &gossip.PeerTime{
+						IncNum: 1,
+						SeqNum: 1,
+					},
+					Identity: []byte("peerID1"),
+				},
+			},
+		},
+	}
+
+	sMsg2 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_AliveMsg{
+				AliveMsg: &gossip.AliveMessage{
+					Membership: &gossip.Member{
+						Endpoint: "localhost",
+						Metadata: []byte{1, 2, 3, 4, 5},
+						PkiId:    []byte{17},
+					},
+					Timestamp: &gossip.PeerTime{
+						IncNum: 2,
+						SeqNum: 2,
+					},
+					Identity: []byte("peerID1"),
+				},
+			},
+		},
+	}
+
+	sMsg3 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_AliveMsg{
+				AliveMsg: &gossip.AliveMessage{
+					Membership: &gossip.Member{
+						Endpoint: "localhost",
+						Metadata: []byte{1, 2, 3, 4, 5},
+						PkiId:    []byte{17},
+					},
+					Timestamp: &gossip.PeerTime{
+						IncNum: 1,
+						SeqNum: 2,
+					},
+					Identity: []byte("peerID1"),
+				},
+			},
+		},
+	}
+
+	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg2, sMsg1), common.MessageInvalidates)
+	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg3, sMsg1), common.MessageInvalidates)
+}
+
+func TestDataMessageInvalidation(t *testing.T) {
+	comparator := protoext.NewGossipMessageComparator(5)
+
+	data := []byte{1, 1, 1}
+	sMsg1 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: dataMessage(1, data),
+		},
+	}
+	sMsg1Clone := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: dataMessage(1, data),
+		},
+	}
+	sMsg3 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: dataMessage(2, data),
+		},
+	}
+	sMsg4 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: dataMessage(7, data),
+		},
+	}
+
+	assert.Equal(t, comparator(sMsg1, sMsg1Clone), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageNoAction)
+	assert.Equal(t, comparator(sMsg1, sMsg4), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg4, sMsg1), common.MessageInvalidates)
+}
+
+func TestIdentityMessagesInvalidation(t *testing.T) {
+	comparator := protoext.NewGossipMessageComparator(5)
+
+	msg1 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_PeerIdentity{
+				PeerIdentity: &gossip.PeerIdentity{
+					PkiId:    []byte{17},
+					Cert:     []byte{1, 2, 3, 4},
+					Metadata: nil,
+				},
+			},
+		},
+	}
+
+	msg2 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_PeerIdentity{
+				PeerIdentity: &gossip.PeerIdentity{
+					PkiId:    []byte{17},
+					Cert:     []byte{1, 2, 3, 4},
+					Metadata: nil,
+				},
+			},
+		},
+	}
+
+	msg3 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_PeerIdentity{
+				PeerIdentity: &gossip.PeerIdentity{
+					PkiId:    []byte{11},
+					Cert:     []byte{11, 21, 31, 41},
+					Metadata: nil,
+				},
+			},
+		},
+	}
+
+	assert.Equal(t, comparator(msg1, msg2), common.MessageInvalidated)
+	assert.Equal(t, comparator(msg1, msg3), common.MessageNoAction)
+}
+
+func TestLeadershipMessagesNoAction(t *testing.T) {
+	comparator := protoext.NewGossipMessageComparator(5)
+
+	msg1 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: leadershipMessage(1, 1, []byte{17}),
+		},
+	}
+	msg2 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: leadershipMessage(1, 1, []byte{11}),
+		},
+	}
+
+	// If message with different pkid's no action should be taken
+	assert.Equal(t, comparator(msg1, msg2), common.MessageNoAction)
+}
+
+func TestLeadershipMessagesInvalidation(t *testing.T) {
+	comparator := protoext.NewGossipMessageComparator(5)
+
+	pkiID := []byte{17}
+	msg1 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: leadershipMessage(1, 1, pkiID),
+		},
+	}
+	msg2 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: leadershipMessage(1, 2, pkiID),
+		},
+	}
+	msg3 := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannel"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: leadershipMessage(2, 1, pkiID),
+		},
+	}
+
+	// If message with different pkid's no action should be taken
+	assert.Equal(t, comparator(msg1, msg2), common.MessageInvalidated)
+	assert.Equal(t, comparator(msg2, msg1), common.MessageInvalidates)
+	assert.Equal(t, comparator(msg1, msg3), common.MessageInvalidated)
+	assert.Equal(t, comparator(msg3, msg1), common.MessageInvalidates)
+	assert.Equal(t, comparator(msg2, msg3), common.MessageInvalidated)
+	assert.Equal(t, comparator(msg3, msg2), common.MessageInvalidates)
+}
+
+func stateInfoMessage(incNum uint64, seqNum uint64, pkid []byte, mac []byte) *gossip.GossipMessage_StateInfo {
+	return &gossip.GossipMessage_StateInfo{
+		StateInfo: &gossip.StateInfo{
+			Timestamp: &gossip.PeerTime{
+				IncNum: incNum,
+				SeqNum: seqNum,
+			},
+			PkiId:       pkid,
+			Channel_MAC: mac,
+		},
+	}
+}
+
+func dataMessage(seqNum uint64, data []byte) *gossip.GossipMessage_DataMsg {
+	return &gossip.GossipMessage_DataMsg{
+		DataMsg: &gossip.DataMessage{
+			Payload: &gossip.Payload{
+				SeqNum: seqNum,
+				Data:   data,
+			},
+		},
+	}
+}
+
+func leadershipMessage(incNum uint64, seqNum uint64, pkid []byte) *gossip.GossipMessage_LeadershipMsg {
+	return &gossip.GossipMessage_LeadershipMsg{
+		LeadershipMsg: &gossip.LeadershipMessage{
+			PkiId:         pkid,
+			IsDeclaration: false,
+			Timestamp: &gossip.PeerTime{
+				IncNum: incNum,
+				SeqNum: seqNum,
+			},
+		},
+	}
+}
diff --git a/gossip/protoext/receivedmessage.go b/gossip/protoext/receivedmessage.go
new file mode 100644
index 00000000..2cba2379
--- /dev/null
+++ b/gossip/protoext/receivedmessage.go
@@ -0,0 +1,64 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext
+
+import (
+	"fmt"
+
+	"github.com/hyperledger/fabric/gossip/api"
+	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/protos/gossip"
+)
+
+// ReceivedMessage is a GossipMessage wrapper that
+// enables the user to send a message to the origin from which
+// the ReceivedMessage was sent from.
+// It also allows to know the identity of the sender,
+// to obtain the raw bytes the GossipMessage was un-marshaled from,
+// and the signature over these raw bytes.
+type ReceivedMessage interface {
+	// Respond sends a GossipMessage to the origin from which this ReceivedMessage was sent from
+	Respond(msg *gossip.GossipMessage)
+
+	// GetGossipMessage returns the underlying GossipMessage
+	GetGossipMessage() *SignedGossipMessage
+
+	// GetSourceMessage Returns the Envelope the ReceivedMessage was
+	// constructed with
+	GetSourceEnvelope() *gossip.Envelope
+
+	// GetConnectionInfo returns information about the remote peer
+	// that sent the message
+	GetConnectionInfo() *ConnectionInfo
+
+	// Ack returns to the sender an acknowledgement for the message
+	// An ack can receive an error that indicates that the operation related
+	// to the message has failed
+	Ack(err error)
+}
+
+// ConnectionInfo represents information about
+// the remote peer that sent a certain ReceivedMessage
+type ConnectionInfo struct {
+	ID       common.PKIidType
+	Auth     *AuthInfo
+	Identity api.PeerIdentityType
+	Endpoint string
+}
+
+// String returns a string representation of this ConnectionInfo
+func (c *ConnectionInfo) String() string {
+	return fmt.Sprintf("%s %v", c.Endpoint, c.ID)
+}
+
+// AuthInfo represents the authentication
+// data that was provided by the remote peer
+// at the connection time
+type AuthInfo struct {
+	SignedData []byte
+	Signature  []byte
+}
diff --git a/gossip/protoext/signing.go b/gossip/protoext/signing.go
new file mode 100644
index 00000000..be04638d
--- /dev/null
+++ b/gossip/protoext/signing.go
@@ -0,0 +1,206 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext
+
+import (
+	"errors"
+	"fmt"
+
+	"github.com/gogo/protobuf/proto"
+	"github.com/hyperledger/fabric/protos/gossip"
+)
+
+// Signer signs a message, and returns (signature, nil)
+// on success, and nil and an error on failure.
+type Signer func(msg []byte) ([]byte, error)
+
+// Verifier receives a peer identity, a signature and a message and returns nil
+// if the signature on the message could be verified using the given identity.
+type Verifier func(peerIdentity []byte, signature, message []byte) error
+
+// SignSecret signs the secret payload and creates a secret envelope out of it.
+func SignSecret(e *gossip.Envelope, signer Signer, secret *gossip.Secret) error {
+	payload, err := proto.Marshal(secret)
+	if err != nil {
+		return err
+	}
+	sig, err := signer(payload)
+	if err != nil {
+		return err
+	}
+	e.SecretEnvelope = &gossip.SecretEnvelope{
+		Payload:   payload,
+		Signature: sig,
+	}
+	return nil
+}
+
+// NoopSign creates a SignedGossipMessage with a nil signature
+func NoopSign(m *gossip.GossipMessage) (*SignedGossipMessage, error) {
+	signer := func(msg []byte) ([]byte, error) {
+		return nil, nil
+	}
+	sMsg := &SignedGossipMessage{
+		GossipMessage: m,
+	}
+	_, err := sMsg.Sign(signer)
+	return sMsg, err
+}
+
+// EnvelopeToGossipMessage un-marshals a given envelope and creates a
+// SignedGossipMessage out of it.
+// Returns an error if un-marshaling fails.
+func EnvelopeToGossipMessage(e *gossip.Envelope) (*SignedGossipMessage, error) {
+	if e == nil {
+		return nil, errors.New("nil envelope")
+	}
+	msg := &gossip.GossipMessage{}
+	err := proto.Unmarshal(e.Payload, msg)
+	if err != nil {
+		return nil, fmt.Errorf("Failed unmarshaling GossipMessage from envelope: %v", err)
+	}
+	return &SignedGossipMessage{
+		GossipMessage: msg,
+		Envelope:      e,
+	}, nil
+}
+
+// InternalEndpoint returns the internal endpoint in the secret envelope, or an
+// empty string if a failure occurs.
+func InternalEndpoint(s *gossip.SecretEnvelope) string {
+	secret := &gossip.Secret{}
+	if err := proto.Unmarshal(s.Payload, secret); err != nil {
+		return ""
+	}
+	return secret.GetInternalEndpoint()
+}
+
+// SignedGossipMessage contains a GossipMessage and the Envelope from which it
+// came from
+type SignedGossipMessage struct {
+	*gossip.Envelope
+	*gossip.GossipMessage
+}
+
+// Sign signs a GossipMessage with given Signer.
+// Returns an Envelope on success, panics on failure.
+func (m *SignedGossipMessage) Sign(signer Signer) (*gossip.Envelope, error) {
+	// If we have a secretEnvelope, don't override it.
+	// Back it up, and restore it later
+	var secretEnvelope *gossip.SecretEnvelope
+	if m.Envelope != nil {
+		secretEnvelope = m.Envelope.SecretEnvelope
+	}
+	m.Envelope = nil
+	payload, err := proto.Marshal(m.GossipMessage)
+	if err != nil {
+		return nil, err
+	}
+	sig, err := signer(payload)
+	if err != nil {
+		return nil, err
+	}
+
+	e := &gossip.Envelope{
+		Payload:        payload,
+		Signature:      sig,
+		SecretEnvelope: secretEnvelope,
+	}
+	m.Envelope = e
+	return e, nil
+}
+
+// Verify verifies a signed GossipMessage with a given Verifier.
+// Returns nil on success, error on failure.
+func (m *SignedGossipMessage) Verify(peerIdentity []byte, verify Verifier) error {
+	if m.Envelope == nil {
+		return errors.New("Missing envelope")
+	}
+	if len(m.Envelope.Payload) == 0 {
+		return errors.New("Empty payload")
+	}
+	if len(m.Envelope.Signature) == 0 {
+		return errors.New("Empty signature")
+	}
+	payloadSigVerificationErr := verify(peerIdentity, m.Envelope.Signature, m.Envelope.Payload)
+	if payloadSigVerificationErr != nil {
+		return payloadSigVerificationErr
+	}
+	if m.Envelope.SecretEnvelope != nil {
+		payload := m.Envelope.SecretEnvelope.Payload
+		sig := m.Envelope.SecretEnvelope.Signature
+		if len(payload) == 0 {
+			return errors.New("Empty payload")
+		}
+		if len(sig) == 0 {
+			return errors.New("Empty signature")
+		}
+		return verify(peerIdentity, sig, payload)
+	}
+	return nil
+}
+
+// IsSigned returns whether the message
+// has a signature in the envelope.
+func (m *SignedGossipMessage) IsSigned() bool {
+	return m.Envelope != nil && m.Envelope.Payload != nil && m.Envelope.Signature != nil
+}
+
+// String returns a string representation
+// of a SignedGossipMessage
+func (m *SignedGossipMessage) String() string {
+	env := "No envelope"
+	if m.Envelope != nil {
+		var secretEnv string
+		if m.SecretEnvelope != nil {
+			pl := len(m.SecretEnvelope.Payload)
+			sl := len(m.SecretEnvelope.Signature)
+			secretEnv = fmt.Sprintf(" Secret payload: %d bytes, Secret Signature: %d bytes", pl, sl)
+		}
+		env = fmt.Sprintf("%d bytes, Signature: %d bytes%s", len(m.Envelope.Payload), len(m.Envelope.Signature), secretEnv)
+	}
+	gMsg := "No gossipMessage"
+	if m.GossipMessage != nil {
+		var isSimpleMsg bool
+		if m.GetStateResponse() != nil {
+			gMsg = fmt.Sprintf("StateResponse with %d items", len(m.GetStateResponse().Payloads))
+		} else if IsDataMsg(m.GossipMessage) && m.GetDataMsg().Payload != nil {
+			gMsg = PayloadToString(m.GetDataMsg().Payload)
+		} else if IsDataUpdate(m.GossipMessage) {
+			update := m.GetDataUpdate()
+			gMsg = fmt.Sprintf("DataUpdate: %s", DataUpdateToString(update))
+		} else if m.GetMemRes() != nil {
+			gMsg = MembershipResponseToString(m.GetMemRes())
+		} else if IsStateInfoSnapshot(m.GossipMessage) {
+			gMsg = StateInfoSnapshotToString(m.GetStateSnapshot())
+		} else if m.GetPrivateRes() != nil {
+			gMsg = RemovePvtDataResponseToString(m.GetPrivateRes())
+		} else if m.GetAliveMsg() != nil {
+			gMsg = AliveMessageToString(m.GetAliveMsg())
+		} else if m.GetMemReq() != nil {
+			gMsg = MembershipRequestToString(m.GetMemReq())
+		} else if m.GetStateInfoPullReq() != nil {
+			gMsg = StateInfoPullRequestToString(m.GetStateInfoPullReq())
+		} else if m.GetStateInfo() != nil {
+			gMsg = StateInfoToString(m.GetStateInfo())
+		} else if m.GetDataDig() != nil {
+			gMsg = DataDigestToString(m.GetDataDig())
+		} else if m.GetDataReq() != nil {
+			gMsg = DataRequestToString(m.GetDataReq())
+		} else if m.GetLeadershipMsg() != nil {
+			gMsg = LeadershipMessageToString(m.GetLeadershipMsg())
+		} else {
+			gMsg = m.GossipMessage.String()
+			isSimpleMsg = true
+		}
+		if !isSimpleMsg {
+			desc := fmt.Sprintf("Channel: %s, nonce: %d, tag: %s", string(m.Channel), m.Nonce, gossip.GossipMessage_Tag_name[int32(m.Tag)])
+			gMsg = fmt.Sprintf("%s %s", desc, gMsg)
+		}
+	}
+	return fmt.Sprintf("GossipMessage: %v, Envelope: %s", gMsg, env)
+}
diff --git a/gossip/protoext/signing_test.go b/gossip/protoext/signing_test.go
new file mode 100644
index 00000000..4dfaeef6
--- /dev/null
+++ b/gossip/protoext/signing_test.go
@@ -0,0 +1,420 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext_test
+
+import (
+	"errors"
+	"fmt"
+	"testing"
+
+	"github.com/gogo/protobuf/proto"
+	"github.com/hyperledger/fabric/gossip/protoext"
+	"github.com/hyperledger/fabric/protos/gossip"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestToGossipMessageNilEnvelope(t *testing.T) {
+	memReq := &gossip.MembershipRequest{}
+	_, err := protoext.EnvelopeToGossipMessage(memReq.SelfInformation)
+	assert.EqualError(t, err, "nil envelope")
+}
+
+func TestToString(t *testing.T) {
+	// Ensure we don't print the byte content when we
+	// log messages.
+	// Each payload or signature contains '2' so we would've logged
+	// them if not for the overloading of the String() method in SignedGossipMessage
+
+	// The following line proves that the envelopes constructed in this test
+	// have "2" in them when they are printed
+	assert.Contains(t, fmt.Sprintf("%v", envelopes()[0]), "2")
+	// and the following does the same for payloads:
+	dMsg := &gossip.DataMessage{
+		Payload: &gossip.Payload{
+			SeqNum: 3,
+			Data:   []byte{2, 2, 2, 2, 2},
+		},
+	}
+	assert.Contains(t, fmt.Sprintf("%v", dMsg), "2")
+
+	// Now we construct all types of messages that have envelopes or payloads in them
+	// and see that "2" is not outputted into their formatting even though it is found
+	// as a sub-message of the outer message.
+
+	sMsg := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Channel: []byte("A"),
+			Content: &gossip.GossipMessage_DataMsg{
+				DataMsg: &gossip.DataMessage{
+					Payload: &gossip.Payload{
+						SeqNum: 3,
+						Data:   []byte{2, 2, 2, 2, 2},
+					},
+				},
+			},
+		},
+		Envelope: &gossip.Envelope{
+			Payload:   []byte{0, 1, 2, 3, 4, 5, 6},
+			Signature: []byte{0, 1, 2},
+			SecretEnvelope: &gossip.SecretEnvelope{
+				Payload:   []byte{0, 1, 2, 3, 4, 5},
+				Signature: []byte{0, 1, 2},
+			},
+		},
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+	sMsg.GetDataMsg().Payload = nil
+	assert.NotPanics(t, func() {
+		_ = sMsg.String()
+	})
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_DataUpdate{
+				DataUpdate: &gossip.DataUpdate{
+					Nonce:   11,
+					MsgType: gossip.PullMsgType_BLOCK_MSG,
+					Data:    envelopes(),
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_MemRes{
+				MemRes: &gossip.MembershipResponse{
+					Alive: envelopes(),
+					Dead:  envelopes(),
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_StateSnapshot{
+				StateSnapshot: &gossip.StateInfoSnapshot{
+					Elements: envelopes(),
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_AliveMsg{
+				AliveMsg: &gossip.AliveMessage{
+					Membership: &gossip.Member{
+						Endpoint: "localhost",
+						Metadata: []byte{1, 2, 3, 4, 5},
+						PkiId:    []byte{17},
+					},
+					Timestamp: &gossip.PeerTime{
+						IncNum: 1,
+						SeqNum: 1,
+					},
+					Identity: []byte("peerID1"),
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_StateResponse{
+				StateResponse: &gossip.RemoteStateResponse{
+					Payloads: []*gossip.Payload{
+						{Data: []byte{2, 2, 2}},
+					},
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_MemReq{
+				MemReq: &gossip.MembershipRequest{
+					SelfInformation: sMsg.Envelope,
+					Known:           [][]byte{},
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_StateInfoPullReq{
+				StateInfoPullReq: &gossip.StateInfoPullRequest{
+					Channel_MAC: []byte{17},
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_StateInfo{
+				StateInfo: &gossip.StateInfo{
+					Channel_MAC: []byte{17},
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_DataDig{
+				DataDig: &gossip.DataDigest{
+					Nonce:   0,
+					Digests: [][]byte{[]byte("msg1"), []byte("msg2")},
+					MsgType: gossip.PullMsgType_BLOCK_MSG,
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.Contains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_DataReq{
+				DataReq: &gossip.DataRequest{
+					Nonce:   0,
+					Digests: [][]byte{[]byte("msg1"), []byte("msg2")},
+					MsgType: gossip.PullMsgType_BLOCK_MSG,
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.Contains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_LeadershipMsg{
+				LeadershipMsg: &gossip.LeadershipMessage{
+					Timestamp: &gossip.PeerTime{
+						IncNum: 1,
+						SeqNum: 1,
+					},
+					PkiId:         []byte{17},
+					IsDeclaration: true,
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+}
+
+func TestSignedGossipMessageSign(t *testing.T) {
+	idSigner := func(msg []byte) ([]byte, error) {
+		return msg, nil
+	}
+
+	errSigner := func(msg []byte) ([]byte, error) {
+		return nil, errors.New("Error")
+	}
+
+	msg := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("testChannelID"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_DataMsg{
+				DataMsg: &gossip.DataMessage{},
+			},
+		},
+	}
+	signedMsg, _ := msg.Sign(idSigner)
+
+	// Since checking the identity signer, signature will be same as the payload
+	assert.Equal(t, signedMsg.Payload, signedMsg.Signature)
+
+	env, err := msg.Sign(errSigner)
+	assert.Error(t, err)
+	assert.Nil(t, env)
+}
+
+func TestEnvelope_NoopSign(t *testing.T) {
+	msg := &gossip.GossipMessage{
+		Channel: []byte("testChannelID"),
+		Tag:     gossip.GossipMessage_EMPTY,
+		Content: &gossip.GossipMessage_DataMsg{
+			DataMsg: &gossip.DataMessage{},
+		},
+	}
+
+	signedMsg, err := protoext.NoopSign(msg)
+
+	// Since checking the identity signer, signature will be same as the payload
+	assert.Nil(t, signedMsg.Signature)
+	assert.NoError(t, err)
+}
+
+func TestSignedGossipMessage_Verify(t *testing.T) {
+	channelID := "testChannelID"
+	peerID := []byte("peer")
+
+	msg := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte(channelID),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_DataMsg{
+				DataMsg: &gossip.DataMessage{},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.True(t, msg.IsSigned())
+
+	verifier := func(peerIdentity []byte, signature, message []byte) error {
+		return nil
+	}
+	res := msg.Verify(peerID, verifier)
+	assert.Nil(t, res)
+
+	msg = &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte(channelID),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Content: &gossip.GossipMessage_DataMsg{
+				DataMsg: &gossip.DataMessage{},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+
+	env := msg.Envelope
+	msg.Envelope = nil
+	res = msg.Verify(peerID, verifier)
+	assert.Error(t, res)
+
+	msg.Envelope = env
+	payload := msg.Envelope.Payload
+	msg.Envelope.Payload = nil
+	res = msg.Verify(peerID, verifier)
+	assert.Error(t, res)
+
+	msg.Envelope.Payload = payload
+	sig := msg.Signature
+	msg.Signature = nil
+	res = msg.Verify(peerID, verifier)
+	assert.Error(t, res)
+	msg.Signature = sig
+
+	errVerifier := func(peerIdentity []byte, signature, message []byte) error {
+		return errors.New("Test")
+	}
+
+	res = msg.Verify(peerID, errVerifier)
+	assert.Error(t, res)
+}
+
+func TestEnvelope(t *testing.T) {
+	dataMsg := &gossip.GossipMessage{
+		Content: dataMessage(1, []byte("data")),
+	}
+	bytes, err := proto.Marshal(dataMsg)
+	assert.NoError(t, err)
+
+	env := envelopes()[0]
+	env.Payload = bytes
+
+	msg, err := protoext.EnvelopeToGossipMessage(env)
+	assert.NoError(t, err)
+	assert.NotNil(t, msg)
+
+	assert.True(t, protoext.IsDataMsg(msg.GossipMessage))
+}
+
+func TestEnvelope_SignSecret(t *testing.T) {
+	dataMsg := &gossip.GossipMessage{
+		Content: dataMessage(1, []byte("data")),
+	}
+	bytes, err := proto.Marshal(dataMsg)
+	assert.NoError(t, err)
+
+	env := envelopes()[0]
+	env.Payload = bytes
+	env.SecretEnvelope = nil
+
+	protoext.SignSecret(env, func(message []byte) ([]byte, error) {
+		return message, nil
+	}, &gossip.Secret{
+		Content: &gossip.Secret_InternalEndpoint{
+			InternalEndpoint: "localhost:5050",
+		},
+	})
+
+	assert.NotNil(t, env.SecretEnvelope)
+	assert.Equal(t, protoext.InternalEndpoint(env.SecretEnvelope), "localhost:5050")
+}
+
+func envelopes() []*gossip.Envelope {
+	return []*gossip.Envelope{
+		{Payload: []byte{2, 2, 2},
+			Signature: []byte{2, 2, 2},
+			SecretEnvelope: &gossip.SecretEnvelope{
+				Payload:   []byte{2, 2, 2},
+				Signature: []byte{2, 2, 2},
+			},
+		},
+	}
+}
diff --git a/gossip/protoext/stringers.go b/gossip/protoext/stringers.go
new file mode 100644
index 00000000..80b584cc
--- /dev/null
+++ b/gossip/protoext/stringers.go
@@ -0,0 +1,124 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext
+
+import (
+	"encoding/hex"
+	"fmt"
+
+	"github.com/gogo/protobuf/proto"
+	"github.com/hyperledger/fabric/protos/gossip"
+	"github.com/hyperledger/fabric/protos/msp"
+)
+
+// MemberToString prints Endpoint and PKI-id
+func MemberToString(m *gossip.Member) string {
+	return fmt.Sprint("Membership: Endpoint:", m.Endpoint, " PKI-id:", hex.EncodeToString(m.PkiId))
+}
+
+// MembershipResponseToString of MembershipResponse prints number of Alive and number of Dead
+func MembershipResponseToString(mr *gossip.MembershipResponse) string {
+	return fmt.Sprintf("MembershipResponse with Alive: %d, Dead: %d", len(mr.Alive), len(mr.Dead))
+}
+
+// AliveMessageToString of AliveMessage prints Alive Message, Identity and Timestamp
+func AliveMessageToString(am *gossip.AliveMessage) string {
+	if am.Membership == nil {
+		return "nil Membership"
+	}
+	var sI string
+	serializeIdentity := &msp.SerializedIdentity{}
+	if err := proto.Unmarshal(am.Identity, serializeIdentity); err == nil {
+		sI = serializeIdentity.Mspid + string(serializeIdentity.IdBytes)
+	}
+	return fmt.Sprint("Alive Message:", MemberToString(am.Membership), "Identity:", sI, "Timestamp:", am.Timestamp)
+}
+
+// PayloadToString prints Block message: Data and seq
+func PayloadToString(p *gossip.Payload) string {
+	return fmt.Sprintf("Block message: {Data: %d bytes, seq: %d}", len(p.Data), p.SeqNum)
+}
+
+// DataUpdateToString prints Type, items and nonce
+func DataUpdateToString(du *gossip.DataUpdate) string {
+	mType := gossip.PullMsgType_name[int32(du.MsgType)]
+	return fmt.Sprintf("Type: %s, items: %d, nonce: %d", mType, len(du.Data), du.Nonce)
+}
+
+// StateInfoSnapshotToString prints items
+func StateInfoSnapshotToString(sis *gossip.StateInfoSnapshot) string {
+	return fmt.Sprintf("StateInfoSnapshot with %d items", len(sis.Elements))
+}
+
+// MembershipRequestToString prints self information
+func MembershipRequestToString(mr *gossip.MembershipRequest) string {
+	if mr.SelfInformation == nil {
+		return ""
+	}
+	signGM, err := EnvelopeToGossipMessage(mr.SelfInformation)
+	if err != nil {
+		return ""
+	}
+	return fmt.Sprintf("Membership Request with self information of %s ", signGM.String())
+}
+
+// StateInfoPullRequestToString prints Channel MAC
+func StateInfoPullRequestToString(sipr *gossip.StateInfoPullRequest) string {
+	return fmt.Sprint("state_info_pull_req: Channel MAC:", hex.EncodeToString(sipr.Channel_MAC))
+}
+
+// StateInfoToString prints Timestamp and PKI-id
+func StateInfoToString(si *gossip.StateInfo) string {
+	return fmt.Sprint("state_info_message: Timestamp:", si.Timestamp, "PKI-id:", hex.EncodeToString(si.PkiId),
+		" channel MAC:", hex.EncodeToString(si.Channel_MAC), " properties:", si.Properties)
+}
+
+// formatDigests formats digest byte arrays into strings depending on the message type
+func formatDigests(msgType gossip.PullMsgType, givenDigests [][]byte) []string {
+	var digests []string
+	switch msgType {
+	case gossip.PullMsgType_BLOCK_MSG:
+		for _, digest := range givenDigests {
+			digests = append(digests, string(digest))
+		}
+	case gossip.PullMsgType_IDENTITY_MSG:
+		for _, digest := range givenDigests {
+			digests = append(digests, hex.EncodeToString(digest))
+		}
+
+	}
+	return digests
+}
+
+// DataDigestToString prints nonce, msg_type and digests
+func DataDigestToString(dig *gossip.DataDigest) string {
+	var digests []string
+	digests = formatDigests(dig.MsgType, dig.Digests)
+	return fmt.Sprintf("data_dig: nonce: %d , Msg_type: %s, digests: %v", dig.Nonce, dig.MsgType, digests)
+}
+
+// DataRequestToString prints nonce, msg_type and digests
+func DataRequestToString(dataReq *gossip.DataRequest) string {
+	var digests []string
+	digests = formatDigests(dataReq.MsgType, dataReq.Digests)
+	return fmt.Sprintf("data request: nonce: %d , Msg_type: %s, digests: %v", dataReq.Nonce, dataReq.MsgType, digests)
+}
+
+// LeadershipMessageToString prints PKI-id, Timestamp and Is Declaration
+func LeadershipMessageToString(lm *gossip.LeadershipMessage) string {
+	return fmt.Sprint("Leadership Message: PKI-id:", hex.EncodeToString(lm.PkiId), " Timestamp:", lm.Timestamp,
+		"Is Declaration ", lm.IsDeclaration)
+}
+
+// RemovePvtDataResponseToString returns a string representation of this RemotePvtDataResponse
+func RemovePvtDataResponseToString(res *gossip.RemotePvtDataResponse) string {
+	a := make([]string, len(res.Elements))
+	for i, el := range res.Elements {
+		a[i] = fmt.Sprintf("%s with %d elements", el.Digest.String(), len(el.Payload))
+	}
+	return fmt.Sprintf("%v", a)
+}
diff --git a/gossip/protoext/stringers_test.go b/gossip/protoext/stringers_test.go
new file mode 100644
index 00000000..9e33a642
--- /dev/null
+++ b/gossip/protoext/stringers_test.go
@@ -0,0 +1,210 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext_test
+
+import (
+	"testing"
+
+	"github.com/hyperledger/fabric/gossip/protoext"
+	"github.com/hyperledger/fabric/protos/gossip"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestMembershipResponseToString(t *testing.T) {
+	mr := &gossip.MembershipResponse{
+		Alive: envelopes(),
+		Dead:  envelopes(),
+	}
+	output := "MembershipResponse with Alive: 1, Dead: 1"
+	assert.Equal(t, output, protoext.MembershipResponseToString(mr))
+}
+
+func TestMembershipRequestToString(t *testing.T) {
+	gossipMessage := &gossip.GossipMessage{
+		Nonce:   5,
+		Channel: []byte("A"),
+		Tag:     0,
+		Content: &gossip.GossipMessage_DataMsg{
+			DataMsg: &gossip.DataMessage{
+				Payload: &gossip.Payload{
+					SeqNum: 3,
+					Data:   []byte{2, 2, 2, 2, 2},
+				},
+			},
+		},
+	}
+	nn, _ := protoext.NoopSign(gossipMessage)
+	sMsg := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Channel: []byte("A"),
+			Content: &gossip.GossipMessage_DataMsg{
+				DataMsg: &gossip.DataMessage{
+					Payload: &gossip.Payload{
+						SeqNum: 3,
+						Data:   []byte{2, 2, 2, 2, 2},
+					},
+				},
+			},
+		},
+		Envelope: &gossip.Envelope{
+			Payload:   nn.Envelope.Payload,
+			Signature: []byte{0, 1, 2},
+			SecretEnvelope: &gossip.SecretEnvelope{
+				Payload:   []byte{0, 1, 2, 3, 4, 5},
+				Signature: []byte{0, 1, 2},
+			},
+		},
+	}
+	mr := &gossip.MembershipRequest{
+		SelfInformation: sMsg.Envelope,
+		Known:           [][]byte{},
+	}
+
+	output := "Membership Request with self information of GossipMessage: Channel: A, nonce: 5, tag: UNDEFINED Block message: {Data: 5 bytes, seq: 3}, Envelope: 18 bytes, Signature: 3 bytes Secret payload: 6 bytes, Secret Signature: 3 bytes "
+	assert.Equal(t, output, protoext.MembershipRequestToString(mr))
+
+	mr1 := &gossip.MembershipRequest{
+		SelfInformation: &gossip.Envelope{
+			Payload:   []byte{1, 2, 3},
+			Signature: []byte{0, 1, 2},
+			SecretEnvelope: &gossip.SecretEnvelope{
+				Payload:   []byte{0, 1, 2, 3, 4, 5},
+				Signature: []byte{0, 1, 2},
+			},
+		},
+		Known: [][]byte{},
+	}
+	assert.Equal(t, "", protoext.MembershipRequestToString(mr1))
+
+	mr2 := &gossip.MembershipRequest{
+		SelfInformation: nil,
+		Known:           [][]byte{},
+	}
+
+	assert.Equal(t, "", protoext.MembershipRequestToString(mr2))
+}
+
+func TestToStringMember(t *testing.T) {
+	member := &gossip.Member{
+		Endpoint: "localhost",
+		Metadata: []byte{1, 2, 3, 4, 5},
+		PkiId:    []byte{15},
+	}
+	output := "Membership: Endpoint:localhost PKI-id:0f"
+	assert.Equal(t, output, protoext.MemberToString(member))
+}
+
+func TestToStringAliveMessage(t *testing.T) {
+	am1 := &gossip.AliveMessage{
+		Membership: &gossip.Member{
+			Endpoint: "localhost",
+			Metadata: []byte{1, 2, 3, 4, 5},
+			PkiId:    []byte{17},
+		},
+		Timestamp: &gossip.PeerTime{
+			IncNum: 1,
+			SeqNum: 1,
+		},
+		Identity: []byte("peerID1"),
+	}
+	output1 := "Alive Message:Membership: Endpoint:localhost PKI-id:11Identity:Timestamp:inc_num:1 seq_num:1 "
+	assert.Equal(t, output1, protoext.AliveMessageToString(am1))
+	am2 := &gossip.AliveMessage{
+		Membership: nil,
+		Timestamp: &gossip.PeerTime{
+			IncNum: 1,
+			SeqNum: 1,
+		},
+		Identity: []byte("peerID1"),
+	}
+	output2 := "nil Membership"
+	assert.Equal(t, output2, protoext.AliveMessageToString(am2))
+}
+
+func TestToStringStateInfoPullRequest(t *testing.T) {
+	// Create State info pull request
+	sipr := &gossip.StateInfoPullRequest{
+		Channel_MAC: []byte{17},
+	}
+
+	output := "state_info_pull_req: Channel MAC:11"
+	assert.Equal(t, output, protoext.StateInfoPullRequestToString(sipr))
+}
+
+func TestToStringStateInfo(t *testing.T) {
+	si := &gossip.StateInfo{
+		Timestamp: &gossip.PeerTime{
+			IncNum: 1,
+			SeqNum: 1,
+		},
+		PkiId:       []byte{17},
+		Channel_MAC: []byte{17},
+		Properties:  nil,
+	}
+	output := "state_info_message: Timestamp:inc_num:1 seq_num:1 PKI-id:11 channel MAC:11 properties:<nil>"
+	assert.Equal(t, output, protoext.StateInfoToString(si))
+}
+
+func TestToStringDataDigest(t *testing.T) {
+	dig1 := &gossip.DataDigest{
+		Nonce:   0,
+		Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		MsgType: gossip.PullMsgType_BLOCK_MSG,
+	}
+	output1 := "data_dig: nonce: 0 , Msg_type: BLOCK_MSG, digests: [msg1 msg2 msg3]"
+	assert.Equal(t, output1, protoext.DataDigestToString(dig1))
+	dig2 := &gossip.DataDigest{
+		Nonce:   0,
+		Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		MsgType: gossip.PullMsgType_IDENTITY_MSG,
+	}
+	output2 := "data_dig: nonce: 0 , Msg_type: IDENTITY_MSG, digests: [6d736731 6d736732 6d736733]"
+	assert.Equal(t, output2, protoext.DataDigestToString(dig2))
+}
+
+func TestToStringDataRequest(t *testing.T) {
+	dataReq1 := &gossip.DataRequest{
+		Nonce:   0,
+		Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		MsgType: gossip.PullMsgType_BLOCK_MSG,
+	}
+	output1 := "data request: nonce: 0 , Msg_type: BLOCK_MSG, digests: [msg1 msg2 msg3]"
+	assert.Equal(t, output1, protoext.DataRequestToString(dataReq1))
+	dataReq2 := &gossip.DataRequest{
+		Nonce:   0,
+		Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		MsgType: gossip.PullMsgType_IDENTITY_MSG,
+	}
+	output2 := "data request: nonce: 0 , Msg_type: IDENTITY_MSG, digests: [6d736731 6d736732 6d736733]"
+	assert.Equal(t, output2, protoext.DataRequestToString(dataReq2))
+}
+
+func TestToStringLeadershipMessage(t *testing.T) {
+	lm := &gossip.LeadershipMessage{
+		Timestamp: &gossip.PeerTime{
+			IncNum: 1,
+			SeqNum: 1,
+		},
+		PkiId:         []byte{17},
+		IsDeclaration: true,
+	}
+	output := "Leadership Message: PKI-id:11 Timestamp:inc_num:1 seq_num:1 Is Declaration true"
+	assert.Equal(t, output, protoext.LeadershipMessageToString(lm))
+}
+
+func TestRemotePvtDataResponseToString(t *testing.T) {
+	res := &gossip.RemotePvtDataResponse{
+		Elements: []*gossip.PvtDataElement{
+			{Digest: &gossip.PvtDataDigest{TxId: "tx-id"}, Payload: [][]byte{[]byte("abcde")}},
+		},
+	}
+
+	output := `[tx_id:"tx-id"  with 1 elements]`
+	assert.Equal(t, output, protoext.RemovePvtDataResponseToString(res))
+}
diff --git a/gossip/service/join_test.go b/gossip/service/join_test.go
index 2bd1c5d8..ce03bfc5 100644
--- a/gossip/service/join_test.go
+++ b/gossip/service/join_test.go
@@ -18,6 +18,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/filter"
 	"github.com/hyperledger/fabric/gossip/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/peer"
@@ -40,7 +41,7 @@ type gossipMock struct {
 	mock.Mock
 }
 
-func (g *gossipMock) SelfChannelInfo(common.ChainID) *proto.SignedGossipMessage {
+func (g *gossipMock) SelfChannelInfo(common.ChainID) *protoext.SignedGossipMessage {
 	panic("implement me")
 }
 
@@ -88,7 +89,7 @@ func (*gossipMock) Gossip(msg *proto.GossipMessage) {
 	panic("implement me")
 }
 
-func (*gossipMock) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (*gossipMock) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	panic("implement me")
 }
 
@@ -108,7 +109,7 @@ func (*gossipMock) Stop() {
 	panic("implement me")
 }
 
-func (*gossipMock) SendByCriteria(*proto.SignedGossipMessage, gossip.SendCriteria) error {
+func (*gossipMock) SendByCriteria(*protoext.SignedGossipMessage, gossip.SendCriteria) error {
 	panic("implement me")
 }
 
diff --git a/gossip/state/metrics_test.go b/gossip/state/metrics_test.go
index 8fd3d5b9..6187f7d9 100644
--- a/gossip/state/metrics_test.go
+++ b/gossip/state/metrics_test.go
@@ -13,6 +13,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	gmetricsmocks "github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/state/mocks"
 	pcomm "github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
@@ -29,7 +30,7 @@ func TestMetrics(t *testing.T) {
 	g := &mocks.GossipMock{}
 	g.On("PeersOfChannel", mock.Anything).Return([]discovery.NetworkMember{})
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 
 	heightWG := sync.WaitGroup{}
 	heightWG.Add(1)
diff --git a/gossip/state/mocks/gossip.go b/gossip/state/mocks/gossip.go
index 1aafdbb4..be8911b9 100644
--- a/gossip/state/mocks/gossip.go
+++ b/gossip/state/mocks/gossip.go
@@ -13,6 +13,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/filter"
 	"github.com/hyperledger/fabric/gossip/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/mock"
 )
@@ -25,7 +26,7 @@ func (g *GossipMock) SelfMembershipInfo() discovery.NetworkMember {
 	panic("implement me")
 }
 
-func (g *GossipMock) SelfChannelInfo(common.ChainID) *proto.SignedGossipMessage {
+func (g *GossipMock) SelfChannelInfo(common.ChainID) *protoext.SignedGossipMessage {
 	panic("implement me")
 }
 
@@ -74,10 +75,10 @@ func (g *GossipMock) Gossip(msg *proto.GossipMessage) {
 	g.Called(msg)
 }
 
-func (g *GossipMock) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (g *GossipMock) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	args := g.Called(acceptor, passThrough)
 	if args.Get(0) == nil {
-		return nil, args.Get(1).(chan proto.ReceivedMessage)
+		return nil, args.Get(1).(chan protoext.ReceivedMessage)
 	}
 	return args.Get(0).(<-chan *proto.GossipMessage), nil
 }
@@ -94,6 +95,6 @@ func (g *GossipMock) Stop() {
 
 }
 
-func (g *GossipMock) SendByCriteria(*proto.SignedGossipMessage, gossip.SendCriteria) error {
+func (g *GossipMock) SendByCriteria(*protoext.SignedGossipMessage, gossip.SendCriteria) error {
 	return nil
 }
diff --git a/gossip/state/state.go b/gossip/state/state.go
index 7f1c4dde..0bf845a2 100644
--- a/gossip/state/state.go
+++ b/gossip/state/state.go
@@ -19,6 +19,7 @@ import (
 	common2 "github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	"github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
@@ -74,7 +75,7 @@ type GossipAdapter interface {
 	// If passThrough is false, the messages are processed by the gossip layer beforehand.
 	// If passThrough is true, the gossip layer doesn't intervene and the messages
 	// can be used to send a reply back to the sender
-	Accept(acceptor common2.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	Accept(acceptor common2.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 
 	// UpdateLedgerHeight updates the ledger height the peer
 	// publishes to other peers in the channel
@@ -136,7 +137,7 @@ type ServicesMediator struct {
 }
 
 type messageDispatcher interface {
-	Dispatch(msg proto.ReceivedMessage) bool
+	Dispatch(msg protoext.ReceivedMessage) bool
 }
 
 // GossipStateProviderImpl the implementation of the GossipStateProvider interface
@@ -151,16 +152,16 @@ type GossipStateProviderImpl struct {
 	// Channel to read gossip messages from
 	gossipChan <-chan *proto.GossipMessage
 
-	commChan <-chan proto.ReceivedMessage
+	commChan <-chan protoext.ReceivedMessage
 
 	// Queue of payloads which wasn't acquired yet
 	payloads PayloadsBuffer
 
 	ledger ledgerResources
 
-	stateResponseCh chan proto.ReceivedMessage
+	stateResponseCh chan protoext.ReceivedMessage
 
-	stateRequestCh chan proto.ReceivedMessage
+	stateRequestCh chan protoext.ReceivedMessage
 
 	stopCh chan struct{}
 
@@ -204,14 +205,14 @@ func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger l
 
 	gossipChan, _ := services.Accept(func(message interface{}) bool {
 		// Get only data messages
-		return message.(*proto.GossipMessage).IsDataMsg() &&
+		return protoext.IsDataMsg(message.(*proto.GossipMessage)) &&
 			bytes.Equal(message.(*proto.GossipMessage).Channel, []byte(chainID))
 	}, false)
 
 	remoteStateMsgFilter := func(message interface{}) bool {
-		receivedMsg := message.(proto.ReceivedMessage)
+		receivedMsg := message.(protoext.ReceivedMessage)
 		msg := receivedMsg.GetGossipMessage()
-		if !(msg.IsRemoteStateMessage() || msg.GetPrivateData() != nil ||
+		if !(protoext.IsRemoteStateMessage(msg.GossipMessage) || msg.GetPrivateData() != nil ||
 			msg.GetCollDataReq() != nil || msg.GetCollDataRes() != nil) {
 			return false
 		}
@@ -267,9 +268,9 @@ func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger l
 
 		ledger: ledger,
 
-		stateResponseCh: make(chan proto.ReceivedMessage, config.ChannelBufferSize),
+		stateResponseCh: make(chan protoext.ReceivedMessage, config.ChannelBufferSize),
 
-		stateRequestCh: make(chan proto.ReceivedMessage, config.ChannelBufferSize),
+		stateRequestCh: make(chan protoext.ReceivedMessage, config.ChannelBufferSize),
 
 		stopCh: make(chan struct{}, 1),
 
@@ -325,9 +326,9 @@ func (s *GossipStateProviderImpl) listen() {
 		}
 	}
 }
-func (s *GossipStateProviderImpl) dispatch(msg proto.ReceivedMessage) {
+func (s *GossipStateProviderImpl) dispatch(msg protoext.ReceivedMessage) {
 	// Check type of the message
-	if msg.GetGossipMessage().IsRemoteStateMessage() {
+	if protoext.IsRemoteStateMessage(msg.GetGossipMessage().GossipMessage) {
 		logger.Debug("Handling direct state transfer message")
 		// Got state transfer request response
 		s.directMessage(msg)
@@ -342,7 +343,7 @@ func (s *GossipStateProviderImpl) dispatch(msg proto.ReceivedMessage) {
 	}
 
 }
-func (s *GossipStateProviderImpl) privateDataMessage(msg proto.ReceivedMessage) {
+func (s *GossipStateProviderImpl) privateDataMessage(msg protoext.ReceivedMessage) {
 	if !bytes.Equal(msg.GetGossipMessage().Channel, []byte(s.chainID)) {
 		logger.Warning("Received state transfer request for channel",
 			string(msg.GetGossipMessage().Channel), "while expecting channel", s.chainID, "skipping request...")
@@ -393,7 +394,7 @@ func (s *GossipStateProviderImpl) privateDataMessage(msg proto.ReceivedMessage)
 	logger.Debug("Private data for collection", collectionName, "has been stored")
 }
 
-func (s *GossipStateProviderImpl) directMessage(msg proto.ReceivedMessage) {
+func (s *GossipStateProviderImpl) directMessage(msg protoext.ReceivedMessage) {
 	logger.Debug("[ENTER] -> directMessage")
 	defer logger.Debug("[EXIT] ->  directMessage")
 
@@ -442,7 +443,7 @@ func (s *GossipStateProviderImpl) processStateRequests() {
 
 // handleStateRequest handles state request message, validate batch size, reads current leader state to
 // obtain required blocks, builds response message and send it back
-func (s *GossipStateProviderImpl) handleStateRequest(msg proto.ReceivedMessage) {
+func (s *GossipStateProviderImpl) handleStateRequest(msg protoext.ReceivedMessage) {
 	if msg == nil {
 		return
 	}
@@ -520,7 +521,7 @@ func (s *GossipStateProviderImpl) handleStateRequest(msg proto.ReceivedMessage)
 	})
 }
 
-func (s *GossipStateProviderImpl) handleStateResponse(msg proto.ReceivedMessage) (uint64, error) {
+func (s *GossipStateProviderImpl) handleStateResponse(msg protoext.ReceivedMessage) (uint64, error) {
 	max := uint64(0)
 	// Send signal that response for given nonce has been received
 	response := msg.GetGossipMessage().GetStateResponse()
diff --git a/gossip/state/state_test.go b/gossip/state/state_test.go
index c9ef87f4..3b136a84 100644
--- a/gossip/state/state_test.go
+++ b/gossip/state/state_test.go
@@ -39,6 +39,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/channel"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/privdata"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/state/mocks"
 	gossiputil "github.com/hyperledger/fabric/gossip/util"
 	gutil "github.com/hyperledger/fabric/gossip/util"
@@ -469,12 +470,12 @@ func TestNilDirectMsg(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNodeWithGossip(0, mc, noopPeerIdentityAcceptor, g)
 	defer p.shutdown()
 	p.s.handleStateRequest(nil)
 	p.s.directMessage(nil)
-	sMsg, _ := p.s.stateRequestMessage(uint64(10), uint64(8)).NoopSign()
+	sMsg, _ := protoext.NoopSign(p.s.stateRequestMessage(uint64(10), uint64(8)))
 	req := &comm.ReceivedMessageImpl{
 		SignedGossipMessage: sMsg,
 	}
@@ -487,7 +488,7 @@ func TestNilAddPayload(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNodeWithGossip(0, mc, noopPeerIdentityAcceptor, g)
 	defer p.shutdown()
 	err := p.s.AddPayload(nil)
@@ -501,7 +502,7 @@ func TestAddPayloadLedgerUnavailable(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNodeWithGossip(0, mc, noopPeerIdentityAcceptor, g)
 	defer p.shutdown()
 	// Simulate a problem in the ledger
@@ -533,7 +534,7 @@ func TestLargeBlockGap(t *testing.T) {
 	mc.On("CommitWithPvtData", mock.Anything).Run(func(arg mock.Arguments) {
 		blocksPassedToLedger <- arg.Get(0).(*pcomm.Block).Header.Number
 	})
-	msgsFromPeer := make(chan proto.ReceivedMessage)
+	msgsFromPeer := make(chan protoext.ReceivedMessage)
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	g := &mocks.GossipMock{}
 	membership := []discovery.NetworkMember{
@@ -570,7 +571,7 @@ func TestLargeBlockGap(t *testing.T) {
 			res.GetStateResponse().Payloads = append(res.GetStateResponse().Payloads, payload)
 		}
 		// Finally, send the response down the channel the peer expects to receive it from
-		sMsg, _ := res.NoopSign()
+		sMsg, _ := protoext.NoopSign(res)
 		msgsFromPeer <- &comm.ReceivedMessageImpl{
 			SignedGossipMessage: sMsg,
 		}
@@ -607,7 +608,7 @@ func TestOverPopulation(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNode(0, mc, noopPeerIdentityAcceptor)
 	defer p.shutdown()
 
@@ -670,7 +671,7 @@ func TestBlockingEnqueue(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNode(0, mc, noopPeerIdentityAcceptor)
 	defer p.shutdown()
 
@@ -770,7 +771,7 @@ func TestHaltChainProcessing(t *testing.T) {
 	gossipMsgs := make(chan *proto.GossipMessage)
 
 	g.On("Accept", mock.Anything, false).Return(gossipChannel(gossipMsgs), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	g.On("PeersOfChannel", mock.Anything).Return([]discovery.NetworkMember{})
 
 	v := &validator.MockValidator{}
@@ -791,7 +792,7 @@ func TestFailures(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(0), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	g.On("PeersOfChannel", mock.Anything).Return([]discovery.NetworkMember{})
 	assert.Panics(t, func() {
 		newPeerNodeWithGossip(0, mc, noopPeerIdentityAcceptor, g)
@@ -855,7 +856,7 @@ func TestGossipReception(t *testing.T) {
 	g.On("Accept", mock.Anything, false).Return(rmc, nil).Run(func(_ mock.Arguments) {
 		signalChan <- struct{}{}
 	})
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	g.On("PeersOfChannel", mock.Anything).Return([]discovery.NetworkMember{})
 	mc := &mockCommitter{Mock: &mock.Mock{}}
 	receivedChan := make(chan struct{})
@@ -897,7 +898,7 @@ func TestLedgerHeightFromProperties(t *testing.T) {
 			finChan <- struct{}{}
 		})
 		g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-		g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+		g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 		defaultPeer := discovery.NetworkMember{
 			InternalEndpoint: "b",
 			PKIid:            common.PKIidType("b"),
@@ -1148,7 +1149,7 @@ func TestGossipStateProvider_TestStateMessages(t *testing.T) {
 	defer peer.shutdown()
 
 	naiveStateMsgPredicate := func(message interface{}) bool {
-		return message.(proto.ReceivedMessage).GetGossipMessage().IsRemoteStateMessage()
+		return protoext.IsRemoteStateMessage(message.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}
 
 	_, bootCh := bootPeer.g.Accept(naiveStateMsgPredicate, true)
@@ -1233,7 +1234,7 @@ func TestNewGossipStateProvider_BatchingOfStateRequest(t *testing.T) {
 	defer peer.shutdown()
 
 	naiveStateMsgPredicate := func(message interface{}) bool {
-		return message.(proto.ReceivedMessage).GetGossipMessage().IsRemoteStateMessage()
+		return protoext.IsRemoteStateMessage(message.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}
 	_, peerCh := peer.g.Accept(naiveStateMsgPredicate, true)
 
@@ -1347,9 +1348,9 @@ func (mock *receivedMessageMock) Respond(msg *proto.GossipMessage) {
 	mock.Called(msg)
 }
 
-func (mock *receivedMessageMock) GetGossipMessage() *proto.SignedGossipMessage {
+func (mock *receivedMessageMock) GetGossipMessage() *protoext.SignedGossipMessage {
 	args := mock.Called()
-	return args.Get(0).(*proto.SignedGossipMessage)
+	return args.Get(0).(*protoext.SignedGossipMessage)
 }
 
 func (mock *receivedMessageMock) GetSourceEnvelope() *proto.Envelope {
@@ -1357,9 +1358,9 @@ func (mock *receivedMessageMock) GetSourceEnvelope() *proto.Envelope {
 	return args.Get(0).(*proto.Envelope)
 }
 
-func (mock *receivedMessageMock) GetConnectionInfo() *proto.ConnectionInfo {
+func (mock *receivedMessageMock) GetConnectionInfo() *protoext.ConnectionInfo {
 	args := mock.Called()
-	return args.Get(0).(*proto.ConnectionInfo)
+	return args.Get(0).(*protoext.ConnectionInfo)
 }
 
 type testData struct {
@@ -1376,7 +1377,7 @@ func TestTransferOfPrivateRWSet(t *testing.T) {
 	coord1 := new(coordinatorMock)
 
 	gossipChannel := make(chan *proto.GossipMessage)
-	commChannel := make(chan proto.ReceivedMessage)
+	commChannel := make(chan protoext.ReceivedMessage)
 
 	gossipChannelFactory := func(ch chan *proto.GossipMessage) <-chan *proto.GossipMessage {
 		return ch
@@ -1483,15 +1484,15 @@ func TestTransferOfPrivateRWSet(t *testing.T) {
 		}},
 	}
 
-	msg, _ := requestGossipMsg.NoopSign()
+	msg, _ := protoext.NoopSign(requestGossipMsg)
 
 	requestMsg.On("GetGossipMessage").Return(msg)
-	requestMsg.On("GetConnectionInfo").Return(&proto.ConnectionInfo{
-		Auth: &proto.AuthInfo{},
+	requestMsg.On("GetConnectionInfo").Return(&protoext.ConnectionInfo{
+		Auth: &protoext.AuthInfo{},
 	})
 
 	// Channel to send responses back
-	responseChannel := make(chan proto.ReceivedMessage)
+	responseChannel := make(chan protoext.ReceivedMessage)
 	defer close(responseChannel)
 
 	requestMsg.On("Respond", mock.Anything).Run(func(args mock.Arguments) {
@@ -1500,7 +1501,7 @@ func TestTransferOfPrivateRWSet(t *testing.T) {
 		// Wrap it up into received response
 		receivedMsg := new(receivedMessageMock)
 		// Create sign response
-		msg, _ := response.NoopSign()
+		msg, _ := protoext.NoopSign(response)
 		// Mock to respond
 		receivedMsg.On("GetGossipMessage").Return(msg)
 		// Send response
@@ -1556,7 +1557,7 @@ type testPeer struct {
 	*mocks.GossipMock
 	id            string
 	gossipChannel chan *proto.GossipMessage
-	commChannel   chan proto.ReceivedMessage
+	commChannel   chan protoext.ReceivedMessage
 	coord         *coordinatorMock
 }
 
@@ -1564,7 +1565,7 @@ func (t testPeer) Gossip() <-chan *proto.GossipMessage {
 	return t.gossipChannel
 }
 
-func (t testPeer) Comm() chan proto.ReceivedMessage {
+func (t testPeer) Comm() chan protoext.ReceivedMessage {
 	return t.commChannel
 }
 
@@ -1572,14 +1573,14 @@ var peers = map[string]testPeer{
 	"peer1": {
 		id:            "peer1",
 		gossipChannel: make(chan *proto.GossipMessage),
-		commChannel:   make(chan proto.ReceivedMessage),
+		commChannel:   make(chan protoext.ReceivedMessage),
 		GossipMock:    &mocks.GossipMock{},
 		coord:         new(coordinatorMock),
 	},
 	"peer2": {
 		id:            "peer2",
 		gossipChannel: make(chan *proto.GossipMessage),
-		commChannel:   make(chan proto.ReceivedMessage),
+		commChannel:   make(chan protoext.ReceivedMessage),
 		GossipMock:    &mocks.GossipMock{},
 		coord:         new(coordinatorMock),
 	},
@@ -1605,7 +1606,7 @@ func TestTransferOfPvtDataBetweenPeers(t *testing.T) {
 			Return(nil, peer.Comm()).
 			Once().
 			On("Accept", mock.Anything, true).
-			Return(nil, make(chan proto.ReceivedMessage))
+			Return(nil, make(chan protoext.ReceivedMessage))
 
 		peer.On("UpdateChannelMetadata", mock.Anything, mock.Anything)
 		peer.coord.On("Close")
@@ -1670,16 +1671,16 @@ func TestTransferOfPvtDataBetweenPeers(t *testing.T) {
 	peers["peer2"].On("Send", mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
 		request := args.Get(0).(*proto.GossipMessage)
 		requestMsg := new(receivedMessageMock)
-		msg, _ := request.NoopSign()
+		msg, _ := protoext.NoopSign(request)
 		requestMsg.On("GetGossipMessage").Return(msg)
-		requestMsg.On("GetConnectionInfo").Return(&proto.ConnectionInfo{
-			Auth: &proto.AuthInfo{},
+		requestMsg.On("GetConnectionInfo").Return(&protoext.ConnectionInfo{
+			Auth: &protoext.AuthInfo{},
 		})
 
 		requestMsg.On("Respond", mock.Anything).Run(func(args mock.Arguments) {
 			response := args.Get(0).(*proto.GossipMessage)
 			receivedMsg := new(receivedMessageMock)
-			msg, _ := response.NoopSign()
+			msg, _ := protoext.NoopSign(response)
 			receivedMsg.On("GetGossipMessage").Return(msg)
 			// Send response back to the peer
 			peers["peer2"].commChannel <- receivedMsg
diff --git a/gossip/util/msgs.go b/gossip/util/msgs.go
index 2366da80..0904c866 100644
--- a/gossip/util/msgs.go
+++ b/gossip/util/msgs.go
@@ -10,24 +10,24 @@ import (
 	"sync"
 
 	"github.com/hyperledger/fabric/gossip/common"
-	proto "github.com/hyperledger/fabric/protos/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 )
 
 // MembershipStore struct which encapsulates
 // membership message store abstraction
 type MembershipStore struct {
-	m map[string]*proto.SignedGossipMessage
+	m map[string]*protoext.SignedGossipMessage
 	sync.RWMutex
 }
 
 // NewMembershipStore creates new membership store instance
 func NewMembershipStore() *MembershipStore {
-	return &MembershipStore{m: make(map[string]*proto.SignedGossipMessage)}
+	return &MembershipStore{m: make(map[string]*protoext.SignedGossipMessage)}
 }
 
 // MsgByID returns a message stored by a certain ID, or nil
 // if such an ID isn't found
-func (m *MembershipStore) MsgByID(pkiID common.PKIidType) *proto.SignedGossipMessage {
+func (m *MembershipStore) MsgByID(pkiID common.PKIidType) *protoext.SignedGossipMessage {
 	m.RLock()
 	defer m.RUnlock()
 	if msg, exists := m.m[string(pkiID)]; exists {
@@ -44,7 +44,7 @@ func (m *MembershipStore) Size() int {
 }
 
 // Put associates msg with the given pkiID
-func (m *MembershipStore) Put(pkiID common.PKIidType, msg *proto.SignedGossipMessage) {
+func (m *MembershipStore) Put(pkiID common.PKIidType, msg *protoext.SignedGossipMessage) {
 	m.Lock()
 	defer m.Unlock()
 	m.m[string(pkiID)] = msg
@@ -59,10 +59,10 @@ func (m *MembershipStore) Remove(pkiID common.PKIidType) {
 
 // ToSlice returns a slice backed by the elements
 // of the MembershipStore
-func (m *MembershipStore) ToSlice() []*proto.SignedGossipMessage {
+func (m *MembershipStore) ToSlice() []*protoext.SignedGossipMessage {
 	m.RLock()
 	defer m.RUnlock()
-	members := make([]*proto.SignedGossipMessage, len(m.m))
+	members := make([]*protoext.SignedGossipMessage, len(m.m))
 	i := 0
 	for _, member := range m.m {
 		members[i] = member
diff --git a/gossip/util/msgs_test.go b/gossip/util/msgs_test.go
index cf4a9dce..17d7aedf 100644
--- a/gossip/util/msgs_test.go
+++ b/gossip/util/msgs_test.go
@@ -10,6 +10,7 @@ import (
 	"testing"
 
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
@@ -24,8 +25,8 @@ func TestMembershipStore(t *testing.T) {
 	id1 := common.PKIidType("id1")
 	id2 := common.PKIidType("id2")
 
-	msg1 := &proto.SignedGossipMessage{}
-	msg2 := &proto.SignedGossipMessage{Envelope: &proto.Envelope{}}
+	msg1 := &protoext.SignedGossipMessage{}
+	msg2 := &protoext.SignedGossipMessage{Envelope: &proto.Envelope{}}
 
 	// Test initially created store is empty
 	assert.Nil(t, membershipStore.MsgByID(id1))
@@ -44,8 +45,8 @@ func TestMembershipStore(t *testing.T) {
 	assert.Nil(t, membershipStore.MsgByID(id1))
 	assert.Equal(t, membershipStore.Size(), 1)
 	// Test returned instance is not a copy
-	msg3 := &proto.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
-	msg3Clone := &proto.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
+	msg3 := &protoext.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
+	msg3Clone := &protoext.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
 	id3 := common.PKIidType("id3")
 	membershipStore.Put(id3, msg3)
 	assert.Equal(t, msg3Clone, msg3)
@@ -60,10 +61,10 @@ func TestToSlice(t *testing.T) {
 	id3 := common.PKIidType("id3")
 	id4 := common.PKIidType("id4")
 
-	msg1 := &proto.SignedGossipMessage{}
-	msg2 := &proto.SignedGossipMessage{Envelope: &proto.Envelope{}}
-	msg3 := &proto.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
-	msg4 := &proto.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}, Envelope: &proto.Envelope{}}
+	msg1 := &protoext.SignedGossipMessage{}
+	msg2 := &protoext.SignedGossipMessage{Envelope: &proto.Envelope{}}
+	msg3 := &protoext.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
+	msg4 := &protoext.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}, Envelope: &proto.Envelope{}}
 
 	membershipStore.Put(id1, msg1)
 	membershipStore.Put(id2, msg2)
@@ -72,7 +73,7 @@ func TestToSlice(t *testing.T) {
 
 	assert.Len(t, membershipStore.ToSlice(), 4)
 
-	existsInSlice := func(slice []*proto.SignedGossipMessage, msg *proto.SignedGossipMessage) bool {
+	existsInSlice := func(slice []*protoext.SignedGossipMessage, msg *protoext.SignedGossipMessage) bool {
 		for _, m := range slice {
 			if assert.ObjectsAreEqual(m, msg) {
 				return true
@@ -81,7 +82,7 @@ func TestToSlice(t *testing.T) {
 		return false
 	}
 
-	expectedMsgs := []*proto.SignedGossipMessage{msg1, msg2, msg3, msg4}
+	expectedMsgs := []*protoext.SignedGossipMessage{msg1, msg2, msg3, msg4}
 	for _, msg := range membershipStore.ToSlice() {
 		assert.True(t, existsInSlice(expectedMsgs, msg))
 	}
diff --git a/protos/common/collection.pb.go b/protos/common/collection.pb.go
index 82283037..d04d991b 100644
--- a/protos/common/collection.pb.go
+++ b/protos/common/collection.pb.go
@@ -25,24 +25,30 @@ const (
 	CollectionType_COL_UNKNOWN   CollectionType = 0
 	CollectionType_COL_PRIVATE   CollectionType = 1
 	CollectionType_COL_TRANSIENT CollectionType = 2
+	CollectionType_COL_OFFLEDGER CollectionType = 3
+	CollectionType_COL_DCAS      CollectionType = 4
 )
 
 var CollectionType_name = map[int32]string{
 	0: "COL_UNKNOWN",
 	1: "COL_PRIVATE",
 	2: "COL_TRANSIENT",
+	3: "COL_OFFLEDGER",
+	4: "COL_DCAS",
 }
 var CollectionType_value = map[string]int32{
 	"COL_UNKNOWN":   0,
 	"COL_PRIVATE":   1,
 	"COL_TRANSIENT": 2,
+	"COL_OFFLEDGER": 3,
+	"COL_DCAS":      4,
 }
 
 func (x CollectionType) String() string {
 	return proto.EnumName(CollectionType_name, int32(x))
 }
 func (CollectionType) EnumDescriptor() ([]byte, []int) {
-	return fileDescriptor_collection_28cf416bb2053e64, []int{0}
+	return fileDescriptor_collection_c4f7076c0a86910e, []int{0}
 }
 
 // CollectionConfigPackage represents an array of CollectionConfig
@@ -59,7 +65,7 @@ func (m *CollectionConfigPackage) Reset()         { *m = CollectionConfigPackage
 func (m *CollectionConfigPackage) String() string { return proto.CompactTextString(m) }
 func (*CollectionConfigPackage) ProtoMessage()    {}
 func (*CollectionConfigPackage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_28cf416bb2053e64, []int{0}
+	return fileDescriptor_collection_c4f7076c0a86910e, []int{0}
 }
 func (m *CollectionConfigPackage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollectionConfigPackage.Unmarshal(m, b)
@@ -102,7 +108,7 @@ func (m *CollectionConfig) Reset()         { *m = CollectionConfig{} }
 func (m *CollectionConfig) String() string { return proto.CompactTextString(m) }
 func (*CollectionConfig) ProtoMessage()    {}
 func (*CollectionConfig) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_28cf416bb2053e64, []int{1}
+	return fileDescriptor_collection_c4f7076c0a86910e, []int{1}
 }
 func (m *CollectionConfig) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollectionConfig.Unmarshal(m, b)
@@ -244,7 +250,7 @@ func (m *StaticCollectionConfig) Reset()         { *m = StaticCollectionConfig{}
 func (m *StaticCollectionConfig) String() string { return proto.CompactTextString(m) }
 func (*StaticCollectionConfig) ProtoMessage()    {}
 func (*StaticCollectionConfig) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_28cf416bb2053e64, []int{2}
+	return fileDescriptor_collection_c4f7076c0a86910e, []int{2}
 }
 func (m *StaticCollectionConfig) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_StaticCollectionConfig.Unmarshal(m, b)
@@ -337,7 +343,7 @@ func (m *CollectionPolicyConfig) Reset()         { *m = CollectionPolicyConfig{}
 func (m *CollectionPolicyConfig) String() string { return proto.CompactTextString(m) }
 func (*CollectionPolicyConfig) ProtoMessage()    {}
 func (*CollectionPolicyConfig) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_28cf416bb2053e64, []int{3}
+	return fileDescriptor_collection_c4f7076c0a86910e, []int{3}
 }
 func (m *CollectionPolicyConfig) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollectionPolicyConfig.Unmarshal(m, b)
@@ -452,7 +458,7 @@ func (m *CollectionCriteria) Reset()         { *m = CollectionCriteria{} }
 func (m *CollectionCriteria) String() string { return proto.CompactTextString(m) }
 func (*CollectionCriteria) ProtoMessage()    {}
 func (*CollectionCriteria) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_28cf416bb2053e64, []int{4}
+	return fileDescriptor_collection_c4f7076c0a86910e, []int{4}
 }
 func (m *CollectionCriteria) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollectionCriteria.Unmarshal(m, b)
@@ -509,44 +515,45 @@ func init() {
 	proto.RegisterEnum("common.CollectionType", CollectionType_name, CollectionType_value)
 }
 
-func init() { proto.RegisterFile("common/collection.proto", fileDescriptor_collection_28cf416bb2053e64) }
-
-var fileDescriptor_collection_28cf416bb2053e64 = []byte{
-	// 569 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0x51, 0x4f, 0xdb, 0x3c,
-	0x14, 0x25, 0x50, 0xca, 0xd7, 0xdb, 0x0f, 0x08, 0x46, 0x2b, 0xd1, 0x34, 0xb1, 0xae, 0xda, 0x43,
-	0x34, 0xa6, 0x76, 0x62, 0xbf, 0x00, 0xaa, 0x4a, 0x20, 0x4a, 0xa9, 0x4c, 0xb7, 0x49, 0xbc, 0x44,
-	0xae, 0x73, 0x09, 0x16, 0x49, 0x1c, 0x1c, 0x17, 0x91, 0xc7, 0xfd, 0x9f, 0xed, 0xef, 0xed, 0x79,
-	0xaa, 0x9d, 0xb4, 0x85, 0xf1, 0x16, 0x9f, 0x73, 0xee, 0xf5, 0xbd, 0xe7, 0x38, 0x70, 0xc0, 0x65,
-	0x92, 0xc8, 0xb4, 0xc7, 0x65, 0x1c, 0x23, 0xd7, 0x42, 0xa6, 0xdd, 0x4c, 0x49, 0x2d, 0x49, 0xdd,
-	0x12, 0x6f, 0xdf, 0x94, 0x82, 0x4c, 0xc6, 0x82, 0x0b, 0xcc, 0x2d, 0xdd, 0xb9, 0x80, 0x83, 0xfe,
-	0xa2, 0xa4, 0x2f, 0xd3, 0x5b, 0x11, 0x8d, 0x19, 0xbf, 0x67, 0x11, 0x92, 0x2f, 0x50, 0xe7, 0x06,
-	0xf0, 0x9c, 0xf6, 0x86, 0xdf, 0x3c, 0xf6, 0xba, 0xb6, 0x45, 0xf7, 0x65, 0x01, 0x2d, 0x75, 0x9d,
-	0x02, 0xdc, 0x97, 0x1c, 0xb9, 0x01, 0x2f, 0xd7, 0x4c, 0x0b, 0x1e, 0x2c, 0x47, 0x0b, 0x16, 0x7d,
-	0x1d, 0xbf, 0x79, 0x7c, 0x58, 0xf5, 0xbd, 0x36, 0xba, 0x97, 0x1d, 0xce, 0xd6, 0x68, 0x2b, 0x7f,
-	0x95, 0x39, 0x6d, 0xc0, 0x56, 0xc6, 0x8a, 0x58, 0xb2, 0xb0, 0xf3, 0x67, 0x1d, 0x5a, 0xaf, 0xd7,
-	0x13, 0x02, 0xb5, 0x94, 0x25, 0x68, 0x6e, 0x6b, 0x50, 0xf3, 0x4d, 0x86, 0x40, 0x12, 0x4c, 0xa6,
-	0xa8, 0x02, 0xa9, 0xa2, 0x3c, 0x30, 0xa6, 0x14, 0xde, 0xfa, 0xf3, 0x79, 0x96, 0x9d, 0xc6, 0x86,
-	0x2f, 0xb7, 0x75, 0x6d, 0xe5, 0x95, 0x8a, 0x72, 0x8b, 0x93, 0x2e, 0xec, 0x2b, 0x7c, 0x98, 0x09,
-	0x85, 0x61, 0x90, 0x21, 0xaa, 0x80, 0xcb, 0x59, 0xaa, 0xbd, 0x8d, 0xb6, 0xe3, 0x6f, 0xd2, 0xbd,
-	0x8a, 0x1a, 0x23, 0xaa, 0xfe, 0x9c, 0x20, 0x9f, 0x81, 0x24, 0xec, 0x49, 0x24, 0xb3, 0x64, 0x55,
-	0x5e, 0x33, 0x72, 0xb7, 0x64, 0x96, 0xea, 0x0e, 0x6c, 0x4f, 0x63, 0xc9, 0xef, 0x03, 0x2d, 0x83,
-	0x58, 0x3c, 0xa2, 0xb7, 0xd9, 0x76, 0xfc, 0x1a, 0x6d, 0x1a, 0x70, 0x22, 0x87, 0xe2, 0x11, 0x89,
-	0x0f, 0x6e, 0xb5, 0x4f, 0x1a, 0x17, 0x81, 0x42, 0x16, 0x7a, 0xf5, 0xb6, 0xe3, 0xff, 0x47, 0x77,
-	0xca, 0x69, 0xd3, 0xb8, 0xa0, 0xc8, 0x42, 0x72, 0x04, 0x35, 0x5d, 0x64, 0xe8, 0xfd, 0xba, 0x6c,
-	0x3b, 0xfe, 0xce, 0x71, 0xeb, 0xdf, 0x65, 0x27, 0x45, 0x86, 0xd4, 0x88, 0xc8, 0x07, 0xf8, 0x5f,
-	0x8b, 0x04, 0x17, 0x37, 0xff, 0xbe, 0x34, 0x1e, 0xc2, 0x1c, 0xb4, 0x37, 0x77, 0x1e, 0xa0, 0xf5,
-	0xba, 0x4f, 0x64, 0x08, 0x6e, 0x2e, 0xa2, 0x94, 0xe9, 0x99, 0xc2, 0xca, 0x61, 0x9b, 0xf8, 0xfb,
-	0x45, 0xe2, 0x15, 0x6f, 0x0b, 0x07, 0xe9, 0x23, 0xc6, 0x32, 0xc3, 0xb3, 0x35, 0xba, 0x9b, 0x3f,
-	0xa7, 0x56, 0xb3, 0xfe, 0xe9, 0x00, 0x59, 0x49, 0x59, 0x09, 0x8d, 0x4a, 0x30, 0xe2, 0xc1, 0x16,
-	0xbf, 0x63, 0x69, 0x8a, 0x71, 0x19, 0x75, 0x75, 0x24, 0xfb, 0xb0, 0xa9, 0x9f, 0x02, 0x11, 0x9a,
-	0x80, 0x1b, 0xb4, 0xa6, 0x9f, 0xce, 0x43, 0x72, 0x08, 0xb0, 0x7c, 0x91, 0x26, 0xab, 0x06, 0x5d,
-	0x41, 0xc8, 0x3b, 0x68, 0xcc, 0x9f, 0x4a, 0x9e, 0x31, 0x8e, 0x26, 0x9b, 0x06, 0x5d, 0x02, 0x9f,
-	0x06, 0xb0, 0xf3, 0xdc, 0x31, 0xb2, 0x0b, 0xcd, 0xfe, 0xd5, 0x30, 0xf8, 0x36, 0xba, 0x18, 0x5d,
-	0xfd, 0x18, 0xb9, 0x6b, 0x15, 0x30, 0xa6, 0xe7, 0xdf, 0x4f, 0x26, 0x03, 0xd7, 0x21, 0x7b, 0xb0,
-	0x3d, 0x07, 0x26, 0xf4, 0x64, 0x74, 0x7d, 0x3e, 0x18, 0x4d, 0xdc, 0xf5, 0xd3, 0x6b, 0xf8, 0x28,
-	0x55, 0xd4, 0xbd, 0x2b, 0x32, 0x54, 0x31, 0x86, 0x11, 0xaa, 0xee, 0x2d, 0x9b, 0x2a, 0xc1, 0xed,
-	0xef, 0x99, 0x97, 0x46, 0xdd, 0x1c, 0x45, 0x42, 0xdf, 0xcd, 0xa6, 0xf3, 0x63, 0x6f, 0x45, 0xdc,
-	0xb3, 0xe2, 0x9e, 0x15, 0xf7, 0xac, 0x78, 0x5a, 0x37, 0xc7, 0xaf, 0x7f, 0x03, 0x00, 0x00, 0xff,
-	0xff, 0xf9, 0xf4, 0x41, 0xd5, 0x14, 0x04, 0x00, 0x00,
+func init() { proto.RegisterFile("common/collection.proto", fileDescriptor_collection_c4f7076c0a86910e) }
+
+var fileDescriptor_collection_c4f7076c0a86910e = []byte{
+	// 591 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0x5d, 0x4f, 0xdb, 0x30,
+	0x14, 0x25, 0x50, 0x0a, 0xbd, 0xe5, 0x23, 0x18, 0xad, 0x44, 0xd3, 0xc4, 0xba, 0x6a, 0x0f, 0xd1,
+	0x98, 0xda, 0x89, 0xfd, 0x02, 0x28, 0x65, 0x20, 0x4a, 0x5b, 0xb9, 0xdd, 0x26, 0xf1, 0x12, 0xb9,
+	0xc9, 0x25, 0x58, 0x24, 0x71, 0x70, 0x5c, 0x44, 0x1e, 0xf7, 0x7f, 0xb6, 0xbf, 0xb7, 0xe7, 0x29,
+	0x4e, 0xd2, 0x16, 0xc6, 0x5b, 0x7c, 0xce, 0xb9, 0xd7, 0xf7, 0x9e, 0xe3, 0xc0, 0x81, 0x2b, 0xc2,
+	0x50, 0x44, 0x1d, 0x57, 0x04, 0x01, 0xba, 0x8a, 0x8b, 0xa8, 0x1d, 0x4b, 0xa1, 0x04, 0xa9, 0xe6,
+	0xc4, 0xdb, 0x37, 0x85, 0x20, 0x16, 0x01, 0x77, 0x39, 0x26, 0x39, 0xdd, 0xba, 0x82, 0x83, 0xee,
+	0xbc, 0xa4, 0x2b, 0xa2, 0x5b, 0xee, 0x8f, 0x98, 0x7b, 0xcf, 0x7c, 0x24, 0x5f, 0xa0, 0xea, 0x6a,
+	0xc0, 0x32, 0x9a, 0x6b, 0x76, 0xfd, 0xd8, 0x6a, 0xe7, 0x2d, 0xda, 0x2f, 0x0b, 0x68, 0xa1, 0x6b,
+	0xa5, 0x60, 0xbe, 0xe4, 0xc8, 0x0d, 0x58, 0x89, 0x62, 0x8a, 0xbb, 0xce, 0x62, 0x34, 0x67, 0xde,
+	0xd7, 0xb0, 0xeb, 0xc7, 0x87, 0x65, 0xdf, 0xb1, 0xd6, 0xbd, 0xec, 0x70, 0xb1, 0x42, 0x1b, 0xc9,
+	0xab, 0xcc, 0x69, 0x0d, 0x36, 0x62, 0x96, 0x06, 0x82, 0x79, 0xad, 0xbf, 0xab, 0xd0, 0x78, 0xbd,
+	0x9e, 0x10, 0xa8, 0x44, 0x2c, 0x44, 0x7d, 0x5b, 0x8d, 0xea, 0x6f, 0xd2, 0x07, 0x12, 0x62, 0x38,
+	0x45, 0xe9, 0x08, 0xe9, 0x27, 0x8e, 0x36, 0x25, 0xb5, 0x56, 0x9f, 0xcf, 0xb3, 0xe8, 0x34, 0xd2,
+	0x7c, 0xb1, 0xad, 0x99, 0x57, 0x0e, 0xa5, 0x9f, 0xe4, 0x38, 0x69, 0xc3, 0xbe, 0xc4, 0x87, 0x19,
+	0x97, 0xe8, 0x39, 0x31, 0xa2, 0x74, 0x5c, 0x31, 0x8b, 0x94, 0xb5, 0xd6, 0x34, 0xec, 0x75, 0xba,
+	0x57, 0x52, 0x23, 0x44, 0xd9, 0xcd, 0x08, 0xf2, 0x19, 0x48, 0xc8, 0x9e, 0x78, 0x38, 0x0b, 0x97,
+	0xe5, 0x15, 0x2d, 0x37, 0x0b, 0x66, 0xa1, 0x6e, 0xc1, 0xf6, 0x34, 0x10, 0xee, 0xbd, 0xa3, 0x84,
+	0x13, 0xf0, 0x47, 0xb4, 0xd6, 0x9b, 0x86, 0x5d, 0xa1, 0x75, 0x0d, 0x4e, 0x44, 0x9f, 0x3f, 0x22,
+	0xb1, 0xc1, 0x2c, 0xf7, 0x89, 0x82, 0xd4, 0x91, 0xc8, 0x3c, 0xab, 0xda, 0x34, 0xec, 0x4d, 0xba,
+	0x53, 0x4c, 0x1b, 0x05, 0x29, 0x45, 0xe6, 0x91, 0x23, 0xa8, 0xa8, 0x34, 0x46, 0xeb, 0xf7, 0x75,
+	0xd3, 0xb0, 0x77, 0x8e, 0x1b, 0xff, 0x2f, 0x3b, 0x49, 0x63, 0xa4, 0x5a, 0x44, 0x3e, 0xc0, 0x96,
+	0xe2, 0x21, 0xce, 0x6f, 0xfe, 0x73, 0xad, 0x3d, 0x84, 0x0c, 0xcc, 0x6f, 0x6e, 0x3d, 0x40, 0xe3,
+	0x75, 0x9f, 0x48, 0x1f, 0xcc, 0x84, 0xfb, 0x11, 0x53, 0x33, 0x89, 0xa5, 0xc3, 0x79, 0xe2, 0xef,
+	0xe7, 0x89, 0x97, 0x7c, 0x5e, 0xd8, 0x8b, 0x1e, 0x31, 0x10, 0x31, 0x5e, 0xac, 0xd0, 0xdd, 0xe4,
+	0x39, 0xb5, 0x9c, 0xf5, 0x2f, 0x03, 0xc8, 0x52, 0xca, 0x92, 0x2b, 0x94, 0x9c, 0x11, 0x0b, 0x36,
+	0xdc, 0x3b, 0x16, 0x45, 0x18, 0x14, 0x51, 0x97, 0x47, 0xb2, 0x0f, 0xeb, 0xea, 0xc9, 0xe1, 0x9e,
+	0x0e, 0xb8, 0x46, 0x2b, 0xea, 0xe9, 0xd2, 0x23, 0x87, 0x00, 0x8b, 0x17, 0xa9, 0xb3, 0xaa, 0xd1,
+	0x25, 0x84, 0xbc, 0x83, 0x5a, 0xf6, 0x54, 0x92, 0x98, 0xb9, 0xa8, 0xb3, 0xa9, 0xd1, 0x05, 0xf0,
+	0xe9, 0x16, 0x76, 0x9e, 0x3b, 0x46, 0x76, 0xa1, 0xde, 0x1d, 0xf6, 0x9d, 0xef, 0x83, 0xab, 0xc1,
+	0xf0, 0xe7, 0xc0, 0x5c, 0x29, 0x81, 0x11, 0xbd, 0xfc, 0x71, 0x32, 0xe9, 0x99, 0x06, 0xd9, 0x83,
+	0xed, 0x0c, 0x98, 0xd0, 0x93, 0xc1, 0xf8, 0xb2, 0x37, 0x98, 0x98, 0xab, 0x25, 0x34, 0x3c, 0x3f,
+	0xef, 0xf7, 0xce, 0xbe, 0xf5, 0xa8, 0xb9, 0x46, 0xb6, 0x60, 0x33, 0x83, 0xce, 0xba, 0x27, 0x63,
+	0xb3, 0x72, 0x3a, 0x86, 0x8f, 0x42, 0xfa, 0xed, 0xbb, 0x34, 0x46, 0x19, 0xa0, 0xe7, 0xa3, 0x6c,
+	0xdf, 0xb2, 0xa9, 0xe4, 0x6e, 0xfe, 0xff, 0x26, 0x85, 0x93, 0x37, 0x47, 0x3e, 0x57, 0x77, 0xb3,
+	0x69, 0x76, 0xec, 0x2c, 0x89, 0x3b, 0xb9, 0xb8, 0x93, 0x8b, 0x3b, 0xb9, 0x78, 0x5a, 0xd5, 0xc7,
+	0xaf, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xf7, 0x1a, 0x4f, 0xba, 0x35, 0x04, 0x00, 0x00,
 }
diff --git a/protos/common/collection.proto b/protos/common/collection.proto
index 1df01a36..19da039b 100644
--- a/protos/common/collection.proto
+++ b/protos/common/collection.proto
@@ -18,6 +18,8 @@ enum CollectionType {
     COL_UNKNOWN = 0;    // Unspecified type - will use PRIVATE as default.
     COL_PRIVATE = 1;    // Persisted private data collection.
     COL_TRANSIENT = 2;  // Transient private data collection.
+    COL_OFFLEDGER = 3;  // Off-ledger private data collection.
+    COL_DCAS = 4;       // Distributed Content Addressable Store (CAS) private data collection.
 }
 
 // CollectionConfigPackage represents an array of CollectionConfig
diff --git a/protos/gossip/extensions.go b/protos/gossip/extensions.go
deleted file mode 100644
index 233c7b79..00000000
--- a/protos/gossip/extensions.go
+++ /dev/null
@@ -1,622 +0,0 @@
-/*
-Copyright IBM Corp. All Rights Reserved.
-
-SPDX-License-Identifier: Apache-2.0
-*/
-
-package gossip
-
-import (
-	"bytes"
-	"encoding/hex"
-	"errors"
-	"fmt"
-
-	"github.com/golang/protobuf/proto"
-	"github.com/hyperledger/fabric/common/util"
-	"github.com/hyperledger/fabric/gossip/api"
-	"github.com/hyperledger/fabric/gossip/common"
-)
-
-// NewGossipMessageComparator creates a MessageReplacingPolicy given a maximum number of blocks to hold
-func NewGossipMessageComparator(dataBlockStorageSize int) common.MessageReplacingPolicy {
-	return (&msgComparator{dataBlockStorageSize: dataBlockStorageSize}).getMsgReplacingPolicy()
-}
-
-type msgComparator struct {
-	dataBlockStorageSize int
-}
-
-func (mc *msgComparator) getMsgReplacingPolicy() common.MessageReplacingPolicy {
-	return func(this interface{}, that interface{}) common.InvalidationResult {
-		return mc.invalidationPolicy(this, that)
-	}
-}
-
-func (mc *msgComparator) invalidationPolicy(this interface{}, that interface{}) common.InvalidationResult {
-	thisMsg := this.(*SignedGossipMessage)
-	thatMsg := that.(*SignedGossipMessage)
-
-	if thisMsg.IsAliveMsg() && thatMsg.IsAliveMsg() {
-		return aliveInvalidationPolicy(thisMsg.GetAliveMsg(), thatMsg.GetAliveMsg())
-	}
-
-	if thisMsg.IsDataMsg() && thatMsg.IsDataMsg() {
-		return mc.dataInvalidationPolicy(thisMsg.GetDataMsg(), thatMsg.GetDataMsg())
-	}
-
-	if thisMsg.IsStateInfoMsg() && thatMsg.IsStateInfoMsg() {
-		return mc.stateInvalidationPolicy(thisMsg.GetStateInfo(), thatMsg.GetStateInfo())
-	}
-
-	if thisMsg.IsIdentityMsg() && thatMsg.IsIdentityMsg() {
-		return mc.identityInvalidationPolicy(thisMsg.GetPeerIdentity(), thatMsg.GetPeerIdentity())
-	}
-
-	if thisMsg.IsLeadershipMsg() && thatMsg.IsLeadershipMsg() {
-		return leaderInvalidationPolicy(thisMsg.GetLeadershipMsg(), thatMsg.GetLeadershipMsg())
-	}
-
-	return common.MessageNoAction
-}
-
-func (mc *msgComparator) stateInvalidationPolicy(thisStateMsg *StateInfo, thatStateMsg *StateInfo) common.InvalidationResult {
-	if !bytes.Equal(thisStateMsg.PkiId, thatStateMsg.PkiId) {
-		return common.MessageNoAction
-	}
-	return compareTimestamps(thisStateMsg.Timestamp, thatStateMsg.Timestamp)
-}
-
-func (mc *msgComparator) identityInvalidationPolicy(thisIdentityMsg *PeerIdentity, thatIdentityMsg *PeerIdentity) common.InvalidationResult {
-	if bytes.Equal(thisIdentityMsg.PkiId, thatIdentityMsg.PkiId) {
-		return common.MessageInvalidated
-	}
-
-	return common.MessageNoAction
-}
-
-func (mc *msgComparator) dataInvalidationPolicy(thisDataMsg *DataMessage, thatDataMsg *DataMessage) common.InvalidationResult {
-	if thisDataMsg.Payload.SeqNum == thatDataMsg.Payload.SeqNum {
-		return common.MessageInvalidated
-	}
-
-	diff := abs(thisDataMsg.Payload.SeqNum, thatDataMsg.Payload.SeqNum)
-	if diff <= uint64(mc.dataBlockStorageSize) {
-		return common.MessageNoAction
-	}
-
-	if thisDataMsg.Payload.SeqNum > thatDataMsg.Payload.SeqNum {
-		return common.MessageInvalidates
-	}
-	return common.MessageInvalidated
-}
-
-func aliveInvalidationPolicy(thisMsg *AliveMessage, thatMsg *AliveMessage) common.InvalidationResult {
-	if !bytes.Equal(thisMsg.Membership.PkiId, thatMsg.Membership.PkiId) {
-		return common.MessageNoAction
-	}
-
-	return compareTimestamps(thisMsg.Timestamp, thatMsg.Timestamp)
-}
-
-func leaderInvalidationPolicy(thisMsg *LeadershipMessage, thatMsg *LeadershipMessage) common.InvalidationResult {
-	if !bytes.Equal(thisMsg.PkiId, thatMsg.PkiId) {
-		return common.MessageNoAction
-	}
-
-	return compareTimestamps(thisMsg.Timestamp, thatMsg.Timestamp)
-}
-
-func compareTimestamps(thisTS *PeerTime, thatTS *PeerTime) common.InvalidationResult {
-	if thisTS.IncNum == thatTS.IncNum {
-		if thisTS.SeqNum > thatTS.SeqNum {
-			return common.MessageInvalidates
-		}
-
-		return common.MessageInvalidated
-	}
-	if thisTS.IncNum < thatTS.IncNum {
-		return common.MessageInvalidated
-	}
-	return common.MessageInvalidates
-}
-
-// IsAliveMsg returns whether this GossipMessage is an AliveMessage
-func (m *GossipMessage) IsAliveMsg() bool {
-	return m.GetAliveMsg() != nil
-}
-
-// IsDataMsg returns whether this GossipMessage is a data message
-func (m *GossipMessage) IsDataMsg() bool {
-	return m.GetDataMsg() != nil
-}
-
-// IsStateInfoPullRequestMsg returns whether this GossipMessage is a stateInfoPullRequest
-func (m *GossipMessage) IsStateInfoPullRequestMsg() bool {
-	return m.GetStateInfoPullReq() != nil
-}
-
-// IsStateInfoSnapshot returns whether this GossipMessage is a stateInfo snapshot
-func (m *GossipMessage) IsStateInfoSnapshot() bool {
-	return m.GetStateSnapshot() != nil
-}
-
-// IsStateInfoMsg returns whether this GossipMessage is a stateInfo message
-func (m *GossipMessage) IsStateInfoMsg() bool {
-	return m.GetStateInfo() != nil
-}
-
-// IsPullMsg returns whether this GossipMessage is a message that belongs
-// to the pull mechanism
-func (m *GossipMessage) IsPullMsg() bool {
-	return m.GetDataReq() != nil || m.GetDataUpdate() != nil ||
-		m.GetHello() != nil || m.GetDataDig() != nil
-}
-
-// IsRemoteStateMessage returns whether this GossipMessage is related to state synchronization
-func (m *GossipMessage) IsRemoteStateMessage() bool {
-	return m.GetStateRequest() != nil || m.GetStateResponse() != nil
-}
-
-// GetPullMsgType returns the phase of the pull mechanism this GossipMessage belongs to
-// for example: Hello, Digest, etc.
-// If this isn't a pull message, PullMsgType_UNDEFINED is returned.
-func (m *GossipMessage) GetPullMsgType() PullMsgType {
-	if helloMsg := m.GetHello(); helloMsg != nil {
-		return helloMsg.MsgType
-	}
-
-	if digMsg := m.GetDataDig(); digMsg != nil {
-		return digMsg.MsgType
-	}
-
-	if reqMsg := m.GetDataReq(); reqMsg != nil {
-		return reqMsg.MsgType
-	}
-
-	if resMsg := m.GetDataUpdate(); resMsg != nil {
-		return resMsg.MsgType
-	}
-
-	return PullMsgType_UNDEFINED
-}
-
-// IsChannelRestricted returns whether this GossipMessage should be routed
-// only in its channel
-func (m *GossipMessage) IsChannelRestricted() bool {
-	return m.Tag == GossipMessage_CHAN_AND_ORG || m.Tag == GossipMessage_CHAN_ONLY || m.Tag == GossipMessage_CHAN_OR_ORG
-}
-
-// IsOrgRestricted returns whether this GossipMessage should be routed only
-// inside the organization
-func (m *GossipMessage) IsOrgRestricted() bool {
-	return m.Tag == GossipMessage_CHAN_AND_ORG || m.Tag == GossipMessage_ORG_ONLY
-}
-
-// IsIdentityMsg returns whether this GossipMessage is an identity message
-func (m *GossipMessage) IsIdentityMsg() bool {
-	return m.GetPeerIdentity() != nil
-}
-
-// IsDataReq returns whether this GossipMessage is a data request message
-func (m *GossipMessage) IsDataReq() bool {
-	return m.GetDataReq() != nil
-}
-
-// IsPrivateDataMsg returns whether this message is related to private data
-func (m *GossipMessage) IsPrivateDataMsg() bool {
-	return m.GetPrivateReq() != nil || m.GetPrivateRes() != nil || m.GetPrivateData() != nil
-}
-
-// IsAck returns whether this GossipMessage is an acknowledgement
-func (m *GossipMessage) IsAck() bool {
-	return m.GetAck() != nil
-}
-
-// IsDataUpdate returns whether this GossipMessage is a data update message
-func (m *GossipMessage) IsDataUpdate() bool {
-	return m.GetDataUpdate() != nil
-}
-
-// IsHelloMsg returns whether this GossipMessage is a hello message
-func (m *GossipMessage) IsHelloMsg() bool {
-	return m.GetHello() != nil
-}
-
-// IsDigestMsg returns whether this GossipMessage is a digest message
-func (m *GossipMessage) IsDigestMsg() bool {
-	return m.GetDataDig() != nil
-}
-
-// IsLeadershipMsg returns whether this GossipMessage is a leadership (leader election) message
-func (m *GossipMessage) IsLeadershipMsg() bool {
-	return m.GetLeadershipMsg() != nil
-}
-
-// MsgConsumer invokes code given a SignedGossipMessage
-type MsgConsumer func(message *SignedGossipMessage)
-
-// IdentifierExtractor extracts from a SignedGossipMessage an identifier
-type IdentifierExtractor func(*SignedGossipMessage) string
-
-// IsTagLegal checks the GossipMessage tags and inner type
-// and returns an error if the tag doesn't match the type.
-func (m *GossipMessage) IsTagLegal() error {
-	if m.Tag == GossipMessage_UNDEFINED {
-		return fmt.Errorf("Undefined tag")
-	}
-	if m.IsDataMsg() {
-		if m.Tag != GossipMessage_CHAN_AND_ORG {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_AND_ORG)])
-		}
-		return nil
-	}
-
-	if m.IsAliveMsg() || m.GetMemReq() != nil || m.GetMemRes() != nil {
-		if m.Tag != GossipMessage_EMPTY {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_EMPTY)])
-		}
-		return nil
-	}
-
-	if m.IsIdentityMsg() {
-		if m.Tag != GossipMessage_ORG_ONLY {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_ORG_ONLY)])
-		}
-		return nil
-	}
-
-	if m.IsPullMsg() {
-		switch m.GetPullMsgType() {
-		case PullMsgType_BLOCK_MSG:
-			if m.Tag != GossipMessage_CHAN_AND_ORG {
-				return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_AND_ORG)])
-			}
-			return nil
-		case PullMsgType_IDENTITY_MSG:
-			if m.Tag != GossipMessage_EMPTY {
-				return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_EMPTY)])
-			}
-			return nil
-		default:
-			return fmt.Errorf("Invalid PullMsgType: %s", PullMsgType_name[int32(m.GetPullMsgType())])
-		}
-	}
-
-	if m.IsStateInfoMsg() || m.IsStateInfoPullRequestMsg() || m.IsStateInfoSnapshot() || m.IsRemoteStateMessage() {
-		if m.Tag != GossipMessage_CHAN_OR_ORG {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_OR_ORG)])
-		}
-		return nil
-	}
-
-	if m.IsLeadershipMsg() {
-		if m.Tag != GossipMessage_CHAN_AND_ORG {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_AND_ORG)])
-		}
-		return nil
-	}
-
-	if m.GetCollDataReq() != nil || m.GetCollDataRes() != nil {
-		if m.Tag != GossipMessage_CHAN_ONLY {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_ONLY)])
-		}
-		return nil
-	}
-
-	return fmt.Errorf("Unknown message type: %v", m)
-}
-
-// Verifier receives a peer identity, a signature and a message
-// and returns nil if the signature on the message could be verified
-// using the given identity.
-type Verifier func(peerIdentity []byte, signature, message []byte) error
-
-// Signer signs a message, and returns (signature, nil)
-// on success, and nil and an error on failure.
-type Signer func(msg []byte) ([]byte, error)
-
-// ReceivedMessage is a GossipMessage wrapper that
-// enables the user to send a message to the origin from which
-// the ReceivedMessage was sent from.
-// It also allows to know the identity of the sender,
-// to obtain the raw bytes the GossipMessage was un-marshaled from,
-// and the signature over these raw bytes.
-type ReceivedMessage interface {
-
-	// Respond sends a GossipMessage to the origin from which this ReceivedMessage was sent from
-	Respond(msg *GossipMessage)
-
-	// GetGossipMessage returns the underlying GossipMessage
-	GetGossipMessage() *SignedGossipMessage
-
-	// GetSourceMessage Returns the Envelope the ReceivedMessage was
-	// constructed with
-	GetSourceEnvelope() *Envelope
-
-	// GetConnectionInfo returns information about the remote peer
-	// that sent the message
-	GetConnectionInfo() *ConnectionInfo
-
-	// Ack returns to the sender an acknowledgement for the message
-	// An ack can receive an error that indicates that the operation related
-	// to the message has failed
-	Ack(err error)
-}
-
-// ConnectionInfo represents information about
-// the remote peer that sent a certain ReceivedMessage
-type ConnectionInfo struct {
-	ID       common.PKIidType
-	Auth     *AuthInfo
-	Identity api.PeerIdentityType
-	Endpoint string
-}
-
-// String returns a string representation of this ConnectionInfo
-func (c *ConnectionInfo) String() string {
-	return fmt.Sprintf("%s %v", c.Endpoint, c.ID)
-}
-
-// AuthInfo represents the authentication
-// data that was provided by the remote peer
-// at the connection time
-type AuthInfo struct {
-	SignedData []byte
-	Signature  []byte
-}
-
-// Sign signs a GossipMessage with given Signer.
-// Returns an Envelope on success,
-// panics on failure.
-func (m *SignedGossipMessage) Sign(signer Signer) (*Envelope, error) {
-	// If we have a secretEnvelope, don't override it.
-	// Back it up, and restore it later
-	var secretEnvelope *SecretEnvelope
-	if m.Envelope != nil {
-		secretEnvelope = m.Envelope.SecretEnvelope
-	}
-	m.Envelope = nil
-	payload, err := proto.Marshal(m.GossipMessage)
-	if err != nil {
-		return nil, err
-	}
-	sig, err := signer(payload)
-	if err != nil {
-		return nil, err
-	}
-
-	e := &Envelope{
-		Payload:        payload,
-		Signature:      sig,
-		SecretEnvelope: secretEnvelope,
-	}
-	m.Envelope = e
-	return e, nil
-}
-
-// NoopSign creates a SignedGossipMessage with a nil signature
-func (m *GossipMessage) NoopSign() (*SignedGossipMessage, error) {
-	signer := func(msg []byte) ([]byte, error) {
-		return nil, nil
-	}
-	sMsg := &SignedGossipMessage{
-		GossipMessage: m,
-	}
-	_, err := sMsg.Sign(signer)
-	return sMsg, err
-}
-
-// Verify verifies a signed GossipMessage with a given Verifier.
-// Returns nil on success, error on failure.
-func (m *SignedGossipMessage) Verify(peerIdentity []byte, verify Verifier) error {
-	if m.Envelope == nil {
-		return errors.New("Missing envelope")
-	}
-	if len(m.Envelope.Payload) == 0 {
-		return errors.New("Empty payload")
-	}
-	if len(m.Envelope.Signature) == 0 {
-		return errors.New("Empty signature")
-	}
-	payloadSigVerificationErr := verify(peerIdentity, m.Envelope.Signature, m.Envelope.Payload)
-	if payloadSigVerificationErr != nil {
-		return payloadSigVerificationErr
-	}
-	if m.Envelope.SecretEnvelope != nil {
-		payload := m.Envelope.SecretEnvelope.Payload
-		sig := m.Envelope.SecretEnvelope.Signature
-		if len(payload) == 0 {
-			return errors.New("Empty payload")
-		}
-		if len(sig) == 0 {
-			return errors.New("Empty signature")
-		}
-		return verify(peerIdentity, sig, payload)
-	}
-	return nil
-}
-
-// IsSigned returns whether the message
-// has a signature in the envelope.
-func (m *SignedGossipMessage) IsSigned() bool {
-	return m.Envelope != nil && m.Envelope.Payload != nil && m.Envelope.Signature != nil
-}
-
-// ToGossipMessage un-marshals a given envelope and creates a
-// SignedGossipMessage out of it.
-// Returns an error if un-marshaling fails.
-func (e *Envelope) ToGossipMessage() (*SignedGossipMessage, error) {
-	if e == nil {
-		return nil, errors.New("nil envelope")
-	}
-	msg := &GossipMessage{}
-	err := proto.Unmarshal(e.Payload, msg)
-	if err != nil {
-		return nil, fmt.Errorf("Failed unmarshaling GossipMessage from envelope: %v", err)
-	}
-	return &SignedGossipMessage{
-		GossipMessage: msg,
-		Envelope:      e,
-	}, nil
-}
-
-// SignSecret signs the secret payload and creates
-// a secret envelope out of it.
-func (e *Envelope) SignSecret(signer Signer, secret *Secret) error {
-	payload, err := proto.Marshal(secret)
-	if err != nil {
-		return err
-	}
-	sig, err := signer(payload)
-	if err != nil {
-		return err
-	}
-	e.SecretEnvelope = &SecretEnvelope{
-		Payload:   payload,
-		Signature: sig,
-	}
-	return nil
-}
-
-// InternalEndpoint returns the internal endpoint
-// in the secret envelope, or an empty string
-// if a failure occurs.
-func (s *SecretEnvelope) InternalEndpoint() string {
-	secret := &Secret{}
-	if err := proto.Unmarshal(s.Payload, secret); err != nil {
-		return ""
-	}
-	return secret.GetInternalEndpoint()
-}
-
-// SignedGossipMessage contains a GossipMessage
-// and the Envelope from which it came from
-type SignedGossipMessage struct {
-	*Envelope
-	*GossipMessage
-}
-
-func (p *Payload) toString() string {
-	return fmt.Sprintf("Block message: {Data: %d bytes, seq: %d}", len(p.Data), p.SeqNum)
-}
-
-func (du *DataUpdate) toString() string {
-	mType := PullMsgType_name[int32(du.MsgType)]
-	return fmt.Sprintf("Type: %s, items: %d, nonce: %d", mType, len(du.Data), du.Nonce)
-}
-
-func (mr *MembershipResponse) toString() string {
-	return fmt.Sprintf("MembershipResponse with Alive: %d, Dead: %d", len(mr.Alive), len(mr.Dead))
-}
-
-func (sis *StateInfoSnapshot) toString() string {
-	return fmt.Sprintf("StateInfoSnapshot with %d items", len(sis.Elements))
-}
-
-// String returns a string representation
-// of a SignedGossipMessage
-func (m *SignedGossipMessage) String() string {
-	env := "No envelope"
-	if m.Envelope != nil {
-		var secretEnv string
-		if m.SecretEnvelope != nil {
-			pl := len(m.SecretEnvelope.Payload)
-			sl := len(m.SecretEnvelope.Signature)
-			secretEnv = fmt.Sprintf(" Secret payload: %d bytes, Secret Signature: %d bytes", pl, sl)
-		}
-		env = fmt.Sprintf("%d bytes, Signature: %d bytes%s", len(m.Envelope.Payload), len(m.Envelope.Signature), secretEnv)
-	}
-	gMsg := "No gossipMessage"
-	if m.GossipMessage != nil {
-		var isSimpleMsg bool
-		if m.GetStateResponse() != nil {
-			gMsg = fmt.Sprintf("StateResponse with %d items", len(m.GetStateResponse().Payloads))
-		} else if m.IsDataMsg() && m.GetDataMsg().Payload != nil {
-			gMsg = m.GetDataMsg().Payload.toString()
-		} else if m.IsDataUpdate() {
-			update := m.GetDataUpdate()
-			gMsg = fmt.Sprintf("DataUpdate: %s", update.toString())
-		} else if m.GetMemRes() != nil {
-			gMsg = m.GetMemRes().toString()
-		} else if m.IsStateInfoSnapshot() {
-			gMsg = m.GetStateSnapshot().toString()
-		} else if m.GetPrivateRes() != nil {
-			gMsg = m.GetPrivateRes().ToString()
-		} else {
-			gMsg = m.GossipMessage.String()
-			isSimpleMsg = true
-		}
-		if !isSimpleMsg {
-			desc := fmt.Sprintf("Channel: %s, nonce: %d, tag: %s", string(m.Channel), m.Nonce, GossipMessage_Tag_name[int32(m.Tag)])
-			gMsg = fmt.Sprintf("%s %s", desc, gMsg)
-		}
-	}
-	return fmt.Sprintf("GossipMessage: %v, Envelope: %s", gMsg, env)
-}
-
-func (dd *DataRequest) FormattedDigests() []string {
-	if dd.MsgType == PullMsgType_IDENTITY_MSG {
-		return digestsToHex(dd.Digests)
-	}
-
-	return digestsAsStrings(dd.Digests)
-}
-
-func (dd *DataDigest) FormattedDigests() []string {
-	if dd.MsgType == PullMsgType_IDENTITY_MSG {
-		return digestsToHex(dd.Digests)
-	}
-	return digestsAsStrings(dd.Digests)
-}
-
-// Hash returns the SHA256 representation of the PvtDataDigest's bytes
-func (dig *PvtDataDigest) Hash() (string, error) {
-	b, err := proto.Marshal(dig)
-	if err != nil {
-		return "", err
-	}
-	return hex.EncodeToString(util.ComputeSHA256(b)), nil
-}
-
-// ToString returns a string representation of this RemotePvtDataResponse
-func (res *RemotePvtDataResponse) ToString() string {
-	a := make([]string, len(res.Elements))
-	for i, el := range res.Elements {
-		a[i] = fmt.Sprintf("%s with %d elements", el.Digest.String(), len(el.Payload))
-	}
-	return fmt.Sprintf("%v", a)
-}
-
-func digestsAsStrings(digests [][]byte) []string {
-	a := make([]string, len(digests))
-	for i, dig := range digests {
-		a[i] = string(dig)
-	}
-	return a
-}
-
-func digestsToHex(digests [][]byte) []string {
-	a := make([]string, len(digests))
-	for i, dig := range digests {
-		a[i] = hex.EncodeToString(dig)
-	}
-	return a
-}
-
-// LedgerHeight returns the ledger height that is specified
-// in the StateInfo message
-func (msg *StateInfo) LedgerHeight() (uint64, error) {
-	if msg.Properties != nil {
-		return msg.Properties.LedgerHeight, nil
-	}
-	return 0, errors.New("properties undefined")
-}
-
-// Abs returns abs(a-b)
-func abs(a, b uint64) uint64 {
-	if a > b {
-		return a - b
-	}
-	return b - a
-}
diff --git a/protos/gossip/extensions_test.go b/protos/gossip/extensions_test.go
deleted file mode 100644
index a2363703..00000000
--- a/protos/gossip/extensions_test.go
+++ /dev/null
@@ -1,863 +0,0 @@
-/*
-Copyright IBM Corp. 2017 All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-		 http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package gossip
-
-import (
-	"errors"
-	"fmt"
-	"testing"
-
-	"github.com/golang/protobuf/proto"
-	"github.com/hyperledger/fabric/gossip/common"
-	"github.com/stretchr/testify/assert"
-)
-
-func TestToGossipMessageNilEnvelope(t *testing.T) {
-	memReq := &MembershipRequest{}
-	_, err := memReq.SelfInformation.ToGossipMessage()
-	assert.EqualError(t, err, "nil envelope")
-}
-
-func TestToString(t *testing.T) {
-	// Ensure we don't print the byte content when we
-	// log messages.
-	// Each payload or signature contains '2' so we would've logged
-	// them if not for the overloading of the String() method in SignedGossipMessage
-
-	// The following line proves that the envelopes constructed in this test
-	// have "2" in them when they are printed
-	assert.Contains(t, fmt.Sprintf("%v", envelopes()[0]), "2")
-	// and the following does the same for payloads:
-	dMsg := &DataMessage{
-		Payload: &Payload{
-			SeqNum: 3,
-			Data:   []byte{2, 2, 2, 2, 2},
-		},
-	}
-	assert.Contains(t, fmt.Sprintf("%v", dMsg), "2")
-
-	// Now we construct all types of messages that have envelopes or payloads in them
-	// and see that "2" is not outputted into their formatting even though it is found
-	// as a sub-message of the outer message.
-
-	sMsg := &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Channel: []byte("A"),
-			Content: &GossipMessage_DataMsg{
-				DataMsg: &DataMessage{
-					Payload: &Payload{
-						SeqNum: 3,
-						Data:   []byte{2, 2, 2, 2, 2},
-					},
-				},
-			},
-		},
-		Envelope: &Envelope{
-			Payload:   []byte{0, 1, 2, 3, 4, 5, 6},
-			Signature: []byte{0, 1, 2},
-			SecretEnvelope: &SecretEnvelope{
-				Payload:   []byte{0, 1, 2, 3, 4, 5},
-				Signature: []byte{0, 1, 2},
-			},
-		},
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-	sMsg.GetDataMsg().Payload = nil
-	assert.NotPanics(t, func() {
-		_ = sMsg.String()
-	})
-
-	sMsg = &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte("A"),
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Content: &GossipMessage_DataUpdate{
-				DataUpdate: &DataUpdate{
-					Nonce:   11,
-					MsgType: PullMsgType_BLOCK_MSG,
-					Data:    envelopes(),
-				},
-			},
-		},
-		Envelope: envelopes()[0],
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-
-	sMsg = &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte("A"),
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Content: &GossipMessage_MemRes{
-				MemRes: &MembershipResponse{
-					Alive: envelopes(),
-					Dead:  envelopes(),
-				},
-			},
-		},
-		Envelope: envelopes()[0],
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-
-	sMsg = &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte("A"),
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Content: &GossipMessage_StateSnapshot{
-				StateSnapshot: &StateInfoSnapshot{
-					Elements: envelopes(),
-				},
-			},
-		},
-		Envelope: envelopes()[0],
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-
-	sMsg = &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte("A"),
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Content: &GossipMessage_StateResponse{
-				StateResponse: &RemoteStateResponse{
-					Payloads: []*Payload{
-						{Data: []byte{2, 2, 2}},
-					},
-				},
-			},
-		},
-		Envelope: envelopes()[0],
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-}
-
-func TestAliveMessageNoActionTaken(t *testing.T) {
-	comparator := NewGossipMessageComparator(1)
-
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{17},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 1,
-				SeqNum: 1,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	sMsg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{15},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 2,
-				SeqNum: 2,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageNoAction)
-}
-
-func TestStateInfoMessageNoActionTaken(t *testing.T) {
-	comparator := NewGossipMessageComparator(1)
-
-	// msg1 and msg2 have same channel mac, while different pkid, while
-	// msg and msg3 same pkid and different channel mac
-
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 1, []byte{17}, []byte{17, 13}))
-	sMsg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 1, []byte{13}, []byte{17, 13}))
-
-	// We only should compare comparable messages, e.g. message from same peer
-	// In any other cases no invalidation should be taken.
-	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageNoAction)
-}
-
-func TestStateInfoMessagesInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(1)
-
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 1, []byte{17}, []byte{17}))
-	sMsg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 1, []byte{17}, []byte{17}))
-	sMsg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 2, []byte{17}, []byte{17}))
-	sMsg4 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(2, 1, []byte{17}, []byte{17}))
-
-	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageInvalidated)
-
-	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg3, sMsg1), common.MessageInvalidates)
-
-	assert.Equal(t, comparator(sMsg1, sMsg4), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg4, sMsg1), common.MessageInvalidates)
-
-	assert.Equal(t, comparator(sMsg3, sMsg4), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg4, sMsg3), common.MessageInvalidates)
-}
-
-func TestAliveMessageInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(1)
-
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{17},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 1,
-				SeqNum: 1,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	sMsg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{17},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 2,
-				SeqNum: 2,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	sMsg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{17},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 1,
-				SeqNum: 2,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg2, sMsg1), common.MessageInvalidates)
-	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg3, sMsg1), common.MessageInvalidates)
-}
-
-func TestDataMessageInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(5)
-
-	data := []byte{1, 1, 1}
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, dataMessage(1, data))
-	sMsg1Clone := signedGossipMessage("testChannel", GossipMessage_EMPTY, dataMessage(1, data))
-	sMsg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY, dataMessage(2, data))
-	sMsg4 := signedGossipMessage("testChannel", GossipMessage_EMPTY, dataMessage(7, data))
-
-	assert.Equal(t, comparator(sMsg1, sMsg1Clone), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageNoAction)
-	assert.Equal(t, comparator(sMsg1, sMsg4), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg4, sMsg1), common.MessageInvalidates)
-}
-
-func TestIdentityMessagesInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(5)
-
-	msg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{
-			PkiId:    []byte{17},
-			Cert:     []byte{1, 2, 3, 4},
-			Metadata: nil,
-		},
-	})
-
-	msg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{
-			PkiId:    []byte{17},
-			Cert:     []byte{1, 2, 3, 4},
-			Metadata: nil,
-		},
-	})
-
-	msg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{
-			PkiId:    []byte{11},
-			Cert:     []byte{11, 21, 31, 41},
-			Metadata: nil,
-		},
-	})
-
-	assert.Equal(t, comparator(msg1, msg2), common.MessageInvalidated)
-	assert.Equal(t, comparator(msg1, msg3), common.MessageNoAction)
-}
-
-func TestLeadershipMessagesNoAction(t *testing.T) {
-	comparator := NewGossipMessageComparator(5)
-
-	msg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(1, 1, []byte{17}))
-	msg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(1, 1, []byte{11}))
-
-	// If message with different pkid's no action should be taken
-	assert.Equal(t, comparator(msg1, msg2), common.MessageNoAction)
-}
-
-func TestLeadershipMessagesInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(5)
-
-	pkiID := []byte{17}
-	msg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(1, 1, pkiID))
-	msg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(1, 2, pkiID))
-	msg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(2, 1, pkiID))
-
-	// If message with different pkid's no action should be taken
-	assert.Equal(t, comparator(msg1, msg2), common.MessageInvalidated)
-	assert.Equal(t, comparator(msg2, msg1), common.MessageInvalidates)
-	assert.Equal(t, comparator(msg1, msg3), common.MessageInvalidated)
-	assert.Equal(t, comparator(msg3, msg1), common.MessageInvalidates)
-	assert.Equal(t, comparator(msg2, msg3), common.MessageInvalidated)
-	assert.Equal(t, comparator(msg3, msg2), common.MessageInvalidates)
-}
-
-func TestCheckGossipMessageTypes(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	// Create State info pull request
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_StateInfoPullReq{
-		StateInfoPullReq: &StateInfoPullRequest{
-			Channel_MAC: []byte{17},
-		},
-	})
-
-	assert.True(t, msg.IsStateInfoPullRequestMsg())
-
-	// Create alive message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Identity: []byte("peerID"),
-			Membership: &Member{
-				PkiId:    []byte("pkiID"),
-				Metadata: []byte{17},
-				Endpoint: "localhost",
-			},
-			Timestamp: &PeerTime{
-				SeqNum: 1,
-				IncNum: 1,
-			},
-		},
-	})
-
-	assert.True(t, msg.IsAliveMsg())
-
-	// Create gossip data message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, dataMessage(1, []byte{1, 2, 3, 4, 5}))
-	assert.True(t, msg.IsDataMsg())
-
-	// Create data request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataReq{
-		DataReq: &DataRequest{
-			MsgType: PullMsgType_UNDEFINED,
-			Nonce:   0,
-			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
-		},
-	})
-	assert.True(t, msg.IsDataReq())
-	assert.True(t, msg.IsPullMsg())
-
-	// Create data request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_UNDEFINED,
-			Nonce:   0,
-			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
-		},
-	})
-	assert.True(t, msg.IsDigestMsg())
-	assert.True(t, msg.IsPullMsg())
-
-	// Create data update message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataUpdate{
-		DataUpdate: &DataUpdate{
-			MsgType: PullMsgType_UNDEFINED,
-			Nonce:   0,
-			Data:    []*Envelope{envelopes()[0]},
-		},
-	})
-	assert.True(t, msg.IsDataUpdate())
-	assert.True(t, msg.IsPullMsg())
-
-	// Create gossip hello message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_Hello{
-		Hello: &GossipHello{
-			MsgType: PullMsgType_UNDEFINED,
-			Nonce:   0,
-		},
-	})
-	assert.True(t, msg.IsHelloMsg())
-	assert.True(t, msg.IsPullMsg())
-
-	// Create state request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_StateRequest{
-		StateRequest: &RemoteStateRequest{
-			StartSeqNum: 1,
-			EndSeqNum:   10,
-		},
-	})
-	assert.True(t, msg.IsRemoteStateMessage())
-
-	// Create state response message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_StateResponse{
-		StateResponse: &RemoteStateResponse{
-			Payloads: []*Payload{{
-				SeqNum: 1,
-				Data:   []byte{1, 2, 3, 4, 5},
-			}},
-		},
-	})
-	assert.True(t, msg.IsRemoteStateMessage())
-}
-
-func TestGossipPullMessageType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	// Create gossip hello message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_Hello{
-		Hello: &GossipHello{
-			MsgType: PullMsgType_BLOCK_MSG,
-			Nonce:   0,
-		},
-	})
-
-	assert.True(t, msg.IsHelloMsg())
-	assert.True(t, msg.IsPullMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_BLOCK_MSG)
-
-	// Create data request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_IDENTITY_MSG,
-			Nonce:   0,
-			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
-		},
-	})
-	assert.True(t, msg.IsDigestMsg())
-	assert.True(t, msg.IsPullMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_IDENTITY_MSG)
-
-	// Create data request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataReq{
-		DataReq: &DataRequest{
-			MsgType: PullMsgType_BLOCK_MSG,
-			Nonce:   0,
-			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
-		},
-	})
-	assert.True(t, msg.IsDataReq())
-	assert.True(t, msg.IsPullMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_BLOCK_MSG)
-
-	// Create data update message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataUpdate{
-		DataUpdate: &DataUpdate{
-			MsgType: PullMsgType_IDENTITY_MSG,
-			Nonce:   0,
-			Data:    []*Envelope{envelopes()[0]},
-		},
-	})
-	assert.True(t, msg.IsDataUpdate())
-	assert.True(t, msg.IsPullMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_IDENTITY_MSG)
-
-	// Create gossip data message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, dataMessage(1, []byte{1, 2, 3, 4, 5}))
-	assert.True(t, msg.IsDataMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_UNDEFINED)
-}
-
-func TestGossipMessageDataMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_AND_ORG, dataMessage(1, []byte{1}))
-	assert.True(t, msg.IsChannelRestricted())
-	assert.True(t, msg.IsOrgRestricted())
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, dataMessage(1, []byte{1}))
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_UNDEFINED, dataMessage(1, []byte{1}))
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, dataMessage(1, []byte{1}))
-	assert.False(t, msg.IsChannelRestricted())
-	assert.True(t, msg.IsOrgRestricted())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, dataMessage(1, []byte{1}))
-	assert.True(t, msg.IsChannelRestricted())
-	assert.False(t, msg.IsOrgRestricted())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, dataMessage(1, []byte{1}))
-	assert.False(t, msg.IsChannelRestricted())
-	assert.False(t, msg.IsOrgRestricted())
-
-	msg = signedGossipMessage(channelID, GossipMessage_UNDEFINED, dataMessage(1, []byte{1}))
-	assert.False(t, msg.IsChannelRestricted())
-	assert.False(t, msg.IsOrgRestricted())
-}
-
-func TestGossipMessageAliveMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{},
-	})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageMembershipMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_MemReq{
-		MemReq: &MembershipRequest{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_MemRes{
-		MemRes: &MembershipResponse{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageIdentityMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{},
-	})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessagePullMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_AND_ORG, &GossipMessage_DataReq{
-		DataReq: &DataRequest{
-			MsgType: PullMsgType_BLOCK_MSG,
-		},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataReq{
-		DataReq: &DataRequest{
-			MsgType: PullMsgType_BLOCK_MSG,
-		},
-	})
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_IDENTITY_MSG,
-		},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_IDENTITY_MSG,
-		},
-	})
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_UNDEFINED,
-		},
-	})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageStateInfoMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateInfo{
-		StateInfo: &StateInfo{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateInfoPullReq{
-		StateInfoPullReq: &StateInfoPullRequest{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateResponse{
-		StateResponse: &RemoteStateResponse{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateRequest{
-		StateRequest: &RemoteStateRequest{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateSnapshot{
-		StateSnapshot: &StateInfoSnapshot{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_StateInfo{
-		StateInfo: &StateInfo{},
-	})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageLeadershipMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_AND_ORG, &GossipMessage_LeadershipMsg{
-		LeadershipMsg: &LeadershipMessage{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_LeadershipMsg{
-		LeadershipMsg: &LeadershipMessage{},
-	})
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_Empty{})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageSign(t *testing.T) {
-	idSigner := func(msg []byte) ([]byte, error) {
-		return msg, nil
-	}
-
-	errSigner := func(msg []byte) ([]byte, error) {
-		return nil, errors.New("Error")
-	}
-
-	msg := signedGossipMessage("testChannelID", GossipMessage_EMPTY, &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{},
-	})
-
-	signedMsg, _ := msg.Sign(idSigner)
-
-	// Since checking the identity signer, signature will be same as the payload
-	assert.Equal(t, signedMsg.Payload, signedMsg.Signature)
-
-	env, err := msg.Sign(errSigner)
-	assert.Error(t, err)
-	assert.Nil(t, env)
-}
-
-func TestEnvelope_NoopSign(t *testing.T) {
-	channelID := "testChannelID"
-	msg := signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{},
-	})
-
-	signedMsg, err := msg.NoopSign()
-
-	// Since checking the identity signer, signature will be same as the payload
-	assert.Nil(t, signedMsg.Signature)
-	assert.NoError(t, err)
-}
-
-func TestSignedGossipMessage_Verify(t *testing.T) {
-	channelID := "testChannelID"
-	peerID := []byte("peer")
-	msg := signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{},
-	})
-
-	assert.True(t, msg.IsSigned())
-
-	verifier := func(peerIdentity []byte, signature, message []byte) error {
-		return nil
-	}
-
-	res := msg.Verify(peerID, verifier)
-	assert.Nil(t, res)
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{},
-	})
-
-	env := msg.Envelope
-	msg.Envelope = nil
-	res = msg.Verify(peerID, verifier)
-	assert.Error(t, res)
-
-	msg.Envelope = env
-	payload := msg.Envelope.Payload
-	msg.Envelope.Payload = nil
-	res = msg.Verify(peerID, verifier)
-	assert.Error(t, res)
-
-	msg.Envelope.Payload = payload
-	sig := msg.Signature
-	msg.Signature = nil
-	res = msg.Verify(peerID, verifier)
-	assert.Error(t, res)
-	msg.Signature = sig
-
-	errVerifier := func(peerIdentity []byte, signature, message []byte) error {
-		return errors.New("Test")
-	}
-
-	res = msg.Verify(peerID, errVerifier)
-	assert.Error(t, res)
-}
-
-func TestEnvelope(t *testing.T) {
-	dataMsg := &GossipMessage{
-		Content: dataMessage(1, []byte("data")),
-	}
-	bytes, err := proto.Marshal(dataMsg)
-	assert.NoError(t, err)
-
-	env := envelopes()[0]
-	env.Payload = bytes
-
-	msg, err := env.ToGossipMessage()
-	assert.NoError(t, err)
-	assert.NotNil(t, msg)
-
-	assert.True(t, msg.IsDataMsg())
-}
-
-func TestEnvelope_SignSecret(t *testing.T) {
-	dataMsg := &GossipMessage{
-		Content: dataMessage(1, []byte("data")),
-	}
-	bytes, err := proto.Marshal(dataMsg)
-	assert.NoError(t, err)
-
-	env := envelopes()[0]
-	env.Payload = bytes
-	env.SecretEnvelope = nil
-
-	env.SignSecret(func(message []byte) ([]byte, error) {
-		return message, nil
-	}, &Secret{
-		Content: &Secret_InternalEndpoint{
-			InternalEndpoint: "localhost:5050",
-		},
-	})
-
-	assert.NotNil(t, env.SecretEnvelope)
-	assert.Equal(t, env.SecretEnvelope.InternalEndpoint(), "localhost:5050")
-}
-
-func envelopes() []*Envelope {
-	return []*Envelope{
-		{Payload: []byte{2, 2, 2},
-			Signature: []byte{2, 2, 2},
-			SecretEnvelope: &SecretEnvelope{
-				Payload:   []byte{2, 2, 2},
-				Signature: []byte{2, 2, 2},
-			},
-		},
-	}
-}
-
-func leadershipMessage(incNum uint64, seqNum uint64, pkid []byte) *GossipMessage_LeadershipMsg {
-	return &GossipMessage_LeadershipMsg{
-		LeadershipMsg: &LeadershipMessage{
-			PkiId:         pkid,
-			IsDeclaration: false,
-			Timestamp: &PeerTime{
-				IncNum: incNum,
-				SeqNum: seqNum,
-			},
-		},
-	}
-}
-
-func stateInfoMessage(incNum uint64, seqNum uint64, pkid []byte, mac []byte) *GossipMessage_StateInfo {
-	return &GossipMessage_StateInfo{
-		StateInfo: &StateInfo{
-			Timestamp: &PeerTime{
-				IncNum: incNum,
-				SeqNum: seqNum,
-			},
-			PkiId:       pkid,
-			Channel_MAC: mac,
-		},
-	}
-}
-
-func dataMessage(seqNum uint64, data []byte) *GossipMessage_DataMsg {
-	return &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{
-			Payload: &Payload{
-				SeqNum: seqNum,
-				Data:   data,
-			},
-		},
-	}
-}
-
-func signedGossipMessage(channelID string, tag GossipMessage_Tag, content isGossipMessage_Content) *SignedGossipMessage {
-	return &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte(channelID),
-			Tag:     tag,
-			Nonce:   0,
-			Content: content,
-		},
-		Envelope: envelopes()[0],
-	}
-}
diff --git a/protos/gossip/message.pb.go b/protos/gossip/message.pb.go
index 6dc899c3..9eb4a1af 100644
--- a/protos/gossip/message.pb.go
+++ b/protos/gossip/message.pb.go
@@ -48,7 +48,7 @@ func (x PullMsgType) String() string {
 	return proto.EnumName(PullMsgType_name, int32(x))
 }
 func (PullMsgType) EnumDescriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{0}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{0}
 }
 
 type GossipMessage_Tag int32
@@ -83,7 +83,7 @@ func (x GossipMessage_Tag) String() string {
 	return proto.EnumName(GossipMessage_Tag_name, int32(x))
 }
 func (GossipMessage_Tag) EnumDescriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{3, 0}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{3, 0}
 }
 
 // Envelope contains a marshalled
@@ -103,7 +103,7 @@ func (m *Envelope) Reset()         { *m = Envelope{} }
 func (m *Envelope) String() string { return proto.CompactTextString(m) }
 func (*Envelope) ProtoMessage()    {}
 func (*Envelope) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{0}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{0}
 }
 func (m *Envelope) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Envelope.Unmarshal(m, b)
@@ -161,7 +161,7 @@ func (m *SecretEnvelope) Reset()         { *m = SecretEnvelope{} }
 func (m *SecretEnvelope) String() string { return proto.CompactTextString(m) }
 func (*SecretEnvelope) ProtoMessage()    {}
 func (*SecretEnvelope) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{1}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{1}
 }
 func (m *SecretEnvelope) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_SecretEnvelope.Unmarshal(m, b)
@@ -211,7 +211,7 @@ func (m *Secret) Reset()         { *m = Secret{} }
 func (m *Secret) String() string { return proto.CompactTextString(m) }
 func (*Secret) ProtoMessage()    {}
 func (*Secret) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{2}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{2}
 }
 func (m *Secret) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Secret.Unmarshal(m, b)
@@ -352,7 +352,7 @@ func (m *GossipMessage) Reset()         { *m = GossipMessage{} }
 func (m *GossipMessage) String() string { return proto.CompactTextString(m) }
 func (*GossipMessage) ProtoMessage()    {}
 func (*GossipMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{3}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{3}
 }
 func (m *GossipMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_GossipMessage.Unmarshal(m, b)
@@ -1195,7 +1195,7 @@ func (m *StateInfo) Reset()         { *m = StateInfo{} }
 func (m *StateInfo) String() string { return proto.CompactTextString(m) }
 func (*StateInfo) ProtoMessage()    {}
 func (*StateInfo) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{4}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{4}
 }
 func (m *StateInfo) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_StateInfo.Unmarshal(m, b)
@@ -1247,6 +1247,7 @@ type Properties struct {
 	LedgerHeight         uint64       `protobuf:"varint,1,opt,name=ledger_height,json=ledgerHeight,proto3" json:"ledger_height,omitempty"`
 	LeftChannel          bool         `protobuf:"varint,2,opt,name=left_channel,json=leftChannel,proto3" json:"left_channel,omitempty"`
 	Chaincodes           []*Chaincode `protobuf:"bytes,3,rep,name=chaincodes,proto3" json:"chaincodes,omitempty"`
+	Roles                []string     `protobuf:"bytes,99,rep,name=roles,proto3" json:"roles,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
 	XXX_unrecognized     []byte       `json:"-"`
 	XXX_sizecache        int32        `json:"-"`
@@ -1256,7 +1257,7 @@ func (m *Properties) Reset()         { *m = Properties{} }
 func (m *Properties) String() string { return proto.CompactTextString(m) }
 func (*Properties) ProtoMessage()    {}
 func (*Properties) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{5}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{5}
 }
 func (m *Properties) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Properties.Unmarshal(m, b)
@@ -1297,6 +1298,13 @@ func (m *Properties) GetChaincodes() []*Chaincode {
 	return nil
 }
 
+func (m *Properties) GetRoles() []string {
+	if m != nil {
+		return m.Roles
+	}
+	return nil
+}
+
 // StateInfoSnapshot is an aggregation of StateInfo messages
 type StateInfoSnapshot struct {
 	Elements             []*Envelope `protobuf:"bytes,1,rep,name=elements,proto3" json:"elements,omitempty"`
@@ -1309,7 +1317,7 @@ func (m *StateInfoSnapshot) Reset()         { *m = StateInfoSnapshot{} }
 func (m *StateInfoSnapshot) String() string { return proto.CompactTextString(m) }
 func (*StateInfoSnapshot) ProtoMessage()    {}
 func (*StateInfoSnapshot) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{6}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{6}
 }
 func (m *StateInfoSnapshot) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_StateInfoSnapshot.Unmarshal(m, b)
@@ -1352,7 +1360,7 @@ func (m *StateInfoPullRequest) Reset()         { *m = StateInfoPullRequest{} }
 func (m *StateInfoPullRequest) String() string { return proto.CompactTextString(m) }
 func (*StateInfoPullRequest) ProtoMessage()    {}
 func (*StateInfoPullRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{7}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{7}
 }
 func (m *StateInfoPullRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_StateInfoPullRequest.Unmarshal(m, b)
@@ -1395,7 +1403,7 @@ func (m *ConnEstablish) Reset()         { *m = ConnEstablish{} }
 func (m *ConnEstablish) String() string { return proto.CompactTextString(m) }
 func (*ConnEstablish) ProtoMessage()    {}
 func (*ConnEstablish) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{8}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{8}
 }
 func (m *ConnEstablish) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_ConnEstablish.Unmarshal(m, b)
@@ -1452,7 +1460,7 @@ func (m *PeerIdentity) Reset()         { *m = PeerIdentity{} }
 func (m *PeerIdentity) String() string { return proto.CompactTextString(m) }
 func (*PeerIdentity) ProtoMessage()    {}
 func (*PeerIdentity) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{9}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{9}
 }
 func (m *PeerIdentity) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PeerIdentity.Unmarshal(m, b)
@@ -1508,7 +1516,7 @@ func (m *DataRequest) Reset()         { *m = DataRequest{} }
 func (m *DataRequest) String() string { return proto.CompactTextString(m) }
 func (*DataRequest) ProtoMessage()    {}
 func (*DataRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{10}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{10}
 }
 func (m *DataRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_DataRequest.Unmarshal(m, b)
@@ -1564,7 +1572,7 @@ func (m *GossipHello) Reset()         { *m = GossipHello{} }
 func (m *GossipHello) String() string { return proto.CompactTextString(m) }
 func (*GossipHello) ProtoMessage()    {}
 func (*GossipHello) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{11}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{11}
 }
 func (m *GossipHello) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_GossipHello.Unmarshal(m, b)
@@ -1620,7 +1628,7 @@ func (m *DataUpdate) Reset()         { *m = DataUpdate{} }
 func (m *DataUpdate) String() string { return proto.CompactTextString(m) }
 func (*DataUpdate) ProtoMessage()    {}
 func (*DataUpdate) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{12}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{12}
 }
 func (m *DataUpdate) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_DataUpdate.Unmarshal(m, b)
@@ -1676,7 +1684,7 @@ func (m *DataDigest) Reset()         { *m = DataDigest{} }
 func (m *DataDigest) String() string { return proto.CompactTextString(m) }
 func (*DataDigest) ProtoMessage()    {}
 func (*DataDigest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{13}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{13}
 }
 func (m *DataDigest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_DataDigest.Unmarshal(m, b)
@@ -1729,7 +1737,7 @@ func (m *DataMessage) Reset()         { *m = DataMessage{} }
 func (m *DataMessage) String() string { return proto.CompactTextString(m) }
 func (*DataMessage) ProtoMessage()    {}
 func (*DataMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{14}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{14}
 }
 func (m *DataMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_DataMessage.Unmarshal(m, b)
@@ -1770,7 +1778,7 @@ func (m *PrivateDataMessage) Reset()         { *m = PrivateDataMessage{} }
 func (m *PrivateDataMessage) String() string { return proto.CompactTextString(m) }
 func (*PrivateDataMessage) ProtoMessage()    {}
 func (*PrivateDataMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{15}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{15}
 }
 func (m *PrivateDataMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PrivateDataMessage.Unmarshal(m, b)
@@ -1811,7 +1819,7 @@ func (m *Payload) Reset()         { *m = Payload{} }
 func (m *Payload) String() string { return proto.CompactTextString(m) }
 func (*Payload) ProtoMessage()    {}
 func (*Payload) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{16}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{16}
 }
 func (m *Payload) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Payload.Unmarshal(m, b)
@@ -1871,7 +1879,7 @@ func (m *PrivatePayload) Reset()         { *m = PrivatePayload{} }
 func (m *PrivatePayload) String() string { return proto.CompactTextString(m) }
 func (*PrivatePayload) ProtoMessage()    {}
 func (*PrivatePayload) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{17}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{17}
 }
 func (m *PrivatePayload) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PrivatePayload.Unmarshal(m, b)
@@ -1948,7 +1956,7 @@ func (m *AliveMessage) Reset()         { *m = AliveMessage{} }
 func (m *AliveMessage) String() string { return proto.CompactTextString(m) }
 func (*AliveMessage) ProtoMessage()    {}
 func (*AliveMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{18}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{18}
 }
 func (m *AliveMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_AliveMessage.Unmarshal(m, b)
@@ -2004,7 +2012,7 @@ func (m *LeadershipMessage) Reset()         { *m = LeadershipMessage{} }
 func (m *LeadershipMessage) String() string { return proto.CompactTextString(m) }
 func (*LeadershipMessage) ProtoMessage()    {}
 func (*LeadershipMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{19}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{19}
 }
 func (m *LeadershipMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_LeadershipMessage.Unmarshal(m, b)
@@ -2058,7 +2066,7 @@ func (m *PeerTime) Reset()         { *m = PeerTime{} }
 func (m *PeerTime) String() string { return proto.CompactTextString(m) }
 func (*PeerTime) ProtoMessage()    {}
 func (*PeerTime) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{20}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{20}
 }
 func (m *PeerTime) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PeerTime.Unmarshal(m, b)
@@ -2106,7 +2114,7 @@ func (m *MembershipRequest) Reset()         { *m = MembershipRequest{} }
 func (m *MembershipRequest) String() string { return proto.CompactTextString(m) }
 func (*MembershipRequest) ProtoMessage()    {}
 func (*MembershipRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{21}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{21}
 }
 func (m *MembershipRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_MembershipRequest.Unmarshal(m, b)
@@ -2153,7 +2161,7 @@ func (m *MembershipResponse) Reset()         { *m = MembershipResponse{} }
 func (m *MembershipResponse) String() string { return proto.CompactTextString(m) }
 func (*MembershipResponse) ProtoMessage()    {}
 func (*MembershipResponse) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{22}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{22}
 }
 func (m *MembershipResponse) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_MembershipResponse.Unmarshal(m, b)
@@ -2202,7 +2210,7 @@ func (m *Member) Reset()         { *m = Member{} }
 func (m *Member) String() string { return proto.CompactTextString(m) }
 func (*Member) ProtoMessage()    {}
 func (*Member) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{23}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{23}
 }
 func (m *Member) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Member.Unmarshal(m, b)
@@ -2254,7 +2262,7 @@ func (m *Empty) Reset()         { *m = Empty{} }
 func (m *Empty) String() string { return proto.CompactTextString(m) }
 func (*Empty) ProtoMessage()    {}
 func (*Empty) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{24}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{24}
 }
 func (m *Empty) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Empty.Unmarshal(m, b)
@@ -2288,7 +2296,7 @@ func (m *RemoteStateRequest) Reset()         { *m = RemoteStateRequest{} }
 func (m *RemoteStateRequest) String() string { return proto.CompactTextString(m) }
 func (*RemoteStateRequest) ProtoMessage()    {}
 func (*RemoteStateRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{25}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{25}
 }
 func (m *RemoteStateRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemoteStateRequest.Unmarshal(m, b)
@@ -2335,7 +2343,7 @@ func (m *RemoteStateResponse) Reset()         { *m = RemoteStateResponse{} }
 func (m *RemoteStateResponse) String() string { return proto.CompactTextString(m) }
 func (*RemoteStateResponse) ProtoMessage()    {}
 func (*RemoteStateResponse) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{26}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{26}
 }
 func (m *RemoteStateResponse) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemoteStateResponse.Unmarshal(m, b)
@@ -2375,7 +2383,7 @@ func (m *RemotePvtDataRequest) Reset()         { *m = RemotePvtDataRequest{} }
 func (m *RemotePvtDataRequest) String() string { return proto.CompactTextString(m) }
 func (*RemotePvtDataRequest) ProtoMessage()    {}
 func (*RemotePvtDataRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{27}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{27}
 }
 func (m *RemotePvtDataRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemotePvtDataRequest.Unmarshal(m, b)
@@ -2418,7 +2426,7 @@ func (m *PvtDataDigest) Reset()         { *m = PvtDataDigest{} }
 func (m *PvtDataDigest) String() string { return proto.CompactTextString(m) }
 func (*PvtDataDigest) ProtoMessage()    {}
 func (*PvtDataDigest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{28}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{28}
 }
 func (m *PvtDataDigest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PvtDataDigest.Unmarshal(m, b)
@@ -2486,7 +2494,7 @@ func (m *RemotePvtDataResponse) Reset()         { *m = RemotePvtDataResponse{} }
 func (m *RemotePvtDataResponse) String() string { return proto.CompactTextString(m) }
 func (*RemotePvtDataResponse) ProtoMessage()    {}
 func (*RemotePvtDataResponse) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{29}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{29}
 }
 func (m *RemotePvtDataResponse) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemotePvtDataResponse.Unmarshal(m, b)
@@ -2526,7 +2534,7 @@ func (m *PvtDataElement) Reset()         { *m = PvtDataElement{} }
 func (m *PvtDataElement) String() string { return proto.CompactTextString(m) }
 func (*PvtDataElement) ProtoMessage()    {}
 func (*PvtDataElement) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{30}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{30}
 }
 func (m *PvtDataElement) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PvtDataElement.Unmarshal(m, b)
@@ -2576,7 +2584,7 @@ func (m *PvtDataPayload) Reset()         { *m = PvtDataPayload{} }
 func (m *PvtDataPayload) String() string { return proto.CompactTextString(m) }
 func (*PvtDataPayload) ProtoMessage()    {}
 func (*PvtDataPayload) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{31}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{31}
 }
 func (m *PvtDataPayload) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PvtDataPayload.Unmarshal(m, b)
@@ -2621,7 +2629,7 @@ func (m *Acknowledgement) Reset()         { *m = Acknowledgement{} }
 func (m *Acknowledgement) String() string { return proto.CompactTextString(m) }
 func (*Acknowledgement) ProtoMessage()    {}
 func (*Acknowledgement) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{32}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{32}
 }
 func (m *Acknowledgement) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Acknowledgement.Unmarshal(m, b)
@@ -2663,7 +2671,7 @@ func (m *Chaincode) Reset()         { *m = Chaincode{} }
 func (m *Chaincode) String() string { return proto.CompactTextString(m) }
 func (*Chaincode) ProtoMessage()    {}
 func (*Chaincode) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{33}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{33}
 }
 func (m *Chaincode) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Chaincode.Unmarshal(m, b)
@@ -2704,69 +2712,6 @@ func (m *Chaincode) GetMetadata() []byte {
 	return nil
 }
 
-// ValidationResultsMessage is the message containing block validation results
-type ValidationResultsMessage struct {
-	SeqNum               uint64   `protobuf:"varint,1,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
-	TxFlags              []byte   `protobuf:"bytes,2,opt,name=txFlags,proto3" json:"txFlags,omitempty"`
-	Signature            []byte   `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
-	Identity             []byte   `protobuf:"bytes,4,opt,name=identity,proto3" json:"identity,omitempty"`
-	XXX_NoUnkeyedLiteral struct{} `json:"-"`
-	XXX_unrecognized     []byte   `json:"-"`
-	XXX_sizecache        int32    `json:"-"`
-}
-
-func (m *ValidationResultsMessage) Reset()         { *m = ValidationResultsMessage{} }
-func (m *ValidationResultsMessage) String() string { return proto.CompactTextString(m) }
-func (*ValidationResultsMessage) ProtoMessage()    {}
-func (*ValidationResultsMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{34}
-}
-func (m *ValidationResultsMessage) XXX_Unmarshal(b []byte) error {
-	return xxx_messageInfo_ValidationResultsMessage.Unmarshal(m, b)
-}
-func (m *ValidationResultsMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
-	return xxx_messageInfo_ValidationResultsMessage.Marshal(b, m, deterministic)
-}
-func (dst *ValidationResultsMessage) XXX_Merge(src proto.Message) {
-	xxx_messageInfo_ValidationResultsMessage.Merge(dst, src)
-}
-func (m *ValidationResultsMessage) XXX_Size() int {
-	return xxx_messageInfo_ValidationResultsMessage.Size(m)
-}
-func (m *ValidationResultsMessage) XXX_DiscardUnknown() {
-	xxx_messageInfo_ValidationResultsMessage.DiscardUnknown(m)
-}
-
-var xxx_messageInfo_ValidationResultsMessage proto.InternalMessageInfo
-
-func (m *ValidationResultsMessage) GetSeqNum() uint64 {
-	if m != nil {
-		return m.SeqNum
-	}
-	return 0
-}
-
-func (m *ValidationResultsMessage) GetTxFlags() []byte {
-	if m != nil {
-		return m.TxFlags
-	}
-	return nil
-}
-
-func (m *ValidationResultsMessage) GetSignature() []byte {
-	if m != nil {
-		return m.Signature
-	}
-	return nil
-}
-
-func (m *ValidationResultsMessage) GetIdentity() []byte {
-	if m != nil {
-		return m.Identity
-	}
-	return nil
-}
-
 // RemoteCollDataRequest message used to request
 // collection data
 type RemoteCollDataRequest struct {
@@ -2781,7 +2726,7 @@ func (m *RemoteCollDataRequest) Reset()         { *m = RemoteCollDataRequest{} }
 func (m *RemoteCollDataRequest) String() string { return proto.CompactTextString(m) }
 func (*RemoteCollDataRequest) ProtoMessage()    {}
 func (*RemoteCollDataRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{35}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{34}
 }
 func (m *RemoteCollDataRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemoteCollDataRequest.Unmarshal(m, b)
@@ -2830,7 +2775,7 @@ func (m *CollDataDigest) Reset()         { *m = CollDataDigest{} }
 func (m *CollDataDigest) String() string { return proto.CompactTextString(m) }
 func (*CollDataDigest) ProtoMessage()    {}
 func (*CollDataDigest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{36}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{35}
 }
 func (m *CollDataDigest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollDataDigest.Unmarshal(m, b)
@@ -2892,7 +2837,7 @@ func (m *RemoteCollDataResponse) Reset()         { *m = RemoteCollDataResponse{}
 func (m *RemoteCollDataResponse) String() string { return proto.CompactTextString(m) }
 func (*RemoteCollDataResponse) ProtoMessage()    {}
 func (*RemoteCollDataResponse) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{37}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{36}
 }
 func (m *RemoteCollDataResponse) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemoteCollDataResponse.Unmarshal(m, b)
@@ -2940,7 +2885,7 @@ func (m *CollDataElement) Reset()         { *m = CollDataElement{} }
 func (m *CollDataElement) String() string { return proto.CompactTextString(m) }
 func (*CollDataElement) ProtoMessage()    {}
 func (*CollDataElement) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_9b7c5a83d1e435d7, []int{38}
+	return fileDescriptor_message_0b03f5a6f808ce81, []int{37}
 }
 func (m *CollDataElement) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollDataElement.Unmarshal(m, b)
@@ -3016,7 +2961,6 @@ func init() {
 	proto.RegisterType((*PvtDataPayload)(nil), "gossip.PvtDataPayload")
 	proto.RegisterType((*Acknowledgement)(nil), "gossip.Acknowledgement")
 	proto.RegisterType((*Chaincode)(nil), "gossip.Chaincode")
-	proto.RegisterType((*ValidationResultsMessage)(nil), "gossip.ValidationResultsMessage")
 	proto.RegisterType((*RemoteCollDataRequest)(nil), "gossip.RemoteCollDataRequest")
 	proto.RegisterType((*CollDataDigest)(nil), "gossip.CollDataDigest")
 	proto.RegisterType((*RemoteCollDataResponse)(nil), "gossip.RemoteCollDataResponse")
@@ -3167,140 +3111,138 @@ var _Gossip_serviceDesc = grpc.ServiceDesc{
 	Metadata: "gossip/message.proto",
 }
 
-func init() { proto.RegisterFile("gossip/message.proto", fileDescriptor_message_9b7c5a83d1e435d7) }
-
-var fileDescriptor_message_9b7c5a83d1e435d7 = []byte{
-	// 2106 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x18, 0x5b, 0x73, 0xdb, 0x58,
-	0x39, 0x4a, 0xec, 0xd8, 0xfe, 0x7c, 0x89, 0x73, 0x9a, 0xb6, 0xda, 0xec, 0xd2, 0x76, 0x05, 0xed,
-	0x16, 0xda, 0x75, 0x4a, 0x0a, 0xc3, 0x0e, 0x0b, 0x74, 0x1c, 0x3b, 0xad, 0x3d, 0xdb, 0xa4, 0x41,
-	0x49, 0x81, 0x2e, 0x0f, 0x1a, 0x45, 0x3a, 0x96, 0x45, 0x74, 0x8b, 0xce, 0x71, 0x36, 0x79, 0x64,
-	0x78, 0x58, 0x86, 0x07, 0x78, 0xe0, 0x17, 0xf0, 0xc4, 0xdf, 0x64, 0xce, 0x45, 0xd2, 0x91, 0x2f,
-	0x99, 0xe9, 0xce, 0xf0, 0xa6, 0xef, 0x7a, 0xbe, 0xef, 0x3b, 0xdf, 0xed, 0x08, 0x76, 0xbc, 0x98,
-	0x10, 0x3f, 0xd9, 0x0b, 0x31, 0x21, 0xb6, 0x87, 0x7b, 0x49, 0x1a, 0xd3, 0x18, 0x6d, 0x0a, 0xec,
-	0xee, 0x7d, 0x27, 0x0e, 0xc3, 0x38, 0xda, 0x73, 0xe2, 0x20, 0xc0, 0x0e, 0xf5, 0xe3, 0x48, 0x30,
-	0xec, 0x3e, 0xf4, 0xe2, 0xd8, 0x0b, 0xf0, 0x1e, 0x87, 0xce, 0x67, 0x93, 0x3d, 0xea, 0x87, 0x98,
-	0x50, 0x3b, 0x4c, 0x04, 0x83, 0xf1, 0x37, 0x0d, 0xea, 0x87, 0xd1, 0x15, 0x0e, 0xe2, 0x04, 0x23,
-	0x1d, 0x6a, 0x89, 0x7d, 0x13, 0xc4, 0xb6, 0xab, 0x6b, 0x8f, 0xb4, 0xa7, 0x2d, 0x33, 0x03, 0xd1,
-	0x67, 0xd0, 0x20, 0xbe, 0x17, 0xd9, 0x74, 0x96, 0x62, 0x7d, 0x9d, 0xd3, 0x0a, 0x04, 0x7a, 0x05,
-	0x5b, 0x04, 0x3b, 0x29, 0xa6, 0x16, 0x96, 0xaa, 0xf4, 0x8d, 0x47, 0xda, 0xd3, 0xe6, 0xfe, 0xbd,
-	0x9e, 0x30, 0xb0, 0x77, 0xca, 0xc9, 0xd9, 0x41, 0x66, 0x87, 0x94, 0x60, 0x63, 0x04, 0x9d, 0x32,
-	0xc7, 0x0f, 0x35, 0xc5, 0xe8, 0xc3, 0xa6, 0xd0, 0x84, 0x9e, 0x43, 0xd7, 0x8f, 0x28, 0x4e, 0x23,
-	0x3b, 0x38, 0x8c, 0xdc, 0x24, 0xf6, 0x23, 0xca, 0x55, 0x35, 0x46, 0x6b, 0xe6, 0x02, 0xe5, 0xa0,
-	0x01, 0x35, 0x27, 0x8e, 0x28, 0x8e, 0xa8, 0xf1, 0xcf, 0x16, 0xb4, 0xdf, 0x70, 0xb3, 0x8f, 0x44,
-	0xb0, 0xd1, 0x0e, 0x54, 0xa3, 0x38, 0x72, 0x30, 0x97, 0xaf, 0x98, 0x02, 0x60, 0x26, 0x3a, 0x53,
-	0x3b, 0x8a, 0x70, 0x20, 0xcd, 0xc8, 0x40, 0xf4, 0x0c, 0x36, 0xa8, 0xed, 0xf1, 0x18, 0x74, 0xf6,
-	0x3f, 0xc9, 0x62, 0x50, 0xd2, 0xd9, 0x3b, 0xb3, 0x3d, 0x93, 0x71, 0xa1, 0x97, 0xd0, 0xb0, 0x03,
-	0xff, 0x0a, 0x5b, 0x21, 0xf1, 0xf4, 0x2a, 0x0f, 0xdb, 0x4e, 0x26, 0xd2, 0x67, 0x04, 0x29, 0x31,
-	0x5a, 0x33, 0xeb, 0x9c, 0xf1, 0x88, 0x78, 0xe8, 0x17, 0x50, 0x0b, 0x71, 0x68, 0xa5, 0xf8, 0x52,
-	0xdf, 0xe4, 0x22, 0xf9, 0x29, 0x47, 0x38, 0x3c, 0xc7, 0x29, 0x99, 0xfa, 0x89, 0x89, 0x2f, 0x67,
-	0x98, 0xd0, 0xd1, 0x9a, 0xb9, 0x19, 0xe2, 0xd0, 0xc4, 0x97, 0xe8, 0x97, 0x99, 0x14, 0xd1, 0x6b,
-	0x5c, 0x6a, 0x77, 0x99, 0x14, 0x49, 0xe2, 0x88, 0xe0, 0x5c, 0x8c, 0xa0, 0x17, 0x50, 0x77, 0x6d,
-	0x6a, 0x73, 0x03, 0xeb, 0x5c, 0xee, 0x4e, 0x26, 0x37, 0xb4, 0xa9, 0x5d, 0xd8, 0x57, 0x63, 0x6c,
-	0xcc, 0xbc, 0x67, 0x50, 0x9d, 0xe2, 0x20, 0x88, 0xf5, 0x46, 0x99, 0x5d, 0x84, 0x60, 0xc4, 0x48,
-	0xa3, 0x35, 0x53, 0xf0, 0xa0, 0x3d, 0xa9, 0xde, 0xf5, 0x3d, 0x1d, 0x38, 0x3f, 0x52, 0xd5, 0x0f,
-	0x7d, 0x4f, 0x78, 0xc1, 0xb5, 0x0f, 0x7d, 0x2f, 0xb7, 0x87, 0x79, 0xdf, 0x5c, 0xb4, 0xa7, 0xf0,
-	0x9b, 0x4b, 0x08, 0xc7, 0x9b, 0x5c, 0x62, 0x96, 0xb8, 0x36, 0xc5, 0x7a, 0x6b, 0xf1, 0x94, 0xf7,
-	0x9c, 0x32, 0x5a, 0x33, 0xc1, 0xcd, 0x21, 0xf4, 0x18, 0xaa, 0x38, 0x4c, 0xe8, 0x8d, 0xde, 0xe6,
-	0x02, 0xed, 0x4c, 0xe0, 0x90, 0x21, 0x99, 0x03, 0x9c, 0x8a, 0x9e, 0x41, 0xc5, 0x89, 0xa3, 0x48,
-	0xef, 0x70, 0xae, 0xbb, 0x19, 0xd7, 0x20, 0x8e, 0xa2, 0x43, 0x42, 0xed, 0xf3, 0xc0, 0x27, 0xd3,
-	0xd1, 0x9a, 0xc9, 0x99, 0xd0, 0x3e, 0x00, 0xa1, 0x36, 0xc5, 0x96, 0x1f, 0x4d, 0x62, 0x7d, 0x8b,
-	0x8b, 0x6c, 0xe7, 0x65, 0xc2, 0x28, 0xe3, 0x68, 0xc2, 0xa2, 0xd3, 0x20, 0x19, 0x80, 0x0e, 0xa0,
-	0x23, 0x64, 0x48, 0x64, 0x27, 0x64, 0x1a, 0x53, 0xbd, 0x5b, 0xbe, 0xf4, 0x5c, 0xee, 0x54, 0x32,
-	0x8c, 0xd6, 0xcc, 0x36, 0x17, 0xc9, 0x10, 0xe8, 0x08, 0xee, 0x14, 0xe7, 0x5a, 0xc9, 0x2c, 0x08,
-	0x78, 0xfc, 0xb6, 0xb9, 0xa2, 0xcf, 0x16, 0x14, 0x9d, 0xcc, 0x82, 0xa0, 0x08, 0x64, 0x97, 0xcc,
-	0xe1, 0x51, 0x1f, 0x84, 0x7e, 0xa6, 0x84, 0x31, 0xe9, 0xa8, 0x9c, 0x50, 0x26, 0x0e, 0x63, 0x8a,
-	0xb9, 0xba, 0x42, 0x4d, 0x8b, 0x28, 0x30, 0x1a, 0x66, 0x5e, 0xa5, 0x32, 0xe5, 0xf4, 0x3b, 0x5c,
-	0xc7, 0xa7, 0x4b, 0x75, 0xe4, 0x59, 0xd9, 0x26, 0x2a, 0x82, 0xc5, 0x26, 0xc0, 0xb6, 0x2b, 0x92,
-	0x97, 0xa7, 0xe8, 0x4e, 0x39, 0x36, 0x6f, 0x73, 0x6a, 0x91, 0xa8, 0xed, 0x42, 0x84, 0xa5, 0xeb,
-	0xd7, 0xd0, 0x4e, 0x30, 0x4e, 0x2d, 0xdf, 0xc5, 0x11, 0xf5, 0xe9, 0x8d, 0x7e, 0xb7, 0x5c, 0x86,
-	0x27, 0x18, 0xa7, 0x63, 0x49, 0x63, 0x6e, 0x24, 0x0a, 0xcc, 0x8a, 0xdd, 0x76, 0x2e, 0xf4, 0x7b,
-	0x5c, 0xe4, 0x7e, 0x5e, 0xb9, 0xce, 0x45, 0x14, 0x7f, 0x17, 0x60, 0xd7, 0xc3, 0x21, 0x8e, 0x98,
-	0xf3, 0x8c, 0x0b, 0xfd, 0x0e, 0x20, 0x49, 0xfd, 0x2b, 0x11, 0x05, 0xfd, 0x7e, 0x39, 0xf8, 0xc2,
-	0xdf, 0x93, 0x2b, 0x5a, 0xce, 0x62, 0x45, 0x02, 0xbd, 0x52, 0xe4, 0x89, 0xae, 0x73, 0xf9, 0x1f,
-	0xad, 0x90, 0xcf, 0x23, 0xa6, 0x88, 0xa0, 0x57, 0xd0, 0x92, 0x90, 0xc5, 0x12, 0x5d, 0xff, 0xa4,
-	0x7c, 0x6d, 0x27, 0x82, 0x56, 0x2e, 0xeb, 0x66, 0x52, 0x60, 0x51, 0x1f, 0x9a, 0x6c, 0xca, 0x48,
-	0x13, 0xf5, 0x6f, 0x97, 0x99, 0x30, 0x28, 0x18, 0xa4, 0x0f, 0xaa, 0x0c, 0x3a, 0x50, 0x55, 0x10,
-	0xfd, 0xcf, 0x5c, 0xc5, 0x83, 0x55, 0x2a, 0x72, 0x37, 0x54, 0x21, 0xc3, 0x82, 0x8d, 0x33, 0xdb,
-	0x43, 0x6d, 0x68, 0xbc, 0x3f, 0x1e, 0x1e, 0xbe, 0x1e, 0x1f, 0x1f, 0x0e, 0xbb, 0x6b, 0xa8, 0x01,
-	0xd5, 0xc3, 0xa3, 0x93, 0xb3, 0x0f, 0x5d, 0x0d, 0xb5, 0xa0, 0xfe, 0xce, 0x7c, 0x63, 0xbd, 0x3b,
-	0x7e, 0xfb, 0xa1, 0xbb, 0xce, 0xf8, 0x06, 0xa3, 0xfe, 0xb1, 0x00, 0x37, 0x50, 0x17, 0x5a, 0x1c,
-	0xec, 0x1f, 0x0f, 0xad, 0x77, 0xe6, 0x9b, 0x6e, 0x05, 0x6d, 0x41, 0x53, 0x30, 0x98, 0x1c, 0x51,
-	0x55, 0x07, 0xc2, 0x7f, 0x35, 0x68, 0xe4, 0x85, 0x81, 0x7a, 0xd0, 0xc8, 0x87, 0x28, 0x6f, 0xfc,
-	0xcd, 0xfd, 0xae, 0x9a, 0x28, 0x67, 0x7e, 0x88, 0xcd, 0x82, 0x05, 0xdd, 0x85, 0xcd, 0xe4, 0xc2,
-	0xb7, 0x7c, 0x97, 0xcf, 0x83, 0x96, 0x59, 0x4d, 0x2e, 0xfc, 0xb1, 0x8b, 0x1e, 0x42, 0x53, 0x8e,
-	0x0b, 0xeb, 0xa8, 0x3f, 0xd0, 0x2b, 0x9c, 0x06, 0x12, 0x75, 0xd4, 0x1f, 0xb0, 0x46, 0x91, 0xa4,
-	0x71, 0x82, 0x53, 0xea, 0x63, 0x22, 0x07, 0x03, 0x2a, 0xee, 0x29, 0xa3, 0x98, 0x0a, 0x97, 0xf1,
-	0xbd, 0x06, 0x50, 0x90, 0xd0, 0x8f, 0xa1, 0xcd, 0x33, 0x30, 0xb5, 0xa6, 0xd8, 0xf7, 0xa6, 0x54,
-	0xce, 0xaf, 0x96, 0x40, 0x8e, 0x38, 0x0e, 0x7d, 0x0e, 0xad, 0x00, 0x4f, 0xa8, 0xa5, 0xce, 0xb2,
-	0xba, 0xd9, 0x64, 0xb8, 0x81, 0x9c, 0x67, 0x3f, 0x07, 0x66, 0x98, 0x1f, 0x39, 0xb1, 0x8b, 0x89,
-	0xbe, 0xf1, 0x68, 0x43, 0xed, 0x59, 0x83, 0x8c, 0x62, 0x2a, 0x4c, 0x46, 0x1f, 0xb6, 0x17, 0x9a,
-	0x12, 0x7a, 0x0e, 0x75, 0x1c, 0xf0, 0x7a, 0x20, 0xba, 0xc6, 0xb5, 0xe4, 0x91, 0xcb, 0x57, 0x83,
-	0x9c, 0xc3, 0xf8, 0x15, 0xec, 0x2c, 0x6b, 0x47, 0xf3, 0x91, 0xd3, 0xe6, 0x23, 0x67, 0x4c, 0xa0,
-	0x5d, 0xea, 0xbd, 0xca, 0x15, 0x68, 0xea, 0x15, 0xec, 0x42, 0x3d, 0xaf, 0x78, 0x31, 0xc1, 0x73,
-	0x18, 0x19, 0xd0, 0xa6, 0x01, 0xb1, 0x1c, 0x9c, 0x52, 0x6b, 0x6a, 0x93, 0xa9, 0xbc, 0xbc, 0x26,
-	0x0d, 0xc8, 0x00, 0xa7, 0x74, 0x64, 0x93, 0xa9, 0xf1, 0x1e, 0x5a, 0x6a, 0x67, 0x58, 0x75, 0x0c,
-	0x82, 0x0a, 0x53, 0x23, 0x8f, 0xe0, 0xdf, 0xec, 0xe8, 0x10, 0x53, 0x9b, 0x97, 0xa0, 0xd0, 0x9c,
-	0xc3, 0x46, 0x08, 0x4d, 0xa5, 0x78, 0x56, 0x2f, 0x1f, 0x2e, 0x1f, 0x8c, 0x44, 0x5f, 0x7f, 0xb4,
-	0xc1, 0x96, 0x0f, 0x09, 0xa2, 0x1e, 0xd4, 0x43, 0xe2, 0x59, 0xf4, 0x46, 0x6e, 0x61, 0x9d, 0x62,
-	0x3a, 0xb2, 0x28, 0x1e, 0x11, 0xef, 0xec, 0x26, 0xc1, 0x66, 0x2d, 0x14, 0x1f, 0x46, 0x0c, 0x4d,
-	0x65, 0x2c, 0xaf, 0x38, 0x4e, 0xb5, 0x77, 0xbd, 0x6c, 0xef, 0x47, 0x1f, 0x78, 0x0d, 0x50, 0x4c,
-	0xdc, 0x15, 0xe7, 0xfd, 0x04, 0x2a, 0xf2, 0xac, 0xe5, 0x59, 0x52, 0xf9, 0x41, 0x27, 0x07, 0xe2,
-	0x64, 0xb1, 0x51, 0xfc, 0xdf, 0x03, 0xfb, 0x95, 0xb8, 0xc7, 0x6c, 0x89, 0xfc, 0x69, 0x79, 0xa3,
-	0x6d, 0xee, 0x6f, 0xe5, 0xd2, 0x02, 0x9d, 0xaf, 0xb8, 0xc6, 0x6b, 0x40, 0x8b, 0x8d, 0x18, 0xbd,
-	0x98, 0x57, 0x70, 0x6f, 0xae, 0x6b, 0x2f, 0xe8, 0xf9, 0x00, 0x35, 0x89, 0x43, 0xf7, 0xa1, 0x46,
-	0xf0, 0xa5, 0x15, 0xcd, 0x42, 0xe9, 0xee, 0x26, 0xc1, 0x97, 0xc7, 0xb3, 0x90, 0x65, 0xa7, 0x72,
-	0xab, 0x22, 0xae, 0x9f, 0xcf, 0x0d, 0x89, 0x0d, 0x1e, 0x08, 0x75, 0x0c, 0x18, 0xff, 0x5a, 0x87,
-	0x4e, 0xf9, 0x58, 0xf4, 0x05, 0x6c, 0x15, 0xef, 0x0f, 0x2b, 0xb2, 0x43, 0x11, 0xd9, 0x86, 0xd9,
-	0x29, 0xd0, 0xc7, 0x76, 0x88, 0xd9, 0x06, 0xcf, 0xa8, 0x24, 0xb1, 0x1d, 0xb1, 0xc1, 0x37, 0xcc,
-	0x02, 0x81, 0xee, 0x40, 0x95, 0x5e, 0x67, 0xed, 0xb2, 0x61, 0x56, 0xe8, 0xf5, 0xd8, 0x65, 0x9d,
-	0x2c, 0xb3, 0x28, 0xfd, 0x8e, 0x60, 0x2a, 0xfb, 0x65, 0x66, 0xa6, 0xc9, 0x70, 0xe8, 0x39, 0xa0,
-	0x8c, 0x89, 0xf8, 0x61, 0xd6, 0xf3, 0xaa, 0xdc, 0xdd, 0xae, 0xa4, 0x9c, 0xfa, 0xa1, 0xec, 0x7b,
-	0xc7, 0x80, 0x14, 0x73, 0x9d, 0x38, 0x9a, 0xf8, 0x1e, 0x91, 0xdb, 0xf4, 0xc3, 0x9e, 0x78, 0x50,
-	0xf5, 0x06, 0x39, 0xc7, 0x80, 0x33, 0x9c, 0xd8, 0xce, 0x85, 0xed, 0x61, 0x73, 0xdb, 0x99, 0x23,
-	0x10, 0xe3, 0x1f, 0x1a, 0xb4, 0xd4, 0x7d, 0x1d, 0xf5, 0x00, 0xc2, 0x7c, 0xad, 0x96, 0x57, 0xd6,
-	0x29, 0x2f, 0xdc, 0xa6, 0xc2, 0xf1, 0xd1, 0x83, 0x45, 0x6d, 0x5f, 0x95, 0x72, 0xfb, 0x32, 0xfe,
-	0xaa, 0xc1, 0xf6, 0xc2, 0xe2, 0xb3, 0xaa, 0x41, 0x7d, 0xec, 0xc1, 0x8f, 0xa1, 0xe3, 0x13, 0xcb,
-	0xc5, 0x4e, 0x60, 0xa7, 0x36, 0x0b, 0x01, 0xbf, 0xaa, 0xba, 0xd9, 0xf6, 0xc9, 0xb0, 0x40, 0x1a,
-	0xbf, 0x81, 0x7a, 0x26, 0xcd, 0xd2, 0xcf, 0x8f, 0x1c, 0x35, 0xfd, 0xfc, 0xc8, 0x61, 0xe9, 0xa7,
-	0xe4, 0xe5, 0xba, 0x9a, 0x97, 0xc6, 0x04, 0xb6, 0x17, 0x9e, 0x32, 0xe8, 0x6b, 0xe8, 0x12, 0x1c,
-	0x4c, 0xf8, 0x0e, 0x9b, 0x86, 0xe2, 0x6c, 0xad, 0x6c, 0x70, 0xde, 0x22, 0xb6, 0x18, 0xe7, 0xb8,
-	0x60, 0x64, 0xf5, 0xce, 0x76, 0xb2, 0x48, 0xd6, 0xb5, 0x00, 0x8c, 0x73, 0x40, 0x8b, 0x8f, 0x1f,
-	0xf4, 0x04, 0xaa, 0xfc, 0xad, 0xb5, 0x72, 0x4c, 0x09, 0x32, 0xef, 0x53, 0xd8, 0x76, 0x6f, 0xe9,
-	0x53, 0xd8, 0x76, 0x8d, 0x3f, 0xc2, 0xa6, 0x38, 0x83, 0xdd, 0x19, 0x2e, 0x3d, 0x46, 0xcd, 0x1c,
-	0xbe, 0xb5, 0xc7, 0x2e, 0x5f, 0x22, 0x8c, 0x1a, 0x54, 0xf9, 0x5b, 0xc4, 0xf8, 0x13, 0xa0, 0xc5,
-	0x8d, 0x9b, 0x0d, 0x31, 0x42, 0xed, 0x94, 0x5a, 0xe5, 0xd2, 0x6f, 0x72, 0xe4, 0xa9, 0xa8, 0xff,
-	0x07, 0xd0, 0xc4, 0x91, 0x6b, 0x95, 0x2f, 0xa1, 0x81, 0x23, 0x57, 0xd0, 0x8d, 0x03, 0xb8, 0xb3,
-	0x64, 0x0f, 0x47, 0xcf, 0xa0, 0x2e, 0xbb, 0x4c, 0x36, 0xca, 0x17, 0xda, 0x59, 0xce, 0x60, 0xbc,
-	0x81, 0x9d, 0x65, 0xbb, 0x2d, 0xda, 0x2b, 0x7a, 0xad, 0xd0, 0x91, 0xbf, 0x9d, 0x24, 0xa3, 0xe8,
-	0xd4, 0x79, 0x0b, 0x36, 0xfe, 0xa3, 0x41, 0xbb, 0x44, 0x2a, 0xba, 0x85, 0xa6, 0x74, 0x8b, 0xdb,
-	0x1b, 0xcc, 0x03, 0x80, 0xa2, 0x7a, 0x65, 0x97, 0x51, 0x30, 0xe8, 0x53, 0x68, 0x9c, 0x07, 0xb1,
-	0x73, 0xc1, 0x62, 0xc2, 0x0b, 0xab, 0x62, 0xd6, 0x39, 0xe2, 0x14, 0x5f, 0xa2, 0x47, 0xd0, 0x62,
-	0xa1, 0xf2, 0x23, 0x8b, 0xa3, 0x64, 0x77, 0x01, 0x82, 0x2f, 0xc7, 0xd1, 0x01, 0xc3, 0x18, 0xdf,
-	0xc0, 0xdd, 0xa5, 0x8b, 0x38, 0xda, 0x5f, 0xd8, 0x7e, 0xee, 0xcd, 0xb9, 0x7b, 0x28, 0xc8, 0xca,
-	0x0e, 0xf4, 0x01, 0x3a, 0x65, 0x1a, 0xfa, 0x12, 0x36, 0x45, 0x34, 0x64, 0xe2, 0xaf, 0x08, 0x99,
-	0x64, 0x52, 0xff, 0xa3, 0xc8, 0x71, 0x96, 0x0d, 0x87, 0xdf, 0xe7, 0xaa, 0xb3, 0x06, 0xfe, 0x18,
-	0xb6, 0xe8, 0xb5, 0x55, 0x72, 0x4f, 0x2e, 0x8c, 0xf4, 0xfa, 0x34, 0x77, 0xb0, 0xac, 0x52, 0xfd,
-	0x35, 0x63, 0x7c, 0x01, 0x5b, 0x73, 0xef, 0x1e, 0x56, 0x74, 0x38, 0x4d, 0xe3, 0x54, 0xde, 0x8f,
-	0x00, 0x8c, 0xf7, 0xd0, 0xc8, 0xd7, 0x46, 0x36, 0x81, 0x94, 0x61, 0xc1, 0xbf, 0xd9, 0x19, 0x57,
-	0x38, 0x25, 0xec, 0x82, 0xc4, 0xfd, 0x65, 0xe0, 0xad, 0x9b, 0xd3, 0xf7, 0x1a, 0xe8, 0x7f, 0xb0,
-	0x03, 0xdf, 0xe5, 0x05, 0x6f, 0x62, 0x32, 0x0b, 0x28, 0xc9, 0x9a, 0xdf, 0xca, 0x09, 0xa8, 0x43,
-	0x8d, 0x5e, 0xbf, 0x0e, 0x6c, 0x8f, 0x64, 0xfe, 0x48, 0xb0, 0xfc, 0xab, 0x69, 0x63, 0xfe, 0xaf,
-	0xd7, 0x6d, 0xfd, 0xd7, 0xca, 0x92, 0x60, 0xee, 0x29, 0xb4, 0x62, 0xe9, 0x78, 0x51, 0x5e, 0x3a,
-	0x94, 0xcc, 0xc8, 0xe4, 0xe7, 0x2b, 0xe1, 0xef, 0x1a, 0x74, 0xca, 0xb4, 0x72, 0xd6, 0x6b, 0xb7,
-	0x67, 0xfd, 0xfa, 0x42, 0xd6, 0x77, 0x61, 0xe3, 0x02, 0xdf, 0xc8, 0x72, 0x60, 0x9f, 0xe8, 0x09,
-	0x74, 0x70, 0xe4, 0xc6, 0x29, 0xc1, 0x6e, 0x9f, 0x9e, 0x5d, 0x8f, 0x87, 0xdc, 0xcb, 0x86, 0x39,
-	0x87, 0x35, 0x1c, 0xb8, 0xb7, 0xfc, 0xcd, 0xb6, 0xc2, 0xd9, 0x97, 0x4a, 0x1d, 0x08, 0x6f, 0xef,
-	0xcf, 0x7b, 0xbb, 0x58, 0x08, 0xff, 0xd6, 0x60, 0x6b, 0x8e, 0x8a, 0x7a, 0x73, 0xa5, 0xb0, 0x2a,
-	0x68, 0x59, 0x2d, 0xec, 0x40, 0xf5, 0xca, 0x0e, 0x66, 0xd9, 0x5f, 0x43, 0x01, 0xa0, 0x5f, 0x03,
-	0xe0, 0xeb, 0xc4, 0x4f, 0x6f, 0xd8, 0xa0, 0x92, 0xff, 0x2d, 0xd9, 0x7b, 0x38, 0xf6, 0x02, 0xf9,
-	0x9b, 0xf5, 0x7c, 0x36, 0xe9, 0x9d, 0x65, 0xd3, 0xcf, 0x54, 0xb8, 0x7f, 0xf6, 0x5b, 0x68, 0x2a,
-	0xab, 0xdf, 0xfc, 0x6b, 0xb4, 0x0d, 0x8d, 0x83, 0xb7, 0xef, 0x06, 0xdf, 0x58, 0x47, 0xa7, 0x6f,
-	0xba, 0x1a, 0x7b, 0x74, 0x8e, 0x87, 0x87, 0xc7, 0x67, 0xe3, 0xb3, 0x0f, 0x1c, 0xb3, 0xbe, 0xff,
-	0x17, 0xd8, 0x14, 0xab, 0x37, 0xfa, 0x0a, 0x5a, 0xe2, 0xeb, 0x94, 0xa6, 0xd8, 0x0e, 0xd1, 0xc2,
-	0x24, 0xd9, 0x5d, 0xc0, 0x18, 0x6b, 0x4f, 0xb5, 0x17, 0x1a, 0x7a, 0x02, 0x95, 0x13, 0x3f, 0xf2,
-	0x50, 0xf9, 0xe7, 0xd4, 0x6e, 0x19, 0x34, 0xd6, 0x0e, 0xbe, 0xfc, 0xf6, 0x99, 0xe7, 0xd3, 0xe9,
-	0xec, 0x9c, 0xad, 0x36, 0x7b, 0xd3, 0x9b, 0x04, 0xa7, 0xe2, 0x19, 0xb8, 0x37, 0xb1, 0xcf, 0x53,
-	0xdf, 0x11, 0xbf, 0x88, 0xc9, 0x9e, 0x10, 0x3b, 0xdf, 0xe4, 0xe0, 0xcb, 0xff, 0x05, 0x00, 0x00,
-	0xff, 0xff, 0xa8, 0x94, 0x0a, 0xc3, 0x78, 0x16, 0x00, 0x00,
+func init() { proto.RegisterFile("gossip/message.proto", fileDescriptor_message_0b03f5a6f808ce81) }
+
+var fileDescriptor_message_0b03f5a6f808ce81 = []byte{
+	// 2078 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x18, 0x4b, 0x73, 0xdc, 0x48,
+	0xd9, 0xb2, 0x67, 0xc6, 0x33, 0xdf, 0x3c, 0x3c, 0xee, 0x38, 0x89, 0xd6, 0xbb, 0x24, 0x5e, 0x41,
+	0xb2, 0x81, 0x64, 0xc7, 0xc1, 0x81, 0x62, 0x8b, 0x05, 0x52, 0xe3, 0x19, 0x6f, 0x66, 0x6a, 0x63,
+	0xc7, 0xc8, 0x4e, 0x41, 0x96, 0x83, 0x4a, 0x96, 0x7a, 0x34, 0xc2, 0x7a, 0x59, 0xdd, 0xe3, 0xb5,
+	0x8f, 0x14, 0x17, 0x8a, 0x03, 0x1c, 0x38, 0x73, 0xe0, 0xc4, 0xdf, 0xa4, 0xfa, 0x21, 0xa9, 0x35,
+	0x0f, 0x57, 0x65, 0xab, 0xb8, 0xe9, 0x7b, 0x3f, 0xfa, 0xeb, 0xef, 0xfb, 0x5a, 0xb0, 0xe3, 0xc5,
+	0x84, 0xf8, 0xc9, 0x7e, 0x88, 0x09, 0xb1, 0x3d, 0xdc, 0x4b, 0xd2, 0x98, 0xc6, 0xa8, 0x26, 0xb0,
+	0xbb, 0x0f, 0x9d, 0x38, 0x0c, 0xe3, 0x68, 0xdf, 0x89, 0x83, 0x00, 0x3b, 0xd4, 0x8f, 0x23, 0xc1,
+	0xb0, 0xfb, 0xd8, 0x8b, 0x63, 0x2f, 0xc0, 0xfb, 0x1c, 0xba, 0x98, 0x4d, 0xf6, 0xa9, 0x1f, 0x62,
+	0x42, 0xed, 0x30, 0x11, 0x0c, 0xc6, 0x5f, 0x35, 0xa8, 0x1f, 0x45, 0xd7, 0x38, 0x88, 0x13, 0x8c,
+	0x74, 0xd8, 0x4c, 0xec, 0xdb, 0x20, 0xb6, 0x5d, 0x5d, 0xdb, 0xd3, 0x9e, 0xb5, 0xcc, 0x0c, 0x44,
+	0x9f, 0x41, 0x83, 0xf8, 0x5e, 0x64, 0xd3, 0x59, 0x8a, 0xf5, 0x75, 0x4e, 0x2b, 0x10, 0xe8, 0x35,
+	0x6c, 0x11, 0xec, 0xa4, 0x98, 0x5a, 0x58, 0xaa, 0xd2, 0x37, 0xf6, 0xb4, 0x67, 0xcd, 0x83, 0x07,
+	0x3d, 0xe1, 0x60, 0xef, 0x8c, 0x93, 0x33, 0x43, 0x66, 0x87, 0x94, 0x60, 0x63, 0x04, 0x9d, 0x32,
+	0xc7, 0x0f, 0x75, 0xc5, 0xe8, 0x43, 0x4d, 0x68, 0x42, 0x2f, 0xa0, 0xeb, 0x47, 0x14, 0xa7, 0x91,
+	0x1d, 0x1c, 0x45, 0x6e, 0x12, 0xfb, 0x11, 0xe5, 0xaa, 0x1a, 0xa3, 0x35, 0x73, 0x81, 0x72, 0xd8,
+	0x80, 0x4d, 0x27, 0x8e, 0x28, 0x8e, 0xa8, 0xf1, 0x8f, 0x16, 0xb4, 0xdf, 0x70, 0xb7, 0x8f, 0x45,
+	0xb2, 0xd1, 0x0e, 0x54, 0xa3, 0x38, 0x72, 0x30, 0x97, 0xaf, 0x98, 0x02, 0x60, 0x2e, 0x3a, 0x53,
+	0x3b, 0x8a, 0x70, 0x20, 0xdd, 0xc8, 0x40, 0xf4, 0x1c, 0x36, 0xa8, 0xed, 0xf1, 0x1c, 0x74, 0x0e,
+	0x3e, 0xc9, 0x72, 0x50, 0xd2, 0xd9, 0x3b, 0xb7, 0x3d, 0x93, 0x71, 0xa1, 0x57, 0xd0, 0xb0, 0x03,
+	0xff, 0x1a, 0x5b, 0x21, 0xf1, 0xf4, 0x2a, 0x4f, 0xdb, 0x4e, 0x26, 0xd2, 0x67, 0x04, 0x29, 0x31,
+	0x5a, 0x33, 0xeb, 0x9c, 0xf1, 0x98, 0x78, 0xe8, 0x17, 0xb0, 0x19, 0xe2, 0xd0, 0x4a, 0xf1, 0x95,
+	0x5e, 0xe3, 0x22, 0xb9, 0x95, 0x63, 0x1c, 0x5e, 0xe0, 0x94, 0x4c, 0xfd, 0xc4, 0xc4, 0x57, 0x33,
+	0x4c, 0xe8, 0x68, 0xcd, 0xac, 0x85, 0x38, 0x34, 0xf1, 0x15, 0xfa, 0x65, 0x26, 0x45, 0xf4, 0x4d,
+	0x2e, 0xb5, 0xbb, 0x4c, 0x8a, 0x24, 0x71, 0x44, 0x70, 0x2e, 0x46, 0xd0, 0x4b, 0xa8, 0xbb, 0x36,
+	0xb5, 0xb9, 0x83, 0x75, 0x2e, 0x77, 0x2f, 0x93, 0x1b, 0xda, 0xd4, 0x2e, 0xfc, 0xdb, 0x64, 0x6c,
+	0xcc, 0xbd, 0xe7, 0x50, 0x9d, 0xe2, 0x20, 0x88, 0xf5, 0x46, 0x99, 0x5d, 0xa4, 0x60, 0xc4, 0x48,
+	0xa3, 0x35, 0x53, 0xf0, 0xa0, 0x7d, 0xa9, 0xde, 0xf5, 0x3d, 0x1d, 0x38, 0x3f, 0x52, 0xd5, 0x0f,
+	0x7d, 0x4f, 0x44, 0xc1, 0xb5, 0x0f, 0x7d, 0x2f, 0xf7, 0x87, 0x45, 0xdf, 0x5c, 0xf4, 0xa7, 0x88,
+	0x9b, 0x4b, 0x88, 0xc0, 0x9b, 0x5c, 0x62, 0x96, 0xb8, 0x36, 0xc5, 0x7a, 0x6b, 0xd1, 0xca, 0x7b,
+	0x4e, 0x19, 0xad, 0x99, 0xe0, 0xe6, 0x10, 0x7a, 0x02, 0x55, 0x1c, 0x26, 0xf4, 0x56, 0x6f, 0x73,
+	0x81, 0x76, 0x26, 0x70, 0xc4, 0x90, 0x2c, 0x00, 0x4e, 0x45, 0xcf, 0xa1, 0xe2, 0xc4, 0x51, 0xa4,
+	0x77, 0x38, 0xd7, 0xfd, 0x8c, 0x6b, 0x10, 0x47, 0xd1, 0x11, 0xa1, 0xf6, 0x45, 0xe0, 0x93, 0xe9,
+	0x68, 0xcd, 0xe4, 0x4c, 0xe8, 0x00, 0x80, 0x50, 0x9b, 0x62, 0xcb, 0x8f, 0x26, 0xb1, 0xbe, 0xc5,
+	0x45, 0xb6, 0xf3, 0x6b, 0xc2, 0x28, 0xe3, 0x68, 0xc2, 0xb2, 0xd3, 0x20, 0x19, 0x80, 0x0e, 0xa1,
+	0x23, 0x64, 0x48, 0x64, 0x27, 0x64, 0x1a, 0x53, 0xbd, 0x5b, 0x3e, 0xf4, 0x5c, 0xee, 0x4c, 0x32,
+	0x8c, 0xd6, 0xcc, 0x36, 0x17, 0xc9, 0x10, 0xe8, 0x18, 0xee, 0x15, 0x76, 0xad, 0x64, 0x16, 0x04,
+	0x3c, 0x7f, 0xdb, 0x5c, 0xd1, 0x67, 0x0b, 0x8a, 0x4e, 0x67, 0x41, 0x50, 0x24, 0xb2, 0x4b, 0xe6,
+	0xf0, 0xa8, 0x0f, 0x42, 0x3f, 0x53, 0xc2, 0x98, 0x74, 0x54, 0x2e, 0x28, 0x13, 0x87, 0x31, 0xc5,
+	0x5c, 0x5d, 0xa1, 0xa6, 0x45, 0x14, 0x18, 0x0d, 0xb3, 0xa8, 0x52, 0x59, 0x72, 0xfa, 0x3d, 0xae,
+	0xe3, 0xd3, 0xa5, 0x3a, 0xf2, 0xaa, 0x6c, 0x13, 0x15, 0xc1, 0x72, 0x13, 0x60, 0xdb, 0x15, 0xc5,
+	0xcb, 0x4b, 0x74, 0xa7, 0x9c, 0x9b, 0xb7, 0x39, 0xb5, 0x28, 0xd4, 0x76, 0x21, 0xc2, 0xca, 0xf5,
+	0x6b, 0x68, 0x27, 0x18, 0xa7, 0x96, 0xef, 0xe2, 0x88, 0xfa, 0xf4, 0x56, 0xbf, 0x5f, 0xbe, 0x86,
+	0xa7, 0x18, 0xa7, 0x63, 0x49, 0x63, 0x61, 0x24, 0x0a, 0xcc, 0x2e, 0xbb, 0xed, 0x5c, 0xea, 0x0f,
+	0xb8, 0xc8, 0xc3, 0xfc, 0xe6, 0x3a, 0x97, 0x51, 0xfc, 0x7d, 0x80, 0x5d, 0x0f, 0x87, 0x38, 0x62,
+	0xc1, 0x33, 0x2e, 0xf4, 0x3b, 0x80, 0x24, 0xf5, 0xaf, 0x45, 0x16, 0xf4, 0x87, 0xe5, 0xe4, 0x8b,
+	0x78, 0x4f, 0xaf, 0x69, 0xb9, 0x8a, 0x15, 0x09, 0xf4, 0x5a, 0x91, 0x27, 0xba, 0xce, 0xe5, 0x7f,
+	0xb4, 0x42, 0x3e, 0xcf, 0x98, 0x22, 0x82, 0x5e, 0x43, 0x4b, 0x42, 0x16, 0x2b, 0x74, 0xfd, 0x93,
+	0xf2, 0xb1, 0x9d, 0x0a, 0x5a, 0xf9, 0x5a, 0x37, 0x93, 0x02, 0x8b, 0xfa, 0xd0, 0x64, 0x53, 0x46,
+	0xba, 0xa8, 0x7f, 0xb7, 0xcc, 0x85, 0x41, 0xc1, 0x20, 0x63, 0x50, 0x65, 0xd0, 0xa1, 0xaa, 0x82,
+	0xe8, 0x7f, 0xe2, 0x2a, 0x1e, 0xad, 0x52, 0x91, 0x87, 0xa1, 0x0a, 0x19, 0x16, 0x6c, 0x9c, 0xdb,
+	0x1e, 0x6a, 0x43, 0xe3, 0xfd, 0xc9, 0xf0, 0xe8, 0x9b, 0xf1, 0xc9, 0xd1, 0xb0, 0xbb, 0x86, 0x1a,
+	0x50, 0x3d, 0x3a, 0x3e, 0x3d, 0xff, 0xd0, 0xd5, 0x50, 0x0b, 0xea, 0xef, 0xcc, 0x37, 0xd6, 0xbb,
+	0x93, 0xb7, 0x1f, 0xba, 0xeb, 0x8c, 0x6f, 0x30, 0xea, 0x9f, 0x08, 0x70, 0x03, 0x75, 0xa1, 0xc5,
+	0xc1, 0xfe, 0xc9, 0xd0, 0x7a, 0x67, 0xbe, 0xe9, 0x56, 0xd0, 0x16, 0x34, 0x05, 0x83, 0xc9, 0x11,
+	0x55, 0x75, 0x20, 0xfc, 0x57, 0x83, 0x46, 0x7e, 0x31, 0x50, 0x0f, 0x1a, 0xf9, 0x10, 0xe5, 0x8d,
+	0xbf, 0x79, 0xd0, 0x55, 0x0b, 0xe5, 0xdc, 0x0f, 0xb1, 0x59, 0xb0, 0xa0, 0xfb, 0x50, 0x4b, 0x2e,
+	0x7d, 0xcb, 0x77, 0xf9, 0x3c, 0x68, 0x99, 0xd5, 0xe4, 0xd2, 0x1f, 0xbb, 0xe8, 0x31, 0x34, 0xe5,
+	0xb8, 0xb0, 0x8e, 0xfb, 0x03, 0xbd, 0xc2, 0x69, 0x20, 0x51, 0xc7, 0xfd, 0x01, 0x6b, 0x14, 0x49,
+	0x1a, 0x27, 0x38, 0xa5, 0x3e, 0x26, 0x72, 0x30, 0xa0, 0xe2, 0x9c, 0x32, 0x8a, 0xa9, 0x70, 0x19,
+	0xff, 0xd6, 0x00, 0x0a, 0x12, 0xfa, 0x31, 0xb4, 0x79, 0x05, 0xa6, 0xd6, 0x14, 0xfb, 0xde, 0x94,
+	0xca, 0xf9, 0xd5, 0x12, 0xc8, 0x11, 0xc7, 0xa1, 0xcf, 0xa1, 0x15, 0xe0, 0x09, 0xb5, 0xd4, 0x59,
+	0x56, 0x37, 0x9b, 0x0c, 0x37, 0x90, 0xf3, 0xec, 0xe7, 0xc0, 0x1c, 0xf3, 0x23, 0x27, 0x76, 0x31,
+	0xd1, 0x37, 0xf6, 0x36, 0xd4, 0x9e, 0x35, 0xc8, 0x28, 0xa6, 0xc2, 0xc4, 0x46, 0x66, 0x1a, 0x07,
+	0x98, 0xe8, 0xce, 0xde, 0xc6, 0xb3, 0x86, 0x29, 0x00, 0xa3, 0x0f, 0xdb, 0x0b, 0xad, 0x0a, 0xbd,
+	0x80, 0x3a, 0x0e, 0xf8, 0x2d, 0x21, 0xba, 0xc6, 0x75, 0xe7, 0xf9, 0xcc, 0x17, 0x86, 0x9c, 0xc3,
+	0xf8, 0x15, 0xec, 0x2c, 0x6b, 0x52, 0xf3, 0xf9, 0xd4, 0xe6, 0xf3, 0x69, 0x4c, 0xa0, 0x5d, 0xea,
+	0xc8, 0xca, 0xc1, 0x68, 0xea, 0xc1, 0xec, 0x42, 0x3d, 0xef, 0x03, 0x62, 0xae, 0xe7, 0x30, 0x32,
+	0xa0, 0x4d, 0x03, 0x62, 0x39, 0x38, 0xa5, 0xd6, 0xd4, 0x26, 0x53, 0x79, 0xa4, 0x4d, 0x1a, 0x90,
+	0x01, 0x4e, 0xe9, 0xc8, 0x26, 0x53, 0xe3, 0x3d, 0xb4, 0xd4, 0x7e, 0xb1, 0xca, 0x0c, 0x82, 0x0a,
+	0x53, 0x23, 0x4d, 0xf0, 0x6f, 0x66, 0x3a, 0xc4, 0xd4, 0xe6, 0x17, 0x53, 0x68, 0xce, 0x61, 0x23,
+	0x84, 0xa6, 0x72, 0xa5, 0x56, 0xaf, 0x24, 0x2e, 0x1f, 0x97, 0x44, 0x5f, 0xdf, 0xdb, 0x60, 0x2b,
+	0x89, 0x04, 0x51, 0x0f, 0xea, 0x21, 0xf1, 0x2c, 0x7a, 0x2b, 0x77, 0xb3, 0x4e, 0x31, 0x33, 0x59,
+	0x16, 0x8f, 0x89, 0x77, 0x7e, 0x9b, 0x60, 0x73, 0x33, 0x14, 0x1f, 0x46, 0x0c, 0x4d, 0x65, 0x58,
+	0xaf, 0x30, 0xa7, 0xfa, 0xbb, 0x5e, 0xf6, 0xf7, 0xa3, 0x0d, 0xde, 0x00, 0x14, 0x73, 0x78, 0x85,
+	0xbd, 0x9f, 0x40, 0x45, 0xda, 0x5a, 0x5e, 0x25, 0x95, 0x1f, 0x64, 0x39, 0x10, 0x96, 0xc5, 0x9e,
+	0xf1, 0x7f, 0x4f, 0xec, 0x57, 0xe2, 0x1c, 0xb3, 0xd5, 0xf2, 0xa7, 0xe5, 0x3d, 0xb7, 0x79, 0xb0,
+	0x95, 0x4b, 0x0b, 0x74, 0xbe, 0xf8, 0x1a, 0xdf, 0x00, 0x5a, 0x6c, 0xcf, 0xe8, 0xe5, 0xbc, 0x82,
+	0x07, 0x73, 0xbd, 0x7c, 0x41, 0xcf, 0x07, 0xd8, 0x94, 0x38, 0xf4, 0x10, 0x36, 0x09, 0xbe, 0xb2,
+	0xa2, 0x59, 0x28, 0xc3, 0xad, 0x11, 0x7c, 0x75, 0x32, 0x0b, 0x59, 0x75, 0x2a, 0xa7, 0x2a, 0xf2,
+	0xfa, 0xf9, 0xdc, 0xe8, 0xd8, 0xe0, 0x89, 0x50, 0x87, 0x83, 0xf1, 0xcf, 0x75, 0xe8, 0x94, 0xcd,
+	0xa2, 0x2f, 0x60, 0xab, 0x78, 0x95, 0x58, 0x91, 0x1d, 0x8a, 0xcc, 0x36, 0xcc, 0x4e, 0x81, 0x3e,
+	0xb1, 0x43, 0xcc, 0xf6, 0x7a, 0x46, 0x25, 0x89, 0xed, 0x88, 0xbd, 0xbe, 0x61, 0x16, 0x08, 0x74,
+	0x0f, 0xaa, 0xf4, 0x26, 0x6b, 0xa2, 0x0d, 0xb3, 0x42, 0x6f, 0xc6, 0x2e, 0xeb, 0x6f, 0x99, 0x47,
+	0xe9, 0xf7, 0x04, 0x53, 0xd9, 0x45, 0x33, 0x37, 0x4d, 0x86, 0x43, 0x2f, 0x00, 0x65, 0x4c, 0xc4,
+	0x0f, 0xb3, 0x4e, 0x58, 0xe5, 0xe1, 0x76, 0x25, 0xe5, 0xcc, 0x0f, 0x65, 0x37, 0x3c, 0x01, 0xa4,
+	0xb8, 0xeb, 0xc4, 0xd1, 0xc4, 0xf7, 0x88, 0xdc, 0xb1, 0x1f, 0xf7, 0xc4, 0x33, 0xab, 0x37, 0xc8,
+	0x39, 0x06, 0x9c, 0xe1, 0xd4, 0x76, 0x2e, 0x6d, 0x0f, 0x9b, 0xdb, 0xce, 0x1c, 0x81, 0x18, 0x7f,
+	0xd7, 0xa0, 0xa5, 0x6e, 0xf1, 0xa8, 0x07, 0x10, 0xe6, 0xcb, 0xb6, 0x3c, 0xb2, 0x4e, 0x79, 0x0d,
+	0x37, 0x15, 0x8e, 0x8f, 0x1e, 0x37, 0x6a, 0xfb, 0xaa, 0x94, 0xdb, 0x97, 0xf1, 0x17, 0x0d, 0xb6,
+	0x17, 0xd6, 0xa1, 0x55, 0x0d, 0xea, 0x63, 0x0d, 0x3f, 0x81, 0x8e, 0x4f, 0x2c, 0x17, 0x3b, 0x81,
+	0x9d, 0xda, 0x2c, 0x05, 0xfc, 0xa8, 0xea, 0x66, 0xdb, 0x27, 0xc3, 0x02, 0x69, 0xfc, 0x06, 0xea,
+	0x99, 0x34, 0x2b, 0x3f, 0x3f, 0x72, 0xd4, 0xf2, 0xf3, 0x23, 0x87, 0x95, 0x9f, 0x52, 0x97, 0xeb,
+	0x6a, 0x5d, 0x1a, 0x13, 0xd8, 0x5e, 0x78, 0xe0, 0xa0, 0xaf, 0xa1, 0x4b, 0x70, 0x30, 0xe1, 0x9b,
+	0x6d, 0x1a, 0x0a, 0xdb, 0x5a, 0xd9, 0xe1, 0xbc, 0x45, 0x6c, 0x31, 0xce, 0x71, 0xc1, 0xc8, 0xee,
+	0x3b, 0xdb, 0xd4, 0x22, 0x79, 0xaf, 0x05, 0x60, 0x5c, 0x00, 0x5a, 0x7c, 0x12, 0xa1, 0xa7, 0x50,
+	0xe5, 0x2f, 0xb0, 0x95, 0x63, 0x4a, 0x90, 0x79, 0x9f, 0xc2, 0xb6, 0x7b, 0x47, 0x9f, 0xc2, 0xb6,
+	0x6b, 0xfc, 0x01, 0x6a, 0xc2, 0x06, 0x3b, 0x33, 0x5c, 0x7a, 0xa2, 0x9a, 0x39, 0x7c, 0x67, 0x8f,
+	0x5d, 0xbe, 0x5a, 0x18, 0x9b, 0x50, 0xe5, 0x2f, 0x14, 0xe3, 0x8f, 0x80, 0x16, 0xf7, 0x70, 0x36,
+	0xc4, 0x08, 0xb5, 0x53, 0x6a, 0x95, 0xaf, 0x7e, 0x93, 0x23, 0xcf, 0xc4, 0xfd, 0x7f, 0x04, 0x4d,
+	0x1c, 0xb9, 0x56, 0xf9, 0x10, 0x1a, 0x38, 0x72, 0x05, 0xdd, 0x38, 0x84, 0x7b, 0x4b, 0xb6, 0x73,
+	0xf4, 0x1c, 0xea, 0xb2, 0xcb, 0x64, 0xa3, 0x7c, 0xa1, 0x9d, 0xe5, 0x0c, 0xc6, 0x1b, 0xd8, 0x59,
+	0xb6, 0xf1, 0xa2, 0xfd, 0xa2, 0xd7, 0x0a, 0x1d, 0xf9, 0x8b, 0x4a, 0x32, 0x8a, 0x4e, 0x9d, 0xb7,
+	0x60, 0xe3, 0x3f, 0x1a, 0xb4, 0x4b, 0xa4, 0xa2, 0x5b, 0x68, 0x4a, 0xb7, 0xb8, 0xbb, 0xc1, 0x3c,
+	0x02, 0x28, 0x6e, 0xaf, 0xec, 0x32, 0x0a, 0x06, 0x7d, 0x0a, 0x8d, 0x8b, 0x20, 0x76, 0x2e, 0x59,
+	0x4e, 0xf8, 0xc5, 0xaa, 0x98, 0x75, 0x8e, 0x38, 0xc3, 0x57, 0x68, 0x0f, 0x5a, 0x2c, 0x55, 0x7e,
+	0x64, 0x71, 0x94, 0xec, 0x2e, 0x40, 0xf0, 0xd5, 0x38, 0x3a, 0x64, 0x18, 0xe3, 0x5b, 0xb8, 0xbf,
+	0x74, 0x3d, 0x47, 0x07, 0x0b, 0xdb, 0xcf, 0x83, 0xb9, 0x70, 0x8f, 0x04, 0x59, 0xd9, 0x81, 0x3e,
+	0x40, 0xa7, 0x4c, 0x43, 0x5f, 0x42, 0x4d, 0x64, 0x43, 0x16, 0xfe, 0x8a, 0x94, 0x49, 0x26, 0xf5,
+	0xef, 0x8a, 0x1c, 0x67, 0xd9, 0x70, 0xf8, 0x7d, 0xae, 0x3a, 0x6b, 0xe0, 0x4f, 0x60, 0x8b, 0xde,
+	0x58, 0xa5, 0xf0, 0xe4, 0x1a, 0x49, 0x6f, 0xce, 0xf2, 0x00, 0xcb, 0x2a, 0xd5, 0x1f, 0x36, 0xc6,
+	0x17, 0xb0, 0x35, 0xf7, 0x1a, 0x62, 0x97, 0x0e, 0xa7, 0x69, 0x9c, 0xca, 0xf3, 0x11, 0x80, 0xf1,
+	0x1e, 0x1a, 0xf9, 0x32, 0xc9, 0x26, 0x90, 0x32, 0x2c, 0xf8, 0x37, 0xb3, 0x71, 0x8d, 0x53, 0xc2,
+	0x0e, 0x48, 0x9c, 0x5f, 0x06, 0xde, 0xb9, 0x39, 0x59, 0x59, 0xea, 0xe7, 0x9e, 0x25, 0x2b, 0x46,
+	0xfd, 0xcb, 0xf2, 0xa8, 0x57, 0xce, 0x23, 0x93, 0x9f, 0xaf, 0xbf, 0xbf, 0x69, 0xd0, 0x29, 0xd3,
+	0xca, 0xb5, 0xa6, 0xdd, 0x5d, 0x6b, 0xeb, 0x0b, 0xb5, 0xd6, 0x85, 0x8d, 0x4b, 0x7c, 0x2b, 0x8b,
+	0x90, 0x7d, 0xa2, 0xa7, 0xd0, 0xc1, 0x91, 0x1b, 0xa7, 0x04, 0xbb, 0x7d, 0x7a, 0x7e, 0x33, 0x1e,
+	0xf2, 0x12, 0x6c, 0x98, 0x73, 0x58, 0xc3, 0x81, 0x07, 0xcb, 0xdf, 0x4f, 0x2b, 0x82, 0x7d, 0xa5,
+	0x54, 0x9f, 0x88, 0xf6, 0xe1, 0x7c, 0xb4, 0x8b, 0xe5, 0xf7, 0x2f, 0x0d, 0xb6, 0xe6, 0xa8, 0xa8,
+	0x37, 0x57, 0x80, 0xab, 0x92, 0x96, 0x55, 0xe0, 0x0e, 0x54, 0xaf, 0xed, 0x60, 0x96, 0xfd, 0xc1,
+	0x13, 0x00, 0xfa, 0x35, 0x00, 0xbe, 0x49, 0xfc, 0xf4, 0x96, 0x8d, 0x07, 0xf9, 0x0f, 0x91, 0xbd,
+	0x4d, 0x63, 0x2f, 0x90, 0xbf, 0x3c, 0x2f, 0x66, 0x93, 0xde, 0x79, 0x36, 0x73, 0x4c, 0x85, 0xfb,
+	0x67, 0xbf, 0x85, 0xa6, 0xb2, 0x70, 0xcd, 0xbf, 0x0c, 0xdb, 0xd0, 0x38, 0x7c, 0xfb, 0x6e, 0xf0,
+	0xad, 0x75, 0x7c, 0xf6, 0xa6, 0xab, 0xb1, 0x07, 0xe0, 0x78, 0x78, 0x74, 0x72, 0x3e, 0x3e, 0xff,
+	0xc0, 0x31, 0xeb, 0x07, 0x7f, 0x86, 0x9a, 0x58, 0x78, 0xd1, 0x57, 0xd0, 0x12, 0x5f, 0x67, 0x34,
+	0xc5, 0x76, 0x88, 0x16, 0xfa, 0xf7, 0xee, 0x02, 0xc6, 0x58, 0x7b, 0xa6, 0xbd, 0xd4, 0xd0, 0x53,
+	0xa8, 0x9c, 0xfa, 0x91, 0x87, 0xca, 0x3f, 0x8a, 0x76, 0xcb, 0xa0, 0xb1, 0x76, 0xf8, 0xe5, 0x77,
+	0xcf, 0x3d, 0x9f, 0x4e, 0x67, 0x17, 0x6c, 0xa1, 0xd8, 0x9f, 0xde, 0x26, 0x38, 0x15, 0x4f, 0xb2,
+	0xfd, 0x89, 0x7d, 0x91, 0xfa, 0x8e, 0xf8, 0x5d, 0x4b, 0xf6, 0x85, 0xd8, 0x45, 0x8d, 0x83, 0xaf,
+	0xfe, 0x17, 0x00, 0x00, 0xff, 0xff, 0xaf, 0x69, 0xfb, 0x5b, 0x04, 0x16, 0x00, 0x00,
 }
diff --git a/protos/gossip/message.proto b/protos/gossip/message.proto
index f9ea4a89..a3d3512f 100644
--- a/protos/gossip/message.proto
+++ b/protos/gossip/message.proto
@@ -158,6 +158,7 @@ message Properties {
     uint64 ledger_height = 1;
     bool left_channel = 2;
     repeated Chaincode chaincodes = 3;
+    repeated string roles = 99;
 }
 
 // StateInfoSnapshot is an aggregation of StateInfo messages
@@ -378,14 +379,6 @@ message Chaincode {
     bytes metadata = 3;
 }
 
-// ValidationResultsMessage is the message containing block validation results
-message ValidationResultsMessage {
-    uint64 seq_num = 1;
-    bytes txFlags  = 2;
-    bytes signature = 3;
-    bytes identity = 4;
-}
-
 // RemoteCollDataRequest message used to request
 // collection data
 message RemoteCollDataRequest {
@@ -413,4 +406,4 @@ message CollDataElement {
     CollDataDigest digest = 1;
     bytes value = 2;
     google.protobuf.Timestamp expiryTime = 3;
-}
+}
\ No newline at end of file
diff --git a/protos/gossip/message_test.go b/protos/gossip/message_test.go
deleted file mode 100644
index 9c404738..00000000
--- a/protos/gossip/message_test.go
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
-Copyright IBM Corp. 2017 All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-		 http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package gossip
-
-import (
-	"reflect"
-	"testing"
-
-	"github.com/golang/protobuf/proto"
-	"github.com/stretchr/testify/assert"
-)
-
-type protoMsg interface {
-	Reset()
-	String() string
-	ProtoMessage()
-	Descriptor() ([]byte, []int)
-}
-
-func TestMethods(t *testing.T) {
-	msgs := []protoMsg{
-		&Envelope{},
-		&SecretEnvelope{},
-		&GossipMessage{},
-		&Secret{},
-		&StateInfo{},
-		&ConnEstablish{},
-		&AliveMessage{},
-		&MembershipRequest{},
-		&MembershipResponse{},
-		&DataMessage{},
-		&GossipHello{},
-		&DataDigest{},
-		&DataRequest{},
-		&DataUpdate{},
-		&Empty{},
-		&StateInfoSnapshot{},
-		&StateInfoPullRequest{},
-		&RemoteStateRequest{},
-		&RemoteStateResponse{},
-		&LeadershipMessage{},
-		&PeerIdentity{},
-	}
-
-	for _, msg := range msgs {
-		msg.Reset()
-		_, _ = msg.Descriptor()
-		msg.ProtoMessage()
-		assert.Empty(t, msg.String())
-
-	}
-
-	contentTypes := []isGossipMessage_Content{
-		&GossipMessage_AliveMsg{},
-		&GossipMessage_MemReq{},
-		&GossipMessage_MemRes{},
-		&GossipMessage_DataMsg{},
-		&GossipMessage_Hello{},
-		&GossipMessage_DataDig{},
-		&GossipMessage_DataReq{},
-		&GossipMessage_DataUpdate{},
-		&GossipMessage_Empty{},
-		&GossipMessage_Conn{},
-		&GossipMessage_StateInfo{},
-		&GossipMessage_StateSnapshot{},
-		&GossipMessage_StateInfoPullReq{},
-		&GossipMessage_StateRequest{},
-		&GossipMessage_StateResponse{},
-		&GossipMessage_LeadershipMsg{},
-		&GossipMessage_PeerIdentity{},
-	}
-
-	for _, ct := range contentTypes {
-		ct.isGossipMessage_Content()
-		gMsg := &GossipMessage{
-			Content: ct,
-		}
-		v := reflect.ValueOf(gMsg)
-		for i := 0; i < v.NumMethod(); i++ {
-			func() {
-				defer func() {
-					recover()
-				}()
-				v.Method(i).Call([]reflect.Value{})
-			}()
-		}
-		gMsg = &GossipMessage{
-			Content: ct,
-		}
-		_GossipMessage_OneofSizer(gMsg)
-		gMsg = &GossipMessage{
-			Content: ct,
-		}
-		_GossipMessage_OneofMarshaler(gMsg, &proto.Buffer{})
-		gMsg = &GossipMessage{
-			Content: ct,
-		}
-
-		for i := 5; i < 22; i++ {
-			_GossipMessage_OneofUnmarshaler(gMsg, i, 2, &proto.Buffer{})
-		}
-	}
-
-	assert.NotZero(t, _Secret_OneofSizer(&Secret{
-		Content: &Secret_InternalEndpoint{
-			InternalEndpoint: "internalEndpoint",
-		},
-	}))
-
-	assert.Nil(t, (&Envelope{}).GetSecretEnvelope())
-}
-
-func TestGrpc(t *testing.T) {
-	cl := NewGossipClient(nil)
-	f1 := func() {
-		cl.GossipStream(nil)
-	}
-	assert.Panics(t, f1)
-	f2 := func() {
-		cl.Ping(nil, nil)
-	}
-	assert.Panics(t, f2)
-	gscl := &gossipGossipStreamClient{}
-	f3 := func() {
-		gscl.Send(nil)
-	}
-	assert.Panics(t, f3)
-	f4 := func() {
-		gscl.Recv()
-	}
-	assert.Panics(t, f4)
-	f5 := func() {
-		gscl.Header()
-	}
-	assert.Panics(t, f5)
-	f6 := func() {
-		gscl.CloseSend()
-	}
-	assert.Panics(t, f6)
-	f7 := func() {
-		gscl.Context()
-	}
-	assert.Panics(t, f7)
-	gss := &gossipGossipStreamServer{}
-	f8 := func() {
-		gss.Recv()
-	}
-	assert.Panics(t, f8)
-	f9 := func() {
-		gss.Send(nil)
-	}
-	assert.Panics(t, f9)
-	f10 := func() {
-		gss.Context()
-	}
-	assert.Panics(t, f10)
-	f11 := func() {
-		gss.RecvMsg(nil)
-	}
-	assert.Panics(t, f11)
-	f12 := func() {
-		gss.SendHeader(nil)
-	}
-	assert.Panics(t, f12)
-	f13 := func() {
-		gss.RecvMsg(nil)
-	}
-	assert.Panics(t, f13)
-	f14 := func() {
-		gss.SendMsg(nil)
-	}
-	assert.Panics(t, f14)
-	f15 := func() {
-		gss.SetTrailer(nil)
-	}
-	assert.Panics(t, f15)
-	f16 := func() {
-		_Gossip_Ping_Handler(nil, nil, func(interface{}) error {
-			return nil
-		}, nil)
-	}
-	assert.Panics(t, f16)
-}
diff --git a/protoutil/blockutils.go b/protoutil/blockutils.go
new file mode 100644
index 00000000..c7535ac9
--- /dev/null
+++ b/protoutil/blockutils.go
@@ -0,0 +1,124 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"github.com/golang/protobuf/proto"
+	cb "github.com/hyperledger/fabric/protos/common"
+	"github.com/pkg/errors"
+)
+
+// GetChainIDFromBlockBytes returns chain ID given byte array which represents
+// the block
+func GetChainIDFromBlockBytes(bytes []byte) (string, error) {
+	block, err := GetBlockFromBlockBytes(bytes)
+	if err != nil {
+		return "", err
+	}
+
+	return GetChainIDFromBlock(block)
+}
+
+// GetChainIDFromBlock returns chain ID in the block
+func GetChainIDFromBlock(block *cb.Block) (string, error) {
+	if block == nil || block.Data == nil || block.Data.Data == nil || len(block.Data.Data) == 0 {
+		return "", errors.Errorf("failed to retrieve channel id - block is empty")
+	}
+	var err error
+	envelope, err := GetEnvelopeFromBlock(block.Data.Data[0])
+	if err != nil {
+		return "", err
+	}
+	payload, err := GetPayload(envelope)
+	if err != nil {
+		return "", err
+	}
+
+	if payload.Header == nil {
+		return "", errors.Errorf("failed to retrieve channel id - payload header is empty")
+	}
+	chdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)
+	if err != nil {
+		return "", err
+	}
+
+	return chdr.ChannelId, nil
+}
+
+// GetMetadataFromBlock retrieves metadata at the specified index.
+func GetMetadataFromBlock(block *cb.Block, index cb.BlockMetadataIndex) (*cb.Metadata, error) {
+	md := &cb.Metadata{}
+	err := proto.Unmarshal(block.Metadata.Metadata[index], md)
+	if err != nil {
+		return nil, errors.Wrapf(err, "error unmarshaling metadata from block at index [%s]", index)
+	}
+	return md, nil
+}
+
+// GetMetadataFromBlockOrPanic retrieves metadata at the specified index, or
+// panics on error
+func GetMetadataFromBlockOrPanic(block *cb.Block, index cb.BlockMetadataIndex) *cb.Metadata {
+	md, err := GetMetadataFromBlock(block, index)
+	if err != nil {
+		panic(err)
+	}
+	return md
+}
+
+// GetLastConfigIndexFromBlock retrieves the index of the last config block as
+// encoded in the block metadata
+func GetLastConfigIndexFromBlock(block *cb.Block) (uint64, error) {
+	md, err := GetMetadataFromBlock(block, cb.BlockMetadataIndex_LAST_CONFIG)
+	if err != nil {
+		return 0, err
+	}
+	lc := &cb.LastConfig{}
+	err = proto.Unmarshal(md.Value, lc)
+	if err != nil {
+		return 0, errors.Wrap(err, "error unmarshaling LastConfig")
+	}
+	return lc.Index, nil
+}
+
+// GetLastConfigIndexFromBlockOrPanic retrieves the index of the last config
+// block as encoded in the block metadata, or panics on error
+func GetLastConfigIndexFromBlockOrPanic(block *cb.Block) uint64 {
+	index, err := GetLastConfigIndexFromBlock(block)
+	if err != nil {
+		panic(err)
+	}
+	return index
+}
+
+// GetBlockFromBlockBytes marshals the bytes into Block
+func GetBlockFromBlockBytes(blockBytes []byte) (*cb.Block, error) {
+	block := &cb.Block{}
+	err := proto.Unmarshal(blockBytes, block)
+	if err != nil {
+		return block, errors.Wrap(err, "error unmarshaling block")
+	}
+	return block, nil
+}
+
+// CopyBlockMetadata copies metadata from one block into another
+func CopyBlockMetadata(src *cb.Block, dst *cb.Block) {
+	dst.Metadata = src.Metadata
+	// Once copied initialize with rest of the
+	// required metadata positions.
+	InitBlockMetadata(dst)
+}
+
+// InitBlockMetadata copies metadata from one block into another
+func InitBlockMetadata(block *cb.Block) {
+	if block.Metadata == nil {
+		block.Metadata = &cb.BlockMetadata{Metadata: [][]byte{{}, {}, {}}}
+	} else if len(block.Metadata.Metadata) < int(cb.BlockMetadataIndex_TRANSACTIONS_FILTER+1) {
+		for i := int(len(block.Metadata.Metadata)); i <= int(cb.BlockMetadataIndex_TRANSACTIONS_FILTER); i++ {
+			block.Metadata.Metadata = append(block.Metadata.Metadata, []byte{})
+		}
+	}
+}
diff --git a/protoutil/blockutils_test.go b/protoutil/blockutils_test.go
new file mode 100644
index 00000000..c7923f3e
--- /dev/null
+++ b/protoutil/blockutils_test.go
@@ -0,0 +1,206 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	configtxtest "github.com/hyperledger/fabric/common/configtx/test"
+	"github.com/hyperledger/fabric/protos/common"
+	cb "github.com/hyperledger/fabric/protos/common"
+	"github.com/hyperledger/fabric/protos/utils"
+	"github.com/stretchr/testify/assert"
+)
+
+var testChainID = "myuniquetestchainid"
+
+func TestGetChainIDFromBlockBytes(t *testing.T) {
+	gb, err := configtxtest.MakeGenesisBlock(testChainID)
+	assert.NoError(t, err, "Failed to create test configuration block")
+	bytes, err := proto.Marshal(gb)
+	cid, err := utils.GetChainIDFromBlockBytes(bytes)
+	assert.NoError(t, err)
+	assert.Equal(t, testChainID, cid, "Failed to return expected chain ID")
+
+	// bad block bytes
+	_, err = utils.GetChainIDFromBlockBytes([]byte("bad block"))
+	assert.Error(t, err, "Expected error with malformed block bytes")
+}
+
+func TestGetChainIDFromBlock(t *testing.T) {
+	var err error
+	var gb *common.Block
+	var cid string
+
+	// nil block
+	_, err = utils.GetChainIDFromBlock(gb)
+	assert.Error(t, err, "Expected error getting channel id from nil block")
+
+	gb, err = configtxtest.MakeGenesisBlock(testChainID)
+	assert.NoError(t, err, "Failed to create test configuration block")
+
+	cid, err = utils.GetChainIDFromBlock(gb)
+	assert.NoError(t, err, "Failed to get chain ID from block")
+	assert.Equal(t, testChainID, cid, "Failed to return expected chain ID")
+
+	// missing data
+	badBlock := gb
+	badBlock.Data = nil
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error with missing block data")
+
+	// no envelope
+	badBlock = &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{[]byte("bad envelope")},
+		},
+	}
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error with no envelope in data")
+
+	// bad payload
+	env, _ := proto.Marshal(&cb.Envelope{
+		Payload: []byte("bad payload"),
+	})
+	badBlock = &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{env},
+		},
+	}
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error - malformed payload")
+
+	// bad channel header
+	payload, _ := proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: []byte("bad header"),
+		},
+	})
+	env, _ = proto.Marshal(&cb.Envelope{
+		Payload: payload,
+	})
+	badBlock = &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{env},
+		},
+	}
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error with malformed channel header")
+
+	// nil payload header
+	payload, _ = proto.Marshal(&cb.Payload{})
+	env, _ = proto.Marshal(&cb.Envelope{
+		Payload: payload,
+	})
+	badBlock = &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{env},
+		},
+	}
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error when payload header is nil")
+}
+
+func TestGetBlockFromBlockBytes(t *testing.T) {
+	testChainID := "myuniquetestchainid"
+	gb, err := configtxtest.MakeGenesisBlock(testChainID)
+	assert.NoError(t, err, "Failed to create test configuration block")
+	blockBytes, err := utils.Marshal(gb)
+	assert.NoError(t, err, "Failed to marshal block")
+	_, err = utils.GetBlockFromBlockBytes(blockBytes)
+	assert.NoError(t, err, "to get block from block bytes")
+
+	// bad block bytes
+	_, err = utils.GetBlockFromBlockBytes([]byte("bad block"))
+	assert.Error(t, err, "Expected error for malformed block bytes")
+}
+
+func TestGetMetadataFromNewBlock(t *testing.T) {
+	block := common.NewBlock(0, nil)
+	md, err := utils.GetMetadataFromBlock(block, cb.BlockMetadataIndex_ORDERER)
+	assert.NoError(t, err, "Unexpected error extracting metadata from new block")
+	assert.Nil(t, md.Value, "Expected metadata field value to be nil")
+	assert.Equal(t, 0, len(md.Value), "Expected length of metadata field value to be 0")
+	md = utils.GetMetadataFromBlockOrPanic(block, cb.BlockMetadataIndex_ORDERER)
+	assert.NotNil(t, md, "Expected to get metadata from block")
+
+	// malformed metadata
+	block.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER] = []byte("bad metadata")
+	_, err = utils.GetMetadataFromBlock(block, cb.BlockMetadataIndex_ORDERER)
+	assert.Error(t, err, "Expected error with malformed metadata")
+	assert.Panics(t, func() {
+		_ = utils.GetMetadataFromBlockOrPanic(block, cb.BlockMetadataIndex_ORDERER)
+	}, "Expected panic with malformed metadata")
+}
+
+func TestInitBlockMeta(t *testing.T) {
+	// block with no metadata
+	block := &cb.Block{}
+	utils.InitBlockMetadata(block)
+	// should have 3 entries
+	assert.Equal(t, 3, len(block.Metadata.Metadata), "Expected block to have 3 metadata entries")
+
+	// block with a single entry
+	block = &cb.Block{
+		Metadata: &cb.BlockMetadata{},
+	}
+	block.Metadata.Metadata = append(block.Metadata.Metadata, []byte{})
+	utils.InitBlockMetadata(block)
+	// should have 3 entries
+	assert.Equal(t, 3, len(block.Metadata.Metadata), "Expected block to have 3 metadata entries")
+}
+
+func TestCopyBlockMetadata(t *testing.T) {
+	srcBlock := common.NewBlock(0, nil)
+	dstBlock := &cb.Block{}
+
+	metadata, _ := proto.Marshal(&cb.Metadata{
+		Value: []byte("orderer metadata"),
+	})
+	srcBlock.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER] = metadata
+	utils.CopyBlockMetadata(srcBlock, dstBlock)
+
+	// check that the copy worked
+	assert.Equal(t, len(srcBlock.Metadata.Metadata), len(dstBlock.Metadata.Metadata),
+		"Expected target block to have same number of metadata entries after copy")
+	assert.Equal(t, metadata, dstBlock.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER],
+		"Unexpected metadata from target block")
+}
+
+func TestGetLastConfigIndexFromBlock(t *testing.T) {
+	block := common.NewBlock(0, nil)
+	index := uint64(2)
+	lc, _ := proto.Marshal(&cb.LastConfig{
+		Index: index,
+	})
+	metadata, _ := proto.Marshal(&cb.Metadata{
+		Value: lc,
+	})
+	block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = metadata
+	result, err := utils.GetLastConfigIndexFromBlock(block)
+	assert.NoError(t, err, "Unexpected error returning last config index")
+	assert.Equal(t, index, result, "Unexpected last config index returned from block")
+	result = utils.GetLastConfigIndexFromBlockOrPanic(block)
+	assert.Equal(t, index, result, "Unexpected last config index returned from block")
+
+	// malformed metadata
+	block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = []byte("bad metadata")
+	_, err = utils.GetLastConfigIndexFromBlock(block)
+	assert.Error(t, err, "Expected error with malformed metadata")
+
+	// malformed last config
+	metadata, _ = proto.Marshal(&cb.Metadata{
+		Value: []byte("bad last config"),
+	})
+	block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = metadata
+	_, err = utils.GetLastConfigIndexFromBlock(block)
+	assert.Error(t, err, "Expected error with malformed last config metadata")
+	assert.Panics(t, func() {
+		_ = utils.GetLastConfigIndexFromBlockOrPanic(block)
+	}, "Expected panic with malformed last config metadata")
+}
diff --git a/protoutil/chaincodeutils.go b/protoutil/chaincodeutils.go
new file mode 100644
index 00000000..c0504d86
--- /dev/null
+++ b/protoutil/chaincodeutils.go
@@ -0,0 +1,25 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/protos/peer"
+	"github.com/pkg/errors"
+)
+
+// UnmarshalChaincodeDeploymentSpec unmarshals a ChaincodeDeploymentSpec from
+// the provided bytes
+func UnmarshalChaincodeDeploymentSpec(cdsBytes []byte) (*peer.ChaincodeDeploymentSpec, error) {
+	cds := &peer.ChaincodeDeploymentSpec{}
+	err := proto.Unmarshal(cdsBytes, cds)
+	if err != nil {
+		return nil, errors.Wrap(err, "error unmarshaling ChaincodeDeploymentSpec")
+	}
+
+	return cds, nil
+}
diff --git a/protoutil/commonutils.go b/protoutil/commonutils.go
new file mode 100644
index 00000000..bced28e3
--- /dev/null
+++ b/protoutil/commonutils.go
@@ -0,0 +1,339 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"fmt"
+	"time"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/golang/protobuf/ptypes/timestamp"
+	"github.com/hyperledger/fabric/common/crypto"
+	cb "github.com/hyperledger/fabric/protos/common"
+	pb "github.com/hyperledger/fabric/protos/peer"
+	"github.com/pkg/errors"
+)
+
+// MarshalOrPanic serializes a protobuf message and panics if this
+// operation fails
+func MarshalOrPanic(pb proto.Message) []byte {
+	data, err := proto.Marshal(pb)
+	if err != nil {
+		panic(err)
+	}
+	return data
+}
+
+// Marshal serializes a protobuf message.
+func Marshal(pb proto.Message) ([]byte, error) {
+	return proto.Marshal(pb)
+}
+
+// CreateNonceOrPanic generates a nonce using the common/crypto package
+// and panics if this operation fails.
+func CreateNonceOrPanic() []byte {
+	nonce, err := CreateNonce()
+	if err != nil {
+		panic(err)
+	}
+	return nonce
+}
+
+// CreateNonce generates a nonce using the common/crypto package.
+func CreateNonce() ([]byte, error) {
+	nonce, err := crypto.GetRandomNonce()
+	return nonce, errors.WithMessage(err, "error generating random nonce")
+}
+
+// UnmarshalPayloadOrPanic unmarshals bytes to a Payload structure or panics
+// on error
+func UnmarshalPayloadOrPanic(encoded []byte) *cb.Payload {
+	payload, err := UnmarshalPayload(encoded)
+	if err != nil {
+		panic(err)
+	}
+	return payload
+}
+
+// UnmarshalPayload unmarshals bytes to a Payload structure
+func UnmarshalPayload(encoded []byte) (*cb.Payload, error) {
+	payload := &cb.Payload{}
+	err := proto.Unmarshal(encoded, payload)
+	return payload, errors.Wrap(err, "error unmarshaling Payload")
+}
+
+// UnmarshalEnvelopeOrPanic unmarshals bytes to an Envelope structure or panics
+// on error
+func UnmarshalEnvelopeOrPanic(encoded []byte) *cb.Envelope {
+	envelope, err := UnmarshalEnvelope(encoded)
+	if err != nil {
+		panic(err)
+	}
+	return envelope
+}
+
+// UnmarshalEnvelope unmarshals bytes to an Envelope structure
+func UnmarshalEnvelope(encoded []byte) (*cb.Envelope, error) {
+	envelope := &cb.Envelope{}
+	err := proto.Unmarshal(encoded, envelope)
+	return envelope, errors.Wrap(err, "error unmarshaling Envelope")
+}
+
+// UnmarshalBlockOrPanic unmarshals bytes to an Block structure or panics
+// on error
+func UnmarshalBlockOrPanic(encoded []byte) *cb.Block {
+	block, err := UnmarshalBlock(encoded)
+	if err != nil {
+		panic(err)
+	}
+	return block
+}
+
+// UnmarshalBlock unmarshals bytes to an Block structure
+func UnmarshalBlock(encoded []byte) (*cb.Block, error) {
+	block := &cb.Block{}
+	err := proto.Unmarshal(encoded, block)
+	return block, errors.Wrap(err, "error unmarshaling Block")
+}
+
+// UnmarshalEnvelopeOfType unmarshals an envelope of the specified type,
+// including unmarshaling the payload data
+func UnmarshalEnvelopeOfType(envelope *cb.Envelope, headerType cb.HeaderType, message proto.Message) (*cb.ChannelHeader, error) {
+	payload, err := UnmarshalPayload(envelope.Payload)
+	if err != nil {
+		return nil, err
+	}
+
+	if payload.Header == nil {
+		return nil, errors.New("envelope must have a Header")
+	}
+
+	chdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	if chdr.Type != int32(headerType) {
+		return nil, errors.Errorf("invalid type %s, expected %s", cb.HeaderType(chdr.Type), headerType)
+	}
+
+	err = proto.Unmarshal(payload.Data, message)
+	err = errors.Wrapf(err, "error unmarshaling message for type %s", headerType)
+	return chdr, err
+}
+
+// ExtractEnvelopeOrPanic retrieves the requested envelope from a given block
+// and unmarshals it -- it panics if either of these operations fail
+func ExtractEnvelopeOrPanic(block *cb.Block, index int) *cb.Envelope {
+	envelope, err := ExtractEnvelope(block, index)
+	if err != nil {
+		panic(err)
+	}
+	return envelope
+}
+
+// ExtractEnvelope retrieves the requested envelope from a given block and
+// unmarshals it
+func ExtractEnvelope(block *cb.Block, index int) (*cb.Envelope, error) {
+	if block.Data == nil {
+		return nil, errors.New("block data is nil")
+	}
+
+	envelopeCount := len(block.Data.Data)
+	if index < 0 || index >= envelopeCount {
+		return nil, errors.New("envelope index out of bounds")
+	}
+	marshaledEnvelope := block.Data.Data[index]
+	envelope, err := GetEnvelopeFromBlock(marshaledEnvelope)
+	err = errors.WithMessage(err, fmt.Sprintf("block data does not carry an envelope at index %d", index))
+	return envelope, err
+}
+
+// ExtractPayloadOrPanic retrieves the payload of a given envelope and
+// unmarshals it -- it panics if either of these operations fail
+func ExtractPayloadOrPanic(envelope *cb.Envelope) *cb.Payload {
+	payload, err := ExtractPayload(envelope)
+	if err != nil {
+		panic(err)
+	}
+	return payload
+}
+
+// ExtractPayload retrieves the payload of a given envelope and unmarshals it.
+func ExtractPayload(envelope *cb.Envelope) (*cb.Payload, error) {
+	payload := &cb.Payload{}
+	err := proto.Unmarshal(envelope.Payload, payload)
+	err = errors.Wrap(err, "no payload in envelope")
+	return payload, err
+}
+
+// MakeChannelHeader creates a ChannelHeader.
+func MakeChannelHeader(headerType cb.HeaderType, version int32, chainID string, epoch uint64) *cb.ChannelHeader {
+	return &cb.ChannelHeader{
+		Type:    int32(headerType),
+		Version: version,
+		Timestamp: &timestamp.Timestamp{
+			Seconds: time.Now().Unix(),
+			Nanos:   0,
+		},
+		ChannelId: chainID,
+		Epoch:     epoch,
+	}
+}
+
+// MakeSignatureHeader creates a SignatureHeader.
+func MakeSignatureHeader(serializedCreatorCertChain []byte, nonce []byte) *cb.SignatureHeader {
+	return &cb.SignatureHeader{
+		Creator: serializedCreatorCertChain,
+		Nonce:   nonce,
+	}
+}
+
+// SetTxID generates a transaction id based on the provided signature header
+// and sets the TxId field in the channel header
+func SetTxID(channelHeader *cb.ChannelHeader, signatureHeader *cb.SignatureHeader) error {
+	txid, err := ComputeTxID(
+		signatureHeader.Nonce,
+		signatureHeader.Creator,
+	)
+	if err != nil {
+		return err
+	}
+	channelHeader.TxId = txid
+	return nil
+}
+
+// MakePayloadHeader creates a Payload Header.
+func MakePayloadHeader(ch *cb.ChannelHeader, sh *cb.SignatureHeader) *cb.Header {
+	return &cb.Header{
+		ChannelHeader:   MarshalOrPanic(ch),
+		SignatureHeader: MarshalOrPanic(sh),
+	}
+}
+
+// NewSignatureHeaderOrPanic returns a signature header and panics on error.
+func NewSignatureHeaderOrPanic(signer crypto.LocalSigner) *cb.SignatureHeader {
+	if signer == nil {
+		panic(errors.New("invalid signer. cannot be nil"))
+	}
+
+	signatureHeader, err := signer.NewSignatureHeader()
+	if err != nil {
+		panic(fmt.Errorf("failed generating a new SignatureHeader: %s", err))
+	}
+	return signatureHeader
+}
+
+// SignOrPanic signs a message and panics on error.
+func SignOrPanic(signer crypto.LocalSigner, msg []byte) []byte {
+	if signer == nil {
+		panic(errors.New("invalid signer. cannot be nil"))
+	}
+
+	sigma, err := signer.Sign(msg)
+	if err != nil {
+		panic(fmt.Errorf("failed generating signature: %s", err))
+	}
+	return sigma
+}
+
+// UnmarshalChannelHeader returns a ChannelHeader from bytes
+func UnmarshalChannelHeader(bytes []byte) (*cb.ChannelHeader, error) {
+	chdr := &cb.ChannelHeader{}
+	err := proto.Unmarshal(bytes, chdr)
+	return chdr, errors.Wrap(err, "error unmarshaling ChannelHeader")
+}
+
+// UnmarshalChannelHeaderOrPanic unmarshals bytes to a ChannelHeader or panics
+// on error
+func UnmarshalChannelHeaderOrPanic(bytes []byte) *cb.ChannelHeader {
+	chdr, err := UnmarshalChannelHeader(bytes)
+	if err != nil {
+		panic(err)
+	}
+	return chdr
+}
+
+// UnmarshalChaincodeID returns a ChaincodeID from bytes
+func UnmarshalChaincodeID(bytes []byte) (*pb.ChaincodeID, error) {
+	ccid := &pb.ChaincodeID{}
+	err := proto.Unmarshal(bytes, ccid)
+	if err != nil {
+		return nil, errors.Wrap(err, "error unmarshaling ChaincodeID")
+	}
+
+	return ccid, nil
+}
+
+// IsConfigBlock validates whenever given block contains configuration
+// update transaction
+func IsConfigBlock(block *cb.Block) bool {
+	envelope, err := ExtractEnvelope(block, 0)
+	if err != nil {
+		return false
+	}
+
+	payload, err := GetPayload(envelope)
+	if err != nil {
+		return false
+	}
+
+	if payload.Header == nil {
+		return false
+	}
+
+	hdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)
+	if err != nil {
+		return false
+	}
+
+	return cb.HeaderType(hdr.Type) == cb.HeaderType_CONFIG || cb.HeaderType(hdr.Type) == cb.HeaderType_ORDERER_TRANSACTION
+}
+
+// ChannelHeader returns the *cb.ChannelHeader for a given *cb.Envelope.
+func ChannelHeader(env *cb.Envelope) (*cb.ChannelHeader, error) {
+	envPayload, err := UnmarshalPayload(env.Payload)
+	if err != nil {
+		return nil, err
+	}
+
+	if envPayload.Header == nil {
+		return nil, errors.New("header not set")
+	}
+
+	if envPayload.Header.ChannelHeader == nil {
+		return nil, errors.New("channel header not set")
+	}
+
+	chdr, err := UnmarshalChannelHeader(envPayload.Header.ChannelHeader)
+	if err != nil {
+		return nil, errors.WithMessage(err, "error unmarshaling channel header")
+	}
+
+	return chdr, nil
+}
+
+// ChannelID returns the Channel ID for a given *cb.Envelope.
+func ChannelID(env *cb.Envelope) (string, error) {
+	chdr, err := ChannelHeader(env)
+	if err != nil {
+		return "", errors.WithMessage(err, "error retrieving channel header")
+	}
+
+	return chdr.ChannelId, nil
+}
+
+// EnvelopeToConfigUpdate is used to extract a ConfigUpdateEnvelope from an envelope of
+// type CONFIG_UPDATE
+func EnvelopeToConfigUpdate(configtx *cb.Envelope) (*cb.ConfigUpdateEnvelope, error) {
+	configUpdateEnv := &cb.ConfigUpdateEnvelope{}
+	_, err := UnmarshalEnvelopeOfType(configtx, cb.HeaderType_CONFIG_UPDATE, configUpdateEnv)
+	if err != nil {
+		return nil, err
+	}
+	return configUpdateEnv, nil
+}
diff --git a/protoutil/commonutils_test.go b/protoutil/commonutils_test.go
new file mode 100644
index 00000000..1fcedd87
--- /dev/null
+++ b/protoutil/commonutils_test.go
@@ -0,0 +1,429 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"bytes"
+	"errors"
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/common/crypto"
+	cb "github.com/hyperledger/fabric/protos/common"
+	pb "github.com/hyperledger/fabric/protos/peer"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestNonceRandomness(t *testing.T) {
+	n1, err := CreateNonce()
+	if err != nil {
+		t.Fatal(err)
+	}
+	n2, err := CreateNonce()
+	if err != nil {
+		t.Fatal(err)
+	}
+	if bytes.Equal(n1, n2) {
+		t.Fatalf("Expected nonces to be different, got %x and %x", n1, n2)
+	}
+}
+
+func TestNonceLength(t *testing.T) {
+	n, err := CreateNonce()
+	if err != nil {
+		t.Fatal(err)
+	}
+	actual := len(n)
+	expected := crypto.NonceSize
+	if actual != expected {
+		t.Fatalf("Expected nonce to be of size %d, got %d instead", expected, actual)
+	}
+
+}
+
+func TestUnmarshalPayload(t *testing.T) {
+	var payload *cb.Payload
+	good, _ := proto.Marshal(&cb.Payload{
+		Data: []byte("payload"),
+	})
+	payload, err := UnmarshalPayload(good)
+	assert.NoError(t, err, "Unexpected error unmarshaling payload")
+	assert.NotNil(t, payload, "Payload should not be nil")
+	payload = UnmarshalPayloadOrPanic(good)
+	assert.NotNil(t, payload, "Payload should not be nil")
+
+	bad := []byte("bad payload")
+	assert.Panics(t, func() {
+		_ = UnmarshalPayloadOrPanic(bad)
+	}, "Expected panic unmarshaling malformed payload")
+
+}
+
+func TestUnmarshalEnvelope(t *testing.T) {
+	var env *cb.Envelope
+	good, _ := proto.Marshal(&cb.Envelope{})
+	env, err := UnmarshalEnvelope(good)
+	assert.NoError(t, err, "Unexpected error unmarshaling envelope")
+	assert.NotNil(t, env, "Envelope should not be nil")
+	env = UnmarshalEnvelopeOrPanic(good)
+	assert.NotNil(t, env, "Envelope should not be nil")
+
+	bad := []byte("bad envelope")
+	assert.Panics(t, func() {
+		_ = UnmarshalEnvelopeOrPanic(bad)
+	}, "Expected panic unmarshaling malformed envelope")
+
+}
+
+func TestUnmarshalBlock(t *testing.T) {
+	var env *cb.Block
+	good, _ := proto.Marshal(&cb.Block{})
+	env, err := UnmarshalBlock(good)
+	assert.NoError(t, err, "Unexpected error unmarshaling block")
+	assert.NotNil(t, env, "Block should not be nil")
+	env = UnmarshalBlockOrPanic(good)
+	assert.NotNil(t, env, "Block should not be nil")
+
+	bad := []byte("bad block")
+	assert.Panics(t, func() {
+		_ = UnmarshalBlockOrPanic(bad)
+	}, "Expected panic unmarshaling malformed block")
+
+}
+
+func TestUnmarshalEnvelopeOfType(t *testing.T) {
+	env := &cb.Envelope{}
+
+	env.Payload = []byte("bad payload")
+	_, err := UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, nil)
+	assert.Error(t, err, "Expected error unmarshaling malformed envelope")
+
+	payload, _ := proto.Marshal(&cb.Payload{
+		Header: nil,
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, nil)
+	assert.Error(t, err, "Expected error with missing payload header")
+
+	payload, _ = proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: []byte("bad header"),
+		},
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, nil)
+	assert.Error(t, err, "Expected error for malformed channel header")
+
+	chdr, _ := proto.Marshal(&cb.ChannelHeader{
+		Type: int32(cb.HeaderType_CHAINCODE_PACKAGE),
+	})
+	payload, _ = proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: chdr,
+		},
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, nil)
+	assert.Error(t, err, "Expected error for wrong channel header type")
+
+	chdr, _ = proto.Marshal(&cb.ChannelHeader{
+		Type: int32(cb.HeaderType_CONFIG),
+	})
+	payload, _ = proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: chdr,
+		},
+		Data: []byte("bad data"),
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, &cb.ConfigEnvelope{})
+	assert.Error(t, err, "Expected error for malformed payload data")
+
+	chdr, _ = proto.Marshal(&cb.ChannelHeader{
+		Type: int32(cb.HeaderType_CONFIG),
+	})
+	configEnv, _ := proto.Marshal(&cb.ConfigEnvelope{})
+	payload, _ = proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: chdr,
+		},
+		Data: configEnv,
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, &cb.ConfigEnvelope{})
+	assert.NoError(t, err, "Unexpected error unmarshaling envelope")
+
+}
+
+func TestExtractEnvelopeNilData(t *testing.T) {
+	block := &cb.Block{}
+	_, err := ExtractEnvelope(block, 0)
+	assert.Error(t, err, "Nil data")
+}
+
+func TestExtractEnvelopeWrongIndex(t *testing.T) {
+	block := testBlock()
+	if _, err := ExtractEnvelope(block, len(block.GetData().Data)); err == nil {
+		t.Fatal("Expected envelope extraction to fail (wrong index)")
+	}
+}
+
+func TestExtractEnvelopeWrongIndexOrPanic(t *testing.T) {
+	defer func() {
+		if r := recover(); r == nil {
+			t.Fatal("Expected envelope extraction to panic (wrong index)")
+		}
+	}()
+
+	block := testBlock()
+	ExtractEnvelopeOrPanic(block, len(block.GetData().Data))
+}
+
+func TestExtractEnvelope(t *testing.T) {
+	if envelope, err := ExtractEnvelope(testBlock(), 0); err != nil {
+		t.Fatalf("Expected envelop extraction to succeed: %s", err)
+	} else if !proto.Equal(envelope, testEnvelope()) {
+		t.Fatal("Expected extracted envelope to match test envelope")
+	}
+}
+
+func TestExtractEnvelopeOrPanic(t *testing.T) {
+	defer func() {
+		if r := recover(); r != nil {
+			t.Fatal("Expected envelope extraction to succeed")
+		}
+	}()
+
+	if !proto.Equal(ExtractEnvelopeOrPanic(testBlock(), 0), testEnvelope()) {
+		t.Fatal("Expected extracted envelope to match test envelope")
+	}
+}
+
+func TestExtractPayload(t *testing.T) {
+	if payload, err := ExtractPayload(testEnvelope()); err != nil {
+		t.Fatalf("Expected payload extraction to succeed: %s", err)
+	} else if !proto.Equal(payload, testPayload()) {
+		t.Fatal("Expected extracted payload to match test payload")
+	}
+}
+
+func TestExtractPayloadOrPanic(t *testing.T) {
+	defer func() {
+		if r := recover(); r != nil {
+			t.Fatal("Expected payload extraction to succeed")
+		}
+	}()
+
+	if !proto.Equal(ExtractPayloadOrPanic(testEnvelope()), testPayload()) {
+		t.Fatal("Expected extracted payload to match test payload")
+	}
+}
+
+func TestUnmarshalChaincodeID(t *testing.T) {
+	ccname := "mychaincode"
+	ccversion := "myversion"
+	ccidbytes, _ := proto.Marshal(&pb.ChaincodeID{
+		Name:    ccname,
+		Version: ccversion,
+	})
+	ccid, err := UnmarshalChaincodeID(ccidbytes)
+	assert.Equal(t, ccname, ccid.Name, "Expected ccid names to match")
+	assert.Equal(t, ccversion, ccid.Version, "Expected ccid versions to match")
+
+	_, err = UnmarshalChaincodeID([]byte("bad chaincodeID"))
+	assert.Error(t, err, "Expected error marshaling malformed chaincode ID")
+}
+
+func TestNewSignatureHeaderOrPanic(t *testing.T) {
+	var sigHeader *cb.SignatureHeader
+
+	sigHeader = NewSignatureHeaderOrPanic(goodSigner)
+	assert.NotNil(t, sigHeader, "Signature header should not be nil")
+
+	assert.Panics(t, func() {
+		_ = NewSignatureHeaderOrPanic(nil)
+	}, "Expected panic with nil signer")
+
+	assert.Panics(t, func() {
+		_ = NewSignatureHeaderOrPanic(badSigner)
+	}, "Expected panic with signature header error")
+
+}
+
+func TestSignOrPanic(t *testing.T) {
+	msg := []byte("sign me")
+	sig := SignOrPanic(goodSigner, msg)
+	// mock signer returns message to be signed
+	assert.Equal(t, msg, sig, "Signature does not match expected value")
+
+	assert.Panics(t, func() {
+		_ = SignOrPanic(nil, []byte("sign me"))
+	}, "Expected panic with nil signer")
+
+	assert.Panics(t, func() {
+		_ = SignOrPanic(badSigner, []byte("sign me"))
+	}, "Expected panic with sign error")
+}
+
+// Helper functions
+
+func testPayload() *cb.Payload {
+	return &cb.Payload{
+		Header: MakePayloadHeader(
+			MakeChannelHeader(cb.HeaderType_MESSAGE, int32(1), "test", 0),
+			MakeSignatureHeader([]byte("creator"), []byte("nonce"))),
+		Data: []byte("test"),
+	}
+}
+
+func testEnvelope() *cb.Envelope {
+	// No need to set the signature
+	return &cb.Envelope{Payload: MarshalOrPanic(testPayload())}
+}
+
+func testBlock() *cb.Block {
+	// No need to set the block's Header, or Metadata
+	return &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{MarshalOrPanic(testEnvelope())},
+		},
+	}
+}
+
+// mock
+var badSigner = &mockLocalSigner{
+	returnError: true,
+}
+
+var goodSigner = &mockLocalSigner{
+	returnError: false,
+}
+
+type mockLocalSigner struct {
+	returnError bool
+}
+
+func (m *mockLocalSigner) NewSignatureHeader() (*cb.SignatureHeader, error) {
+	if m.returnError {
+		return nil, errors.New("signature header error")
+	}
+	return &cb.SignatureHeader{}, nil
+}
+
+func (m *mockLocalSigner) Sign(message []byte) ([]byte, error) {
+	if m.returnError {
+		return nil, errors.New("sign error")
+	}
+	return message, nil
+}
+
+func TestChannelHeader(t *testing.T) {
+	makeEnvelope := func(payload *cb.Payload) *cb.Envelope {
+		return &cb.Envelope{
+			Payload: MarshalOrPanic(payload),
+		}
+	}
+
+	_, err := ChannelHeader(makeEnvelope(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: MarshalOrPanic(&cb.ChannelHeader{
+				ChannelId: "foo",
+			}),
+		},
+	}))
+	assert.NoError(t, err, "Channel header was present")
+
+	_, err = ChannelHeader(makeEnvelope(&cb.Payload{
+		Header: &cb.Header{},
+	}))
+	assert.Error(t, err, "ChannelHeader was missing")
+
+	_, err = ChannelHeader(makeEnvelope(&cb.Payload{}))
+	assert.Error(t, err, "Header was missing")
+
+	_, err = ChannelHeader(&cb.Envelope{})
+	assert.Error(t, err, "Payload was missing")
+}
+
+func TestIsConfigBlock(t *testing.T) {
+	newBlock := func(env *cb.Envelope) *cb.Block {
+		return &cb.Block{
+			Data: &cb.BlockData{
+				Data: [][]byte{MarshalOrPanic(env)},
+			},
+		}
+	}
+
+	newConfigEnv := func(envType int32) *cb.Envelope {
+		return &cb.Envelope{
+			Payload: MarshalOrPanic(&cb.Payload{
+				Header: &cb.Header{
+					ChannelHeader: MarshalOrPanic(&cb.ChannelHeader{
+						Type:      envType,
+						ChannelId: "test-chain",
+					}),
+				},
+				Data: []byte("test bytes"),
+			}), // common.Payload
+		} // LastUpdate
+	}
+
+	// scenario 1: CONFIG envelope
+	envType := int32(cb.HeaderType_CONFIG)
+	env := newConfigEnv(envType)
+	block := newBlock(env)
+
+	result := IsConfigBlock(block)
+	assert.True(t, result, "IsConfigBlock returns true for blocks with CONFIG envelope")
+
+	// scenario 2: ORDERER_TRANSACTION envelope
+	envType = int32(cb.HeaderType_ORDERER_TRANSACTION)
+	env = newConfigEnv(envType)
+	block = newBlock(env)
+
+	result = IsConfigBlock(block)
+	assert.True(t, result, "IsConfigBlock returns true for blocks with ORDERER_TRANSACTION envelope")
+
+	// scenario 3: MESSAGE envelope
+	envType = int32(cb.HeaderType_MESSAGE)
+	env = newConfigEnv(envType)
+	block = newBlock(env)
+
+	result = IsConfigBlock(block)
+	assert.False(t, result, "IsConfigBlock returns false for blocks with MESSAGE envelope")
+}
+
+func TestEnvelopeToConfigUpdate(t *testing.T) {
+
+	makeEnv := func(data []byte) *cb.Envelope {
+		return &cb.Envelope{
+			Payload: MarshalOrPanic(&cb.Payload{
+				Header: &cb.Header{
+					ChannelHeader: MarshalOrPanic(&cb.ChannelHeader{
+						Type:      int32(cb.HeaderType_CONFIG_UPDATE),
+						ChannelId: "test-chain",
+					}),
+				},
+				Data: data,
+			}), // common.Payload
+		} // LastUpdate
+	}
+
+	// scenario 1: for valid envelopes
+	configUpdateEnv := &cb.ConfigUpdateEnvelope{}
+	env := makeEnv(MarshalOrPanic(configUpdateEnv))
+	result, err := EnvelopeToConfigUpdate(env)
+
+	assert.NoError(t, err, "EnvelopeToConfigUpdate runs without error for valid CONFIG_UPDATE envelope")
+	assert.Equal(t, configUpdateEnv, result, "Correct configUpdateEnvelope returned")
+
+	// scenario 2: for invalid envelopes
+	env = makeEnv([]byte("test bytes"))
+	_, err = EnvelopeToConfigUpdate(env)
+
+	assert.Error(t, err, "EnvelopeToConfigUpdate fails with error for invalid CONFIG_UPDATE envelope")
+}
diff --git a/protoutil/proputils.go b/protoutil/proputils.go
new file mode 100644
index 00000000..7b67b0a6
--- /dev/null
+++ b/protoutil/proputils.go
@@ -0,0 +1,642 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"encoding/binary"
+	"encoding/hex"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/bccsp"
+	"github.com/hyperledger/fabric/bccsp/factory"
+	"github.com/hyperledger/fabric/common/crypto"
+	"github.com/hyperledger/fabric/common/util"
+	"github.com/hyperledger/fabric/core/chaincode/platforms"
+	"github.com/hyperledger/fabric/protos/common"
+	"github.com/hyperledger/fabric/protos/peer"
+	"github.com/pkg/errors"
+)
+
+// GetChaincodeInvocationSpec get the ChaincodeInvocationSpec from the proposal
+func GetChaincodeInvocationSpec(prop *peer.Proposal) (*peer.ChaincodeInvocationSpec, error) {
+	if prop == nil {
+		return nil, errors.New("proposal is nil")
+	}
+	_, err := GetHeader(prop.Header)
+	if err != nil {
+		return nil, err
+	}
+	ccPropPayload, err := GetChaincodeProposalPayload(prop.Payload)
+	if err != nil {
+		return nil, err
+	}
+	cis := &peer.ChaincodeInvocationSpec{}
+	err = proto.Unmarshal(ccPropPayload.Input, cis)
+	return cis, errors.Wrap(err, "error unmarshaling ChaincodeInvocationSpec")
+}
+
+// GetChaincodeProposalContext returns creator and transient
+func GetChaincodeProposalContext(prop *peer.Proposal) ([]byte, map[string][]byte, error) {
+	if prop == nil {
+		return nil, nil, errors.New("proposal is nil")
+	}
+	if len(prop.Header) == 0 {
+		return nil, nil, errors.New("proposal's header is nil")
+	}
+	if len(prop.Payload) == 0 {
+		return nil, nil, errors.New("proposal's payload is nil")
+	}
+	// get back the header
+	hdr, err := GetHeader(prop.Header)
+	if err != nil {
+		return nil, nil, errors.WithMessage(err, "error extracting header from proposal")
+	}
+	if hdr == nil {
+		return nil, nil, errors.New("unmarshaled header is nil")
+	}
+
+	chdr, err := UnmarshalChannelHeader(hdr.ChannelHeader)
+	if err != nil {
+		return nil, nil, errors.WithMessage(err, "error extracting channel header from proposal")
+	}
+
+	if err = validateChannelHeaderType(chdr, []common.HeaderType{common.HeaderType_ENDORSER_TRANSACTION, common.HeaderType_CONFIG}); err != nil {
+		return nil, nil, errors.WithMessage(err, "invalid proposal")
+	}
+
+	shdr, err := GetSignatureHeader(hdr.SignatureHeader)
+	if err != nil {
+		return nil, nil, errors.WithMessage(err, "error extracting signature header from proposal")
+	}
+
+	ccPropPayload, err := GetChaincodeProposalPayload(prop.Payload)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	return shdr.Creator, ccPropPayload.TransientMap, nil
+}
+
+func validateChannelHeaderType(chdr *common.ChannelHeader, expectedTypes []common.HeaderType) error {
+	for _, t := range expectedTypes {
+		if common.HeaderType(chdr.Type) == t {
+			return nil
+		}
+	}
+	return errors.Errorf("invalid channel header type. expected one of %s, received %s", expectedTypes, common.HeaderType(chdr.Type))
+}
+
+// GetHeader Get Header from bytes
+func GetHeader(bytes []byte) (*common.Header, error) {
+	hdr := &common.Header{}
+	err := proto.Unmarshal(bytes, hdr)
+	return hdr, errors.Wrap(err, "error unmarshaling Header")
+}
+
+// GetNonce returns the nonce used in Proposal
+func GetNonce(prop *peer.Proposal) ([]byte, error) {
+	if prop == nil {
+		return nil, errors.New("proposal is nil")
+	}
+
+	// get back the header
+	hdr, err := GetHeader(prop.Header)
+	if err != nil {
+		return nil, err
+	}
+
+	chdr, err := UnmarshalChannelHeader(hdr.ChannelHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	if err = validateChannelHeaderType(chdr, []common.HeaderType{common.HeaderType_ENDORSER_TRANSACTION, common.HeaderType_CONFIG}); err != nil {
+		return nil, errors.WithMessage(err, "invalid proposal")
+	}
+
+	shdr, err := GetSignatureHeader(hdr.SignatureHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	if hdr.SignatureHeader == nil {
+		return nil, errors.New("invalid signature header. cannot be nil")
+	}
+
+	return shdr.Nonce, nil
+}
+
+// GetChaincodeHeaderExtension get chaincode header extension given header
+func GetChaincodeHeaderExtension(hdr *common.Header) (*peer.ChaincodeHeaderExtension, error) {
+	chdr, err := UnmarshalChannelHeader(hdr.ChannelHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	chaincodeHdrExt := &peer.ChaincodeHeaderExtension{}
+	err = proto.Unmarshal(chdr.Extension, chaincodeHdrExt)
+	return chaincodeHdrExt, errors.Wrap(err, "error unmarshaling ChaincodeHeaderExtension")
+}
+
+// GetProposalResponse given proposal in bytes
+func GetProposalResponse(prBytes []byte) (*peer.ProposalResponse, error) {
+	proposalResponse := &peer.ProposalResponse{}
+	err := proto.Unmarshal(prBytes, proposalResponse)
+	return proposalResponse, errors.Wrap(err, "error unmarshaling ProposalResponse")
+}
+
+// GetChaincodeDeploymentSpec returns a ChaincodeDeploymentSpec given args
+func GetChaincodeDeploymentSpec(code []byte, pr *platforms.Registry) (*peer.ChaincodeDeploymentSpec, error) {
+	cds := &peer.ChaincodeDeploymentSpec{}
+	err := proto.Unmarshal(code, cds)
+	if err != nil {
+		return nil, errors.Wrap(err, "error unmarshaling ChaincodeDeploymentSpec")
+	}
+
+	// FAB-2122: Validate the CDS according to platform specific requirements
+	return cds, pr.ValidateDeploymentSpec(cds.CCType(), cds.Bytes())
+}
+
+// GetChaincodeAction gets the ChaincodeAction given chaicnode action bytes
+func GetChaincodeAction(caBytes []byte) (*peer.ChaincodeAction, error) {
+	chaincodeAction := &peer.ChaincodeAction{}
+	err := proto.Unmarshal(caBytes, chaincodeAction)
+	return chaincodeAction, errors.Wrap(err, "error unmarshaling ChaincodeAction")
+}
+
+// GetResponse gets the Response given response bytes
+func GetResponse(resBytes []byte) (*peer.Response, error) {
+	response := &peer.Response{}
+	err := proto.Unmarshal(resBytes, response)
+	return response, errors.Wrap(err, "error unmarshaling Response")
+}
+
+// GetChaincodeEvents gets the ChaincodeEvents given chaincode event bytes
+func GetChaincodeEvents(eBytes []byte) (*peer.ChaincodeEvent, error) {
+	chaincodeEvent := &peer.ChaincodeEvent{}
+	err := proto.Unmarshal(eBytes, chaincodeEvent)
+	return chaincodeEvent, errors.Wrap(err, "error unmarshaling ChaicnodeEvent")
+}
+
+// GetProposalResponsePayload gets the proposal response payload
+func GetProposalResponsePayload(prpBytes []byte) (*peer.ProposalResponsePayload, error) {
+	prp := &peer.ProposalResponsePayload{}
+	err := proto.Unmarshal(prpBytes, prp)
+	return prp, errors.Wrap(err, "error unmarshaling ProposalResponsePayload")
+}
+
+// GetProposal returns a Proposal message from its bytes
+func GetProposal(propBytes []byte) (*peer.Proposal, error) {
+	prop := &peer.Proposal{}
+	err := proto.Unmarshal(propBytes, prop)
+	return prop, errors.Wrap(err, "error unmarshaling Proposal")
+}
+
+// GetPayload Get Payload from Envelope message
+func GetPayload(e *common.Envelope) (*common.Payload, error) {
+	payload := &common.Payload{}
+	err := proto.Unmarshal(e.Payload, payload)
+	return payload, errors.Wrap(err, "error unmarshaling Payload")
+}
+
+// GetTransaction Get Transaction from bytes
+func GetTransaction(txBytes []byte) (*peer.Transaction, error) {
+	tx := &peer.Transaction{}
+	err := proto.Unmarshal(txBytes, tx)
+	return tx, errors.Wrap(err, "error unmarshaling Transaction")
+
+}
+
+// GetChaincodeActionPayload Get ChaincodeActionPayload from bytes
+func GetChaincodeActionPayload(capBytes []byte) (*peer.ChaincodeActionPayload, error) {
+	cap := &peer.ChaincodeActionPayload{}
+	err := proto.Unmarshal(capBytes, cap)
+	return cap, errors.Wrap(err, "error unmarshaling ChaincodeActionPayload")
+}
+
+// GetChaincodeProposalPayload Get ChaincodeProposalPayload from bytes
+func GetChaincodeProposalPayload(bytes []byte) (*peer.ChaincodeProposalPayload, error) {
+	cpp := &peer.ChaincodeProposalPayload{}
+	err := proto.Unmarshal(bytes, cpp)
+	return cpp, errors.Wrap(err, "error unmarshaling ChaincodeProposalPayload")
+}
+
+// GetSignatureHeader Get SignatureHeader from bytes
+func GetSignatureHeader(bytes []byte) (*common.SignatureHeader, error) {
+	sh := &common.SignatureHeader{}
+	err := proto.Unmarshal(bytes, sh)
+	return sh, errors.Wrap(err, "error unmarshaling SignatureHeader")
+}
+
+// CreateChaincodeProposal creates a proposal from given input.
+// It returns the proposal and the transaction id associated to the proposal
+func CreateChaincodeProposal(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte) (*peer.Proposal, string, error) {
+	return CreateChaincodeProposalWithTransient(typ, chainID, cis, creator, nil)
+}
+
+// CreateChaincodeProposalWithTransient creates a proposal from given input
+// It returns the proposal and the transaction id associated to the proposal
+func CreateChaincodeProposalWithTransient(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte, transientMap map[string][]byte) (*peer.Proposal, string, error) {
+	// generate a random nonce
+	nonce, err := crypto.GetRandomNonce()
+	if err != nil {
+		return nil, "", err
+	}
+
+	// compute txid
+	txid, err := ComputeTxID(nonce, creator)
+	if err != nil {
+		return nil, "", err
+	}
+
+	return CreateChaincodeProposalWithTxIDNonceAndTransient(txid, typ, chainID, cis, nonce, creator, transientMap)
+}
+
+// CreateChaincodeProposalWithTxIDAndTransient creates a proposal from given
+// input. It returns the proposal and the transaction id associated with the
+// proposal
+func CreateChaincodeProposalWithTxIDAndTransient(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte, txid string, transientMap map[string][]byte) (*peer.Proposal, string, error) {
+	// generate a random nonce
+	nonce, err := crypto.GetRandomNonce()
+	if err != nil {
+		return nil, "", err
+	}
+
+	// compute txid unless provided by tests
+	if txid == "" {
+		txid, err = ComputeTxID(nonce, creator)
+		if err != nil {
+			return nil, "", err
+		}
+	}
+
+	return CreateChaincodeProposalWithTxIDNonceAndTransient(txid, typ, chainID, cis, nonce, creator, transientMap)
+}
+
+// CreateChaincodeProposalWithTxIDNonceAndTransient creates a proposal from
+// given input
+func CreateChaincodeProposalWithTxIDNonceAndTransient(txid string, typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, nonce, creator []byte, transientMap map[string][]byte) (*peer.Proposal, string, error) {
+	ccHdrExt := &peer.ChaincodeHeaderExtension{ChaincodeId: cis.ChaincodeSpec.ChaincodeId}
+	ccHdrExtBytes, err := proto.Marshal(ccHdrExt)
+	if err != nil {
+		return nil, "", errors.Wrap(err, "error marshaling ChaincodeHeaderExtension")
+	}
+
+	cisBytes, err := proto.Marshal(cis)
+	if err != nil {
+		return nil, "", errors.Wrap(err, "error marshaling ChaincodeInvocationSpec")
+	}
+
+	ccPropPayload := &peer.ChaincodeProposalPayload{Input: cisBytes, TransientMap: transientMap}
+	ccPropPayloadBytes, err := proto.Marshal(ccPropPayload)
+	if err != nil {
+		return nil, "", errors.Wrap(err, "error marshaling ChaincodeProposalPayload")
+	}
+
+	// TODO: epoch is now set to zero. This must be changed once we
+	// get a more appropriate mechanism to handle it in.
+	var epoch uint64
+
+	timestamp := util.CreateUtcTimestamp()
+
+	hdr := &common.Header{
+		ChannelHeader: MarshalOrPanic(
+			&common.ChannelHeader{
+				Type:      int32(typ),
+				TxId:      txid,
+				Timestamp: timestamp,
+				ChannelId: chainID,
+				Extension: ccHdrExtBytes,
+				Epoch:     epoch,
+			},
+		),
+		SignatureHeader: MarshalOrPanic(
+			&common.SignatureHeader{
+				Nonce:   nonce,
+				Creator: creator,
+			},
+		),
+	}
+
+	hdrBytes, err := proto.Marshal(hdr)
+	if err != nil {
+		return nil, "", err
+	}
+
+	prop := &peer.Proposal{
+		Header:  hdrBytes,
+		Payload: ccPropPayloadBytes,
+	}
+	return prop, txid, nil
+}
+
+// GetBytesProposalResponsePayload gets proposal response payload
+func GetBytesProposalResponsePayload(hash []byte, response *peer.Response, result []byte, event []byte, ccid *peer.ChaincodeID) ([]byte, error) {
+	cAct := &peer.ChaincodeAction{
+		Events: event, Results: result,
+		Response:    response,
+		ChaincodeId: ccid,
+	}
+	cActBytes, err := proto.Marshal(cAct)
+	if err != nil {
+		return nil, errors.Wrap(err, "error marshaling ChaincodeAction")
+	}
+
+	prp := &peer.ProposalResponsePayload{
+		Extension:    cActBytes,
+		ProposalHash: hash,
+	}
+	prpBytes, err := proto.Marshal(prp)
+	return prpBytes, errors.Wrap(err, "error marshaling ProposalResponsePayload")
+}
+
+// GetBytesChaincodeProposalPayload gets the chaincode proposal payload
+func GetBytesChaincodeProposalPayload(cpp *peer.ChaincodeProposalPayload) ([]byte, error) {
+	cppBytes, err := proto.Marshal(cpp)
+	return cppBytes, errors.Wrap(err, "error marshaling ChaincodeProposalPayload")
+}
+
+// GetBytesResponse gets the bytes of Response
+func GetBytesResponse(res *peer.Response) ([]byte, error) {
+	resBytes, err := proto.Marshal(res)
+	return resBytes, errors.Wrap(err, "error marshaling Response")
+}
+
+// GetBytesChaincodeEvent gets the bytes of ChaincodeEvent
+func GetBytesChaincodeEvent(event *peer.ChaincodeEvent) ([]byte, error) {
+	eventBytes, err := proto.Marshal(event)
+	return eventBytes, errors.Wrap(err, "error marshaling ChaincodeEvent")
+}
+
+// GetBytesChaincodeActionPayload get the bytes of ChaincodeActionPayload from
+// the message
+func GetBytesChaincodeActionPayload(cap *peer.ChaincodeActionPayload) ([]byte, error) {
+	capBytes, err := proto.Marshal(cap)
+	return capBytes, errors.Wrap(err, "error marshaling ChaincodeActionPayload")
+}
+
+// GetBytesProposalResponse gets proposal bytes response
+func GetBytesProposalResponse(pr *peer.ProposalResponse) ([]byte, error) {
+	respBytes, err := proto.Marshal(pr)
+	return respBytes, errors.Wrap(err, "error marshaling ProposalResponse")
+}
+
+// GetBytesProposal returns the bytes of a proposal message
+func GetBytesProposal(prop *peer.Proposal) ([]byte, error) {
+	propBytes, err := proto.Marshal(prop)
+	return propBytes, errors.Wrap(err, "error marshaling Proposal")
+}
+
+// GetBytesHeader get the bytes of Header from the message
+func GetBytesHeader(hdr *common.Header) ([]byte, error) {
+	bytes, err := proto.Marshal(hdr)
+	return bytes, errors.Wrap(err, "error marshaling Header")
+}
+
+// GetBytesSignatureHeader get the bytes of SignatureHeader from the message
+func GetBytesSignatureHeader(hdr *common.SignatureHeader) ([]byte, error) {
+	bytes, err := proto.Marshal(hdr)
+	return bytes, errors.Wrap(err, "error marshaling SignatureHeader")
+}
+
+// GetBytesTransaction get the bytes of Transaction from the message
+func GetBytesTransaction(tx *peer.Transaction) ([]byte, error) {
+	bytes, err := proto.Marshal(tx)
+	return bytes, errors.Wrap(err, "error unmarshaling Transaction")
+}
+
+// GetBytesPayload get the bytes of Payload from the message
+func GetBytesPayload(payl *common.Payload) ([]byte, error) {
+	bytes, err := proto.Marshal(payl)
+	return bytes, errors.Wrap(err, "error marshaling Payload")
+}
+
+// GetBytesEnvelope get the bytes of Envelope from the message
+func GetBytesEnvelope(env *common.Envelope) ([]byte, error) {
+	bytes, err := proto.Marshal(env)
+	return bytes, errors.Wrap(err, "error marshaling Envelope")
+}
+
+// GetActionFromEnvelope extracts a ChaincodeAction message from a
+// serialized Envelope
+// TODO: fix function name as per FAB-11831
+func GetActionFromEnvelope(envBytes []byte) (*peer.ChaincodeAction, error) {
+	env, err := GetEnvelopeFromBlock(envBytes)
+	if err != nil {
+		return nil, err
+	}
+	return GetActionFromEnvelopeMsg(env)
+}
+
+func GetActionFromEnvelopeMsg(env *common.Envelope) (*peer.ChaincodeAction, error) {
+	payl, err := GetPayload(env)
+	if err != nil {
+		return nil, err
+	}
+
+	tx, err := GetTransaction(payl.Data)
+	if err != nil {
+		return nil, err
+	}
+
+	if len(tx.Actions) == 0 {
+		return nil, errors.New("at least one TransactionAction required")
+	}
+
+	_, respPayload, err := GetPayloads(tx.Actions[0])
+	return respPayload, err
+}
+
+// CreateProposalFromCISAndTxid returns a proposal given a serialized identity
+// and a ChaincodeInvocationSpec
+func CreateProposalFromCISAndTxid(txid string, typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte) (*peer.Proposal, string, error) {
+	nonce, err := crypto.GetRandomNonce()
+	if err != nil {
+		return nil, "", err
+	}
+	return CreateChaincodeProposalWithTxIDNonceAndTransient(txid, typ, chainID, cis, nonce, creator, nil)
+}
+
+// CreateProposalFromCIS returns a proposal given a serialized identity and a
+// ChaincodeInvocationSpec
+func CreateProposalFromCIS(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte) (*peer.Proposal, string, error) {
+	return CreateChaincodeProposal(typ, chainID, cis, creator)
+}
+
+// CreateGetChaincodesProposal returns a GETCHAINCODES proposal given a
+// serialized identity
+func CreateGetChaincodesProposal(chainID string, creator []byte) (*peer.Proposal, string, error) {
+	ccinp := &peer.ChaincodeInput{Args: [][]byte{[]byte("getchaincodes")}}
+	lsccSpec := &peer.ChaincodeInvocationSpec{
+		ChaincodeSpec: &peer.ChaincodeSpec{
+			Type:        peer.ChaincodeSpec_GOLANG,
+			ChaincodeId: &peer.ChaincodeID{Name: "lscc"},
+			Input:       ccinp,
+		},
+	}
+	return CreateProposalFromCIS(common.HeaderType_ENDORSER_TRANSACTION, chainID, lsccSpec, creator)
+}
+
+// CreateGetInstalledChaincodesProposal returns a GETINSTALLEDCHAINCODES
+// proposal given a serialized identity
+func CreateGetInstalledChaincodesProposal(creator []byte) (*peer.Proposal, string, error) {
+	ccinp := &peer.ChaincodeInput{Args: [][]byte{[]byte("getinstalledchaincodes")}}
+	lsccSpec := &peer.ChaincodeInvocationSpec{
+		ChaincodeSpec: &peer.ChaincodeSpec{
+			Type:        peer.ChaincodeSpec_GOLANG,
+			ChaincodeId: &peer.ChaincodeID{Name: "lscc"},
+			Input:       ccinp,
+		},
+	}
+	return CreateProposalFromCIS(common.HeaderType_ENDORSER_TRANSACTION, "", lsccSpec, creator)
+}
+
+// CreateInstallProposalFromCDS returns a install proposal given a serialized
+// identity and a ChaincodeDeploymentSpec
+func CreateInstallProposalFromCDS(ccpack proto.Message, creator []byte) (*peer.Proposal, string, error) {
+	return createProposalFromCDS("", ccpack, creator, "install")
+}
+
+// CreateDeployProposalFromCDS returns a deploy proposal given a serialized
+// identity and a ChaincodeDeploymentSpec
+func CreateDeployProposalFromCDS(
+	chainID string,
+	cds *peer.ChaincodeDeploymentSpec,
+	creator []byte,
+	policy []byte,
+	escc []byte,
+	vscc []byte,
+	collectionConfig []byte) (*peer.Proposal, string, error) {
+	if collectionConfig == nil {
+		return createProposalFromCDS(chainID, cds, creator, "deploy", policy, escc, vscc)
+	}
+	return createProposalFromCDS(chainID, cds, creator, "deploy", policy, escc, vscc, collectionConfig)
+}
+
+// CreateUpgradeProposalFromCDS returns a upgrade proposal given a serialized
+// identity and a ChaincodeDeploymentSpec
+func CreateUpgradeProposalFromCDS(
+	chainID string,
+	cds *peer.ChaincodeDeploymentSpec,
+	creator []byte,
+	policy []byte,
+	escc []byte,
+	vscc []byte,
+	collectionConfig []byte) (*peer.Proposal, string, error) {
+	if collectionConfig == nil {
+		return createProposalFromCDS(chainID, cds, creator, "upgrade", policy, escc, vscc)
+	}
+	return createProposalFromCDS(chainID, cds, creator, "upgrade", policy, escc, vscc, collectionConfig)
+}
+
+// createProposalFromCDS returns a deploy or upgrade proposal given a
+// serialized identity and a ChaincodeDeploymentSpec
+func createProposalFromCDS(chainID string, msg proto.Message, creator []byte, propType string, args ...[]byte) (*peer.Proposal, string, error) {
+	// in the new mode, cds will be nil, "deploy" and "upgrade" are instantiates.
+	var ccinp *peer.ChaincodeInput
+	var b []byte
+	var err error
+	if msg != nil {
+		b, err = proto.Marshal(msg)
+		if err != nil {
+			return nil, "", err
+		}
+	}
+	switch propType {
+	case "deploy":
+		fallthrough
+	case "upgrade":
+		cds, ok := msg.(*peer.ChaincodeDeploymentSpec)
+		if !ok || cds == nil {
+			return nil, "", errors.New("invalid message for creating lifecycle chaincode proposal")
+		}
+		Args := [][]byte{[]byte(propType), []byte(chainID), b}
+		Args = append(Args, args...)
+
+		ccinp = &peer.ChaincodeInput{Args: Args}
+	case "install":
+		ccinp = &peer.ChaincodeInput{Args: [][]byte{[]byte(propType), b}}
+	}
+
+	// wrap the deployment in an invocation spec to lscc...
+	lsccSpec := &peer.ChaincodeInvocationSpec{
+		ChaincodeSpec: &peer.ChaincodeSpec{
+			Type:        peer.ChaincodeSpec_GOLANG,
+			ChaincodeId: &peer.ChaincodeID{Name: "lscc"},
+			Input:       ccinp,
+		},
+	}
+
+	// ...and get the proposal for it
+	return CreateProposalFromCIS(common.HeaderType_ENDORSER_TRANSACTION, chainID, lsccSpec, creator)
+}
+
+// ComputeTxID computes TxID as the Hash computed
+// over the concatenation of nonce and creator.
+func ComputeTxID(nonce, creator []byte) (string, error) {
+	// TODO: Get the Hash function to be used from
+	// channel configuration
+	digest, err := factory.GetDefault().Hash(
+		append(nonce, creator...),
+		&bccsp.SHA256Opts{})
+	if err != nil {
+		return "", err
+	}
+	return hex.EncodeToString(digest), nil
+}
+
+// CheckTxID checks that txid is equal to the Hash computed
+// over the concatenation of nonce and creator.
+func CheckTxID(txid string, nonce, creator []byte) error {
+	computedTxID, err := ComputeTxID(nonce, creator)
+	if err != nil {
+		return errors.WithMessage(err, "error computing target txid")
+	}
+
+	if txid != computedTxID {
+		return errors.Errorf("invalid txid. got [%s], expected [%s]", txid, computedTxID)
+	}
+
+	return nil
+}
+
+// ComputeProposalBinding computes the binding of a proposal
+func ComputeProposalBinding(proposal *peer.Proposal) ([]byte, error) {
+	if proposal == nil {
+		return nil, errors.New("proposal is nil")
+	}
+	if len(proposal.Header) == 0 {
+		return nil, errors.New("proposal's header is nil")
+	}
+
+	h, err := GetHeader(proposal.Header)
+	if err != nil {
+		return nil, err
+	}
+
+	chdr, err := UnmarshalChannelHeader(h.ChannelHeader)
+	if err != nil {
+		return nil, err
+	}
+	shdr, err := GetSignatureHeader(h.SignatureHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	return computeProposalBindingInternal(shdr.Nonce, shdr.Creator, chdr.Epoch)
+}
+
+func computeProposalBindingInternal(nonce, creator []byte, epoch uint64) ([]byte, error) {
+	epochBytes := make([]byte, 8)
+	binary.LittleEndian.PutUint64(epochBytes, epoch)
+
+	// TODO: add to genesis block the hash function used for
+	// the binding computation
+	return factory.GetDefault().Hash(
+		append(append(nonce, creator...), epochBytes...),
+		&bccsp.SHA256Opts{})
+}
diff --git a/protoutil/proputils_test.go b/protoutil/proputils_test.go
new file mode 100644
index 00000000..ca7f54b3
--- /dev/null
+++ b/protoutil/proputils_test.go
@@ -0,0 +1,665 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"bytes"
+	"crypto/sha256"
+	"encoding/hex"
+	"fmt"
+	"os"
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/common/util"
+	"github.com/hyperledger/fabric/core/chaincode/platforms"
+	"github.com/hyperledger/fabric/core/chaincode/platforms/golang"
+	"github.com/hyperledger/fabric/msp"
+	mspmgmt "github.com/hyperledger/fabric/msp/mgmt"
+	msptesttools "github.com/hyperledger/fabric/msp/mgmt/testtools"
+	"github.com/hyperledger/fabric/protos/common"
+	pb "github.com/hyperledger/fabric/protos/peer"
+	"github.com/hyperledger/fabric/protos/utils"
+	"github.com/stretchr/testify/assert"
+)
+
+func createCIS() *pb.ChaincodeInvocationSpec {
+	return &pb.ChaincodeInvocationSpec{
+		ChaincodeSpec: &pb.ChaincodeSpec{
+			Type:        pb.ChaincodeSpec_GOLANG,
+			ChaincodeId: &pb.ChaincodeID{Name: "chaincode_name"},
+			Input:       &pb.ChaincodeInput{Args: [][]byte{[]byte("arg1"), []byte("arg2")}}}}
+}
+
+func TestNilProposal(t *testing.T) {
+	// pass nil to all function which accept *peer.Proposal
+	_, err := utils.GetChaincodeInvocationSpec(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, _, err = utils.GetChaincodeProposalContext(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, err = utils.GetNonce(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, err = utils.GetBytesProposal(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, err = utils.ComputeProposalBinding(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+}
+
+func TestBadProposalHeaders(t *testing.T) {
+	// NOTE:  There is a lot of repetitive proposal validation code
+	// in multiple functions which should be refactored in the future.
+	// For now, simply consolidating the test cases
+
+	// empty header
+	prop := &pb.Proposal{
+		Header: []byte{},
+	}
+	_, _, err := utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with empty proposal header")
+	_, err = utils.ComputeProposalBinding(prop)
+	assert.Error(t, err, "Expected error with empty proposal header")
+
+	// empty payload
+	prop = &pb.Proposal{
+		Header: []byte("header"),
+	}
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with empty proposal payload")
+
+	// malformed proposal header
+	prop = &pb.Proposal{
+		Header:  []byte("bad header"),
+		Payload: []byte("payload"),
+	}
+	_, err = utils.GetHeader(prop.Header)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+	_, err = utils.GetChaincodeInvocationSpec(prop)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+	_, err = utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+	_, err = utils.ComputeProposalBinding(prop)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+
+	// malformed signature header
+	chdr, _ := proto.Marshal(&common.ChannelHeader{
+		Type: int32(common.HeaderType_ENDORSER_TRANSACTION),
+	})
+	hdr := &common.Header{
+		ChannelHeader:   chdr,
+		SignatureHeader: []byte("bad signature header"),
+	}
+	_, err = utils.GetSignatureHeader(hdr.SignatureHeader)
+	assert.Error(t, err, "Expected error with malformed signature header")
+	hdrBytes, _ := proto.Marshal(hdr)
+	prop.Header = hdrBytes
+	_, err = utils.GetChaincodeInvocationSpec(prop)
+	assert.Error(t, err, "Expected error with malformed signature header")
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with malformed signature header")
+	_, err = utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with malformed signature header")
+	_, err = utils.ComputeProposalBinding(prop)
+	assert.Error(t, err, "Expected error with malformed signature header")
+
+	// wrong channel header type
+	chdr, _ = proto.Marshal(&common.ChannelHeader{
+		Type: int32(common.HeaderType_DELIVER_SEEK_INFO),
+	})
+	hdr.ChannelHeader = chdr
+	hdrBytes, _ = proto.Marshal(hdr)
+	prop.Header = hdrBytes
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with wrong header type")
+	assert.Contains(t, err.Error(), "invalid proposal: invalid channel header type")
+	_, err = utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with wrong header type")
+
+	// malformed channel header
+	hdr.ChannelHeader = []byte("bad channel header")
+	hdrBytes, _ = proto.Marshal(hdr)
+	prop.Header = hdrBytes
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with malformed channel header")
+	_, err = utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with malformed channel header")
+	_, err = utils.GetChaincodeHeaderExtension(hdr)
+	assert.Error(t, err, "Expected error with malformed channel header")
+	_, err = utils.ComputeProposalBinding(prop)
+	assert.Error(t, err, "Expected error with malformed channel header")
+
+}
+
+func TestGetNonce(t *testing.T) {
+	chdr, _ := proto.Marshal(&common.ChannelHeader{
+		Type: int32(common.HeaderType_ENDORSER_TRANSACTION),
+	})
+	hdr, _ := proto.Marshal(&common.Header{
+		ChannelHeader:   chdr,
+		SignatureHeader: []byte{},
+	})
+	prop := &pb.Proposal{
+		Header: hdr,
+	}
+	_, err := utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with nil signature header")
+
+	shdr, _ := proto.Marshal(&common.SignatureHeader{
+		Nonce: []byte("nonce"),
+	})
+	hdr, _ = proto.Marshal(&common.Header{
+		ChannelHeader:   chdr,
+		SignatureHeader: shdr,
+	})
+	prop = &pb.Proposal{
+		Header: hdr,
+	}
+	nonce, err := utils.GetNonce(prop)
+	assert.NoError(t, err, "Unexpected error getting nonce")
+	assert.Equal(t, "nonce", string(nonce), "Failed to return the expected nonce")
+
+}
+
+func TestGetChaincodeDeploymentSpec(t *testing.T) {
+	pr := platforms.NewRegistry(&golang.Platform{})
+
+	_, err := utils.GetChaincodeDeploymentSpec([]byte("bad spec"), pr)
+	assert.Error(t, err, "Expected error with malformed spec")
+
+	cds, _ := proto.Marshal(&pb.ChaincodeDeploymentSpec{
+		ChaincodeSpec: &pb.ChaincodeSpec{
+			Type: pb.ChaincodeSpec_GOLANG,
+		},
+	})
+	_, err = utils.GetChaincodeDeploymentSpec(cds, pr)
+	assert.NoError(t, err, "Unexpected error getting deployment spec")
+
+	cds, _ = proto.Marshal(&pb.ChaincodeDeploymentSpec{
+		ChaincodeSpec: &pb.ChaincodeSpec{
+			Type: pb.ChaincodeSpec_UNDEFINED,
+		},
+	})
+	_, err = utils.GetChaincodeDeploymentSpec(cds, pr)
+	assert.Error(t, err, "Expected error with invalid spec type")
+
+}
+
+func TestCDSProposals(t *testing.T) {
+	var prop *pb.Proposal
+	var err error
+	var txid string
+	creator := []byte("creator")
+	cds := &pb.ChaincodeDeploymentSpec{
+		ChaincodeSpec: &pb.ChaincodeSpec{
+			Type: pb.ChaincodeSpec_GOLANG,
+		},
+	}
+	policy := []byte("policy")
+	escc := []byte("escc")
+	vscc := []byte("vscc")
+	chainID := "testchainid"
+
+	// install
+	prop, txid, err = utils.CreateInstallProposalFromCDS(cds, creator)
+	assert.NotNil(t, prop, "Install proposal should not be nil")
+	assert.NoError(t, err, "Unexpected error creating install proposal")
+	assert.NotEqual(t, "", txid, "txid should not be empty")
+
+	// deploy
+	prop, txid, err = utils.CreateDeployProposalFromCDS(chainID, cds, creator, policy, escc, vscc, nil)
+	assert.NotNil(t, prop, "Deploy proposal should not be nil")
+	assert.NoError(t, err, "Unexpected error creating deploy proposal")
+	assert.NotEqual(t, "", txid, "txid should not be empty")
+
+	// upgrade
+	prop, txid, err = utils.CreateUpgradeProposalFromCDS(chainID, cds, creator, policy, escc, vscc, nil)
+	assert.NotNil(t, prop, "Upgrade proposal should not be nil")
+	assert.NoError(t, err, "Unexpected error creating upgrade proposal")
+	assert.NotEqual(t, "", txid, "txid should not be empty")
+
+}
+
+func TestComputeProposalBinding(t *testing.T) {
+	expectedDigestHex := "5093dd4f4277e964da8f4afbde0a9674d17f2a6a5961f0670fc21ae9b67f2983"
+	expectedDigest, _ := hex.DecodeString(expectedDigestHex)
+	chdr, _ := proto.Marshal(&common.ChannelHeader{
+		Epoch: uint64(10),
+	})
+	shdr, _ := proto.Marshal(&common.SignatureHeader{
+		Nonce:   []byte("nonce"),
+		Creator: []byte("creator"),
+	})
+	hdr, _ := proto.Marshal(&common.Header{
+		ChannelHeader:   chdr,
+		SignatureHeader: shdr,
+	})
+	prop := &pb.Proposal{
+		Header: hdr,
+	}
+	binding, _ := utils.ComputeProposalBinding(prop)
+	assert.Equal(t, expectedDigest, binding, "Binding does not match expected digest")
+}
+
+func TestProposal(t *testing.T) {
+	// create a proposal from a ChaincodeInvocationSpec
+	prop, _, err := utils.CreateChaincodeProposalWithTransient(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		util.GetTestChainID(), createCIS(),
+		[]byte("creator"),
+		map[string][]byte{"certx": []byte("transient")})
+	if err != nil {
+		t.Fatalf("Could not create chaincode proposal, err %s\n", err)
+		return
+	}
+
+	// serialize the proposal
+	pBytes, err := utils.GetBytesProposal(prop)
+	if err != nil {
+		t.Fatalf("Could not serialize the chaincode proposal, err %s\n", err)
+		return
+	}
+
+	// deserialize it and expect it to be the same
+	propBack, err := utils.GetProposal(pBytes)
+	if err != nil {
+		t.Fatalf("Could not deserialize the chaincode proposal, err %s\n", err)
+		return
+	}
+	if !proto.Equal(prop, propBack) {
+		t.Fatalf("Proposal and deserialized proposals don't match\n")
+		return
+	}
+
+	// get back the header
+	hdr, err := utils.GetHeader(prop.Header)
+	if err != nil {
+		t.Fatalf("Could not extract the header from the proposal, err %s\n", err)
+	}
+
+	hdrBytes, err := utils.GetBytesHeader(hdr)
+	if err != nil {
+		t.Fatalf("Could not marshal the header, err %s\n", err)
+	}
+
+	hdr, err = utils.GetHeader(hdrBytes)
+	if err != nil {
+		t.Fatalf("Could not unmarshal the header, err %s\n", err)
+	}
+
+	chdr, err := utils.UnmarshalChannelHeader(hdr.ChannelHeader)
+	if err != nil {
+		t.Fatalf("Could not unmarshal channel header, err %s", err)
+	}
+
+	shdr, err := utils.GetSignatureHeader(hdr.SignatureHeader)
+	if err != nil {
+		t.Fatalf("Could not unmarshal signature header, err %s", err)
+	}
+
+	_, err = utils.GetBytesSignatureHeader(shdr)
+	if err != nil {
+		t.Fatalf("Could not marshal signature header, err %s", err)
+	}
+
+	// sanity check on header
+	if chdr.Type != int32(common.HeaderType_ENDORSER_TRANSACTION) ||
+		shdr.Nonce == nil ||
+		string(shdr.Creator) != "creator" {
+		t.Fatalf("Invalid header after unmarshalling\n")
+		return
+	}
+
+	// get back the header extension
+	hdrExt, err := utils.GetChaincodeHeaderExtension(hdr)
+	if err != nil {
+		t.Fatalf("Could not extract the header extensions from the proposal, err %s\n", err)
+		return
+	}
+
+	// sanity check on header extension
+	if string(hdrExt.ChaincodeId.Name) != "chaincode_name" {
+		t.Fatalf("Invalid header extension after unmarshalling\n")
+		return
+	}
+
+	// get back the ChaincodeInvocationSpec
+	cis, err := utils.GetChaincodeInvocationSpec(prop)
+	if err != nil {
+		t.Fatalf("Could not extract chaincode invocation spec from header, err %s\n", err)
+		return
+	}
+
+	// sanity check on cis
+	if cis.ChaincodeSpec.Type != pb.ChaincodeSpec_GOLANG ||
+		cis.ChaincodeSpec.ChaincodeId.Name != "chaincode_name" ||
+		len(cis.ChaincodeSpec.Input.Args) != 2 ||
+		string(cis.ChaincodeSpec.Input.Args[0]) != "arg1" ||
+		string(cis.ChaincodeSpec.Input.Args[1]) != "arg2" {
+		t.Fatalf("Invalid chaincode invocation spec after unmarshalling\n")
+		return
+	}
+
+	creator, transient, err := utils.GetChaincodeProposalContext(prop)
+	if err != nil {
+		t.Fatalf("Failed getting chaincode proposal context [%s]", err)
+	}
+	if string(creator) != "creator" {
+		t.Fatalf("Failed checking Creator field. Invalid value, expectext 'creator', got [%s]", string(creator))
+		return
+	}
+	value, ok := transient["certx"]
+	if !ok || string(value) != "transient" {
+		t.Fatalf("Failed checking Transient field. Invalid value, expectext 'transient', got [%s]", string(value))
+		return
+	}
+}
+
+func TestProposalWithTxID(t *testing.T) {
+	// create a proposal from a ChaincodeInvocationSpec
+	prop, txid, err := utils.CreateChaincodeProposalWithTxIDAndTransient(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		util.GetTestChainID(),
+		createCIS(),
+		[]byte("creator"),
+		"testtx",
+		map[string][]byte{"certx": []byte("transient")},
+	)
+	assert.Nil(t, err)
+	assert.NotNil(t, prop)
+	assert.Equal(t, txid, "testtx")
+
+	prop, txid, err = utils.CreateChaincodeProposalWithTxIDAndTransient(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		util.GetTestChainID(),
+		createCIS(),
+		[]byte("creator"),
+		"",
+		map[string][]byte{"certx": []byte("transient")},
+	)
+	assert.Nil(t, err)
+	assert.NotNil(t, prop)
+	assert.NotEmpty(t, txid)
+}
+
+func TestProposalResponse(t *testing.T) {
+	events := &pb.ChaincodeEvent{
+		ChaincodeId: "ccid",
+		EventName:   "EventName",
+		Payload:     []byte("EventPayload"),
+		TxId:        "TxID"}
+	ccid := &pb.ChaincodeID{
+		Name:    "ccid",
+		Version: "v1",
+	}
+
+	pHashBytes := []byte("proposal_hash")
+	pResponse := &pb.Response{Status: 200}
+	results := []byte("results")
+	eventBytes, err := utils.GetBytesChaincodeEvent(events)
+	if err != nil {
+		t.Fatalf("Failure while marshalling the ProposalResponsePayload")
+		return
+	}
+
+	// get the bytes of the response
+	pResponseBytes, err := utils.GetBytesResponse(pResponse)
+	if err != nil {
+		t.Fatalf("Failure while marshalling the Response")
+		return
+	}
+
+	// get the response from bytes
+	_, err = utils.GetResponse(pResponseBytes)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the Response")
+		return
+	}
+
+	// get the bytes of the ProposalResponsePayload
+	prpBytes, err := utils.GetBytesProposalResponsePayload(pHashBytes, pResponse, results, eventBytes, ccid)
+	if err != nil {
+		t.Fatalf("Failure while marshalling the ProposalResponsePayload")
+		return
+	}
+
+	// get the ProposalResponsePayload message
+	prp, err := utils.GetProposalResponsePayload(prpBytes)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the ProposalResponsePayload")
+		return
+	}
+
+	// get the ChaincodeAction message
+	act, err := utils.GetChaincodeAction(prp.Extension)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the ChaincodeAction")
+		return
+	}
+
+	// sanity check on the action
+	if string(act.Results) != "results" {
+		t.Fatalf("Invalid actions after unmarshalling")
+		return
+	}
+
+	event, err := utils.GetChaincodeEvents(act.Events)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the ChainCodeEvents")
+		return
+	}
+
+	// sanity check on the event
+	if string(event.ChaincodeId) != "ccid" {
+		t.Fatalf("Invalid actions after unmarshalling")
+		return
+	}
+
+	pr := &pb.ProposalResponse{
+		Payload:     prpBytes,
+		Endorsement: &pb.Endorsement{Endorser: []byte("endorser"), Signature: []byte("signature")},
+		Version:     1, // TODO: pick right version number
+		Response:    &pb.Response{Status: 200, Message: "OK"}}
+
+	// create a proposal response
+	prBytes, err := utils.GetBytesProposalResponse(pr)
+	if err != nil {
+		t.Fatalf("Failure while marshalling the ProposalResponse")
+		return
+	}
+
+	// get the proposal response message back
+	prBack, err := utils.GetProposalResponse(prBytes)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the ProposalResponse")
+		return
+	}
+
+	// sanity check on pr
+	if prBack.Response.Status != 200 ||
+		string(prBack.Endorsement.Signature) != "signature" ||
+		string(prBack.Endorsement.Endorser) != "endorser" ||
+		bytes.Compare(prBack.Payload, prpBytes) != 0 {
+		t.Fatalf("Invalid ProposalResponse after unmarshalling")
+		return
+	}
+}
+
+func TestEnvelope(t *testing.T) {
+	// create a proposal from a ChaincodeInvocationSpec
+	prop, _, err := utils.CreateChaincodeProposal(common.HeaderType_ENDORSER_TRANSACTION, util.GetTestChainID(), createCIS(), signerSerialized)
+	if err != nil {
+		t.Fatalf("Could not create chaincode proposal, err %s\n", err)
+		return
+	}
+
+	response := &pb.Response{Status: 200, Payload: []byte("payload")}
+	result := []byte("res")
+	ccid := &pb.ChaincodeID{Name: "foo", Version: "v1"}
+
+	presp, err := utils.CreateProposalResponse(prop.Header, prop.Payload, response, result, nil, ccid, nil, signer)
+	if err != nil {
+		t.Fatalf("Could not create proposal response, err %s\n", err)
+		return
+	}
+
+	tx, err := utils.CreateSignedTx(prop, signer, presp)
+	if err != nil {
+		t.Fatalf("Could not create signed tx, err %s\n", err)
+		return
+	}
+
+	envBytes, err := utils.GetBytesEnvelope(tx)
+	if err != nil {
+		t.Fatalf("Could not marshal envelope, err %s\n", err)
+		return
+	}
+
+	tx, err = utils.GetEnvelopeFromBlock(envBytes)
+	if err != nil {
+		t.Fatalf("Could not unmarshal envelope, err %s\n", err)
+		return
+	}
+
+	act2, err := utils.GetActionFromEnvelope(envBytes)
+	if err != nil {
+		t.Fatalf("Could not extract actions from envelop, err %s\n", err)
+		return
+	}
+
+	if act2.Response.Status != response.Status {
+		t.Fatalf("response staus don't match")
+		return
+	}
+	if bytes.Compare(act2.Response.Payload, response.Payload) != 0 {
+		t.Fatalf("response payload don't match")
+		return
+	}
+
+	if bytes.Compare(act2.Results, result) != 0 {
+		t.Fatalf("results don't match")
+		return
+	}
+
+	txpayl, err := utils.GetPayload(tx)
+	if err != nil {
+		t.Fatalf("Could not unmarshal payload, err %s\n", err)
+		return
+	}
+
+	tx2, err := utils.GetTransaction(txpayl.Data)
+	if err != nil {
+		t.Fatalf("Could not unmarshal Transaction, err %s\n", err)
+		return
+	}
+
+	sh, err := utils.GetSignatureHeader(tx2.Actions[0].Header)
+	if err != nil {
+		t.Fatalf("Could not unmarshal SignatureHeader, err %s\n", err)
+		return
+	}
+
+	if bytes.Compare(sh.Creator, signerSerialized) != 0 {
+		t.Fatalf("creator does not match")
+		return
+	}
+
+	cap, err := utils.GetChaincodeActionPayload(tx2.Actions[0].Payload)
+	if err != nil {
+		t.Fatalf("Could not unmarshal ChaincodeActionPayload, err %s\n", err)
+		return
+	}
+	assert.NotNil(t, cap)
+
+	prp, err := utils.GetProposalResponsePayload(cap.Action.ProposalResponsePayload)
+	if err != nil {
+		t.Fatalf("Could not unmarshal ProposalResponsePayload, err %s\n", err)
+		return
+	}
+
+	ca, err := utils.GetChaincodeAction(prp.Extension)
+	if err != nil {
+		t.Fatalf("Could not unmarshal ChaincodeAction, err %s\n", err)
+		return
+	}
+
+	if ca.Response.Status != response.Status {
+		t.Fatalf("response staus don't match")
+		return
+	}
+	if bytes.Compare(ca.Response.Payload, response.Payload) != 0 {
+		t.Fatalf("response payload don't match")
+		return
+	}
+
+	if bytes.Compare(ca.Results, result) != 0 {
+		t.Fatalf("results don't match")
+		return
+	}
+}
+
+func TestProposalTxID(t *testing.T) {
+	nonce := []byte{1}
+	creator := []byte{2}
+
+	txid, err := utils.ComputeTxID(nonce, creator)
+	assert.NotEmpty(t, txid, "TxID cannot be empty.")
+	assert.NoError(t, err, "Failed computing txID")
+	assert.Nil(t, utils.CheckTxID(txid, nonce, creator))
+	assert.Error(t, utils.CheckTxID("", nonce, creator))
+
+	txid, err = utils.ComputeTxID(nil, nil)
+	assert.NotEmpty(t, txid, "TxID cannot be empty.")
+	assert.NoError(t, err, "Failed computing txID")
+}
+
+func TestComputeProposalTxID(t *testing.T) {
+	txid, err := utils.ComputeTxID([]byte{1}, []byte{1})
+	assert.NoError(t, err, "Failed computing TxID")
+
+	// Compute the function computed by ComputeTxID,
+	// namely, base64(sha256(nonce||creator))
+	hf := sha256.New()
+	hf.Write([]byte{1})
+	hf.Write([]byte{1})
+	hashOut := hf.Sum(nil)
+	txid2 := hex.EncodeToString(hashOut)
+
+	t.Logf("% x\n", hashOut)
+	t.Logf("% s\n", txid)
+	t.Logf("% s\n", txid2)
+
+	assert.Equal(t, txid, txid2)
+}
+
+var signer msp.SigningIdentity
+var signerSerialized []byte
+
+func TestMain(m *testing.M) {
+	// setup the MSP manager so that we can sign/verify
+	err := msptesttools.LoadMSPSetupForTesting()
+	if err != nil {
+		os.Exit(-1)
+		fmt.Printf("Could not initialize msp")
+		return
+	}
+	signer, err = mspmgmt.GetLocalMSP().GetDefaultSigningIdentity()
+	if err != nil {
+		os.Exit(-1)
+		fmt.Printf("Could not get signer")
+		return
+	}
+
+	signerSerialized, err = signer.Serialize()
+	if err != nil {
+		os.Exit(-1)
+		fmt.Printf("Could not serialize identity")
+		return
+	}
+
+	os.Exit(m.Run())
+}
diff --git a/protoutil/readme.md b/protoutil/readme.md
new file mode 100644
index 00000000..9f258a41
--- /dev/null
+++ b/protoutil/readme.md
@@ -0,0 +1,2 @@
+protoutil package is a copy of protos/utils
+it has been created for trustbloc/fabric-peer-ext dependency
\ No newline at end of file
diff --git a/protoutil/txutils.go b/protoutil/txutils.go
new file mode 100644
index 00000000..20b6b5a7
--- /dev/null
+++ b/protoutil/txutils.go
@@ -0,0 +1,453 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"bytes"
+	"fmt"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/bccsp"
+	"github.com/hyperledger/fabric/bccsp/factory"
+	"github.com/hyperledger/fabric/common/crypto"
+	"github.com/hyperledger/fabric/msp"
+	"github.com/hyperledger/fabric/protos/common"
+	"github.com/hyperledger/fabric/protos/peer"
+	"github.com/pkg/errors"
+)
+
+// GetPayloads gets the underlying payload objects in a TransactionAction
+func GetPayloads(txActions *peer.TransactionAction) (*peer.ChaincodeActionPayload, *peer.ChaincodeAction, error) {
+	// TODO: pass in the tx type (in what follows we're assuming the
+	// type is ENDORSER_TRANSACTION)
+	ccPayload, err := GetChaincodeActionPayload(txActions.Payload)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	if ccPayload.Action == nil || ccPayload.Action.ProposalResponsePayload == nil {
+		return nil, nil, errors.New("no payload in ChaincodeActionPayload")
+	}
+	pRespPayload, err := GetProposalResponsePayload(ccPayload.Action.ProposalResponsePayload)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	if pRespPayload.Extension == nil {
+		return nil, nil, errors.New("response payload is missing extension")
+	}
+
+	respPayload, err := GetChaincodeAction(pRespPayload.Extension)
+	if err != nil {
+		return ccPayload, nil, err
+	}
+	return ccPayload, respPayload, nil
+}
+
+// GetEnvelopeFromBlock gets an envelope from a block's Data field.
+func GetEnvelopeFromBlock(data []byte) (*common.Envelope, error) {
+	// Block always begins with an envelope
+	var err error
+	env := &common.Envelope{}
+	if err = proto.Unmarshal(data, env); err != nil {
+		return nil, errors.Wrap(err, "error unmarshaling Envelope")
+	}
+
+	return env, nil
+}
+
+// CreateSignedEnvelope creates a signed envelope of the desired type, with
+// marshaled dataMsg and signs it
+func CreateSignedEnvelope(txType common.HeaderType, channelID string, signer crypto.LocalSigner, dataMsg proto.Message, msgVersion int32, epoch uint64) (*common.Envelope, error) {
+	return CreateSignedEnvelopeWithTLSBinding(txType, channelID, signer, dataMsg, msgVersion, epoch, nil)
+}
+
+// CreateSignedEnvelopeWithTLSBinding creates a signed envelope of the desired
+// type, with marshaled dataMsg and signs it. It also includes a TLS cert hash
+// into the channel header
+func CreateSignedEnvelopeWithTLSBinding(txType common.HeaderType, channelID string, signer crypto.LocalSigner, dataMsg proto.Message, msgVersion int32, epoch uint64, tlsCertHash []byte) (*common.Envelope, error) {
+	payloadChannelHeader := MakeChannelHeader(txType, msgVersion, channelID, epoch)
+	payloadChannelHeader.TlsCertHash = tlsCertHash
+	var err error
+	payloadSignatureHeader := &common.SignatureHeader{}
+
+	if signer != nil {
+		payloadSignatureHeader, err = signer.NewSignatureHeader()
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	data, err := proto.Marshal(dataMsg)
+	if err != nil {
+		return nil, errors.Wrap(err, "error marshaling")
+	}
+
+	paylBytes := MarshalOrPanic(
+		&common.Payload{
+			Header: MakePayloadHeader(payloadChannelHeader, payloadSignatureHeader),
+			Data:   data,
+		},
+	)
+
+	var sig []byte
+	if signer != nil {
+		sig, err = signer.Sign(paylBytes)
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	env := &common.Envelope{
+		Payload:   paylBytes,
+		Signature: sig,
+	}
+
+	return env, nil
+}
+
+// CreateSignedTx assembles an Envelope message from proposal, endorsements,
+// and a signer. This function should be called by a client when it has
+// collected enough endorsements for a proposal to create a transaction and
+// submit it to peers for ordering
+func CreateSignedTx(proposal *peer.Proposal, signer msp.SigningIdentity, resps ...*peer.ProposalResponse) (*common.Envelope, error) {
+	if len(resps) == 0 {
+		return nil, errors.New("at least one proposal response is required")
+	}
+
+	// the original header
+	hdr, err := GetHeader(proposal.Header)
+	if err != nil {
+		return nil, err
+	}
+
+	// the original payload
+	pPayl, err := GetChaincodeProposalPayload(proposal.Payload)
+	if err != nil {
+		return nil, err
+	}
+
+	// check that the signer is the same that is referenced in the header
+	// TODO: maybe worth removing?
+	signerBytes, err := signer.Serialize()
+	if err != nil {
+		return nil, err
+	}
+
+	shdr, err := GetSignatureHeader(hdr.SignatureHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	if bytes.Compare(signerBytes, shdr.Creator) != 0 {
+		return nil, errors.New("signer must be the same as the one referenced in the header")
+	}
+
+	// get header extensions so we have the visibility field
+	hdrExt, err := GetChaincodeHeaderExtension(hdr)
+	if err != nil {
+		return nil, err
+	}
+
+	// ensure that all actions are bitwise equal and that they are successful
+	var a1 []byte
+	for n, r := range resps {
+		if n == 0 {
+			a1 = r.Payload
+			if r.Response.Status < 200 || r.Response.Status >= 400 {
+				return nil, errors.Errorf("proposal response was not successful, error code %d, msg %s", r.Response.Status, r.Response.Message)
+			}
+			continue
+		}
+
+		if bytes.Compare(a1, r.Payload) != 0 {
+			return nil, errors.New("ProposalResponsePayloads do not match")
+		}
+	}
+
+	// fill endorsements
+	endorsements := make([]*peer.Endorsement, len(resps))
+	for n, r := range resps {
+		endorsements[n] = r.Endorsement
+	}
+
+	// create ChaincodeEndorsedAction
+	cea := &peer.ChaincodeEndorsedAction{ProposalResponsePayload: resps[0].Payload, Endorsements: endorsements}
+
+	// obtain the bytes of the proposal payload that will go to the transaction
+	propPayloadBytes, err := GetBytesProposalPayloadForTx(pPayl, hdrExt.PayloadVisibility)
+	if err != nil {
+		return nil, err
+	}
+
+	// serialize the chaincode action payload
+	cap := &peer.ChaincodeActionPayload{ChaincodeProposalPayload: propPayloadBytes, Action: cea}
+	capBytes, err := GetBytesChaincodeActionPayload(cap)
+	if err != nil {
+		return nil, err
+	}
+
+	// create a transaction
+	taa := &peer.TransactionAction{Header: hdr.SignatureHeader, Payload: capBytes}
+	taas := make([]*peer.TransactionAction, 1)
+	taas[0] = taa
+	tx := &peer.Transaction{Actions: taas}
+
+	// serialize the tx
+	txBytes, err := GetBytesTransaction(tx)
+	if err != nil {
+		return nil, err
+	}
+
+	// create the payload
+	payl := &common.Payload{Header: hdr, Data: txBytes}
+	paylBytes, err := GetBytesPayload(payl)
+	if err != nil {
+		return nil, err
+	}
+
+	// sign the payload
+	sig, err := signer.Sign(paylBytes)
+	if err != nil {
+		return nil, err
+	}
+
+	// here's the envelope
+	return &common.Envelope{Payload: paylBytes, Signature: sig}, nil
+}
+
+// CreateProposalResponse creates a proposal response.
+func CreateProposalResponse(hdrbytes []byte, payl []byte, response *peer.Response, results []byte, events []byte, ccid *peer.ChaincodeID, visibility []byte, signingEndorser msp.SigningIdentity) (*peer.ProposalResponse, error) {
+	hdr, err := GetHeader(hdrbytes)
+	if err != nil {
+		return nil, err
+	}
+
+	// obtain the proposal hash given proposal header, payload and the
+	// requested visibility
+	pHashBytes, err := GetProposalHash1(hdr, payl, visibility)
+	if err != nil {
+		return nil, errors.WithMessage(err, "error computing proposal hash")
+	}
+
+	// get the bytes of the proposal response payload - we need to sign them
+	prpBytes, err := GetBytesProposalResponsePayload(pHashBytes, response, results, events, ccid)
+	if err != nil {
+		return nil, err
+	}
+
+	// serialize the signing identity
+	endorser, err := signingEndorser.Serialize()
+	if err != nil {
+		return nil, errors.WithMessage(err, fmt.Sprintf("error serializing signing identity for %s", signingEndorser.GetIdentifier()))
+	}
+
+	// sign the concatenation of the proposal response and the serialized
+	// endorser identity with this endorser's key
+	signature, err := signingEndorser.Sign(append(prpBytes, endorser...))
+	if err != nil {
+		return nil, errors.WithMessage(err, "could not sign the proposal response payload")
+	}
+
+	resp := &peer.ProposalResponse{
+		// Timestamp: TODO!
+		Version: 1, // TODO: pick right version number
+		Endorsement: &peer.Endorsement{
+			Signature: signature,
+			Endorser:  endorser,
+		},
+		Payload: prpBytes,
+		Response: &peer.Response{
+			Status:  200,
+			Message: "OK",
+		},
+	}
+
+	return resp, nil
+}
+
+// CreateProposalResponseFailure creates a proposal response for cases where
+// endorsement proposal fails either due to a endorsement failure or a
+// chaincode failure (chaincode response status >= shim.ERRORTHRESHOLD)
+func CreateProposalResponseFailure(hdrbytes []byte, payl []byte, response *peer.Response, results []byte, events []byte, ccid *peer.ChaincodeID, visibility []byte) (*peer.ProposalResponse, error) {
+	hdr, err := GetHeader(hdrbytes)
+	if err != nil {
+		return nil, err
+	}
+
+	// obtain the proposal hash given proposal header, payload and the requested visibility
+	pHashBytes, err := GetProposalHash1(hdr, payl, visibility)
+	if err != nil {
+		return nil, errors.WithMessage(err, "error computing proposal hash")
+	}
+
+	// get the bytes of the proposal response payload
+	prpBytes, err := GetBytesProposalResponsePayload(pHashBytes, response, results, events, ccid)
+	if err != nil {
+		return nil, err
+	}
+
+	resp := &peer.ProposalResponse{
+		// Timestamp: TODO!
+		Payload:  prpBytes,
+		Response: response,
+	}
+
+	return resp, nil
+}
+
+// GetSignedProposal returns a signed proposal given a Proposal message and a
+// signing identity
+func GetSignedProposal(prop *peer.Proposal, signer msp.SigningIdentity) (*peer.SignedProposal, error) {
+	// check for nil argument
+	if prop == nil || signer == nil {
+		return nil, errors.New("nil arguments")
+	}
+
+	propBytes, err := GetBytesProposal(prop)
+	if err != nil {
+		return nil, err
+	}
+
+	signature, err := signer.Sign(propBytes)
+	if err != nil {
+		return nil, err
+	}
+
+	return &peer.SignedProposal{ProposalBytes: propBytes, Signature: signature}, nil
+}
+
+// MockSignedEndorserProposalOrPanic creates a SignedProposal with the
+// passed arguments
+func MockSignedEndorserProposalOrPanic(chainID string, cs *peer.ChaincodeSpec, creator, signature []byte) (*peer.SignedProposal, *peer.Proposal) {
+	prop, _, err := CreateChaincodeProposal(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		chainID,
+		&peer.ChaincodeInvocationSpec{ChaincodeSpec: cs},
+		creator)
+	if err != nil {
+		panic(err)
+	}
+
+	propBytes, err := GetBytesProposal(prop)
+	if err != nil {
+		panic(err)
+	}
+
+	return &peer.SignedProposal{ProposalBytes: propBytes, Signature: signature}, prop
+}
+
+func MockSignedEndorserProposal2OrPanic(chainID string, cs *peer.ChaincodeSpec, signer msp.SigningIdentity) (*peer.SignedProposal, *peer.Proposal) {
+	serializedSigner, err := signer.Serialize()
+	if err != nil {
+		panic(err)
+	}
+
+	prop, _, err := CreateChaincodeProposal(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		chainID,
+		&peer.ChaincodeInvocationSpec{ChaincodeSpec: &peer.ChaincodeSpec{}},
+		serializedSigner)
+	if err != nil {
+		panic(err)
+	}
+
+	sProp, err := GetSignedProposal(prop, signer)
+	if err != nil {
+		panic(err)
+	}
+
+	return sProp, prop
+}
+
+// GetBytesProposalPayloadForTx takes a ChaincodeProposalPayload and returns
+// its serialized version according to the visibility field
+func GetBytesProposalPayloadForTx(payload *peer.ChaincodeProposalPayload, visibility []byte) ([]byte, error) {
+	// check for nil argument
+	if payload == nil {
+		return nil, errors.New("nil arguments")
+	}
+
+	// strip the transient bytes off the payload - this needs to be done no
+	// matter the visibility mode
+	cppNoTransient := &peer.ChaincodeProposalPayload{Input: payload.Input, TransientMap: nil}
+	cppBytes, err := GetBytesChaincodeProposalPayload(cppNoTransient)
+	if err != nil {
+		return nil, err
+	}
+
+	// currently the fabric only supports full visibility: this means that
+	// there are no restrictions on which parts of the proposal payload will
+	// be visible in the final transaction; this default approach requires
+	// no additional instructions in the PayloadVisibility field; however
+	// the fabric may be extended to encode more elaborate visibility
+	// mechanisms that shall be encoded in this field (and handled
+	// appropriately by the peer)
+
+	return cppBytes, nil
+}
+
+// GetProposalHash2 gets the proposal hash - this version
+// is called by the committer where the visibility policy
+// has already been enforced and so we already get what
+// we have to get in ccPropPayl
+func GetProposalHash2(header *common.Header, ccPropPayl []byte) ([]byte, error) {
+	// check for nil argument
+	if header == nil ||
+		header.ChannelHeader == nil ||
+		header.SignatureHeader == nil ||
+		ccPropPayl == nil {
+		return nil, errors.New("nil arguments")
+	}
+
+	hash, err := factory.GetDefault().GetHash(&bccsp.SHA256Opts{})
+	if err != nil {
+		return nil, errors.WithMessage(err, "error instantiating hash function")
+	}
+	// hash the serialized Channel Header object
+	hash.Write(header.ChannelHeader)
+	// hash the serialized Signature Header object
+	hash.Write(header.SignatureHeader)
+	// hash the bytes of the chaincode proposal payload that we are given
+	hash.Write(ccPropPayl)
+	return hash.Sum(nil), nil
+}
+
+// GetProposalHash1 gets the proposal hash bytes after sanitizing the
+// chaincode proposal payload according to the rules of visibility
+func GetProposalHash1(header *common.Header, ccPropPayl []byte, visibility []byte) ([]byte, error) {
+	// check for nil argument
+	if header == nil ||
+		header.ChannelHeader == nil ||
+		header.SignatureHeader == nil ||
+		ccPropPayl == nil {
+		return nil, errors.New("nil arguments")
+	}
+
+	// unmarshal the chaincode proposal payload
+	cpp, err := GetChaincodeProposalPayload(ccPropPayl)
+	if err != nil {
+		return nil, err
+	}
+
+	ppBytes, err := GetBytesProposalPayloadForTx(cpp, visibility)
+	if err != nil {
+		return nil, err
+	}
+
+	hash2, err := factory.GetDefault().GetHash(&bccsp.SHA256Opts{})
+	if err != nil {
+		return nil, errors.WithMessage(err, "error instantiating hash function")
+	}
+	// hash the serialized Channel Header object
+	hash2.Write(header.ChannelHeader)
+	// hash the serialized Signature Header object
+	hash2.Write(header.SignatureHeader)
+	// hash of the part of the chaincode proposal payload that will go to the tx
+	hash2.Write(ppBytes)
+	return hash2.Sum(nil), nil
+}
diff --git a/protoutil/txutils_test.go b/protoutil/txutils_test.go
new file mode 100644
index 00000000..7ac81a12
--- /dev/null
+++ b/protoutil/txutils_test.go
@@ -0,0 +1,522 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"encoding/hex"
+	"errors"
+	"strconv"
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	mockmsp "github.com/hyperledger/fabric/common/mocks/msp"
+	"github.com/hyperledger/fabric/common/util"
+	cb "github.com/hyperledger/fabric/protos/common"
+	pb "github.com/hyperledger/fabric/protos/peer"
+	"github.com/hyperledger/fabric/protos/utils"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestGetPayloads(t *testing.T) {
+	var txAction *pb.TransactionAction
+	var err error
+
+	// good
+	ccActionBytes, _ := proto.Marshal(&pb.ChaincodeAction{
+		Results: []byte("results"),
+	})
+	proposalResponsePayload := &pb.ProposalResponsePayload{
+		Extension: ccActionBytes,
+	}
+	proposalResponseBytes, err := proto.Marshal(proposalResponsePayload)
+	ccActionPayload := &pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: proposalResponseBytes,
+		},
+	}
+	ccActionPayloadBytes, _ := proto.Marshal(ccActionPayload)
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.NoError(t, err, "Unexpected error getting payload bytes")
+	t.Logf("error1 [%s]", err)
+
+	// nil proposal response extension
+	proposalResponseBytes, err = proto.Marshal(&pb.ProposalResponsePayload{
+		Extension: nil,
+	})
+	ccActionPayloadBytes, _ = proto.Marshal(&pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: proposalResponseBytes,
+		},
+	})
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with nil proposal response extension")
+	t.Logf("error2 [%s]", err)
+
+	// malformed proposal response payload
+	ccActionPayloadBytes, _ = proto.Marshal(&pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: []byte("bad payload"),
+		},
+	})
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with malformed proposal response payload")
+	t.Logf("error3 [%s]", err)
+
+	// malformed proposal response payload extension
+	proposalResponseBytes, _ = proto.Marshal(&pb.ProposalResponsePayload{
+		Extension: []byte("bad extension"),
+	})
+	ccActionPayloadBytes, _ = proto.Marshal(&pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: proposalResponseBytes,
+		},
+	})
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with malformed proposal response extension")
+	t.Logf("error4 [%s]", err)
+
+	// nil proposal response payload extension
+	proposalResponseBytes, _ = proto.Marshal(&pb.ProposalResponsePayload{
+		ProposalHash: []byte("hash"),
+	})
+	ccActionPayloadBytes, _ = proto.Marshal(&pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: proposalResponseBytes,
+		},
+	})
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with nil proposal response extension")
+	t.Logf("error5 [%s]", err)
+
+	// malformed transaction action payload
+	txAction = &pb.TransactionAction{
+		Payload: []byte("bad payload"),
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with malformed transaction action payload")
+	t.Logf("error6 [%s]", err)
+
+}
+
+func TestCreateSignedTx(t *testing.T) {
+	var err error
+	prop := &pb.Proposal{}
+
+	signID, err := mockmsp.NewNoopMsp().GetDefaultSigningIdentity()
+	assert.NoError(t, err, "Unexpected error getting signing identity")
+	signerBytes, err := signID.Serialize()
+	assert.NoError(t, err, "Unexpected error serializing signing identity")
+
+	ccHeaderExtensionBytes, _ := proto.Marshal(&pb.ChaincodeHeaderExtension{})
+	chdrBytes, _ := proto.Marshal(&cb.ChannelHeader{
+		Extension: ccHeaderExtensionBytes,
+	})
+	shdrBytes, _ := proto.Marshal(&cb.SignatureHeader{
+		Creator: signerBytes,
+	})
+	responses := []*pb.ProposalResponse{{}}
+
+	// malformed chaincode header extension
+	headerBytes, _ := proto.Marshal(&cb.Header{
+		ChannelHeader:   []byte("bad channel header"),
+		SignatureHeader: shdrBytes,
+	})
+	prop.Header = headerBytes
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with malformed chaincode extension")
+
+	// malformed signature header
+	headerBytes, _ = proto.Marshal(&cb.Header{
+		SignatureHeader: []byte("bad signature header"),
+	})
+	prop.Header = headerBytes
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with malformed signature header")
+
+	// set up the header bytes for the remaining tests
+	headerBytes, _ = proto.Marshal(&cb.Header{
+		ChannelHeader:   chdrBytes,
+		SignatureHeader: shdrBytes,
+	})
+	prop.Header = headerBytes
+
+	// non-matching responses
+	responses = []*pb.ProposalResponse{{
+		Payload: []byte("payload"),
+		Response: &pb.Response{
+			Status: int32(200),
+		},
+	}}
+	responses = append(responses, &pb.ProposalResponse{
+		Payload: []byte("payload2"),
+		Response: &pb.Response{
+			Status: int32(200),
+		},
+	})
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with non-matching responses")
+
+	// no endorsement
+	responses = []*pb.ProposalResponse{{
+		Payload: []byte("payload"),
+		Response: &pb.Response{
+			Status: int32(200),
+		},
+	}}
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with no endorsements")
+
+	// success
+	responses = []*pb.ProposalResponse{{
+		Payload:     []byte("payload"),
+		Endorsement: &pb.Endorsement{},
+		Response: &pb.Response{
+			Status: int32(200),
+		},
+	}}
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.NoError(t, err, "Unexpected error creating signed transaction")
+	t.Logf("error: [%s]", err)
+
+	//
+	//
+	// additional failure cases
+	prop = &pb.Proposal{}
+	responses = []*pb.ProposalResponse{}
+	// no proposal responses
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with no proposal responses")
+
+	// missing proposal header
+	responses = append(responses, &pb.ProposalResponse{})
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with no proposal header")
+
+	// bad proposal payload
+	prop.Payload = []byte("bad payload")
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with malformed proposal payload")
+
+	// bad payload header
+	prop.Header = []byte("bad header")
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+
+}
+
+func TestCreateSignedTxStatus(t *testing.T) {
+	serializedExtension, err := proto.Marshal(&pb.ChaincodeHeaderExtension{})
+	assert.NoError(t, err)
+	serializedChannelHeader, err := proto.Marshal(&cb.ChannelHeader{
+		Extension: serializedExtension,
+	})
+	assert.NoError(t, err)
+
+	signingID, err := mockmsp.NewNoopMsp().GetDefaultSigningIdentity()
+	assert.NoError(t, err)
+	serializedSigningID, err := signingID.Serialize()
+	assert.NoError(t, err)
+	serializedSignatureHeader, err := proto.Marshal(&cb.SignatureHeader{
+		Creator: serializedSigningID,
+	})
+	assert.NoError(t, err)
+
+	header := &cb.Header{
+		ChannelHeader:   serializedChannelHeader,
+		SignatureHeader: serializedSignatureHeader,
+	}
+
+	serializedHeader, err := proto.Marshal(header)
+	assert.NoError(t, err)
+
+	proposal := &pb.Proposal{
+		Header: serializedHeader,
+	}
+
+	tests := []struct {
+		status      int32
+		expectedErr string
+	}{
+		{status: 0, expectedErr: "proposal response was not successful, error code 0, msg response-message"},
+		{status: 199, expectedErr: "proposal response was not successful, error code 199, msg response-message"},
+		{status: 200, expectedErr: ""},
+		{status: 201, expectedErr: ""},
+		{status: 399, expectedErr: ""},
+		{status: 400, expectedErr: "proposal response was not successful, error code 400, msg response-message"},
+	}
+	for _, tc := range tests {
+		t.Run(strconv.Itoa(int(tc.status)), func(t *testing.T) {
+			response := &pb.ProposalResponse{
+				Payload:     []byte("payload"),
+				Endorsement: &pb.Endorsement{},
+				Response: &pb.Response{
+					Status:  tc.status,
+					Message: "response-message",
+				},
+			}
+
+			_, err := utils.CreateSignedTx(proposal, signingID, response)
+			if tc.expectedErr == "" {
+				assert.NoError(t, err)
+			} else {
+				assert.EqualError(t, err, tc.expectedErr)
+			}
+		})
+	}
+}
+
+func TestCreateSignedEnvelope(t *testing.T) {
+	var env *cb.Envelope
+	channelID := "mychannelID"
+	msg := &cb.ConfigEnvelope{}
+
+	env, err := utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID,
+		goodSigner, msg, int32(1), uint64(1))
+	assert.NoError(t, err, "Unexpected error creating signed envelope")
+	assert.NotNil(t, env, "Envelope should not be nil")
+	// mock sign returns the bytes to be signed
+	assert.Equal(t, env.Payload, env.Signature, "Unexpected signature returned")
+	payload := &cb.Payload{}
+	err = proto.Unmarshal(env.Payload, payload)
+	assert.NoError(t, err, "Failed to unmarshal payload")
+	data := &cb.ConfigEnvelope{}
+	err = proto.Unmarshal(payload.Data, data)
+	assert.NoError(t, err, "Expected payload data to be a config envelope")
+	assert.Equal(t, msg, data, "Payload data does not match expected value")
+
+	_, err = utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID,
+		badSigner, &cb.ConfigEnvelope{}, int32(1), uint64(1))
+	assert.Error(t, err, "Expected sign error")
+}
+
+func TestCreateSignedEnvelopeNilSigner(t *testing.T) {
+	var env *cb.Envelope
+	channelID := "mychannelID"
+	msg := &cb.ConfigEnvelope{}
+
+	env, err := utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID,
+		nil, msg, int32(1), uint64(1))
+	assert.NoError(t, err, "Unexpected error creating signed envelope")
+	assert.NotNil(t, env, "Envelope should not be nil")
+	assert.Empty(t, env.Signature, "Signature should have been empty")
+	payload := &cb.Payload{}
+	err = proto.Unmarshal(env.Payload, payload)
+	assert.NoError(t, err, "Failed to unmarshal payload")
+	data := &cb.ConfigEnvelope{}
+	err = proto.Unmarshal(payload.Data, data)
+	assert.NoError(t, err, "Expected payload data to be a config envelope")
+	assert.Equal(t, msg, data, "Payload data does not match expected value")
+}
+
+func TestGetSignedProposal(t *testing.T) {
+	var signedProp *pb.SignedProposal
+	var err error
+
+	signID, err := mockmsp.NewNoopMsp().GetDefaultSigningIdentity()
+	assert.NoError(t, err, "Unexpected error getting signing identity")
+
+	prop := &pb.Proposal{}
+	propBytes, _ := proto.Marshal(prop)
+	signedProp, err = utils.GetSignedProposal(prop, signID)
+	assert.NoError(t, err, "Unexpected error getting signed proposal")
+	assert.Equal(t, propBytes, signedProp.ProposalBytes,
+		"Proposal bytes did not match expected value")
+	assert.Equal(t, []byte("signature"), signedProp.Signature,
+		"Signature did not match expected value")
+
+	_, err = utils.GetSignedProposal(nil, signID)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, err = utils.GetSignedProposal(prop, nil)
+	assert.Error(t, err, "Expected error with nil signing identity")
+
+}
+
+func TestMockSignedEndorserProposalOrPanic(t *testing.T) {
+	var prop *pb.Proposal
+	var signedProp *pb.SignedProposal
+
+	ccProposal := &pb.ChaincodeProposalPayload{}
+	cis := &pb.ChaincodeInvocationSpec{}
+	chainID := "testchainid"
+	sig := []byte("signature")
+	creator := []byte("creator")
+	cs := &pb.ChaincodeSpec{
+		ChaincodeId: &pb.ChaincodeID{
+			Name: "mychaincode",
+		},
+	}
+
+	signedProp, prop = utils.MockSignedEndorserProposalOrPanic(chainID, cs,
+		creator, sig)
+	assert.Equal(t, sig, signedProp.Signature,
+		"Signature did not match expected result")
+	propBytes, _ := proto.Marshal(prop)
+	assert.Equal(t, propBytes, signedProp.ProposalBytes,
+		"Proposal bytes do not match expected value")
+	err := proto.Unmarshal(prop.Payload, ccProposal)
+	assert.NoError(t, err, "Expected ChaincodeProposalPayload")
+	err = proto.Unmarshal(ccProposal.Input, cis)
+	assert.NoError(t, err, "Expected ChaincodeInvocationSpec")
+	assert.Equal(t, cs.ChaincodeId.Name, cis.ChaincodeSpec.ChaincodeId.Name,
+		"Chaincode name did not match expected value")
+}
+
+func TestMockSignedEndorserProposal2OrPanic(t *testing.T) {
+	var prop *pb.Proposal
+	var signedProp *pb.SignedProposal
+
+	ccProposal := &pb.ChaincodeProposalPayload{}
+	cis := &pb.ChaincodeInvocationSpec{}
+	chainID := "testchainid"
+	sig := []byte("signature")
+	signID, err := mockmsp.NewNoopMsp().GetDefaultSigningIdentity()
+	assert.NoError(t, err, "Unexpected error getting signing identity")
+
+	signedProp, prop = utils.MockSignedEndorserProposal2OrPanic(chainID,
+		&pb.ChaincodeSpec{}, signID)
+	assert.Equal(t, sig, signedProp.Signature,
+		"Signature did not match expected result")
+	propBytes, _ := proto.Marshal(prop)
+	assert.Equal(t, propBytes, signedProp.ProposalBytes,
+		"Proposal bytes do not match expected value")
+	err = proto.Unmarshal(prop.Payload, ccProposal)
+	assert.NoError(t, err, "Expected ChaincodeProposalPayload")
+	err = proto.Unmarshal(ccProposal.Input, cis)
+	assert.NoError(t, err, "Expected ChaincodeInvocationSpec")
+}
+
+func TestGetBytesProposalPayloadForTx(t *testing.T) {
+	input := &pb.ChaincodeProposalPayload{
+		Input:        []byte("input"),
+		TransientMap: make(map[string][]byte),
+	}
+	expected, _ := proto.Marshal(&pb.ChaincodeProposalPayload{
+		Input: []byte("input"),
+	})
+
+	result, err := utils.GetBytesProposalPayloadForTx(input, []byte{})
+	assert.NoError(t, err, "Unexpected error getting proposal payload")
+	assert.Equal(t, expected, result, "Payload does not match expected value")
+
+	_, err = utils.GetBytesProposalPayloadForTx(nil, []byte{})
+	assert.Error(t, err, "Expected error with nil proposal payload")
+}
+
+func TestGetProposalHash2(t *testing.T) {
+	expectedHashHex := "7b622ef4e1ab9b7093ec3bbfbca17d5d6f14a437914a6839319978a7034f7960"
+	expectedHash, _ := hex.DecodeString(expectedHashHex)
+	hdr := &cb.Header{
+		ChannelHeader:   []byte("chdr"),
+		SignatureHeader: []byte("shdr"),
+	}
+	propHash, err := utils.GetProposalHash2(hdr, []byte("ccproppayload"))
+	assert.NoError(t, err, "Unexpected error getting hash2 for proposal")
+	t.Logf("%x", propHash)
+	assert.Equal(t, expectedHash, propHash,
+		"Proposal hash did not match expected hash")
+
+	propHash, err = utils.GetProposalHash2(&cb.Header{},
+		[]byte("ccproppayload"))
+	assert.Error(t, err, "Expected error with nil arguments")
+}
+
+func TestGetProposalHash1(t *testing.T) {
+	expectedHashHex := "d4c1e3cac2105da5fddc2cfe776d6ec28e4598cf1e6fa51122c7f70d8076437b"
+	expectedHash, _ := hex.DecodeString(expectedHashHex)
+	hdr := &cb.Header{
+		ChannelHeader:   []byte("chdr"),
+		SignatureHeader: []byte("shdr"),
+	}
+
+	ccProposal, _ := proto.Marshal(&pb.ChaincodeProposalPayload{})
+
+	propHash, err := utils.GetProposalHash1(hdr, ccProposal, []byte{})
+	assert.NoError(t, err, "Unexpected error getting hash for proposal")
+	t.Logf("%x", propHash)
+	assert.Equal(t, expectedHash, propHash,
+		"Proposal hash did not match expected hash")
+
+	propHash, err = utils.GetProposalHash1(hdr,
+		[]byte("ccproppayload"), []byte{})
+	assert.Error(t, err,
+		"Expected error with malformed chaincode proposal payload")
+
+	propHash, err = utils.GetProposalHash1(&cb.Header{},
+		[]byte("ccproppayload"), []byte{})
+	assert.Error(t, err, "Expected error with nil arguments")
+}
+
+func TestCreateProposalResponseFailure(t *testing.T) {
+	// create a proposal from a ChaincodeInvocationSpec
+	prop, _, err := utils.CreateChaincodeProposal(cb.HeaderType_ENDORSER_TRANSACTION, util.GetTestChainID(), createCIS(), signerSerialized)
+	if err != nil {
+		t.Fatalf("Could not create chaincode proposal, err %s\n", err)
+		return
+	}
+
+	response := &pb.Response{Status: 502, Payload: []byte("Invalid function name")}
+	result := []byte("res")
+	ccid := &pb.ChaincodeID{Name: "foo", Version: "v1"}
+
+	prespFailure, err := utils.CreateProposalResponseFailure(prop.Header, prop.Payload, response, result, nil, ccid, nil)
+	if err != nil {
+		t.Fatalf("Could not create proposal response failure, err %s\n", err)
+		return
+	}
+
+	assert.Equal(t, int32(502), prespFailure.Response.Status)
+	// drilldown into the response to find the chaincode response
+	pRespPayload, err := utils.GetProposalResponsePayload(prespFailure.Payload)
+	assert.NoError(t, err, "Error while unmarshaling proposal response payload: %s", err)
+	ca, err := utils.GetChaincodeAction(pRespPayload.Extension)
+	assert.NoError(t, err, "Error while unmarshaling chaincode action: %s", err)
+
+	assert.Equal(t, int32(502), ca.Response.Status)
+	assert.Equal(t, "Invalid function name", string(ca.Response.Payload))
+}
+
+// mock
+var badSigner = &mockLocalSigner{
+	returnError: true,
+}
+
+var goodSigner = &mockLocalSigner{
+	returnError: false,
+}
+
+type mockLocalSigner struct {
+	returnError bool
+}
+
+func (m *mockLocalSigner) NewSignatureHeader() (*cb.SignatureHeader, error) {
+	if m.returnError {
+		return nil, errors.New("signature header error")
+	}
+	return &cb.SignatureHeader{}, nil
+}
+
+func (m *mockLocalSigner) Sign(message []byte) ([]byte, error) {
+	if m.returnError {
+		return nil, errors.New("sign error")
+	}
+	return message, nil
+}
diff --git a/unit-test/run.sh b/unit-test/run.sh
index 110de506..b3a9d827 100755
--- a/unit-test/run.sh
+++ b/unit-test/run.sh
@@ -10,6 +10,7 @@ set -e
 # regexes for packages to exclude from unit test
 excluded_packages=(
     "/integration(/|$)"
+    "github.com/hyperledger/fabric/extensions(/|$)"
 )
 
 # regexes for packages that must be run serially
-- 
2.15.0

