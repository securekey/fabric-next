diff a/core/ledger/kvledger/txmgmt/pvtstatepurgemgmt/purge_mgr.go b/core/ledger/kvledger/txmgmt/pvtstatepurgemgmt/purge_mgr.go	(rejected hunks)
@@ -17,7 +19,7 @@ import (
 	"github.com/hyperledger/fabric/core/ledger/pvtdatapolicy"
 )
 
-// PurgeMgr manages purging of the expired pvtdata
+// PurgeMgr manages purging of the expired pvtdata and removes non-durable key, value pairs
 type PurgeMgr interface {
 	// PrepareForExpiringKeys gives a chance to the PurgeMgr to do background work in advance if any
 	PrepareForExpiringKeys(expiringAtBlk uint64)
@@ -27,6 +29,11 @@ type PurgeMgr interface {
 	DeleteExpiredAndUpdateBookkeeping(
 		pvtUpdates *privacyenabledstate.PvtUpdateBatch,
 		hashedUpdates *privacyenabledstate.HashedUpdateBatch) error
+	// RemoveNonDurable updates the bookkeeping and modifies the update batch by removing non-durable items
+	RemoveNonDurable(
+		pvtUpdateBatch *privacyenabledstate.PvtUpdateBatch,
+		hashedUpdateBatch *privacyenabledstate.HashedUpdateBatch) error
+
 	// BlockCommitDone is a callback to the PurgeMgr when the block is committed to the ledger
 	BlockCommitDone() error
 }
@@ -86,6 +93,49 @@ func (p *purgeMgr) WaitForPrepareToFinish() {
 	p.lock.Unlock()
 }
 
+// RemoveNonDurable implements function in the interface 'PurgeMgr'
+func (p *purgeMgr) RemoveNonDurable(
+	pvtUpdates *privacyenabledstate.PvtUpdateBatch,
+	hashedUpdates *privacyenabledstate.HashedUpdateBatch) error {
+
+	p.lock.Lock()
+	defer p.lock.Unlock()
+	if p.workingset.err != nil {
+		return p.workingset.err
+	}
+
+	blocksToLiveInCache := ledgerconfig.GetKVCacheBlocksToLive()
+	for ns, nsBatch := range pvtUpdates.UpdateMap {
+		for _, coll := range nsBatch.GetCollectionNames() {
+			btl, err := p.btlPolicy.GetBTL(ns, coll)
+			if err != nil {
+				return err
+			}
+			if btl != 0 && btl < blocksToLiveInCache {
+				logger.Debugf("Collection policy[%s] blocks to live[%d] is less than blocks to live in cache[%d] - no need to store collection entries for data",
+					coll, btl, blocksToLiveInCache)
+				nsBatch.RemoveUpdates(coll)
+			}
+		}
+	}
+
+	for ns, nsBatch := range hashedUpdates.UpdateMap {
+		for _, coll := range nsBatch.GetCollectionNames() {
+			btl, err := p.btlPolicy.GetBTL(ns, coll)
+			if err != nil {
+				return err
+			}
+			if btl != 0 && btl < blocksToLiveInCache {
+				logger.Debugf("Collection policy[%s] blocks to live[%d] is less than blocks to live in cache[%d] - no need to store collection entries for hashes",
+					coll, btl, blocksToLiveInCache)
+				nsBatch.RemoveUpdates(coll)
+			}
+		}
+	}
+
+	return nil
+}
+
 // DeleteExpiredAndUpdateBookkeeping implements function in the interface 'PurgeMgr'
 func (p *purgeMgr) DeleteExpiredAndUpdateBookkeeping(
 	pvtUpdates *privacyenabledstate.PvtUpdateBatch,
