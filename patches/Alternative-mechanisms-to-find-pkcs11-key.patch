From afbc42f5b768797947d02f8ec2f6e88b0d490da5 Mon Sep 17 00:00:00 2001
From: Luc Desrosiers <ldesrosi@uk.ibm.com>
Date: Sat, 29 Feb 2020 17:52:55 +0000
Subject: [PATCH] [FAB-16951] Alternative mechanisms to find pkcs11 key

This modification adds a parameter called AltID to the PKCS11 BCCSP module.
When this parameter is set, the generateECKey and findKeyPairFromSKI functions
will use this alternative ID as the CKA_ID and CKA_LABEL to store and use the
associated private key.
This code change is required in situations where the HSM does not allow
modification of the CKA_ID after creation.
This code change includes corresponding unit-test and has been tested against
both AWS CloudHSM and the SoftHSM.

Signed-off-by: Luc Desrosiers <ldesrosi@uk.ibm.com>
---
 bccsp/pkcs11/conf.go        |   1 +
 bccsp/pkcs11/impl.go        |   4 +-
 bccsp/pkcs11/impl_test.go   |  66 +++++++++++++++++---
 bccsp/pkcs11/pkcs11.go      | 118 +++++++++++++++++++++---------------
 bccsp/pkcs11/pkcs11_test.go |  61 +++++++++++++++++++
 5 files changed, 193 insertions(+), 57 deletions(-)

diff --git a/bccsp/pkcs11/conf.go b/bccsp/pkcs11/conf.go
index ba7fed12ac..cb176051e8 100644
--- a/bccsp/pkcs11/conf.go
+++ b/bccsp/pkcs11/conf.go
@@ -88,6 +88,7 @@ type PKCS11Opts struct {
 	Pin        string `mapstructure:"pin" json:"pin"`
 	SoftVerify bool   `mapstructure:"softwareverify,omitempty" json:"softwareverify,omitempty"`
 	Immutable  bool   `mapstructure:"immutable,omitempty" json:"immutable,omitempty"`
+	AltId      string `mapstructure:"altid" json:"altid"`
 }
 
 // FileKeystoreOpts currently only ECDSA operations go to PKCS11, need a keystore still
diff --git a/bccsp/pkcs11/impl.go b/bccsp/pkcs11/impl.go
index 11f8e54c96..9c2e34ec9f 100644
--- a/bccsp/pkcs11/impl.go
+++ b/bccsp/pkcs11/impl.go
@@ -54,7 +54,7 @@ func New(opts PKCS11Opts, keyStore bccsp.KeyStore) (bccsp.BCCSP, error) {
 	}
 
 	sessions := make(chan pkcs11.SessionHandle, sessionCacheSize)
-	csp := &impl{swCSP, conf, keyStore, ctx, sessions, slot, lib, opts.SoftVerify, opts.Immutable}
+	csp := &impl{swCSP, conf, keyStore, ctx, sessions, slot, lib, opts.SoftVerify, opts.Immutable, opts.AltId}
 	csp.returnSession(*session)
 	return csp, nil
 }
@@ -73,6 +73,8 @@ type impl struct {
 	softVerify bool
 	//Immutable flag makes object immutable
 	immutable bool
+	// Alternate identifier of the private key
+	altId string
 }
 
 // KeyGen generates a key using opts.
diff --git a/bccsp/pkcs11/impl_test.go b/bccsp/pkcs11/impl_test.go
index a285e366b1..da0358e074 100644
--- a/bccsp/pkcs11/impl_test.go
+++ b/bccsp/pkcs11/impl_test.go
@@ -47,6 +47,7 @@ type testConfig struct {
 	hashFamily    string
 	softVerify    bool
 	immutable     bool
+	altId         string
 }
 
 func TestMain(m *testing.M) {
@@ -70,17 +71,18 @@ func testMain(m *testing.M) int {
 
 	lib, pin, label := FindPKCS11Lib()
 	tests := []testConfig{
-		{256, "SHA2", true, false},
-		{256, "SHA3", false, false},
-		{384, "SHA2", false, false},
-		{384, "SHA3", false, false},
-		{384, "SHA3", true, false},
+		{256, "SHA2", true, false, ""},
+		{256, "SHA3", false, false, ""},
+		{384, "SHA2", false, false, ""},
+		{384, "SHA3", false, false, ""},
+		{384, "SHA3", true, false, ""},
 	}
 
 	if strings.Contains(lib, "softhsm") {
 		tests = append(tests, []testConfig{
-			{256, "SHA2", true, false},
-			{256, "SHA2", true, true},
+			{256, "SHA2", true, false, ""},
+			{256, "SHA2", true, true, ""},
+			{256, "SHA2", true, true, "AnAltId"},
 		}...)
 	}
 
@@ -97,6 +99,7 @@ func testMain(m *testing.M) int {
 		opts.SecLevel = config.securityLevel
 		opts.SoftVerify = config.softVerify
 		opts.Immutable = config.immutable
+		opts.AltId = config.altId
 		fmt.Printf("Immutable = [%v]\n", opts.Immutable)
 		currentBCCSP, err = New(opts, keyStore)
 		if err != nil {
@@ -218,6 +221,10 @@ func TestInvalidNewParameter(t *testing.T) {
 }
 
 func TestInvalidSKI(t *testing.T) {
+	if currentTestConfig.altId != "" {
+		t.Skip("Skipping TestInvalidSKI since AltId is set for this test run.")
+	}
+
 	k, err := currentBCCSP.GetKey(nil)
 	if err == nil {
 		t.Fatal("Error should be different from nil in this case")
@@ -235,6 +242,51 @@ func TestInvalidSKI(t *testing.T) {
 	}
 }
 
+func TestInvalidAltId(t *testing.T) {
+	if currentTestConfig.altId == "" {
+		t.Skip("Skipping TestInvalidAltId since AltId not set for this test run.")
+	}
+
+	opts := PKCS11Opts{
+		HashFamily: currentTestConfig.hashFamily,
+		SecLevel:   currentTestConfig.securityLevel,
+		SoftVerify: currentTestConfig.softVerify,
+		Immutable:  currentTestConfig.immutable,
+		AltId:      "ADifferentAltId",
+		Library:    "lib",
+		Label:      "ForFabric",
+		Pin:        "98765432",
+	}
+
+	// Setup PKCS11 library and provide initial set of values
+	lib, _, _ := FindPKCS11Lib()
+	opts.Library = lib
+
+	// Generate a KeyPair associated to the initial label
+	k, err := currentBCCSP.KeyGen(&bccsp.ECDSAP256KeyGenOpts{Temporary: false})
+	if err != nil {
+		t.Fatalf("Failed generating ECDSA P256 key [%s]", err)
+	}
+	if k == nil {
+		t.Fatal("Failed generating ECDSA P256 key. Key must be different from nil")
+	}
+
+	// Create temporary BCCSP set with an initial label
+	testBCCSP, err := New(opts, currentKS)
+	if err != nil {
+		t.Fatalf("Failed initiliazing Test BCCSP at [%+v] \n%s\n", opts, err)
+	}
+
+	// Now, try to retrieve the key using a different label
+	k, err = testBCCSP.GetKey([]byte{0, 1, 2, 3, 4, 5, 6})
+	if err == nil {
+		t.Fatal("Error should be different from nil in this case")
+	}
+	if k != nil {
+		t.Fatal("Return value should be equal to nil in this case")
+	}
+}
+
 func TestKeyGenECDSAOpts(t *testing.T) {
 	if testing.Short() {
 		t.Skip("Skipping TestKeyGenECDSAOpts")
diff --git a/bccsp/pkcs11/pkcs11.go b/bccsp/pkcs11/pkcs11.go
index 657f1f96ba..07ea1f0d7c 100644
--- a/bccsp/pkcs11/pkcs11.go
+++ b/bccsp/pkcs11/pkcs11.go
@@ -124,13 +124,13 @@ func (csp *impl) getECKey(ski []byte) (pubKey *ecdsa.PublicKey, isPriv bool, err
 	session := csp.getSession()
 	defer csp.returnSession(session)
 	isPriv = true
-	_, err = findKeyPairFromSKI(p11lib, session, ski, privateKeyFlag)
+	_, err = findKeyPairFromSKI(p11lib, session, ski, csp.altId, privateKeyFlag)
 	if err != nil {
 		isPriv = false
 		logger.Debugf("Private key not found [%s] for SKI [%s], looking for Public key", err, hex.EncodeToString(ski))
 	}
 
-	publicKey, err := findKeyPairFromSKI(p11lib, session, ski, publicKeyFlag)
+	publicKey, err := findKeyPairFromSKI(p11lib, session, ski, csp.altId, publicKeyFlag)
 	if err != nil {
 		return nil, false, fmt.Errorf("Public key not found [%s] for SKI [%s]", err, hex.EncodeToString(ski))
 	}
@@ -215,9 +215,22 @@ func (csp *impl) generateECKey(curve asn1.ObjectIdentifier, ephemeral bool) (ski
 	session := csp.getSession()
 	defer csp.returnSession(session)
 
-	id := nextIDCtr()
-	publabel := fmt.Sprintf("BCPUB%s", id.Text(16))
-	prvlabel := fmt.Sprintf("BCPRV%s", id.Text(16))
+	keylabel := ""
+	updateSKI := false
+	if csp.altId == "" {
+		// Generate using the SKI process and then make keypair immutable according to csp.immutable
+		keylabel = fmt.Sprintf("BCP%s", nextIDCtr().Text(16))
+		updateSKI = true
+	} else if csp.altId != "" && csp.immutable {
+		// Generate the key pair using AltID process.
+		// No need to worry about immutable since AltID is used with Write-Once HSMs
+		keylabel = csp.altId
+		updateSKI = false
+	} else if csp.altId != "" && !csp.immutable {
+		// Raise an error since AltID is used with Write-Once HSMs
+		// So cannot make support AltID with immutable = false.
+		return nil, nil, fmt.Errorf("Cannot generate a mutable key using AltID.")
+	}
 
 	marshaledOID, err := asn1.Marshal(curve)
 	if err != nil {
@@ -230,10 +243,9 @@ func (csp *impl) generateECKey(curve asn1.ObjectIdentifier, ephemeral bool) (ski
 		pkcs11.NewAttribute(pkcs11.CKA_TOKEN, !ephemeral),
 		pkcs11.NewAttribute(pkcs11.CKA_VERIFY, true),
 		pkcs11.NewAttribute(pkcs11.CKA_EC_PARAMS, marshaledOID),
-		pkcs11.NewAttribute(pkcs11.CKA_PRIVATE, false),
 
-		pkcs11.NewAttribute(pkcs11.CKA_ID, publabel),
-		pkcs11.NewAttribute(pkcs11.CKA_LABEL, publabel),
+		pkcs11.NewAttribute(pkcs11.CKA_ID, []byte(keylabel)),
+		pkcs11.NewAttribute(pkcs11.CKA_LABEL, keylabel),
 	}
 
 	prvkeyT := []*pkcs11.Attribute{
@@ -243,8 +255,8 @@ func (csp *impl) generateECKey(curve asn1.ObjectIdentifier, ephemeral bool) (ski
 		pkcs11.NewAttribute(pkcs11.CKA_PRIVATE, true),
 		pkcs11.NewAttribute(pkcs11.CKA_SIGN, true),
 
-		pkcs11.NewAttribute(pkcs11.CKA_ID, prvlabel),
-		pkcs11.NewAttribute(pkcs11.CKA_LABEL, prvlabel),
+		pkcs11.NewAttribute(pkcs11.CKA_ID, []byte(keylabel)),
+		pkcs11.NewAttribute(pkcs11.CKA_LABEL, keylabel),
 
 		pkcs11.NewAttribute(pkcs11.CKA_EXTRACTABLE, false),
 		pkcs11.NewAttribute(pkcs11.CKA_SENSITIVE, true),
@@ -265,46 +277,48 @@ func (csp *impl) generateECKey(curve asn1.ObjectIdentifier, ephemeral bool) (ski
 	hash := sha256.Sum256(ecpt)
 	ski = hash[:]
 
-	// set CKA_ID of the both keys to SKI(public key) and CKA_LABEL to hex string of SKI
-	setskiT := []*pkcs11.Attribute{
-		pkcs11.NewAttribute(pkcs11.CKA_ID, ski),
-		pkcs11.NewAttribute(pkcs11.CKA_LABEL, hex.EncodeToString(ski)),
-	}
-
-	logger.Infof("Generated new P11 key, SKI %x\n", ski)
-	err = p11lib.SetAttributeValue(session, pub, setskiT)
-	if err != nil {
-		return nil, nil, fmt.Errorf("P11: set-ID-to-SKI[public] failed [%s]", err)
-	}
-
-	err = p11lib.SetAttributeValue(session, prv, setskiT)
-	if err != nil {
-		return nil, nil, fmt.Errorf("P11: set-ID-to-SKI[private] failed [%s]", err)
-	}
-
-	//Set CKA_Modifible to false for both public key and private keys
-	if csp.immutable {
-		setCKAModifiable := []*pkcs11.Attribute{
-			pkcs11.NewAttribute(pkcs11.CKA_MODIFIABLE, false),
+	if updateSKI {
+		// set CKA_ID of the both keys to SKI(public key) and CKA_LABEL to hex string of SKI
+		setskiT := []*pkcs11.Attribute{
+			pkcs11.NewAttribute(pkcs11.CKA_ID, ski),
+			pkcs11.NewAttribute(pkcs11.CKA_LABEL, hex.EncodeToString(ski)),
 		}
 
-		_, pubCopyerror := p11lib.CopyObject(session, pub, setCKAModifiable)
-		if pubCopyerror != nil {
-			return nil, nil, fmt.Errorf("P11: Public Key copy failed with error [%s] . Please contact your HSM vendor", pubCopyerror)
+		logger.Infof("Generated new P11 key, SKI %x\n", ski)
+		err = p11lib.SetAttributeValue(session, pub, setskiT)
+		if err != nil {
+			return nil, nil, fmt.Errorf("P11: set-ID-to-SKI[public] failed [%s]", err)
 		}
 
-		pubKeyDestroyError := p11lib.DestroyObject(session, pub)
-		if pubKeyDestroyError != nil {
-			return nil, nil, fmt.Errorf("P11: Public Key destroy failed with error [%s]. Please contact your HSM vendor", pubCopyerror)
+		err = p11lib.SetAttributeValue(session, prv, setskiT)
+		if err != nil {
+			return nil, nil, fmt.Errorf("P11: set-ID-to-SKI[private] failed [%s]", err)
 		}
 
-		_, prvCopyerror := p11lib.CopyObject(session, prv, setCKAModifiable)
-		if prvCopyerror != nil {
-			return nil, nil, fmt.Errorf("P11: Private Key copy failed with error [%s]. Please contact your HSM vendor", prvCopyerror)
-		}
-		prvKeyDestroyError := p11lib.DestroyObject(session, prv)
-		if pubKeyDestroyError != nil {
-			return nil, nil, fmt.Errorf("P11: Private Key destroy failed with error [%s]. Please contact your HSM vendor", prvKeyDestroyError)
+		//Set CKA_Modifible to false for both public key and private keys
+		if csp.immutable {
+			setCKAModifiable := []*pkcs11.Attribute{
+				pkcs11.NewAttribute(pkcs11.CKA_MODIFIABLE, false),
+			}
+
+			_, pubCopyerror := p11lib.CopyObject(session, pub, setCKAModifiable)
+			if pubCopyerror != nil {
+				return nil, nil, fmt.Errorf("P11: Public Key copy failed with error [%s] . Please contact your HSM vendor", pubCopyerror)
+			}
+
+			pubKeyDestroyError := p11lib.DestroyObject(session, pub)
+			if pubKeyDestroyError != nil {
+				return nil, nil, fmt.Errorf("P11: Public Key destroy failed with error [%s]. Please contact your HSM vendor", pubCopyerror)
+			}
+
+			_, prvCopyerror := p11lib.CopyObject(session, prv, setCKAModifiable)
+			if prvCopyerror != nil {
+				return nil, nil, fmt.Errorf("P11: Private Key copy failed with error [%s]. Please contact your HSM vendor", prvCopyerror)
+			}
+			prvKeyDestroyError := p11lib.DestroyObject(session, prv)
+			if pubKeyDestroyError != nil {
+				return nil, nil, fmt.Errorf("P11: Private Key destroy failed with error [%s]. Please contact your HSM vendor", prvKeyDestroyError)
+			}
 		}
 	}
 
@@ -332,7 +346,7 @@ func (csp *impl) signP11ECDSA(ski []byte, msg []byte) (R, S *big.Int, err error)
 	session := csp.getSession()
 	defer csp.returnSession(session)
 
-	privateKey, err := findKeyPairFromSKI(p11lib, session, ski, privateKeyFlag)
+	privateKey, err := findKeyPairFromSKI(p11lib, session, ski, csp.altId, privateKeyFlag)
 	if err != nil {
 		return nil, nil, fmt.Errorf("Private key not found [%s]", err)
 	}
@@ -364,7 +378,7 @@ func (csp *impl) verifyP11ECDSA(ski []byte, msg []byte, R, S *big.Int, byteSize
 
 	logger.Debugf("Verify ECDSA\n")
 
-	publicKey, err := findKeyPairFromSKI(p11lib, session, ski, publicKeyFlag)
+	publicKey, err := findKeyPairFromSKI(p11lib, session, ski, csp.altId, publicKeyFlag)
 	if err != nil {
 		return false, fmt.Errorf("Public key not found [%s]", err)
 	}
@@ -398,16 +412,22 @@ const (
 	publicKeyFlag  = false
 )
 
-func findKeyPairFromSKI(mod *pkcs11.Ctx, session pkcs11.SessionHandle, ski []byte, keyType bool) (*pkcs11.ObjectHandle, error) {
+func findKeyPairFromSKI(mod *pkcs11.Ctx, session pkcs11.SessionHandle, ski []byte, altID string, keyType bool) (*pkcs11.ObjectHandle, error) {
 	ktype := pkcs11.CKO_PUBLIC_KEY
 	if keyType == privateKeyFlag {
 		ktype = pkcs11.CKO_PRIVATE_KEY
 	}
 
+	keyId := []byte(altID)
+	if altID == "" {
+		keyId = ski
+	}
+
 	template := []*pkcs11.Attribute{
 		pkcs11.NewAttribute(pkcs11.CKA_CLASS, ktype),
-		pkcs11.NewAttribute(pkcs11.CKA_ID, ski),
+		pkcs11.NewAttribute(pkcs11.CKA_ID, keyId),
 	}
+
 	if err := mod.FindObjectsInit(session, template); err != nil {
 		return nil, err
 	}
@@ -541,7 +561,7 @@ func (csp *impl) getSecretValue(ski []byte) []byte {
 	session := csp.getSession()
 	defer csp.returnSession(session)
 
-	keyHandle, err := findKeyPairFromSKI(p11lib, session, ski, privateKeyFlag)
+	keyHandle, err := findKeyPairFromSKI(p11lib, session, ski, csp.altId, privateKeyFlag)
 	if err != nil {
 		logger.Warningf("P11: findKeyPairFromSKI [%s]\n", err)
 	}
diff --git a/bccsp/pkcs11/pkcs11_test.go b/bccsp/pkcs11/pkcs11_test.go
index 007829388f..7aabcf2daf 100644
--- a/bccsp/pkcs11/pkcs11_test.go
+++ b/bccsp/pkcs11/pkcs11_test.go
@@ -11,7 +11,9 @@ import (
 	"crypto/ecdsa"
 	"crypto/elliptic"
 	"encoding/asn1"
+	"strconv"
 	"testing"
+	"time"
 
 	"github.com/hyperledger/fabric/bccsp"
 	"github.com/miekg/pkcs11"
@@ -88,6 +90,65 @@ func TestOIDFromNamedCurve(t *testing.T) {
 	}
 }
 
+func TestAlternateLabelGeneration(t *testing.T) {
+	if currentTestConfig.altId == "" {
+		t.Skip("Skipping TestAlternateLabelGeneration since AltId is not set for this test run.")
+	}
+
+	// We generate a unique Alt ID for the test
+	uniqueAltId := strconv.FormatInt(time.Now().UnixNano()/1e6, 10)
+	fakeSKI := []byte("FakeSKI")
+
+	opts := PKCS11Opts{
+		HashFamily: currentTestConfig.hashFamily,
+		SecLevel:   currentTestConfig.securityLevel,
+		SoftVerify: currentTestConfig.softVerify,
+		Immutable:  currentTestConfig.immutable,
+		AltId:      uniqueAltId,
+		Library:    "lib",
+		Label:      "ForFabric",
+		Pin:        "98765432",
+	}
+
+	// Setup PKCS11 library and provide initial set of values
+	lib, _, _ := FindPKCS11Lib()
+	opts.Library = lib
+
+	// Create temporary BCCSP set with the  label
+	testBCCSP, err := New(opts, currentKS)
+
+	p11lib := testBCCSP.(*impl).ctx
+	session := testBCCSP.(*impl).getSession()
+	defer testBCCSP.(*impl).returnSession(session)
+
+	// Passing fake SKI to ensure that the look up fails if the uniqueAltId is not used
+	k, err := findKeyPairFromSKI(p11lib, session, fakeSKI, uniqueAltId, privateKeyFlag)
+	if err == nil {
+		t.Fatalf("Found a key when expected to find none.")
+	}
+
+	// Now generate a new EC Key, which should be using the uniqueAltId
+	var oid asn1.ObjectIdentifier
+	if currentTestConfig.securityLevel == 256 {
+		oid = oidNamedCurveP256
+	} else if currentTestConfig.securityLevel == 384 {
+		oid = oidNamedCurveP384
+	}
+
+	_, _, err = testBCCSP.(*impl).generateECKey(oid, true)
+	if err != nil {
+		t.Fatalf("Failed generating Key [%s]", err)
+	}
+
+	k, err = findKeyPairFromSKI(p11lib, session, fakeSKI, uniqueAltId, privateKeyFlag)
+	if err != nil {
+		t.Fatalf("Found no key after generating an EC Key based on the AltId.")
+	}
+	if k == nil {
+		t.Fatalf("No Key returned from the findKeyPairFromSKI call.")
+	}
+}
+
 func TestNamedCurveFromOID(t *testing.T) {
 	if testing.Short() {
 		t.Skip("Skipping TestNamedCurveFromOID")
