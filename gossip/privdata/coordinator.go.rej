--- gossip/privdata/coordinator.go
+++ gossip/privdata/coordinator.go
@@ -22,7 +24,9 @@ import (
 	"github.com/hyperledger/fabric/core/common/privdata"
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil"
+	ledgerUtil "github.com/hyperledger/fabric/core/ledger/util"
 	"github.com/hyperledger/fabric/core/transientstore"
+	"github.com/hyperledger/fabric/gossip/privdata/collpolicy"
 	"github.com/hyperledger/fabric/gossip/util"
 	"github.com/hyperledger/fabric/protos/common"
 	gossip2 "github.com/hyperledger/fabric/protos/gossip"
@@ -186,22 +203,54 @@ func (c *coordinator) ValidateBlock(block *common.Block, privateDataSets util.Pv
 		return nil, nil, errors.New("Block header is nil")
 	}
 
+	stopWatch1 := metrics.StopWatch(fmt.Sprintf("validator_%s_phase1_duration", metrics.FilterMetricName(c.ChainID)))
+
 	// FIXME: Change to Debug
-	logger.Infof("[%s] Starting first phase validation of %d transactions in block %d against committed data...", c.ChainID, len(block.Data.Data), block.Header.Number)
+	logger.Infof("[%s] Validating block and private data for %d transactions in block %d ...", c.ChainID, len(block.Data.Data), block.Header.Number)
+
+	// Initialize the flags all to TxValidationCode_NOT_VALIDATED
+	utils.InitBlockMetadata(block)
+	block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER] = ledgerUtil.NewTxValidationFlags(len(block.Data.Data))
+
+	blockAndPvtData, privateInfo, err := c.validateBlockAndPvtData(block, privateDataSets)
+	if err != nil {
+		logger.Errorf("[%s] Got error validating block and private data in block %d: %s", c.ChainID, block.Header.Number, err)
+		return nil, nil, err
+	}
+	stopWatch1()
+
+	// FIXME: Change to Debug
+	logger.Infof("[%s] ... finished validating block and private data for %d transactions in block %d. Starting second phase validation ...", c.ChainID, len(block.Data.Data), block.Header.Number)
+
+	stopWatch2 := metrics.StopWatch(fmt.Sprintf("validator_%s_phase2_duration", metrics.FilterMetricName(c.ChainID)))
 
-	begin := time.Now()
+	// Prepare the block for second phase validation by setting all Valid transactions
+	// to NotValidated (since only the transactions that are not validated will be validated
+	// in the second phase)
+	blockFltr := ledgerUtil.TxValidationFlags(block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER])
+	for tIdx := range block.Data.Data {
+		if blockFltr.Flag(tIdx) == peer.TxValidationCode_VALID {
+			blockFltr.SetFlag(tIdx, peer.TxValidationCode_NOT_VALIDATED)
+		} else {
+			// FIXME: Change to Debug
+			logger.Infof("[%s] Not setting flag to 'NotValidated' for TxIdx[%d] in block %d since it has already been set to %s", c.ChainID, tIdx, block.Header.Number, blockFltr.Flag(tIdx))
+		}
+	}
 
-	err := c.Validator.Validate(block, resultsChan)
+	err = c.Validator.Validate(block, resultsChan)
 	if err != nil {
-		logger.Errorf("Validation failed: %+v", err)
+		logger.Errorf("[%s] Got error in second phase validation of block %d: %s", c.ChainID, block.Header.Number, err)
 		return nil, nil, err
 	}
+	stopWatch2()
 
 	// FIXME: Change to Debug
-	logger.Infof("[%s] ... finished first phase validation of %d transactions in block %d against committed data in %s. Starting second phase...", c.ChainID, len(block.Data.Data), block.Header.Number, time.Since(begin))
+	logger.Infof("[%s] ... finished second phase validation of %d transactions in block %d.", c.ChainID, len(block.Data.Data), block.Header.Number)
 
-	begin2 := time.Now()
+	return blockAndPvtData, privateInfo.txns, nil
+}
 
+func (c *coordinator) validateBlockAndPvtData(block *common.Block, privateDataSets util.PvtDataCollections) (*ledger.BlockAndPvtData, *privateDataInfo, error) {
 	blockAndPvtData := &ledger.BlockAndPvtData{
 		Block:        block,
 		BlockPvtData: make(map[uint64]*ledger.TxPvtData),
@@ -284,11 +333,8 @@ func (c *coordinator) ValidateBlock(block *common.Block, privateDataSets util.Pv
 	if err != nil {
 		return nil, nil, err
 	}
-	// FIXME: Change to Debug
-	logger.Infof("[%s] ... finished second phase validation of %d transactions in block %d in %s", c.ChainID, len(block.Data.Data), blockAndPvtData.Block.Header.Number, time.Since(begin2))
-	logger.Infof("[%s] Finished validating %d transactions in block %d in %s", c.ChainID, len(block.Data.Data), blockAndPvtData.Block.Header.Number, time.Since(begin))
 
-	return blockAndPvtData, privateInfo.txns, nil
+	return blockAndPvtData, privateInfo, nil
 }
 
 func (c *coordinator) ValidatePartialBlock(ctx context.Context, block *common.Block) {
@@ -665,72 +745,131 @@ func (k *rwSetKey) toTxPvtReadWriteSet(rws []byte) *rwset.TxPvtReadWriteSet {
 }
 
 type txns []string
-type blockData [][]byte
+
+type txnIterator struct {
+	consumer  blockConsumer
+	evaluate  func(data [][]byte) txns
+	semaphore *semaphore.Weighted
+}
+
+func newTxnIterator(consumer blockConsumer) *txnIterator {
+	o := &txnIterator{consumer: consumer}
+	o.evaluate = o.doSync
+	return o
+}
+
+func newAsyncTxnIterator(consumer blockConsumer, semaphore *semaphore.Weighted) *txnIterator {
+	o := &txnIterator{consumer: consumer, semaphore: semaphore}
+	o.evaluate = o.doAsync
+	return o
+}
+
 type blockConsumer func(seqInBlock uint64, chdr *common.ChannelHeader, txRWSet *rwsetutil.TxRwSet, endorsers []*peer.Endorsement)
 
-func (data blockData) forEachTxn(txsFilter txValidationFlags, consumer blockConsumer) txns {
-	var txList []string
+func (o *txnIterator) forEachTxn(data [][]byte) txns {
+	return o.evaluate(data)
+}
+
+func (o *txnIterator) doSync(data [][]byte) txns {
+	var txIDs txns
 	for seqInBlock, envBytes := range data {
-		env, err := utils.GetEnvelopeFromBlock(envBytes)
-		if err != nil {
-			logger.Warning("Invalid envelope:", err)
-			continue
+		txID := o.evaluateTxn(uint64(seqInBlock), envBytes)
+		if txID != "" {
+			txIDs = append(txIDs, txID)
 		}
+	}
+	return txIDs
+}
 
-		payload, err := utils.GetPayload(env)
-		if err != nil {
-			logger.Warning("Invalid payload:", err)
-			continue
-		}
+func (o *txnIterator) doAsync(data [][]byte) txns {
+	var txIDs txns
+	var mutex sync.Mutex
+	var wg sync.WaitGroup
 
-		chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
-		if err != nil {
-			logger.Warning("Invalid channel header:", err)
-			continue
-		}
+	wg.Add(len(data))
+	ctx := context.Background()
 
-		if chdr.Type != int32(common.HeaderType_ENDORSER_TRANSACTION) {
-			continue
-		}
+	go func() {
+		for seqInBlock, envBytes := range data {
+			if err := o.semaphore.Acquire(ctx, 1); err != nil {
+				// This should never happen with background context
+				panic(fmt.Sprintf("Unable to acquire semaphore: %s", err))
+			}
 
-		txList = append(txList, chdr.TxId)
+			seq := seqInBlock
+			bytes := envBytes
 
-		if txsFilter[seqInBlock] != uint8(peer.TxValidationCode_VALID) {
-			logger.Debug("Skipping Tx", seqInBlock, "because it's invalid. Status is", txsFilter[seqInBlock])
-			continue
+			go func() {
+				txID := o.evaluateTxn(uint64(seq), bytes)
+				if txID != "" {
+					mutex.Lock()
+					txIDs = append(txIDs, txID)
+					mutex.Unlock()
+				}
+				o.semaphore.Release(1)
+				wg.Done()
+			}()
 		}
+	}()
+	wg.Wait()
 
-		respPayload, err := utils.GetActionFromEnvelope(envBytes)
-		if err != nil {
-			logger.Warning("Failed obtaining action from envelope", err)
-			continue
-		}
+	return txIDs
+}
 
-		tx, err := utils.GetTransaction(payload.Data)
-		if err != nil {
-			logger.Warning("Invalid transaction in payload data for tx ", chdr.TxId, ":", err)
-			continue
-		}
+func (o *txnIterator) evaluateTxn(seqInBlock uint64, envBytes []byte) string {
+	env, err := utils.GetEnvelopeFromBlock(envBytes)
+	if err != nil {
+		logger.Warning("Invalid envelope:", err)
+		return ""
+	}
 
-		ccActionPayload, err := utils.GetChaincodeActionPayload(tx.Actions[0].Payload)
-		if err != nil {
-			logger.Warning("Invalid chaincode action in payload for tx", chdr.TxId, ":", err)
-			continue
-		}
+	payload, err := utils.GetPayload(env)
+	if err != nil {
+		logger.Warning("Invalid payload:", err)
+		return ""
+	}
 
-		if ccActionPayload.Action == nil {
-			logger.Warning("Action in ChaincodeActionPayload for", chdr.TxId, "is nil")
-			continue
-		}
+	chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
+	if err != nil {
+		logger.Warning("Invalid channel header:", err)
+		return ""
+	}
 
-		txRWSet := &rwsetutil.TxRwSet{}
-		if err = txRWSet.FromProtoBytes(respPayload.Results); err != nil {
-			logger.Warning("Failed obtaining TxRwSet from ChaincodeAction's results", err)
-			continue
-		}
-		consumer(uint64(seqInBlock), chdr, txRWSet, ccActionPayload.Action.Endorsements)
+	if chdr.Type != int32(common.HeaderType_ENDORSER_TRANSACTION) {
+		return ""
 	}
-	return txList
+
+	respPayload, err := utils.GetActionFromEnvelope(envBytes)
+	if err != nil {
+		logger.Warning("Failed obtaining action from envelope", err)
+		return chdr.TxId
+	}
+
+	tx, err := utils.GetTransaction(payload.Data)
+	if err != nil {
+		logger.Warning("Invalid transaction in payload data for tx ", chdr.TxId, ":", err)
+		return chdr.TxId
+	}
+
+	ccActionPayload, err := utils.GetChaincodeActionPayload(tx.Actions[0].Payload)
+	if err != nil {
+		logger.Warning("Invalid chaincode action in payload for tx", chdr.TxId, ":", err)
+		return chdr.TxId
+	}
+
+	if ccActionPayload.Action == nil {
+		logger.Warning("Action in ChaincodeActionPayload for", chdr.TxId, "is nil")
+		return chdr.TxId
+	}
+
+	txRWSet := &rwsetutil.TxRwSet{}
+	if err = txRWSet.FromProtoBytes(respPayload.Results); err != nil {
+		logger.Warning("Failed obtaining TxRwSet from ChaincodeAction's results", err)
+		return chdr.TxId
+	}
+
+	o.consumer(uint64(seqInBlock), chdr, txRWSet, ccActionPayload.Action.Endorsements)
+	return chdr.TxId
 }
 
 func endorsersFromOrgs(ns string, col string, endorsers []*peer.Endorsement, orgs []string) []*peer.Endorsement {
@@ -763,23 +902,21 @@ func (c *coordinator) listMissingPrivateData(block *common.Block, ownedRWsets ma
 	if block.Metadata == nil || len(block.Metadata.Metadata) <= int(common.BlockMetadataIndex_TRANSACTIONS_FILTER) {
 		return nil, errors.New("Block.Metadata is nil or Block.Metadata lacks a Tx filter bitmap")
 	}
-	txsFilter := txValidationFlags(block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER])
-	if len(txsFilter) != len(block.Data.Data) {
-		return nil, errors.Errorf("Block data size(%d) is different from Tx filter size(%d)", len(block.Data.Data), len(txsFilter))
-	}
 
 	sources := make(map[rwSetKey][]*peer.Endorsement)
 	privateRWsetsInBlock := make(map[rwSetKey]struct{})
 	missing := make(rwSetKeysByTxIDs)
-	data := blockData(block.Data.Data)
+
 	bi := &transactionInspector{
 		sources:              sources,
 		missingKeys:          missing,
 		ownedRWsets:          ownedRWsets,
 		privateRWsetsInBlock: privateRWsetsInBlock,
 		coordinator:          c,
+		policyCache:          collpolicy.NewCache(c.ChainID, c.accessPolicyForCollection),
 	}
-	txList := data.forEachTxn(txsFilter, bi.inspectTransaction)
+
+	txList := newAsyncTxnIterator(bi.inspectTransaction, c.semaphore).forEachTxn(block.Data.Data)
 
 	privateInfo := &privateDataInfo{
 		sources:            sources,
@@ -826,7 +965,7 @@ func (bi *transactionInspector) inspectTransaction(seqInBlock uint64, chdr *comm
 			if !containsWrites(chdr.TxId, ns.NameSpace, hashedCollection) {
 				continue
 			}
-			policy := bi.accessPolicyForCollection(chdr, ns.NameSpace, hashedCollection.CollectionName)
+			policy := bi.policyCache.Get(ns.NameSpace, hashedCollection.CollectionName)
 			if policy == nil {
 				logger.Errorf("Failed to retrieve collection config for channel [%s], chaincode [%s], collection name [%s] for txID [%s]. Skipping.",
 					chdr.ChannelId, ns.NameSpace, hashedCollection.CollectionName, chdr.TxId)
@@ -845,27 +984,37 @@ func (bi *transactionInspector) inspectTransaction(seqInBlock uint64, chdr *comm
 				namespace:  ns.NameSpace,
 				collection: hashedCollection.CollectionName,
 			}
-			bi.privateRWsetsInBlock[key] = struct{}{}
 			if _, exists := bi.ownedRWsets[key]; !exists {
-				txAndSeq := txAndSeqInBlock{
-					txID:       chdr.TxId,
-					seqInBlock: seqInBlock,
-				}
-				bi.missingKeys[txAndSeq] = append(bi.missingKeys[txAndSeq], key)
-				bi.sources[key] = endorsersFromOrgs(ns.NameSpace, hashedCollection.CollectionName, endorsers, policy.MemberOrgs())
+				bi.addKey(key, true, endorsersFromOrgs(ns.NameSpace, hashedCollection.CollectionName, endorsers, policy.MemberOrgs()))
+			} else {
+				bi.addKey(key, false, nil)
 			}
 		} // for all hashed RW sets
 	} // for all RW sets
 }
 
+func (bi *transactionInspector) addKey(key rwSetKey, missing bool, missingKeySource []*peer.Endorsement) {
+	bi.mutex.Lock()
+	defer bi.mutex.Unlock()
+
+	bi.privateRWsetsInBlock[key] = struct{}{}
+	if missing {
+		bi.sources[key] = missingKeySource
+		txAndSeq := txAndSeqInBlock{
+			txID:       key.txID,
+			seqInBlock: key.seqInBlock,
+		}
+		bi.missingKeys[txAndSeq] = append(bi.missingKeys[txAndSeq], key)
+	}
+}
+
 // accessPolicyForCollection retrieves a CollectionAccessPolicy for a given namespace, collection name
 // that corresponds to a given ChannelHeader
-func (c *coordinator) accessPolicyForCollection(chdr *common.ChannelHeader, namespace string, col string) privdata.CollectionAccessPolicy {
+func (c *coordinator) accessPolicyForCollection(channelID, namespace, col string) privdata.CollectionAccessPolicy {
 	cp := common.CollectionCriteria{
-		Channel:    chdr.ChannelId,
+		Channel:    channelID,
 		Namespace:  namespace,
 		Collection: col,
-		TxId:       chdr.TxId,
 	}
 	sp, err := c.CollectionStore.RetrieveCollectionAccessPolicy(cp)
 	if err != nil {
@@ -940,8 +1089,7 @@ func (c *coordinator) GetPvtDataAndBlockByNum(seqNum uint64, peerAuthInfo common
 	}
 
 	seqs2Namespaces := aggregatedCollections(make(map[seqAndDataModel]map[string][]*rwset.CollectionPvtReadWriteSet))
-	data := blockData(blockAndPvtData.Block.Data.Data)
-	data.forEachTxn(make(txValidationFlags, len(data)), func(seqInBlock uint64, chdr *common.ChannelHeader, txRWSet *rwsetutil.TxRwSet, _ []*peer.Endorsement) {
+	newTxnIterator(func(seqInBlock uint64, chdr *common.ChannelHeader, txRWSet *rwsetutil.TxRwSet, _ []*peer.Endorsement) {
 		item, exists := blockAndPvtData.BlockPvtData[seqInBlock]
 		if !exists {
 			return
