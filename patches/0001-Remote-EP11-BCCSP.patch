From ee87ac02abb58d2fd67db49649810a20155d42b0 Mon Sep 17 00:00:00 2001
From: Sudesh Shetty <sudesh.shetty@securekey.com>
Date: Tue, 12 Jun 2018 11:40:15 -0400
Subject: [PATCH] Remote EP11 BCCSP

This new provider connects directly to EP11 library. This library
is much closer to the device driver for the IBM Crypto Cards.

Change-Id: I1d8646edce441dd03af72263fd410df89dfbf553
Signed-off-by: Volodymyr Paprotski <vpaprots@ca.ibm.com>
---
 bccsp/factory/grep11factory.go   |  53 +++++
 bccsp/factory/pkcs11.go          |  29 +--
 bccsp/grep11/client.go           | 185 +++++++++++++++
 bccsp/grep11/conf.go             | 110 +++++++++
 bccsp/grep11/ecdsa.go            | 121 ++++++++++
 bccsp/grep11/ecdsakey.go         |  99 ++++++++
 bccsp/grep11/hsmks.go            | 394 +++++++++++++++++++++++++++++++
 bccsp/grep11/impl.go             | 366 +++++++++++++++++++++++++++++
 bccsp/grep11/protos/grep11.pb.go | 491 +++++++++++++++++++++++++++++++++++++++
 bccsp/grep11/protos/grep11.proto |  70 ++++++
 10 files changed, 1905 insertions(+), 13 deletions(-)
 create mode 100644 bccsp/factory/grep11factory.go
 create mode 100644 bccsp/grep11/client.go
 create mode 100644 bccsp/grep11/conf.go
 create mode 100644 bccsp/grep11/ecdsa.go
 create mode 100644 bccsp/grep11/ecdsakey.go
 create mode 100644 bccsp/grep11/hsmks.go
 create mode 100644 bccsp/grep11/impl.go
 create mode 100644 bccsp/grep11/protos/grep11.pb.go
 create mode 100644 bccsp/grep11/protos/grep11.proto

diff --git a/bccsp/factory/grep11factory.go b/bccsp/factory/grep11factory.go
new file mode 100644
index 000000000..83f27db5e
--- /dev/null
+++ b/bccsp/factory/grep11factory.go
@@ -0,0 +1,53 @@
+// +build pkcs11
+
+/*
+Copyright IBM Corp. All Rights Reserved.
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package factory
+
+import (
+	"errors"
+	"fmt"
+
+	"github.com/hyperledger/fabric/bccsp"
+	"github.com/hyperledger/fabric/bccsp/sw"
+	"github.com/hyperledger/fabric/bccsp/grep11"
+)
+
+const (
+	// GREP11BasedFactoryName is the name of the factory of the hsm-based BCCSP implementation
+	GREP11BasedFactoryName = "GREP11"
+)
+
+// GREP11Factory is the factory of the HSM-based BCCSP.
+type GREP11Factory struct{}
+
+// Name returns the name of this factory
+func (f *GREP11Factory) Name() string {
+	return GREP11BasedFactoryName
+}
+
+// Get returns an instance of BCCSP using Opts.
+func (f *GREP11Factory) Get(config *FactoryOpts) (bccsp.BCCSP, error) {
+	// Validate arguments
+	if config == nil || config.Grep11Opts == nil {
+		return nil, errors.New("Invalid config. It must not be nil.")
+	}
+
+	p11Opts := config.Grep11Opts
+
+	var ks bccsp.KeyStore
+	if p11Opts.FileKeystore != nil {
+		fks, err := sw.NewFileBasedKeyStore(nil, p11Opts.FileKeystore.KeyStorePath, false)
+		if err != nil {
+			return nil, fmt.Errorf("Failed to initialize software key store: %s", err)
+		}
+		ks = fks
+	} else {
+		// Default to DummyKeystore
+		ks = sw.NewDummyKeyStore()
+	}
+	return grep11.New(*p11Opts, ks)
+}
diff --git a/bccsp/factory/pkcs11.go b/bccsp/factory/pkcs11.go
index 4456d70eb..6ea7548ed 100644
--- a/bccsp/factory/pkcs11.go
+++ b/bccsp/factory/pkcs11.go
@@ -1,26 +1,17 @@
 // +build pkcs11
 
 /*
-Copyright IBM Corp. 2017 All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-		 http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
+Copyright IBM Corp. All Rights Reserved.
+SPDX-License-Identifier: Apache-2.0
 */
+
 package factory
 
 import (
 	"github.com/hyperledger/fabric/bccsp"
 	"github.com/hyperledger/fabric/bccsp/pkcs11"
 	"github.com/pkg/errors"
+	"github.com/hyperledger/fabric/bccsp/grep11"
 )
 
 // FactoryOpts holds configuration information used to initialize factory implementations
@@ -29,6 +20,7 @@ type FactoryOpts struct {
 	SwOpts       *SwOpts            `mapstructure:"SW,omitempty" json:"SW,omitempty" yaml:"SwOpts"`
 	PluginOpts   *PluginOpts        `mapstructure:"PLUGIN,omitempty" json:"PLUGIN,omitempty" yaml:"PluginOpts"`
 	Pkcs11Opts   *pkcs11.PKCS11Opts `mapstructure:"PKCS11,omitempty" json:"PKCS11,omitempty" yaml:"PKCS11"`
+	Grep11Opts   *grep11.GREP11Opts `mapstructure:"GREP11,omitempty" json:"GREP11,omitempty" yaml:"GREP11"`
 }
 
 // InitFactories must be called before using factory interfaces
@@ -87,6 +79,15 @@ func setFactories(config *FactoryOpts) error {
 		}
 	}
 
+	// GREP11-Based BCCSP
+	if config.Grep11Opts != nil {
+		f := &GREP11Factory{}
+		err := initBCCSP(f, config)
+		if err != nil {
+			factoriesInitError = errors.Errorf("Failed initializing GREP11.BCCSP %s\n[%s]", factoriesInitError, err)
+		}
+	}
+
 	var ok bool
 	defaultBCCSP, ok = bccspMap[config.ProviderName]
 	if !ok {
@@ -106,6 +107,8 @@ func GetBCCSPFromOpts(config *FactoryOpts) (bccsp.BCCSP, error) {
 		f = &PKCS11Factory{}
 	case "PLUGIN":
 		f = &PluginFactory{}
+	case "GREP11":
+		f = &GREP11Factory{}
 	default:
 		return nil, errors.Errorf("Could not find BCCSP, no '%s' provider", config.ProviderName)
 	}
diff --git a/bccsp/grep11/client.go b/bccsp/grep11/client.go
new file mode 100644
index 000000000..ec9499ded
--- /dev/null
+++ b/bccsp/grep11/client.go
@@ -0,0 +1,185 @@
+/*
+Copyright IBM Corp. 2017 All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+package grep11
+
+import (
+	"crypto/elliptic"
+	"encoding/asn1"
+	"fmt"
+	"math/big"
+
+	pb "github.com/hyperledger/fabric/bccsp/grep11/protos"
+	"golang.org/x/net/context"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
+)
+
+// RFC 5480, 2.1.1.1. Named Curve
+//
+// secp224r1 OBJECT IDENTIFIER ::= {
+//   iso(1) identified-organization(3) certicom(132) curve(0) 33 }
+//
+// secp256r1 OBJECT IDENTIFIER ::= {
+//   iso(1) member-body(2) us(840) ansi-X9-62(10045) curves(3)
+//   prime(1) 7 }
+//
+// secp384r1 OBJECT IDENTIFIER ::= {
+//   iso(1) identified-organization(3) certicom(132) curve(0) 34 }
+//
+// secp521r1 OBJECT IDENTIFIER ::= {
+//   iso(1) identified-organization(3) certicom(132) curve(0) 35 }
+//
+var (
+	oidNamedCurveP224 = asn1.ObjectIdentifier{1, 3, 132, 0, 33}
+	oidNamedCurveP256 = asn1.ObjectIdentifier{1, 2, 840, 10045, 3, 1, 7}
+	oidNamedCurveP384 = asn1.ObjectIdentifier{1, 3, 132, 0, 34}
+	oidNamedCurveP521 = asn1.ObjectIdentifier{1, 3, 132, 0, 35}
+)
+
+func namedCurveFromOID(oid asn1.ObjectIdentifier) elliptic.Curve {
+	switch {
+	case oid.Equal(oidNamedCurveP224):
+		return elliptic.P224()
+	case oid.Equal(oidNamedCurveP256):
+		return elliptic.P256()
+	case oid.Equal(oidNamedCurveP384):
+		return elliptic.P384()
+	case oid.Equal(oidNamedCurveP521):
+		return elliptic.P521()
+	}
+	return nil
+}
+
+func oidFromNamedCurve(curve elliptic.Curve) (asn1.ObjectIdentifier, bool) {
+	switch curve {
+	case elliptic.P224():
+		return oidNamedCurveP224, true
+	case elliptic.P256():
+		return oidNamedCurveP256, true
+	case elliptic.P384():
+		return oidNamedCurveP384, true
+	case elliptic.P521():
+		return oidNamedCurveP521, true
+	}
+
+	return nil, false
+}
+
+func (csp *impl) reLoad(grpcCall func() error) error {
+	err := grpcCall()
+	if err != nil {
+		grpcStatus, ok := status.FromError(err)
+		if ok {
+			switch grpcStatus.Code() {
+			case codes.Unavailable, codes.FailedPrecondition:
+				logger.Debugf("GRPC Error received, reconnecting: [%s]", grpcStatus.Code().String())
+				err = csp.connectSession()
+				if err == nil {
+					err = grpcCall()
+				}
+			}
+		}
+	}
+	return err
+}
+
+func (csp *impl) generateECKey(curve asn1.ObjectIdentifier, ephemeral bool) (*ecdsaPrivateKey, error) {
+	marshaledOID, err := asn1.Marshal(curve)
+	if err != nil {
+		return nil, fmt.Errorf("Could not marshal OID [%s]", err.Error())
+	}
+
+	var k *pb.GenerateStatus
+	err = csp.reLoad(func() error {
+		var err error
+		k, err = csp.grepClient.GenerateECKey(context.Background(), &pb.GenerateInfo{marshaledOID})
+		return err
+	})
+
+	if err != nil {
+		return nil, fmt.Errorf("Could not remote-generate PKCS11 library [%s]\n Remote Response: <%+v>", err, k)
+	}
+	if k.Error != "" {
+		return nil, fmt.Errorf("Remote Generate call reports error: %s", k.Error)
+	}
+
+	ski, pubGoKey, err := blobToPubKey(k.PubKey, curve)
+	if err != nil {
+		return nil, fmt.Errorf("Failed Unmarshaling Public Key [%s]", err)
+	}
+
+	/* VP DELETE Verifying pub key generation from soft key
+	ioutil.WriteFile("/tmp/pub.asn1", k.PubKey, 0644)
+	checkBlob, err := pubKeyToBlob(pubGoKey)
+	if err != nil {
+		return nil, fmt.Errorf("Well this is strange! [%s]", err)
+	}
+
+	if bytes.Equal(k.PubKey, checkBlob) {
+		logger.Fatalf("VP>>>>>>>>>>>>>>>>>>>>>>>> That was too easy?")
+	} else {
+		logger.Fatalf("Keys mismatch\nExpected:\n%s\nGenerated:\n%s", hex.Dump(k.PubKey), hex.Dump(checkBlob))
+	}
+	//endDELETE */
+
+	key := &ecdsaPrivateKey{ski, k.PrivKey, &ecdsaPublicKey{ski, k.PubKey, pubGoKey}}
+	return key, nil
+}
+
+func (csp *impl) signP11ECDSA(keyBlob []byte, msg []byte) (R, S *big.Int, err error) {
+	var sig *pb.SignStatus
+	err = csp.reLoad(func() error {
+		var err error
+		sig, err = csp.grepClient.SignP11ECDSA(context.Background(), &pb.SignInfo{keyBlob, msg})
+		return err
+	})
+
+	if err != nil {
+		return nil, nil, fmt.Errorf("Could not remote-sign PKCS11 library [%s]\n Remote Response: <%s>", err, sig)
+	}
+	if sig.Error != "" {
+		return nil, nil, fmt.Errorf("Remote Sign call reports error: %s", sig.Error)
+	}
+
+	R = new(big.Int)
+	S = new(big.Int)
+	R.SetBytes(sig.Sig[0 : len(sig.Sig)/2])
+	S.SetBytes(sig.Sig[len(sig.Sig)/2:])
+
+	return R, S, nil
+}
+
+func (csp *impl) verifyP11ECDSA(keyBlob []byte, msg []byte, R, S *big.Int, byteSize int) (valid bool, err error) {
+	// TODO: Uncomment when HSM Verify is supported
+	//r := R.Bytes()
+	//s := S.Bytes()
+	//
+	//// Pad front of R and S with Zeroes if needed
+	//sig := make([]byte, 2*byteSize)
+	//copy(sig[byteSize-len(r):byteSize], r)
+	//copy(sig[2*byteSize-len(s):], s)
+	//
+	//val, err := csp.grepClient.VerifyP11ECDSA(context.Background(), &pb.VerifyInfo{keyBlob, msg, sig})
+	//if err != nil {
+	//	return false, fmt.Errorf("Could not remote-verify PKCS11 library [%s]\n Remote Response: <%+v>", err, val)
+	//}
+	//if val.Error != "" {
+	//	return false, fmt.Errorf("Remote Verify call reports error: %s", val.Error)
+	//}
+	//
+	//return val.Valid, nil
+	return false, fmt.Errorf("Remote Verify is currently not supported.")
+}
diff --git a/bccsp/grep11/conf.go b/bccsp/grep11/conf.go
new file mode 100644
index 000000000..acb740378
--- /dev/null
+++ b/bccsp/grep11/conf.go
@@ -0,0 +1,110 @@
+/*
+Copyright IBM Corp. 2016 All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+package grep11
+
+import (
+	"crypto/sha256"
+	"crypto/sha512"
+	"encoding/asn1"
+	"fmt"
+	"hash"
+
+	"golang.org/x/crypto/sha3"
+)
+
+type config struct {
+	ellipticCurve asn1.ObjectIdentifier
+	hashFunction  func() hash.Hash
+	aesBitLength  int
+	rsaBitLength  int
+
+	softVerify bool
+	address    string
+	port       string
+}
+
+func (conf *config) setSecurityLevel(securityLevel int, hashFamily string, opts GREP11Opts) (err error) {
+	switch hashFamily {
+	case "SHA2":
+		err = conf.setSecurityLevelSHA2(securityLevel)
+	case "SHA3":
+		err = conf.setSecurityLevelSHA3(securityLevel)
+	default:
+		err = fmt.Errorf("Hash Family not supported [%s]", hashFamily)
+	}
+
+	conf.softVerify = opts.SoftVerify
+	conf.address = opts.Address
+	conf.port = opts.Port
+	return
+}
+
+func (conf *config) setSecurityLevelSHA2(level int) (err error) {
+	switch level {
+	case 256:
+		conf.ellipticCurve = oidNamedCurveP256
+		conf.hashFunction = sha256.New
+		conf.rsaBitLength = 2048
+		conf.aesBitLength = 32
+	case 384:
+		conf.ellipticCurve = oidNamedCurveP384
+		conf.hashFunction = sha512.New384
+		conf.rsaBitLength = 3072
+		conf.aesBitLength = 32
+	default:
+		err = fmt.Errorf("Security level not supported [%d]", level)
+	}
+	return
+}
+
+func (conf *config) setSecurityLevelSHA3(level int) (err error) {
+	switch level {
+	case 256:
+		conf.ellipticCurve = oidNamedCurveP256
+		conf.hashFunction = sha3.New256
+		conf.rsaBitLength = 2048
+		conf.aesBitLength = 32
+	case 384:
+		conf.ellipticCurve = oidNamedCurveP384
+		conf.hashFunction = sha3.New384
+		conf.rsaBitLength = 3072
+		conf.aesBitLength = 32
+	default:
+		err = fmt.Errorf("Security level not supported [%d]", level)
+	}
+	return
+}
+
+// PKCS11Opts contains options for the P11Factory
+type GREP11Opts struct {
+	// Default algorithms when not specified (Deprecated?)
+	SecLevel   int    `mapstructure:"security" json:"security"`
+	HashFamily string `mapstructure:"hash" json:"hash"`
+
+	// Keystore options
+	FileKeystore *FileKeystoreOpts `mapstructure:"filekeystore,omitempty" json:"filekeystore,omitempty"`
+
+	Address string `mapstructure:"address" json:"library"`
+	Port    string `mapstructure:"port" json:"library"`
+
+	SoftVerify bool `mapstructure:"softwareverify,omitempty" json:"softwareverify,omitempty"`
+}
+
+// Since currently only ECDSA operations go to PKCS11, need a keystore still
+// Pluggable Keystores, could add JKS, P12, etc..
+type FileKeystoreOpts struct {
+	KeyStorePath string `mapstructure:"keystore" json:"keystore" yaml:"KeyStore"`
+}
diff --git a/bccsp/grep11/ecdsa.go b/bccsp/grep11/ecdsa.go
new file mode 100644
index 000000000..aaeb43d28
--- /dev/null
+++ b/bccsp/grep11/ecdsa.go
@@ -0,0 +1,121 @@
+/*
+Copyright IBM Corp. 2016 All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+package grep11
+
+import (
+	"crypto/ecdsa"
+	"crypto/elliptic"
+	"encoding/asn1"
+	"errors"
+	"fmt"
+	"math/big"
+
+	"github.com/hyperledger/fabric/bccsp"
+)
+
+type ecdsaSignature struct {
+	R, S *big.Int
+}
+
+var (
+	// curveHalfOrders contains the precomputed curve group orders halved.
+	// It is used to ensure that signature' S value is lower or equal to the
+	// curve group order halved. We accept only low-S signatures.
+	// They are precomputed for efficiency reasons.
+	curveHalfOrders map[elliptic.Curve]*big.Int = map[elliptic.Curve]*big.Int{
+		elliptic.P224(): new(big.Int).Rsh(elliptic.P224().Params().N, 1),
+		elliptic.P256(): new(big.Int).Rsh(elliptic.P256().Params().N, 1),
+		elliptic.P384(): new(big.Int).Rsh(elliptic.P384().Params().N, 1),
+		elliptic.P521(): new(big.Int).Rsh(elliptic.P521().Params().N, 1),
+	}
+)
+
+func marshalECDSASignature(r, s *big.Int) ([]byte, error) {
+	return asn1.Marshal(ecdsaSignature{r, s})
+}
+
+func unmarshalECDSASignature(raw []byte) (*big.Int, *big.Int, error) {
+	// Unmarshal
+	sig := new(ecdsaSignature)
+	_, err := asn1.Unmarshal(raw, sig)
+	if err != nil {
+		return nil, nil, fmt.Errorf("Failed unmashalling signature [%s]", err)
+	}
+
+	// Validate sig
+	if sig.R == nil {
+		return nil, nil, errors.New("Invalid signature. R must be different from nil.")
+	}
+	if sig.S == nil {
+		return nil, nil, errors.New("Invalid signature. S must be different from nil.")
+	}
+
+	if sig.R.Sign() != 1 {
+		return nil, nil, errors.New("Invalid signature. R must be larger than zero")
+	}
+	if sig.S.Sign() != 1 {
+		return nil, nil, errors.New("Invalid signature. S must be larger than zero")
+	}
+
+	return sig.R, sig.S, nil
+}
+
+func (csp *impl) signECDSA(k ecdsaPrivateKey, digest []byte, opts bccsp.SignerOpts) (signature []byte, err error) {
+	r, s, err := csp.signP11ECDSA(k.keyBlob, digest)
+	if err != nil {
+		return nil, err
+	}
+
+	// check for low-S
+	halfOrder, ok := curveHalfOrders[k.pub.pub.Curve]
+	if !ok {
+		return nil, fmt.Errorf("Curve not recognized [%s]", k.pub.pub.Curve)
+	}
+
+	// is s > halfOrder Then
+	if s.Cmp(halfOrder) == 1 {
+		// Set s to N - s that will be then in the lower part of signature space
+		// less or equal to half order
+		s.Sub(k.pub.pub.Params().N, s)
+	}
+
+	return marshalECDSASignature(r, s)
+}
+
+func (csp *impl) verifyECDSA(k ecdsaPublicKey, signature, digest []byte, opts bccsp.SignerOpts) (valid bool, err error) {
+	r, s, err := unmarshalECDSASignature(signature)
+	if err != nil {
+		return false, fmt.Errorf("Failed unmashalling signature [%s]", err)
+	}
+
+	// check for low-S
+	halfOrder, ok := curveHalfOrders[k.pub.Curve]
+	if !ok {
+		return false, fmt.Errorf("Curve not recognized [%s]", k.pub.Curve)
+	}
+
+	// If s > halfOrder Then
+	if s.Cmp(halfOrder) == 1 {
+		return false, fmt.Errorf("Invalid S. Must be smaller than half the order [%s][%s].", s, halfOrder)
+	}
+
+	if csp.conf.softVerify {
+		return ecdsa.Verify(k.pub, digest, r, s), nil
+	} else {
+		return false, fmt.Errorf("HSM Verify Not yet supported")
+		//return csp.verifyP11ECDSA(k.keyBlob, digest, r, s, k.pub.Curve.Params().BitSize/8)
+	}
+}
diff --git a/bccsp/grep11/ecdsakey.go b/bccsp/grep11/ecdsakey.go
new file mode 100644
index 000000000..21cbcac0a
--- /dev/null
+++ b/bccsp/grep11/ecdsakey.go
@@ -0,0 +1,99 @@
+/*
+Copyright IBM Corp. 2016 All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+package grep11
+
+import (
+	"crypto/ecdsa"
+	"crypto/x509"
+	"errors"
+	"fmt"
+
+	"github.com/hyperledger/fabric/bccsp"
+)
+
+type ecdsaPrivateKey struct {
+	ski     []byte
+	keyBlob []byte
+	pub     *ecdsaPublicKey
+}
+
+// Bytes converts this key to its byte representation,
+// if this operation is allowed.
+func (k *ecdsaPrivateKey) Bytes() (raw []byte, err error) {
+	return nil, errors.New("Not supported.")
+}
+
+// SKI returns the subject key identifier of this key.
+func (k *ecdsaPrivateKey) SKI() (ski []byte) {
+	return k.ski
+}
+
+// Symmetric returns true if this key is a symmetric key,
+// false if this key is asymmetric
+func (k *ecdsaPrivateKey) Symmetric() bool {
+	return false
+}
+
+// Private returns true if this key is a private key,
+// false otherwise.
+func (k *ecdsaPrivateKey) Private() bool {
+	return true
+}
+
+// PublicKey returns the corresponding public key part of an asymmetric public/private key pair.
+// This method returns an error in symmetric key schemes.
+func (k *ecdsaPrivateKey) PublicKey() (bccsp.Key, error) {
+	return k.pub, nil
+}
+
+type ecdsaPublicKey struct {
+	ski     []byte
+	keyBlob []byte
+	pub     *ecdsa.PublicKey
+}
+
+// Bytes converts this key to its byte representation,
+// if this operation is allowed.
+func (k *ecdsaPublicKey) Bytes() (raw []byte, err error) {
+	raw, err = x509.MarshalPKIXPublicKey(k.pub)
+	if err != nil {
+		return nil, fmt.Errorf("Failed marshalling key [%s]", err)
+	}
+	return
+}
+
+// SKI returns the subject key identifier of this key.
+func (k *ecdsaPublicKey) SKI() (ski []byte) {
+	return k.ski
+}
+
+// Symmetric returns true if this key is a symmetric key,
+// false if this key is asymmetric
+func (k *ecdsaPublicKey) Symmetric() bool {
+	return false
+}
+
+// Private returns true if this key is a private key,
+// false otherwise.
+func (k *ecdsaPublicKey) Private() bool {
+	return false
+}
+
+// PublicKey returns the corresponding public key part of an asymmetric public/private key pair.
+// This method returns an error in symmetric key schemes.
+func (k *ecdsaPublicKey) PublicKey() (bccsp.Key, error) {
+	return k, nil
+}
diff --git a/bccsp/grep11/hsmks.go b/bccsp/grep11/hsmks.go
new file mode 100644
index 000000000..19c503113
--- /dev/null
+++ b/bccsp/grep11/hsmks.go
@@ -0,0 +1,394 @@
+/*
+Copyright IBM Corp. 2016 All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+package grep11
+
+import (
+	"crypto/ecdsa"
+	"crypto/elliptic"
+	"crypto/rand"
+	"crypto/sha256"
+	"encoding/asn1"
+	"encoding/hex"
+	"encoding/pem"
+	"errors"
+	"fmt"
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strings"
+	"sync"
+
+	"github.com/hyperledger/fabric/bccsp"
+	"github.com/hyperledger/fabric/bccsp/utils"
+)
+
+func NewHsmBasedKeyStore(path string, fallbackKS bccsp.KeyStore) (*hsmBasedKeyStore, error) {
+	_, err := os.Stat(path)
+	if os.IsNotExist(err) {
+		return nil, fmt.Errorf("Cannot find keystore directory %s", path)
+	}
+
+	ks := &hsmBasedKeyStore{}
+	ks.path = path
+	ks.KeyStore = fallbackKS
+	return ks, nil
+}
+
+func newPin() ([]byte, error) {
+	const pinLen = 8
+	pinLetters := []byte("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
+
+	pin := make([]byte, pinLen)
+	_, err := rand.Read(pin)
+	if err != nil {
+		return nil, fmt.Errorf("Failed on rand.Read() in genPin [%s]", err)
+	}
+
+	for i := 0; i < pinLen; i++ {
+		index := int(pin[i])
+		size := len(pinLetters)
+		pin[i] = pinLetters[index%size]
+	}
+	return pin, nil
+}
+
+func newNonce() ([]byte, error) {
+	const nonceLen = 1024
+	nonce := make([]byte, nonceLen)
+	_, err := rand.Read(nonce)
+	if err != nil {
+		return nil, fmt.Errorf("Failed on rand.Read() in getNonce [%s]", err)
+	}
+	return nonce, nil
+}
+
+type hsmBasedKeyStore struct {
+	bccsp.KeyStore
+	path string
+
+	// Sync
+	m sync.Mutex
+}
+
+func (ks *hsmBasedKeyStore) getPinAndNonce() (pin, nonce []byte, isNewPin bool, err error) {
+	pinPath := ks.getPathForAlias("pin", "nonce")
+	_, err = os.Stat(pinPath)
+	if os.IsNotExist(err) {
+		pin, err = newPin()
+		if err != nil {
+			return nil, nil, true, fmt.Errorf("Could not generate pin %s", err)
+		}
+		nonce, err = newNonce()
+		if err != nil {
+			return nil, nil, true, fmt.Errorf("Could not generate nonce %s", err)
+		}
+		logger.Debugf("Generated new pin %s and nonce", pin)
+		isNewPin = true
+	} else {
+		raw, err := ioutil.ReadFile(pinPath)
+		if err != nil {
+			logger.Fatalf("Failed loading pin and nonce: [%s].", err)
+		}
+		block, rest := pem.Decode(raw)
+		if block == nil || block.Type != "PIN" {
+			return nil, nil, true, fmt.Errorf("Failed to decode PEM block containing pin")
+		}
+		pin = block.Bytes
+		block, _ = pem.Decode(rest)
+		if block == nil || block.Type != "NONCE" {
+			return nil, nil, true, fmt.Errorf("Failed to decode PEM block containing pin")
+		}
+		nonce = block.Bytes
+		isNewPin = false
+		logger.Debugf("Loaded existing pin %s and nonce", pin)
+	}
+
+	return pin, nonce, isNewPin, nil
+}
+
+func (ks *hsmBasedKeyStore) storePinAndNonce(pin, nonce []byte) error {
+	pinPath := ks.getPathForAlias("pin", "nonce")
+	pinNnonce := pem.EncodeToMemory(
+		&pem.Block{
+			Type:  "PIN",
+			Bytes: pin,
+		})
+
+	pinNnonce = append(pinNnonce, pem.EncodeToMemory(
+		&pem.Block{
+			Type:  "NONCE",
+			Bytes: nonce,
+		})...)
+
+	err := ioutil.WriteFile(pinPath, pinNnonce, 0700)
+	if err != nil {
+		return fmt.Errorf("Failed storing pin and nonce: [%s]", err)
+	}
+	return nil
+}
+
+// ReadOnly returns true if this KeyStore is read only, false otherwise.
+// If ReadOnly is true then StoreKey will fail.
+func (ks *hsmBasedKeyStore) ReadOnly() bool {
+	return false
+}
+
+// GetKey returns a key object whose SKI is the one passed.
+func (ks *hsmBasedKeyStore) GetKey(ski []byte) (k bccsp.Key, err error) {
+	// Validate arguments
+	if len(ski) == 0 {
+		return nil, errors.New("Invalid SKI. Cannot be of zero length.")
+	}
+
+	suffix := ks.getSuffix(hex.EncodeToString(ski))
+
+	switch suffix {
+	case "sk":
+		// Load the private key
+		keyBlob, err := ks.loadPrivateKey(hex.EncodeToString(ski))
+		if err != nil {
+			logger.Debugf("Failed loading secret key [%x] [%s]", ski, err)
+			break
+		}
+
+		// Load the public key
+		key, err := ks.loadPublicKey(hex.EncodeToString(ski))
+		if err != nil {
+			return nil, fmt.Errorf("Failed loading public key [%x] [%s]", ski, err)
+		}
+
+		pubKey, ok := key.(*ecdsa.PublicKey)
+		if !ok {
+			return nil, fmt.Errorf("Failed loading public key, expected type *ecdsa.PublicKey [%s]", ski)
+		}
+
+		pubKeyBlob, err := pubKeyToBlob(pubKey)
+		if err != nil {
+			return nil, fmt.Errorf("Failed marshaling HSM pubKeyBlob [%s]", err)
+		}
+
+		return &ecdsaPrivateKey{ski, keyBlob, &ecdsaPublicKey{ski, pubKeyBlob, pubKey}}, nil
+	case "pk":
+		// Load the public key
+		key, err := ks.loadPublicKey(hex.EncodeToString(ski))
+		if err != nil {
+			return nil, fmt.Errorf("Failed loading public key [%x] [%s]", ski, err)
+		}
+
+		pubKey, ok := key.(*ecdsa.PublicKey)
+		if !ok {
+			return nil, fmt.Errorf("Failed loading public key, expected type *ecdsa.PublicKey [%s]", ski)
+		}
+
+		pubKeyBlob, err := pubKeyToBlob(pubKey)
+		if err != nil {
+			return nil, fmt.Errorf("Failed marshaling HSM pubKeyBlob [%s]", err)
+		}
+
+		return &ecdsaPublicKey{ski, pubKeyBlob, pubKey}, nil
+	}
+
+	return ks.KeyStore.GetKey(ski)
+}
+
+// StoreKey stores the key k in this KeyStore.
+// If this KeyStore is read only then the method will fail.
+func (ks *hsmBasedKeyStore) StoreKey(k bccsp.Key) (err error) {
+	if k == nil {
+		return errors.New("Invalid key. It must be different from nil.")
+	}
+
+	switch k.(type) {
+	case *ecdsaPrivateKey:
+		kk := k.(*ecdsaPrivateKey)
+
+		err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), kk.keyBlob)
+		if err != nil {
+			return fmt.Errorf("Failed storing ECDSA private key [%s]", err)
+		}
+
+		err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pub.pub)
+		if err != nil {
+			return fmt.Errorf("Failed storing ECDSA public key [%s]", err)
+		}
+
+	case *ecdsaPublicKey:
+		kk := k.(*ecdsaPublicKey)
+
+		err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pub)
+		if err != nil {
+			return fmt.Errorf("Failed storing ECDSA public key [%s]", err)
+		}
+
+	default:
+		ks.KeyStore.StoreKey(k)
+	}
+
+	return
+}
+
+func (ks *hsmBasedKeyStore) getSuffix(alias string) string {
+	rc := ""
+	files, _ := ioutil.ReadDir(ks.path)
+	for _, f := range files {
+		if strings.HasPrefix(f.Name(), alias) {
+			if strings.HasSuffix(f.Name(), "sk") {
+				// Found private key
+				return "sk"
+			}
+			if strings.HasSuffix(f.Name(), "pk") {
+				// Found public key, try to find matching private key instead
+				rc = "pk"
+				continue
+			}
+			if strings.HasSuffix(f.Name(), "key") {
+				// Found symmetric key
+				return "key"
+			}
+			break
+		}
+	}
+	return rc
+}
+
+func (ks *hsmBasedKeyStore) storePrivateKey(alias string, raw []byte) error {
+	encodedKey := pem.EncodeToMemory(
+		&pem.Block{
+			Type:  "HSM ENCRYPTED PRIVATE KEY",
+			Bytes: raw,
+		})
+
+	err := ioutil.WriteFile(ks.getPathForAlias(alias, "sk"), encodedKey, 0700)
+	if err != nil {
+		return fmt.Errorf("Failed storing private key [%s]: [%s]", alias, err)
+	}
+
+	return nil
+}
+
+func (ks *hsmBasedKeyStore) storePublicKey(alias string, publicKey interface{}) error {
+	rawKey, err := utils.PublicKeyToPEM(publicKey, nil)
+	if err != nil {
+		return fmt.Errorf("Failed converting public key to PEM [%s]: [%s]", alias, err)
+	}
+
+	err = ioutil.WriteFile(ks.getPathForAlias(alias, "pk"), rawKey, 0700)
+	if err != nil {
+		return fmt.Errorf("Failed storing public key [%s]: [%s]", alias, err)
+	}
+
+	return nil
+}
+
+func (ks *hsmBasedKeyStore) loadPrivateKey(alias string) ([]byte, error) {
+	path := ks.getPathForAlias(alias, "sk")
+	logger.Debugf("Loading private key [%s] at [%s]...", alias, path)
+
+	raw, err := ioutil.ReadFile(path)
+	if err != nil {
+		return nil, fmt.Errorf("Failed loading private key [%s]: [%s].", alias, err.Error())
+	}
+
+	block, _ := pem.Decode(raw)
+	if block == nil || block.Type != "HSM ENCRYPTED PRIVATE KEY" {
+		return nil, fmt.Errorf("Failed to decode PEM block containing private key")
+	}
+
+	if block.Bytes == nil {
+		return nil, fmt.Errorf("Found no private key blob in file")
+	}
+
+	return block.Bytes, nil
+}
+
+func (ks *hsmBasedKeyStore) loadPublicKey(alias string) (interface{}, error) {
+	path := ks.getPathForAlias(alias, "pk")
+	logger.Debugf("Loading public key [%s] at [%s]...", alias, path)
+
+	raw, err := ioutil.ReadFile(path)
+	if err != nil {
+		return nil, fmt.Errorf("Failed loading public key [%s]: [%s].", alias, err.Error())
+	}
+
+	publicKey, err := utils.PEMtoPublicKey(raw, nil)
+	if err != nil {
+		return nil, fmt.Errorf("Failed parsing public key [%s]: [%s].", alias, err.Error())
+	}
+
+	return publicKey, nil
+}
+
+func (ks *hsmBasedKeyStore) getPathForAlias(alias, suffix string) string {
+	return filepath.Join(ks.path, alias+"_"+suffix)
+}
+
+type EckeyIdentASN struct {
+	KeyType asn1.ObjectIdentifier
+	Curve   asn1.ObjectIdentifier
+}
+
+type PubKeyASN struct {
+	Ident EckeyIdentASN
+	Point asn1.BitString
+}
+
+func blobToPubKey(pubKey []byte, curve asn1.ObjectIdentifier) ([]byte, *ecdsa.PublicKey, error) {
+	nistCurve := namedCurveFromOID(curve)
+	if curve == nil {
+		return nil, nil, fmt.Errorf("Cound not recognize Curve from OID")
+	}
+
+	decode := &PubKeyASN{}
+	_, err := asn1.Unmarshal(pubKey, decode)
+	if err != nil {
+		return nil, nil, fmt.Errorf("Failed Unmarshaling Public Key [%s]", err)
+	}
+
+	hash := sha256.Sum256(decode.Point.Bytes)
+	ski := hash[:]
+
+	x, y := elliptic.Unmarshal(nistCurve, decode.Point.Bytes)
+	if x == nil {
+		return nil, nil, fmt.Errorf("Failed Unmarshaling Public Key..\n%s", hex.Dump(decode.Point.Bytes))
+	}
+
+	return ski, &ecdsa.PublicKey{Curve: nistCurve, X: x, Y: y}, nil
+}
+
+func pubKeyToBlob(pubKey *ecdsa.PublicKey) ([]byte, error) {
+	if pubKey == nil {
+		return nil, fmt.Errorf("Value of Public Key was nil")
+	}
+
+	oid, ok := oidFromNamedCurve(pubKey.Curve)
+	point := elliptic.Marshal(pubKey.Curve, pubKey.X, pubKey.Y)
+	if !ok {
+		return nil, fmt.Errorf("Curve not recognized")
+	}
+
+	encode := &PubKeyASN{
+		Ident: EckeyIdentASN{
+			KeyType: asn1.ObjectIdentifier{1, 2, 840, 10045, 2, 1}, //ecPublicKey
+			Curve:   oid,
+		},
+		Point: asn1.BitString{
+			Bytes:     point,
+			BitLength: len(point) * 8,
+		},
+	}
+
+	return asn1.Marshal(*encode)
+}
diff --git a/bccsp/grep11/impl.go b/bccsp/grep11/impl.go
new file mode 100644
index 000000000..b345bd525
--- /dev/null
+++ b/bccsp/grep11/impl.go
@@ -0,0 +1,366 @@
+/*
+Copyright IBM Corp. 2016 All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+package grep11
+
+import (
+	"crypto/ecdsa"
+	"errors"
+	"fmt"
+
+	"golang.org/x/net/context"
+	"google.golang.org/grpc"
+
+	"time"
+
+	"github.com/hyperledger/fabric/bccsp"
+	pb "github.com/hyperledger/fabric/bccsp/grep11/protos"
+	"github.com/hyperledger/fabric/bccsp/sw"
+	"github.com/hyperledger/fabric/bccsp/utils"
+	"github.com/hyperledger/fabric/common/flogging"
+	"github.com/securekey/fabric-snaps/metrics/cmd/filter/metrics"
+)
+
+var (
+	logger           = flogging.MustGetLogger("bccsp_ep11")
+	sessionCacheSize = 10
+)
+
+// New returns a new instance of the software-based BCCSP
+// set at the passed security level, hash family and KeyStore.
+func New(opts GREP11Opts, fallbackKS bccsp.KeyStore) (bccsp.BCCSP, error) {
+	// Init config
+	conf := &config{}
+	err := conf.setSecurityLevel(opts.SecLevel, opts.HashFamily, opts)
+	if err != nil {
+		return nil, fmt.Errorf("Failed initializing configuration [%s]", err)
+	}
+
+	// Note: If the fallbackKS is nil, the sw.New function will catch the error
+	swCSP, err := sw.NewWithParams(opts.SecLevel, opts.HashFamily, fallbackKS)
+	if err != nil {
+		return nil, fmt.Errorf("Failed initializing fallback SW BCCSP [%s]", err)
+	}
+
+	if opts.FileKeystore == nil {
+		return nil, fmt.Errorf("FileKeystore is required to use GREP11 CSP")
+	}
+
+	keyStore, err := NewHsmBasedKeyStore(opts.FileKeystore.KeyStorePath, fallbackKS)
+	if err != nil {
+		return nil, fmt.Errorf("Failed initializing HSMBasedKeyStore [%s]", err)
+	}
+
+	csp := &impl{
+		BCCSP: swCSP,
+		conf:  conf,
+		ks:    keyStore,
+	}
+	err = csp.connectSession()
+	if err != nil {
+		return nil, fmt.Errorf("Failed connecting to GREP11 Manager [%s]", err)
+	}
+
+	return csp, nil
+}
+
+type impl struct {
+	bccsp.BCCSP
+
+	conf *config
+	ks   bccsp.KeyStore
+
+	grepClient       pb.Grep11Client
+	grepManager      pb.Grep11ManagerClient
+	clientConnection *grpc.ClientConn
+}
+
+func (csp *impl) connectSession() error {
+	logger.Debugf("Connecting to GREP11 Master %s:%s", csp.conf.address, csp.conf.port)
+
+	// Setup timeout context for manager connection
+	mgrCtx, cancelMgrConn := context.WithTimeout(context.Background(), time.Second*60)
+	defer cancelMgrConn()
+
+	mgrConn, err := grpc.DialContext(mgrCtx, csp.conf.address+":"+csp.conf.port, grpc.WithInsecure(), grpc.WithBlock())
+	if err != nil {
+		return fmt.Errorf("Failed connecting to GREP11 manager at %s:%s [%s]", csp.conf.address, csp.conf.port, err)
+	}
+
+	// Close the manager TCP connection to the GREP11 Manager after
+	// connecting to its GREP11 Server service
+	defer mgrConn.Close()
+
+	csp.grepManager = pb.NewGrep11ManagerClient(mgrConn)
+
+	pin, nonce, isNewPin, err := csp.ks.(*hsmBasedKeyStore).getPinAndNonce()
+	if err != nil {
+		return fmt.Errorf("Failed generating PIN and Nonce for the EP11 session [%s]", err)
+	}
+
+	if !isNewPin && len(pin) == 0 && len(nonce) == 0 {
+		logger.Warningf("Starting GREP11 BCCSP without a session! Using Domain Master key to encrypt/decrypt key material.")
+		//TODO: We could attempt to log in with a new session at this point
+		//      if that were to succeed, re-wrap keys with new session
+		//      this might also be a place to place generic 're-wrap logic' (i.e. if Master Key changed
+		//      when container got moved to different LPAR)
+	}
+
+	r, err := csp.grepManager.Load(context.Background(), &pb.LoadInfo{pin, nonce})
+	if err != nil {
+		return fmt.Errorf("Could not remote-load EP11 library [%s]\n Remote Response: <%+v>", err, r)
+	}
+	if r.Error != "" {
+		return fmt.Errorf("Remote Load call reports error: %s", r.Error)
+	}
+
+	if r.Session == false {
+		// Ran out of sessions!!
+		if !isNewPin && len(pin) != 0 && len(nonce) != 0 {
+			// This is bad! Existing keys are inaccessible.
+			return fmt.Errorf("Failed to log in into EP11 session. Crypto material inaccessible.")
+		}
+
+		// Carry on with reduced container isolation.
+		logger.Warningf("ep11server ran out of sessions!! Using Domain Master key to encrypt/decrypt key material.")
+		pin = nil
+		nonce = nil
+	}
+
+	if isNewPin {
+		err = csp.ks.(*hsmBasedKeyStore).storePinAndNonce(pin, nonce)
+		if err != nil {
+			return fmt.Errorf("Failed storing PIN and nonce [%s]", err)
+		}
+	}
+
+	// Setup timeout context for server connection
+	srvrCtx, cancelSrvrConn := context.WithTimeout(context.Background(), time.Second*10)
+	defer cancelSrvrConn()
+
+	srvrConn, err := grpc.DialContext(srvrCtx, r.Address, grpc.WithInsecure(), grpc.WithBlock())
+	if err != nil {
+		return fmt.Errorf("Failed connecting to GREP11 dedicated connection at %s [%s]", r.Address, err)
+	}
+
+	logger.Infof("Connected to a dedicated crypto Server connection at %s", r.Address)
+
+	csp.grepClient = pb.NewGrep11Client(srvrConn)
+	csp.clientConnection = srvrConn
+	return nil
+}
+
+// KeyGen generates a key using opts.
+func (csp *impl) KeyGen(opts bccsp.KeyGenOpts) (k bccsp.Key, err error) {
+	// Validate arguments
+	if opts == nil {
+		return nil, errors.New("Invalid Opts parameter. It must not be nil.")
+	}
+
+	// Parse algorithm
+	switch opts.(type) {
+	case *bccsp.ECDSAKeyGenOpts:
+		k, err = csp.generateECKey(csp.conf.ellipticCurve, opts.Ephemeral())
+		if err != nil {
+			return nil, fmt.Errorf("Failed generating ECDSA key [%s]", err)
+		}
+
+	case *bccsp.ECDSAP256KeyGenOpts:
+		k, err = csp.generateECKey(oidNamedCurveP256, opts.Ephemeral())
+		if err != nil {
+			return nil, fmt.Errorf("Failed generating ECDSA P256 key [%s]", err)
+		}
+
+	case *bccsp.ECDSAP384KeyGenOpts:
+		k, err = csp.generateECKey(oidNamedCurveP384, opts.Ephemeral())
+		if err != nil {
+			return nil, fmt.Errorf("Failed generating ECDSA P384 key [%s]", err)
+		}
+
+	default:
+		return csp.BCCSP.KeyGen(opts)
+	}
+
+	if !opts.Ephemeral() {
+		err := csp.ks.StoreKey(k)
+		if err != nil {
+			return nil, fmt.Errorf("Failed storing key [%s]", err)
+		}
+	}
+
+	return k, nil
+}
+
+// KeyDeriv derives a key from k using opts.
+// The opts argument should be appropriate for the primitive used.
+func (csp *impl) KeyDeriv(k bccsp.Key, opts bccsp.KeyDerivOpts) (dk bccsp.Key, err error) {
+	// Validate arguments
+	if k == nil {
+		return nil, errors.New("Invalid Key. It must not be nil.")
+	}
+
+	// Derive key
+	switch k.(type) {
+	case *ecdsaPrivateKey:
+		return nil, fmt.Errorf("Key Derrivation not implemented with HSM Private keys yet")
+
+	default:
+		return csp.BCCSP.KeyDeriv(k, opts)
+
+	}
+}
+
+// KeyImport imports a key from its raw representation using opts.
+// The opts argument should be appropriate for the primitive used.
+func (csp *impl) KeyImport(raw interface{}, opts bccsp.KeyImportOpts) (k bccsp.Key, err error) {
+	// Validate arguments
+	if raw == nil {
+		return nil, errors.New("Invalid raw. Cannot be nil.")
+	}
+
+	if opts == nil {
+		return nil, errors.New("Invalid Opts parameter. It must not be nil.")
+	}
+
+	swK, err := csp.BCCSP.KeyImport(raw, opts)
+	if err != nil {
+		return nil, err
+	}
+
+	if swK.Symmetric() {
+		// No support for symmetric keys yet, use clear keys for now
+		return swK, nil
+	}
+
+	if swK.Private() {
+		return nil, errors.New("Importing Private Key into GREP11 provider is not allowed.")
+	}
+
+	// Must be public key, see if its an ECDSA key
+	pubKeyBytes, err := swK.Bytes()
+	if err != nil {
+		return nil, fmt.Errorf("Failed marshalling public key [%s]", err)
+	}
+
+	pk, err := utils.DERToPublicKey(pubKeyBytes)
+	if err != nil {
+		return nil, fmt.Errorf("Failed marshalling der to public key [%s]", err)
+	}
+
+	switch k := pk.(type) {
+	case *ecdsa.PublicKey:
+		if k == nil {
+			return nil, errors.New("Invalid ecdsa public key. It must be different from nil.")
+		}
+
+		pubKeyBlob, err := pubKeyToBlob(k)
+		if err != nil {
+			return nil, fmt.Errorf("Failed marshaling HSM pubKeyBlob [%s]", err)
+		}
+		return &ecdsaPublicKey{swK.SKI(), pubKeyBlob, k}, nil
+
+	default:
+		return swK, nil
+	}
+}
+
+// GetKey returns the key this CSP associates to
+// the Subject Key Identifier ski.
+func (csp *impl) GetKey(ski []byte) (k bccsp.Key, err error) {
+	if metrics.IsDebug() {
+		stopWatch := metrics.RootScope.Timer("crypto_grep11_getkey_time_seconds").Start()
+		defer stopWatch.Stop()
+	}
+	return csp.ks.GetKey(ski)
+}
+
+// Sign signs digest using key k.
+// The opts argument should be appropriate for the primitive used.
+//
+// Note that when a signature of a hash of a larger message is needed,
+// the caller is responsible for hashing the larger message and passing
+// the hash (as digest).
+func (csp *impl) Sign(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) (signature []byte, err error) {
+	if metrics.IsDebug() {
+		stopWatch := metrics.RootScope.Timer("crypto_grep11_sign_time_seconds").Start()
+		defer stopWatch.Stop()
+	}
+	// Validate arguments
+	if k == nil {
+		return nil, errors.New("Invalid Key. It must not be nil.")
+	}
+	if len(digest) == 0 {
+		return nil, errors.New("Invalid digest. Cannot be empty.")
+	}
+
+	// Check key type
+	switch k.(type) {
+	case *ecdsaPrivateKey:
+		return csp.signECDSA(*k.(*ecdsaPrivateKey), digest, opts)
+	case *ecdsaPublicKey:
+		return nil, errors.New("Cannot sign with a grep11.ecdsaPublicKey")
+	default:
+		return csp.BCCSP.Sign(k, digest, opts)
+	}
+}
+
+// Verify verifies signature against key k and digest
+func (csp *impl) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (valid bool, err error) {
+	if metrics.IsDebug() {
+		stopWatch := metrics.RootScope.Timer("crypto_grep11_verify_time_seconds").Start()
+		defer stopWatch.Stop()
+	}
+	// Validate arguments
+	if k == nil {
+		return false, errors.New("Invalid Key. It must not be nil.")
+	}
+	if len(signature) == 0 {
+		return false, errors.New("Invalid signature. Cannot be empty.")
+	}
+	if len(digest) == 0 {
+		return false, errors.New("Invalid digest. Cannot be empty.")
+	}
+
+	// Check key type
+	switch k.(type) {
+	case *ecdsaPrivateKey:
+		return csp.verifyECDSA(*k.(*ecdsaPrivateKey).pub, signature, digest, opts)
+	case *ecdsaPublicKey:
+		return csp.verifyECDSA(*k.(*ecdsaPublicKey), signature, digest, opts)
+	default:
+		return csp.BCCSP.Verify(k, signature, digest, opts)
+	}
+}
+
+// Encrypt encrypts plaintext using key k.
+// The opts argument should be appropriate for the primitive used.
+func (csp *impl) Encrypt(k bccsp.Key, plaintext []byte, opts bccsp.EncrypterOpts) (ciphertext []byte, err error) {
+	if metrics.IsDebug() {
+		stopWatch := metrics.RootScope.Timer("crypto_grep11_encrypt_time_seconds").Start()
+		defer stopWatch.Stop()
+	}
+	// TODO: Add PKCS11 support for encryption, when fabric starts requiring it
+	return csp.BCCSP.Encrypt(k, plaintext, opts)
+}
+
+// Decrypt decrypts ciphertext using key k.
+// The opts argument should be appropriate for the primitive used.
+func (csp *impl) Decrypt(k bccsp.Key, ciphertext []byte, opts bccsp.DecrypterOpts) (plaintext []byte, err error) {
+	if metrics.IsDebug() {
+		stopWatch := metrics.RootScope.Timer("crypto_grep11_decrypt_time_seconds").Start()
+		defer stopWatch.Stop()
+	}
+	return csp.BCCSP.Decrypt(k, ciphertext, opts)
+}
diff --git a/bccsp/grep11/protos/grep11.pb.go b/bccsp/grep11/protos/grep11.pb.go
new file mode 100644
index 000000000..158608f8a
--- /dev/null
+++ b/bccsp/grep11/protos/grep11.pb.go
@@ -0,0 +1,491 @@
+// Code generated by protoc-gen-go. DO NOT EDIT.
+// source: grep11.proto
+
+/*
+Package grep11protos is a generated protocol buffer package.
+
+It is generated from these files:
+	grep11.proto
+
+It has these top-level messages:
+	LoadInfo
+	LoadStatus
+	GenerateInfo
+	GenerateStatus
+	SignInfo
+	SignStatus
+	VerifyInfo
+	VerifyStatus
+*/
+package grep11protos
+
+import proto "github.com/golang/protobuf/proto"
+import fmt "fmt"
+import math "math"
+
+import (
+	context "golang.org/x/net/context"
+	grpc "google.golang.org/grpc"
+)
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the proto package it is being compiled against.
+// A compilation error at this line likely means your copy of the
+// proto package needs to be updated.
+const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package
+
+type LoadInfo struct {
+	Pin   []byte `protobuf:"bytes,1,opt,name=pin,proto3" json:"pin,omitempty"`
+	Nonce []byte `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
+}
+
+func (m *LoadInfo) Reset()                    { *m = LoadInfo{} }
+func (m *LoadInfo) String() string            { return proto.CompactTextString(m) }
+func (*LoadInfo) ProtoMessage()               {}
+func (*LoadInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }
+
+func (m *LoadInfo) GetPin() []byte {
+	if m != nil {
+		return m.Pin
+	}
+	return nil
+}
+
+func (m *LoadInfo) GetNonce() []byte {
+	if m != nil {
+		return m.Nonce
+	}
+	return nil
+}
+
+type LoadStatus struct {
+	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
+	Session bool   `protobuf:"varint,2,opt,name=session" json:"session,omitempty"`
+	Error   string `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
+}
+
+func (m *LoadStatus) Reset()                    { *m = LoadStatus{} }
+func (m *LoadStatus) String() string            { return proto.CompactTextString(m) }
+func (*LoadStatus) ProtoMessage()               {}
+func (*LoadStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }
+
+func (m *LoadStatus) GetAddress() string {
+	if m != nil {
+		return m.Address
+	}
+	return ""
+}
+
+func (m *LoadStatus) GetSession() bool {
+	if m != nil {
+		return m.Session
+	}
+	return false
+}
+
+func (m *LoadStatus) GetError() string {
+	if m != nil {
+		return m.Error
+	}
+	return ""
+}
+
+type GenerateInfo struct {
+	Oid []byte `protobuf:"bytes,1,opt,name=oid,proto3" json:"oid,omitempty"`
+}
+
+func (m *GenerateInfo) Reset()                    { *m = GenerateInfo{} }
+func (m *GenerateInfo) String() string            { return proto.CompactTextString(m) }
+func (*GenerateInfo) ProtoMessage()               {}
+func (*GenerateInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }
+
+func (m *GenerateInfo) GetOid() []byte {
+	if m != nil {
+		return m.Oid
+	}
+	return nil
+}
+
+type GenerateStatus struct {
+	PrivKey []byte `protobuf:"bytes,1,opt,name=privKey,proto3" json:"privKey,omitempty"`
+	PubKey  []byte `protobuf:"bytes,2,opt,name=pubKey,proto3" json:"pubKey,omitempty"`
+	Error   string `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
+}
+
+func (m *GenerateStatus) Reset()                    { *m = GenerateStatus{} }
+func (m *GenerateStatus) String() string            { return proto.CompactTextString(m) }
+func (*GenerateStatus) ProtoMessage()               {}
+func (*GenerateStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }
+
+func (m *GenerateStatus) GetPrivKey() []byte {
+	if m != nil {
+		return m.PrivKey
+	}
+	return nil
+}
+
+func (m *GenerateStatus) GetPubKey() []byte {
+	if m != nil {
+		return m.PubKey
+	}
+	return nil
+}
+
+func (m *GenerateStatus) GetError() string {
+	if m != nil {
+		return m.Error
+	}
+	return ""
+}
+
+type SignInfo struct {
+	PrivKey []byte `protobuf:"bytes,1,opt,name=privKey,proto3" json:"privKey,omitempty"`
+	Hash    []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
+}
+
+func (m *SignInfo) Reset()                    { *m = SignInfo{} }
+func (m *SignInfo) String() string            { return proto.CompactTextString(m) }
+func (*SignInfo) ProtoMessage()               {}
+func (*SignInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }
+
+func (m *SignInfo) GetPrivKey() []byte {
+	if m != nil {
+		return m.PrivKey
+	}
+	return nil
+}
+
+func (m *SignInfo) GetHash() []byte {
+	if m != nil {
+		return m.Hash
+	}
+	return nil
+}
+
+type SignStatus struct {
+	Sig   []byte `protobuf:"bytes,1,opt,name=sig,proto3" json:"sig,omitempty"`
+	Error string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
+}
+
+func (m *SignStatus) Reset()                    { *m = SignStatus{} }
+func (m *SignStatus) String() string            { return proto.CompactTextString(m) }
+func (*SignStatus) ProtoMessage()               {}
+func (*SignStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }
+
+func (m *SignStatus) GetSig() []byte {
+	if m != nil {
+		return m.Sig
+	}
+	return nil
+}
+
+func (m *SignStatus) GetError() string {
+	if m != nil {
+		return m.Error
+	}
+	return ""
+}
+
+type VerifyInfo struct {
+	PubKey []byte `protobuf:"bytes,1,opt,name=pubKey,proto3" json:"pubKey,omitempty"`
+	Hash   []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
+	Sig    []byte `protobuf:"bytes,3,opt,name=sig,proto3" json:"sig,omitempty"`
+}
+
+func (m *VerifyInfo) Reset()                    { *m = VerifyInfo{} }
+func (m *VerifyInfo) String() string            { return proto.CompactTextString(m) }
+func (*VerifyInfo) ProtoMessage()               {}
+func (*VerifyInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }
+
+func (m *VerifyInfo) GetPubKey() []byte {
+	if m != nil {
+		return m.PubKey
+	}
+	return nil
+}
+
+func (m *VerifyInfo) GetHash() []byte {
+	if m != nil {
+		return m.Hash
+	}
+	return nil
+}
+
+func (m *VerifyInfo) GetSig() []byte {
+	if m != nil {
+		return m.Sig
+	}
+	return nil
+}
+
+type VerifyStatus struct {
+	Valid bool   `protobuf:"varint,1,opt,name=valid" json:"valid,omitempty"`
+	Error string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
+}
+
+func (m *VerifyStatus) Reset()                    { *m = VerifyStatus{} }
+func (m *VerifyStatus) String() string            { return proto.CompactTextString(m) }
+func (*VerifyStatus) ProtoMessage()               {}
+func (*VerifyStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }
+
+func (m *VerifyStatus) GetValid() bool {
+	if m != nil {
+		return m.Valid
+	}
+	return false
+}
+
+func (m *VerifyStatus) GetError() string {
+	if m != nil {
+		return m.Error
+	}
+	return ""
+}
+
+func init() {
+	proto.RegisterType((*LoadInfo)(nil), "grep11protos.LoadInfo")
+	proto.RegisterType((*LoadStatus)(nil), "grep11protos.LoadStatus")
+	proto.RegisterType((*GenerateInfo)(nil), "grep11protos.GenerateInfo")
+	proto.RegisterType((*GenerateStatus)(nil), "grep11protos.GenerateStatus")
+	proto.RegisterType((*SignInfo)(nil), "grep11protos.SignInfo")
+	proto.RegisterType((*SignStatus)(nil), "grep11protos.SignStatus")
+	proto.RegisterType((*VerifyInfo)(nil), "grep11protos.VerifyInfo")
+	proto.RegisterType((*VerifyStatus)(nil), "grep11protos.VerifyStatus")
+}
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ context.Context
+var _ grpc.ClientConn
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the grpc package it is being compiled against.
+const _ = grpc.SupportPackageIsVersion4
+
+// Client API for Grep11Manager service
+
+type Grep11ManagerClient interface {
+	Load(ctx context.Context, in *LoadInfo, opts ...grpc.CallOption) (*LoadStatus, error)
+}
+
+type grep11ManagerClient struct {
+	cc *grpc.ClientConn
+}
+
+func NewGrep11ManagerClient(cc *grpc.ClientConn) Grep11ManagerClient {
+	return &grep11ManagerClient{cc}
+}
+
+func (c *grep11ManagerClient) Load(ctx context.Context, in *LoadInfo, opts ...grpc.CallOption) (*LoadStatus, error) {
+	out := new(LoadStatus)
+	err := grpc.Invoke(ctx, "/grep11protos.Grep11Manager/Load", in, out, c.cc, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
+// Server API for Grep11Manager service
+
+type Grep11ManagerServer interface {
+	Load(context.Context, *LoadInfo) (*LoadStatus, error)
+}
+
+func RegisterGrep11ManagerServer(s *grpc.Server, srv Grep11ManagerServer) {
+	s.RegisterService(&_Grep11Manager_serviceDesc, srv)
+}
+
+func _Grep11Manager_Load_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(LoadInfo)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(Grep11ManagerServer).Load(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/grep11protos.Grep11Manager/Load",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(Grep11ManagerServer).Load(ctx, req.(*LoadInfo))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
+var _Grep11Manager_serviceDesc = grpc.ServiceDesc{
+	ServiceName: "grep11protos.Grep11Manager",
+	HandlerType: (*Grep11ManagerServer)(nil),
+	Methods: []grpc.MethodDesc{
+		{
+			MethodName: "Load",
+			Handler:    _Grep11Manager_Load_Handler,
+		},
+	},
+	Streams:  []grpc.StreamDesc{},
+	Metadata: "grep11.proto",
+}
+
+// Client API for Grep11 service
+
+type Grep11Client interface {
+	GenerateECKey(ctx context.Context, in *GenerateInfo, opts ...grpc.CallOption) (*GenerateStatus, error)
+	SignP11ECDSA(ctx context.Context, in *SignInfo, opts ...grpc.CallOption) (*SignStatus, error)
+	VerifyP11ECDSA(ctx context.Context, in *VerifyInfo, opts ...grpc.CallOption) (*VerifyStatus, error)
+}
+
+type grep11Client struct {
+	cc *grpc.ClientConn
+}
+
+func NewGrep11Client(cc *grpc.ClientConn) Grep11Client {
+	return &grep11Client{cc}
+}
+
+func (c *grep11Client) GenerateECKey(ctx context.Context, in *GenerateInfo, opts ...grpc.CallOption) (*GenerateStatus, error) {
+	out := new(GenerateStatus)
+	err := grpc.Invoke(ctx, "/grep11protos.Grep11/GenerateECKey", in, out, c.cc, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
+func (c *grep11Client) SignP11ECDSA(ctx context.Context, in *SignInfo, opts ...grpc.CallOption) (*SignStatus, error) {
+	out := new(SignStatus)
+	err := grpc.Invoke(ctx, "/grep11protos.Grep11/SignP11ECDSA", in, out, c.cc, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
+func (c *grep11Client) VerifyP11ECDSA(ctx context.Context, in *VerifyInfo, opts ...grpc.CallOption) (*VerifyStatus, error) {
+	out := new(VerifyStatus)
+	err := grpc.Invoke(ctx, "/grep11protos.Grep11/VerifyP11ECDSA", in, out, c.cc, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
+// Server API for Grep11 service
+
+type Grep11Server interface {
+	GenerateECKey(context.Context, *GenerateInfo) (*GenerateStatus, error)
+	SignP11ECDSA(context.Context, *SignInfo) (*SignStatus, error)
+	VerifyP11ECDSA(context.Context, *VerifyInfo) (*VerifyStatus, error)
+}
+
+func RegisterGrep11Server(s *grpc.Server, srv Grep11Server) {
+	s.RegisterService(&_Grep11_serviceDesc, srv)
+}
+
+func _Grep11_GenerateECKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(GenerateInfo)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(Grep11Server).GenerateECKey(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/grep11protos.Grep11/GenerateECKey",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(Grep11Server).GenerateECKey(ctx, req.(*GenerateInfo))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
+func _Grep11_SignP11ECDSA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(SignInfo)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(Grep11Server).SignP11ECDSA(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/grep11protos.Grep11/SignP11ECDSA",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(Grep11Server).SignP11ECDSA(ctx, req.(*SignInfo))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
+func _Grep11_VerifyP11ECDSA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(VerifyInfo)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(Grep11Server).VerifyP11ECDSA(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/grep11protos.Grep11/VerifyP11ECDSA",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(Grep11Server).VerifyP11ECDSA(ctx, req.(*VerifyInfo))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
+var _Grep11_serviceDesc = grpc.ServiceDesc{
+	ServiceName: "grep11protos.Grep11",
+	HandlerType: (*Grep11Server)(nil),
+	Methods: []grpc.MethodDesc{
+		{
+			MethodName: "GenerateECKey",
+			Handler:    _Grep11_GenerateECKey_Handler,
+		},
+		{
+			MethodName: "SignP11ECDSA",
+			Handler:    _Grep11_SignP11ECDSA_Handler,
+		},
+		{
+			MethodName: "VerifyP11ECDSA",
+			Handler:    _Grep11_VerifyP11ECDSA_Handler,
+		},
+	},
+	Streams:  []grpc.StreamDesc{},
+	Metadata: "grep11.proto",
+}
+
+func init() { proto.RegisterFile("grep11.proto", fileDescriptor0) }
+
+var fileDescriptor0 = []byte{
+	// 380 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x74, 0x52, 0x4f, 0xeb, 0xda, 0x30,
+	0x18, 0xb6, 0x56, 0x5d, 0xf7, 0xd2, 0x89, 0x04, 0x91, 0x52, 0x76, 0x90, 0x9c, 0x76, 0x12, 0xea,
+	0x76, 0x18, 0xde, 0x36, 0x27, 0x6e, 0x73, 0x83, 0x51, 0x41, 0x76, 0x8d, 0x6b, 0xac, 0x81, 0x91,
+	0x94, 0xa4, 0x0a, 0x7e, 0xde, 0x7d, 0x91, 0x91, 0x7f, 0x56, 0xfd, 0xd5, 0x5b, 0x9f, 0xbc, 0x79,
+	0xfe, 0x34, 0xcf, 0x0b, 0x71, 0x29, 0x69, 0x95, 0x65, 0xb3, 0x4a, 0x8a, 0x5a, 0x20, 0x87, 0x0c,
+	0x50, 0x78, 0x0e, 0xd1, 0x0f, 0x41, 0x8a, 0x6f, 0xfc, 0x20, 0xd0, 0x08, 0xc2, 0x8a, 0xf1, 0x24,
+	0x98, 0x06, 0xef, 0xe2, 0x5c, 0x7f, 0xa2, 0x31, 0xf4, 0xb9, 0xe0, 0x7f, 0x68, 0xd2, 0x35, 0x67,
+	0x16, 0xe0, 0x1d, 0x80, 0xe6, 0x6c, 0x6b, 0x52, 0x9f, 0x14, 0x4a, 0xe0, 0x15, 0x29, 0x0a, 0x49,
+	0x95, 0x32, 0xcc, 0xd7, 0xb9, 0x87, 0x7a, 0xa2, 0xa8, 0x52, 0x4c, 0x70, 0xc3, 0x8f, 0x72, 0x0f,
+	0xb5, 0x2e, 0x95, 0x52, 0xc8, 0x24, 0x34, 0x0c, 0x0b, 0xf0, 0x14, 0xe2, 0x35, 0xe5, 0x54, 0x92,
+	0x9a, 0xfa, 0x3c, 0x82, 0x15, 0x3e, 0x8f, 0x60, 0x05, 0xfe, 0x0d, 0x43, 0x7f, 0xa3, 0x71, 0xaf,
+	0x24, 0x3b, 0x6f, 0xe8, 0xc5, 0xdd, 0xf3, 0x10, 0x4d, 0x60, 0x50, 0x9d, 0xf6, 0x7a, 0x60, 0xc3,
+	0x3b, 0xf4, 0xc4, 0xfb, 0x23, 0x44, 0x5b, 0x56, 0x72, 0xe3, 0xfb, 0x5c, 0x13, 0x41, 0xef, 0x48,
+	0xd4, 0xd1, 0x29, 0x9a, 0x6f, 0xfc, 0x01, 0x40, 0x33, 0x5d, 0x9e, 0x11, 0x84, 0x8a, 0x95, 0x3e,
+	0xb3, 0x62, 0x65, 0xe3, 0xd7, 0xbd, 0xf5, 0xfb, 0x0e, 0xb0, 0xa3, 0x92, 0x1d, 0x2e, 0xc6, 0xb1,
+	0xc9, 0x1a, 0xdc, 0x65, 0x6d, 0xf1, 0xf3, 0x0e, 0xe1, 0xd5, 0x01, 0x2f, 0x20, 0xb6, 0x5a, 0x2e,
+	0xc3, 0x18, 0xfa, 0x67, 0xf2, 0xd7, 0xbd, 0x5c, 0x94, 0x5b, 0xd0, 0x9e, 0x63, 0xbe, 0x81, 0x37,
+	0x6b, 0xb3, 0x0f, 0x3f, 0x09, 0x27, 0x25, 0x95, 0x68, 0x01, 0x3d, 0x5d, 0x2e, 0x9a, 0xcc, 0x6e,
+	0xf7, 0x64, 0xe6, 0x97, 0x24, 0x4d, 0x5e, 0x9e, 0x5b, 0x5b, 0xdc, 0x99, 0xff, 0x0b, 0x60, 0x60,
+	0xd5, 0x90, 0xd6, 0x75, 0x4d, 0xad, 0x96, 0xfa, 0x57, 0xd2, 0x7b, 0xde, 0x6d, 0xd1, 0xe9, 0xdb,
+	0xf6, 0x99, 0xd7, 0x45, 0x9f, 0x21, 0xd6, 0x4f, 0xfc, 0x2b, 0xcb, 0x56, 0xcb, 0x2f, 0xdb, 0x4f,
+	0x8f, 0xd9, 0x7c, 0x71, 0x8f, 0xd9, 0x9a, 0x5a, 0x70, 0x07, 0x7d, 0x85, 0xa1, 0x7d, 0xa4, 0xab,
+	0xca, 0xc3, 0xed, 0xa6, 0x8e, 0x34, 0x6d, 0x9b, 0x78, 0xa5, 0xfd, 0xc0, 0x1c, 0xbf, 0xff, 0x1f,
+	0x00, 0x00, 0xff, 0xff, 0x8f, 0x09, 0x3d, 0x44, 0x57, 0x03, 0x00, 0x00,
+}
diff --git a/bccsp/grep11/protos/grep11.proto b/bccsp/grep11/protos/grep11.proto
new file mode 100644
index 000000000..5dde39cb7
--- /dev/null
+++ b/bccsp/grep11/protos/grep11.proto
@@ -0,0 +1,70 @@
+/*
+Copyright IBM Corp. 2016 All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+syntax = "proto3";
+
+package grep11protos;
+
+service Grep11Manager {
+	rpc Load(LoadInfo) returns (LoadStatus) {}
+}
+
+service Grep11 {
+	rpc GenerateECKey(GenerateInfo) returns (GenerateStatus) {}
+	rpc SignP11ECDSA(SignInfo) returns (SignStatus) {}
+	rpc VerifyP11ECDSA(VerifyInfo) returns (VerifyStatus) {}
+}
+
+message LoadInfo {
+	bytes pin = 1;
+	bytes nonce = 2;
+}
+
+message LoadStatus {
+	string address = 1;
+	bool session = 2;
+	string error = 3;
+}
+
+message GenerateInfo {
+	bytes oid = 1;
+}
+
+message GenerateStatus {
+	bytes privKey = 1;
+	bytes pubKey = 2;
+	string error = 3;
+}
+
+message SignInfo {
+	bytes privKey = 1;
+	bytes hash = 2;
+}
+
+message SignStatus {
+	bytes sig = 1;
+	string error = 2;
+}
+
+message VerifyInfo {
+	bytes pubKey = 1;
+	bytes hash = 2;
+	bytes sig = 3;
+}
+
+message VerifyStatus {
+	bool valid = 1;
+	string error = 2;
+}
-- 
2.15.2 (Apple Git-101.1)

