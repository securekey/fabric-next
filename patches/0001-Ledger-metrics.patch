From c94fbbc83bc2c3b306537a90679148061593972f Mon Sep 17 00:00:00 2001
From: Aleksandar Likic <aleksandar.likic@securekey.com>
Date: Thu, 9 Aug 2018 18:21:13 -0400
Subject: [PATCH] Ledger metrics

Change-Id: I994680bb548eb9abd70c4aba33df024080bcdaae
Signed-off-by: Aleksandar Likic <aleksandar.likic@securekey.com>
---
 .../ledger/blkstorage/fsblkstorage/blocks_itr.go   |  10 +
 common/metrics/server.go                           | 246 +++++------
 common/metrics/server_test.go                      | 242 -----------
 common/metrics/tally_provider.go                   | 372 ++---------------
 common/metrics/tally_provider_test.go              | 462 ---------------------
 common/metrics/types.go                            |  45 --
 core/endorser/endorser.go                          |  43 +-
 core/ledger/ledgerstorage/store.go                 |  18 +
 util/concurrent/futurevalue/futurevalue.go         | 102 +++++
 util/concurrent/lazycache/keys.go                  |  22 +
 util/concurrent/lazycache/lazycache.go             | 258 ++++++++++++
 util/concurrent/lazycache/refoptcheck.go           |  38 ++
 util/concurrent/lazyref/expiration.go              |  32 ++
 util/concurrent/lazyref/lazyref.go                 | 375 +++++++++++++++++
 util/concurrent/lazyref/options.go                 | 133 ++++++
 util/concurrent/options/options.go                 |  21 +
 16 files changed, 1223 insertions(+), 1196 deletions(-)
 delete mode 100644 common/metrics/server_test.go
 delete mode 100644 common/metrics/tally_provider_test.go
 delete mode 100644 common/metrics/types.go
 create mode 100644 util/concurrent/futurevalue/futurevalue.go
 create mode 100644 util/concurrent/lazycache/keys.go
 create mode 100644 util/concurrent/lazycache/lazycache.go
 create mode 100644 util/concurrent/lazycache/refoptcheck.go
 create mode 100644 util/concurrent/lazyref/expiration.go
 create mode 100644 util/concurrent/lazyref/lazyref.go
 create mode 100644 util/concurrent/lazyref/options.go
 create mode 100644 util/concurrent/options/options.go

diff --git a/common/ledger/blkstorage/fsblkstorage/blocks_itr.go b/common/ledger/blkstorage/fsblkstorage/blocks_itr.go
index 7ebe52af9..1d16a7544 100644
--- a/common/ledger/blkstorage/fsblkstorage/blocks_itr.go
+++ b/common/ledger/blkstorage/fsblkstorage/blocks_itr.go
@@ -20,8 +20,16 @@ import (
 	"sync"
 
 	"github.com/hyperledger/fabric/common/ledger"
+	"github.com/hyperledger/fabric/common/metrics"
+	"github.com/uber-go/tally"
 )
 
+var waitForBlockTimer tally.Timer
+
+func init() {
+	waitForBlockTimer = metrics.RootScope.Timer("fsblkstorage_waitForBlock_time_seconds")
+}
+
 // blocksItr - an iterator for iterating over a sequence of blocks
 type blocksItr struct {
 	mgr                  *blockfileMgr
@@ -37,6 +45,8 @@ func newBlockItr(mgr *blockfileMgr, startBlockNum uint64) *blocksItr {
 }
 
 func (itr *blocksItr) waitForBlock(blockNum uint64) uint64 {
+	stopWatch := waitForBlockTimer.Start()
+	defer stopWatch.Stop()
 	itr.mgr.cpInfoCond.L.Lock()
 	defer itr.mgr.cpInfoCond.L.Unlock()
 	for itr.mgr.cpInfo.lastBlockNumber < blockNum && !itr.shouldClose() {
diff --git a/common/metrics/server.go b/common/metrics/server.go
index 677151e78..eb9422f12 100644
--- a/common/metrics/server.go
+++ b/common/metrics/server.go
@@ -8,11 +8,19 @@ package metrics
 
 import (
 	"fmt"
-	"sync"
+	"io"
 	"time"
 
+	"sync"
+
+	"strings"
+
+	"runtime"
+
+	"github.com/pkg/errors"
 	"github.com/spf13/viper"
 	"github.com/uber-go/tally"
+	promreporter "github.com/uber-go/tally/prometheus"
 )
 
 const (
@@ -28,21 +36,93 @@ const (
 	defaultStatsdReporterFlushBytes    = 1432
 )
 
-var RootScope Scope
-var once sync.Once
+const (
+	peerConfigFileName = "core"
+	peerConfigPath     = "/etc/hyperledger/fabric"
+	cmdRootPrefix      = "core"
+)
+
+var peerConfig *viper.Viper
+var peerConfigPathOverride string
+
+// RootScope tally.NoopScope is a scope that does nothing
+var RootScope = tally.NoopScope
 var rootScopeMutex = &sync.Mutex{}
 var running bool
 
-// NewOpts create metrics options based config file
-func NewOpts() Opts {
+// StatsdReporterOpts ...
+type StatsdReporterOpts struct {
+	Address       string
+	FlushInterval time.Duration
+	FlushBytes    int
+}
+
+// PromReporterOpts ...
+type PromReporterOpts struct {
+	ListenAddress string
+}
+
+// Opts ...
+type Opts struct {
+	Reporter           string
+	Interval           time.Duration
+	Enabled            bool
+	StatsdReporterOpts StatsdReporterOpts
+	PromReporterOpts   PromReporterOpts
+}
+
+func init() {
+
+	// load peer config
+	if err := initPeerConfig(); err != nil {
+		panic(fmt.Sprintf("error initPeerConfig %v", err))
+	}
+
+	if peerConfig.GetBool("peer.profile.enabled") {
+		runtime.SetMutexProfileFraction(5)
+	}
+
+	// start metric server
+	opts := NewOpts(peerConfig)
+	err := Start(opts)
+	if err != nil {
+		logger.Errorf("Failed to start metrics collection: %s", err)
+	}
+
+	logger.Info("Fabric Bootstrap filter initialized")
+}
+
+func initPeerConfig() error {
+	peerConfig = viper.New()
+	peerConfig.AddConfigPath(peerConfigPath)
+	if peerConfigPathOverride != "" {
+		peerConfig.AddConfigPath(peerConfigPathOverride)
+	}
+	peerConfig.SetConfigName(peerConfigFileName)
+	peerConfig.SetEnvPrefix(cmdRootPrefix)
+	peerConfig.AutomaticEnv()
+	peerConfig.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
+	err := peerConfig.ReadInConfig()
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// NewOpts create metrics options based config file.
+// TODO: Currently this is only for peer node which uses global viper.
+// As for orderer, which uses its local viper, we are unable to get
+// metrics options with the function NewOpts()
+func NewOpts(peerConfig *viper.Viper) Opts {
 	opts := Opts{}
-	opts.Enabled = viper.GetBool("metrics.enabled")
-	if report := viper.GetString("metrics.reporter"); report != "" {
+	opts.Enabled = peerConfig.GetBool("metrics.enabled")
+	if report := peerConfig.GetString("metrics.reporter"); report != "" {
 		opts.Reporter = report
 	} else {
 		opts.Reporter = defaultReporterType
 	}
-	if interval := viper.GetDuration("metrics.interval"); interval > 0 {
+	if interval := peerConfig.GetDuration("metrics.interval"); interval > 0 {
 		opts.Interval = interval
 	} else {
 		opts.Interval = defaultInterval
@@ -50,13 +130,13 @@ func NewOpts() Opts {
 
 	if opts.Reporter == statsdReporterType {
 		statsdOpts := StatsdReporterOpts{}
-		statsdOpts.Address = viper.GetString("metrics.statsdReporter.address")
-		if flushInterval := viper.GetDuration("metrics.statsdReporter.flushInterval"); flushInterval > 0 {
+		statsdOpts.Address = peerConfig.GetString("metrics.statsdReporter.address")
+		if flushInterval := peerConfig.GetDuration("metrics.statsdReporter.flushInterval"); flushInterval > 0 {
 			statsdOpts.FlushInterval = flushInterval
 		} else {
 			statsdOpts.FlushInterval = defaultStatsdReporterFlushInterval
 		}
-		if flushBytes := viper.GetInt("metrics.statsdReporter.flushBytes"); flushBytes > 0 {
+		if flushBytes := peerConfig.GetInt("metrics.statsdReporter.flushBytes"); flushBytes > 0 {
 			statsdOpts.FlushBytes = flushBytes
 		} else {
 			statsdOpts.FlushBytes = defaultStatsdReporterFlushBytes
@@ -66,45 +146,47 @@ func NewOpts() Opts {
 
 	if opts.Reporter == promReporterType {
 		promOpts := PromReporterOpts{}
-		promOpts.ListenAddress = viper.GetString("metrics.promReporter.listenAddress")
+		promOpts.ListenAddress = peerConfig.GetString("metrics.fabric.PromReporter.listenAddress")
 		opts.PromReporterOpts = promOpts
 	}
 
 	return opts
 }
 
-//Init initializes global root metrics scope instance, all callers can only use it to extend sub scope
-func Init(opts Opts) (err error) {
-	once.Do(func() {
-		RootScope, err = create(opts)
-	})
-
-	return
-}
-
-//Start starts metrics server
-func Start() error {
+// Start starts metrics server
+func Start(opts Opts) error {
+	if !opts.Enabled {
+		return errors.New("Unable to start metrics server because is disbled")
+	}
 	rootScopeMutex.Lock()
 	defer rootScopeMutex.Unlock()
-	if running {
-		return nil
+	if !running {
+		rootScope, err := create(opts)
+		if err == nil {
+			running = true
+			RootScope = rootScope
+		}
+		return err
 	}
-	running = true
-	return RootScope.Start()
+	return errors.New("metrics server was already started")
 }
 
-//Shutdown closes underlying resources used by metrics server
+// Shutdown closes underlying resources used by metrics server
 func Shutdown() error {
 	rootScopeMutex.Lock()
 	defer rootScopeMutex.Unlock()
-	if !running {
-		return nil
+	if running {
+		var err error
+		if closer, ok := RootScope.(io.Closer); ok {
+			if err = closer.Close(); err != nil {
+				return err
+			}
+		}
+		running = false
+		RootScope = tally.NoopScope
+		return err
 	}
-
-	err := RootScope.Close()
-	RootScope = nil
-	running = false
-	return err
+	return nil
 }
 
 func isRunning() bool {
@@ -113,109 +195,35 @@ func isRunning() bool {
 	return running
 }
 
-type StatsdReporterOpts struct {
-	Address       string
-	FlushInterval time.Duration
-	FlushBytes    int
-}
-
-type PromReporterOpts struct {
-	ListenAddress string
-}
-
-type Opts struct {
-	Reporter           string
-	Interval           time.Duration
-	Enabled            bool
-	StatsdReporterOpts StatsdReporterOpts
-	PromReporterOpts   PromReporterOpts
-}
-
-type noOpCounter struct {
-}
-
-func (c *noOpCounter) Inc(v int64) {
-
-}
-
-type noOpGauge struct {
-}
-
-func (g *noOpGauge) Update(v float64) {
-
-}
-
-type noOpScope struct {
-	counter *noOpCounter
-	gauge   *noOpGauge
-}
-
-func (s *noOpScope) Counter(name string) Counter {
-	return s.counter
-}
-
-func (s *noOpScope) Gauge(name string) Gauge {
-	return s.gauge
-}
-
-func (s *noOpScope) Tagged(tags map[string]string) Scope {
-	return s
-}
-
-func (s *noOpScope) SubScope(prefix string) Scope {
-	return s
-}
-
-func (s *noOpScope) Close() error {
-	return nil
-}
-
-func (s *noOpScope) Start() error {
-	return nil
-}
-
-func newNoOpScope() Scope {
-	return &noOpScope{
-		counter: &noOpCounter{},
-		gauge:   &noOpGauge{},
-	}
-}
-
-func create(opts Opts) (rootScope Scope, e error) {
+func create(opts Opts) (rootScope tally.Scope, e error) {
 	if !opts.Enabled {
-		rootScope = newNoOpScope()
-		return
+		rootScope = tally.NoopScope
 	} else {
 		if opts.Interval <= 0 {
 			e = fmt.Errorf("invalid Interval option %d", opts.Interval)
 			return
 		}
-
-		if opts.Reporter != statsdReporterType && opts.Reporter != promReporterType {
-			e = fmt.Errorf("not supported Reporter type %s", opts.Reporter)
-			return
-		}
-
 		var reporter tally.StatsReporter
 		var cachedReporter tally.CachedStatsReporter
-		if opts.Reporter == statsdReporterType {
+		switch opts.Reporter {
+		case statsdReporterType:
 			reporter, e = newStatsdReporter(opts.StatsdReporterOpts)
-		}
-
-		if opts.Reporter == promReporterType {
+		case promReporterType:
 			cachedReporter, e = newPromReporter(opts.PromReporterOpts)
+		default:
+			e = fmt.Errorf("not supported Reporter type %s", opts.Reporter)
+			return
 		}
-
 		if e != nil {
 			return
 		}
-
 		rootScope = newRootScope(
 			tally.ScopeOptions{
 				Prefix:         namespace,
 				Reporter:       reporter,
 				CachedReporter: cachedReporter,
+				Separator:      promreporter.DefaultSeparator,
 			}, opts.Interval)
-		return
 	}
+	return
 }
diff --git a/common/metrics/server_test.go b/common/metrics/server_test.go
deleted file mode 100644
index 07d010ca8..000000000
--- a/common/metrics/server_test.go
+++ /dev/null
@@ -1,242 +0,0 @@
-/*
-Copyright IBM Corp. All Rights Reserved.
-
-SPDX-License-Identifier: Apache-2.0
-*/
-
-package metrics
-
-import (
-	"fmt"
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/hyperledger/fabric/core/config/configtest"
-	. "github.com/onsi/gomega"
-	"github.com/spf13/viper"
-	"github.com/stretchr/testify/assert"
-)
-
-func TestStartSuccessStatsd(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled:  true,
-		Reporter: statsdReporterType,
-		Interval: 1 * time.Second,
-		StatsdReporterOpts: StatsdReporterOpts{
-			Address:       "127.0.0.1:0",
-			FlushInterval: 2 * time.Second,
-			FlushBytes:    512,
-		}}
-	s, err := create(opts)
-	go s.Start()
-	defer s.Close()
-	assert.NotNil(t, s)
-	assert.NoError(t, err)
-}
-
-func TestStartSuccessProm(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled:  true,
-		Reporter: promReporterType,
-		Interval: 1 * time.Second,
-		PromReporterOpts: PromReporterOpts{
-			ListenAddress: "127.0.0.1:0",
-		}}
-	s, err := create(opts)
-	go s.Start()
-	defer s.Close()
-	assert.NotNil(t, s)
-	assert.NoError(t, err)
-}
-
-func TestStartDisabled(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled: false,
-	}
-	s, err := create(opts)
-	go s.Start()
-	defer s.Close()
-	assert.NotNil(t, s)
-	assert.NoError(t, err)
-}
-
-func TestStartInvalidInterval(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled:  true,
-		Interval: 0,
-	}
-	s, err := create(opts)
-	assert.Nil(t, s)
-	assert.Error(t, err)
-}
-
-func TestStartStatsdInvalidAddress(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled:  true,
-		Interval: 1 * time.Second,
-		Reporter: statsdReporterType,
-		StatsdReporterOpts: StatsdReporterOpts{
-			Address:       "",
-			FlushInterval: 2 * time.Second,
-			FlushBytes:    512,
-		},
-	}
-	s, err := create(opts)
-	assert.Nil(t, s)
-	assert.Error(t, err)
-}
-
-func TestStartStatsdInvalidFlushInterval(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled:  true,
-		Interval: 1 * time.Second,
-		Reporter: statsdReporterType,
-		StatsdReporterOpts: StatsdReporterOpts{
-			Address:       "127.0.0.1:0",
-			FlushInterval: 0,
-			FlushBytes:    512,
-		},
-	}
-	s, err := create(opts)
-	assert.Nil(t, s)
-	assert.Error(t, err)
-}
-
-func TestStartPromInvalidListernAddress(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled:  true,
-		Interval: 1 * time.Second,
-		Reporter: statsdReporterType,
-		PromReporterOpts: PromReporterOpts{
-			ListenAddress: "",
-		},
-	}
-	s, err := create(opts)
-	assert.Nil(t, s)
-	assert.Error(t, err)
-}
-
-func TestStartStatsdInvalidFlushBytes(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled:  true,
-		Interval: 1 * time.Second,
-		Reporter: statsdReporterType,
-		StatsdReporterOpts: StatsdReporterOpts{
-			Address:       "127.0.0.1:0",
-			FlushInterval: 2 * time.Second,
-			FlushBytes:    0,
-		},
-	}
-	s, err := create(opts)
-	assert.Nil(t, s)
-	assert.Error(t, err)
-}
-
-func TestStartInvalidReporter(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled:  true,
-		Interval: 1 * time.Second,
-		Reporter: "test",
-	}
-	s, err := create(opts)
-	assert.Nil(t, s)
-	assert.Error(t, err)
-}
-
-func TestStartAndClose(t *testing.T) {
-	t.Parallel()
-	gt := NewGomegaWithT(t)
-	defer Shutdown()
-	opts := Opts{
-		Enabled:  true,
-		Reporter: statsdReporterType,
-		Interval: 1 * time.Second,
-		StatsdReporterOpts: StatsdReporterOpts{
-			Address:       "127.0.0.1:0",
-			FlushInterval: 2 * time.Second,
-			FlushBytes:    512,
-		}}
-	Init(opts)
-	assert.NotNil(t, RootScope)
-	go Start()
-	gt.Eventually(isRunning).Should(BeTrue())
-}
-
-func TestNoOpScopeMetrics(t *testing.T) {
-	t.Parallel()
-	opts := Opts{
-		Enabled: false,
-	}
-	s, err := create(opts)
-	go s.Start()
-	defer s.Close()
-	assert.NotNil(t, s)
-	assert.NoError(t, err)
-
-	// make sure no error throws when invoke noOpScope
-	subScope := s.SubScope("test")
-	subScope.Counter("foo").Inc(2)
-	subScope.Gauge("bar").Update(1.33)
-	tagSubScope := subScope.Tagged(map[string]string{"env": "test"})
-	tagSubScope.Counter("foo").Inc(2)
-	tagSubScope.Gauge("bar").Update(1.33)
-}
-
-func TestNewOpts(t *testing.T) {
-	t.Parallel()
-	defer viper.Reset()
-	setupTestConfig()
-	opts := NewOpts()
-	assert.False(t, opts.Enabled)
-	assert.Equal(t, 1*time.Second, opts.Interval)
-	assert.Equal(t, statsdReporterType, opts.Reporter)
-	assert.Equal(t, 1432, opts.StatsdReporterOpts.FlushBytes)
-	assert.Equal(t, 2*time.Second, opts.StatsdReporterOpts.FlushInterval)
-	assert.Equal(t, "0.0.0.0:8125", opts.StatsdReporterOpts.Address)
-	viper.Reset()
-
-	setupTestConfig()
-	viper.Set("metrics.Reporter", promReporterType)
-	opts1 := NewOpts()
-	assert.False(t, opts1.Enabled)
-	assert.Equal(t, 1*time.Second, opts1.Interval)
-	assert.Equal(t, promReporterType, opts1.Reporter)
-	assert.Equal(t, "0.0.0.0:8080", opts1.PromReporterOpts.ListenAddress)
-}
-
-func TestNewOptsDefaultVar(t *testing.T) {
-	t.Parallel()
-	opts := NewOpts()
-	assert.False(t, opts.Enabled)
-	assert.Equal(t, 1*time.Second, opts.Interval)
-	assert.Equal(t, statsdReporterType, opts.Reporter)
-	assert.Equal(t, 1432, opts.StatsdReporterOpts.FlushBytes)
-	assert.Equal(t, 2*time.Second, opts.StatsdReporterOpts.FlushInterval)
-}
-
-func setupTestConfig() {
-	viper.SetConfigName("core")
-	viper.SetEnvPrefix("CORE")
-	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
-	viper.AutomaticEnv()
-
-	err := configtest.AddDevConfigPath(nil)
-	if err != nil {
-		panic(fmt.Errorf("Fatal error adding dev dir: %s \n", err))
-	}
-
-	err = viper.ReadInConfig()
-	if err != nil { // Handle errors reading the config file
-		panic(fmt.Errorf("Fatal error config file: %s \n", err))
-	}
-}
diff --git a/common/metrics/tally_provider.go b/common/metrics/tally_provider.go
index cf1e3deff..660078d52 100644
--- a/common/metrics/tally_provider.go
+++ b/common/metrics/tally_provider.go
@@ -7,17 +7,16 @@ SPDX-License-Identifier: Apache-2.0
 package metrics
 
 import (
-	"context"
 	"errors"
-	"fmt"
-	"io"
 	"net/http"
-	"sort"
-	"sync"
 	"time"
 
+	"net"
+
+	"sort"
+
 	"github.com/cactus/go-statsd-client/statsd"
-	"github.com/op/go-logging"
+	"github.com/hyperledger/fabric/common/flogging"
 	"github.com/prometheus/client_golang/prometheus"
 	"github.com/prometheus/client_golang/prometheus/promhttp"
 	"github.com/uber-go/tally"
@@ -25,74 +24,11 @@ import (
 	statsdreporter "github.com/uber-go/tally/statsd"
 )
 
-var logger = logging.MustGetLogger("common/metrics/tally")
-
-var scopeRegistryKey = tally.KeyForPrefixedStringMap
-
-type counter struct {
-	tallyCounter tally.Counter
-}
-
-func newCounter(tallyCounter tally.Counter) *counter {
-	return &counter{tallyCounter: tallyCounter}
-}
-
-func (c *counter) Inc(v int64) {
-	c.tallyCounter.Inc(v)
-}
-
-type gauge struct {
-	tallyGauge tally.Gauge
-}
-
-func newGauge(tallyGauge tally.Gauge) *gauge {
-	return &gauge{tallyGauge: tallyGauge}
-}
+var logger = flogging.MustGetLogger("common/metrics/tally")
 
-func (g *gauge) Update(v float64) {
-	g.tallyGauge.Update(v)
-}
-
-type scopeRegistry struct {
-	sync.RWMutex
-	subScopes map[string]*scope
-}
-
-type scope struct {
-	separator    string
-	prefix       string
-	tags         map[string]string
-	tallyScope   tally.Scope
-	registry     *scopeRegistry
-	baseReporter tally.BaseStatsReporter
-
-	cm sync.RWMutex
-	gm sync.RWMutex
-
-	counters map[string]*counter
-	gauges   map[string]*gauge
-}
-
-func newRootScope(opts tally.ScopeOptions, interval time.Duration) Scope {
+func newRootScope(opts tally.ScopeOptions, interval time.Duration) tally.Scope {
 	s, _ := tally.NewRootScope(opts, interval)
-
-	var baseReporter tally.BaseStatsReporter
-	if opts.Reporter != nil {
-		baseReporter = opts.Reporter
-	} else if opts.CachedReporter != nil {
-		baseReporter = opts.CachedReporter
-	}
-
-	return &scope{
-		prefix:     opts.Prefix,
-		separator:  opts.Separator,
-		tallyScope: s,
-		registry: &scopeRegistry{
-			subScopes: make(map[string]*scope),
-		},
-		baseReporter: baseReporter,
-		counters:     make(map[string]*counter),
-		gauges:       make(map[string]*gauge)}
+	return s
 }
 
 func newStatsdReporter(statsdReporterOpts StatsdReporterOpts) (tally.StatsReporter, error) {
@@ -115,7 +51,7 @@ func newStatsdReporter(statsdReporterOpts StatsdReporterOpts) (tally.StatsReport
 	}
 	opts := statsdreporter.Options{}
 	reporter := statsdreporter.NewReporter(statter, opts)
-	statsdReporter := &statsdReporter{reporter: reporter, statter: statter}
+	statsdReporter := &statsdReporter{StatsReporter: reporter, statter: statter}
 	return statsdReporter, nil
 }
 
@@ -127,159 +63,52 @@ func newPromReporter(promReporterOpts PromReporterOpts) (promreporter.Reporter,
 	opts := promreporter.Options{Registerer: prometheus.NewRegistry()}
 	reporter := promreporter.NewReporter(opts)
 	mux := http.NewServeMux()
-	handler := promReporterHttpHandler(opts.Registerer.(*prometheus.Registry))
+	handler := promReporterHTTPHandler(opts.Registerer.(*prometheus.Registry))
 	mux.Handle("/metrics", handler)
-	server := &http.Server{Addr: promReporterOpts.ListenAddress, Handler: mux}
+	server := &http.Server{Handler: mux}
+	addr := promReporterOpts.ListenAddress
+	if addr == "" {
+		addr = ":http"
+	}
+	listener, err := net.Listen("tcp", addr)
+	if err != nil {
+		return nil, err
+	}
 	promReporter := &promReporter{
-		reporter: reporter,
+		Reporter: reporter,
 		server:   server,
-		registry: opts.Registerer.(*prometheus.Registry)}
+		registry: opts.Registerer.(*prometheus.Registry),
+		listener: listener}
+	go server.Serve(listener)
 	return promReporter, nil
 }
 
-func (s *scope) Counter(name string) Counter {
-	s.cm.RLock()
-	val, ok := s.counters[name]
-	s.cm.RUnlock()
-	if !ok {
-		s.cm.Lock()
-		val, ok = s.counters[name]
-		if !ok {
-			counter := s.tallyScope.Counter(name)
-			val = newCounter(counter)
-			s.counters[name] = val
-		}
-		s.cm.Unlock()
-	}
-	return val
-}
-
-func (s *scope) Gauge(name string) Gauge {
-	s.gm.RLock()
-	val, ok := s.gauges[name]
-	s.gm.RUnlock()
-	if !ok {
-		s.gm.Lock()
-		val, ok = s.gauges[name]
-		if !ok {
-			gauge := s.tallyScope.Gauge(name)
-			val = newGauge(gauge)
-			s.gauges[name] = val
-		}
-		s.gm.Unlock()
-	}
-	return val
-}
-
-func (s *scope) Tagged(tags map[string]string) Scope {
-	originTags := tags
-	tags = mergeRightTags(s.tags, tags)
-	key := scopeRegistryKey(s.prefix, tags)
-
-	s.registry.RLock()
-	existing, ok := s.registry.subScopes[key]
-	if ok {
-		s.registry.RUnlock()
-		return existing
-	}
-	s.registry.RUnlock()
-
-	s.registry.Lock()
-	defer s.registry.Unlock()
-
-	existing, ok = s.registry.subScopes[key]
-	if ok {
-		return existing
-	}
-
-	subScope := &scope{
-		separator: s.separator,
-		prefix:    s.prefix,
-		// NB(r): Take a copy of the tags on creation
-		// so that it cannot be modified after set.
-		tags:       copyStringMap(tags),
-		tallyScope: s.tallyScope.Tagged(originTags),
-		registry:   s.registry,
-
-		counters: make(map[string]*counter),
-		gauges:   make(map[string]*gauge),
-	}
-
-	s.registry.subScopes[key] = subScope
-	return subScope
-}
-
-func (s *scope) SubScope(prefix string) Scope {
-	key := scopeRegistryKey(s.fullyQualifiedName(prefix), s.tags)
-
-	s.registry.RLock()
-	existing, ok := s.registry.subScopes[key]
-	if ok {
-		s.registry.RUnlock()
-		return existing
-	}
-	s.registry.RUnlock()
-
-	s.registry.Lock()
-	defer s.registry.Unlock()
-
-	existing, ok = s.registry.subScopes[key]
-	if ok {
-		return existing
-	}
-
-	subScope := &scope{
-		separator: s.separator,
-		prefix:    s.prefix,
-		// NB(r): Take a copy of the tags on creation
-		// so that it cannot be modified after set.
-		tags:       copyStringMap(s.tags),
-		tallyScope: s.tallyScope.SubScope(prefix),
-		registry:   s.registry,
-
-		counters: make(map[string]*counter),
-		gauges:   make(map[string]*gauge),
-	}
-
-	s.registry.subScopes[key] = subScope
-	return subScope
-}
-
-func (s *scope) Close() error {
-	if closer, ok := s.tallyScope.(io.Closer); ok {
-		return closer.Close()
-	}
-	return nil
-}
-
-func (s *scope) Start() error {
-	if server, ok := s.baseReporter.(serve); ok {
-		return server.Start()
-	}
-	return nil
-}
-
 type statsdReporter struct {
-	reporter tally.StatsReporter
-	statter  statsd.Statter
+	tally.StatsReporter
+	statter statsd.Statter
 }
 
 type promReporter struct {
-	reporter promreporter.Reporter
+	promreporter.Reporter
 	server   *http.Server
+	listener net.Listener
 	registry *prometheus.Registry
 }
 
+func (r *statsdReporter) Close() error {
+	return r.statter.Close()
+}
+
 func (r *statsdReporter) ReportCounter(name string, tags map[string]string, value int64) {
-	r.reporter.ReportCounter(tagsToName(name, tags), tags, value)
+	r.StatsReporter.ReportCounter(tagsToName(name, tags), tags, value)
 }
 
 func (r *statsdReporter) ReportGauge(name string, tags map[string]string, value float64) {
-	r.reporter.ReportGauge(tagsToName(name, tags), tags, value)
+	r.StatsReporter.ReportGauge(tagsToName(name, tags), tags, value)
 }
 
 func (r *statsdReporter) ReportTimer(name string, tags map[string]string, interval time.Duration) {
-	r.reporter.ReportTimer(tagsToName(name, tags), tags, interval)
+	r.StatsReporter.ReportTimer(tagsToName(name, tags), tags, interval)
 }
 
 func (r *statsdReporter) ReportHistogramValueSamples(
@@ -290,7 +119,7 @@ func (r *statsdReporter) ReportHistogramValueSamples(
 	bucketUpperBound float64,
 	samples int64,
 ) {
-	r.reporter.ReportHistogramValueSamples(tagsToName(name, tags), tags, buckets, bucketLowerBound, bucketUpperBound, samples)
+	r.StatsReporter.ReportHistogramValueSamples(tagsToName(name, tags), tags, buckets, bucketLowerBound, bucketUpperBound, samples)
 }
 
 func (r *statsdReporter) ReportHistogramDurationSamples(
@@ -301,7 +130,7 @@ func (r *statsdReporter) ReportHistogramDurationSamples(
 	bucketUpperBound time.Duration,
 	samples int64,
 ) {
-	r.reporter.ReportHistogramDurationSamples(tagsToName(name, tags), tags, buckets, bucketLowerBound, bucketUpperBound, samples)
+	r.StatsReporter.ReportHistogramDurationSamples(tagsToName(name, tags), tags, buckets, bucketLowerBound, bucketUpperBound, samples)
 }
 
 func (r *statsdReporter) Capabilities() tally.Capabilities {
@@ -316,127 +145,20 @@ func (r *statsdReporter) Tagging() bool {
 	return true
 }
 
-func (r *statsdReporter) Flush() {
-	// no-op
-}
-
-func (r *statsdReporter) Close() error {
-	return r.statter.Close()
-}
-
-func (r *promReporter) RegisterCounter(
-	name string,
-	tagKeys []string,
-	desc string,
-) (*prometheus.CounterVec, error) {
-	return r.reporter.RegisterCounter(name, tagKeys, desc)
-}
-
-// AllocateCounter implements tally.CachedStatsReporter.
-func (r *promReporter) AllocateCounter(name string, tags map[string]string) tally.CachedCount {
-	return r.reporter.AllocateCounter(name, tags)
-}
-
-func (r *promReporter) RegisterGauge(
-	name string,
-	tagKeys []string,
-	desc string,
-) (*prometheus.GaugeVec, error) {
-	return r.reporter.RegisterGauge(name, tagKeys, desc)
-}
-
-// AllocateGauge implements tally.CachedStatsReporter.
-func (r *promReporter) AllocateGauge(name string, tags map[string]string) tally.CachedGauge {
-	return r.reporter.AllocateGauge(name, tags)
-}
-
-func (r *promReporter) RegisterTimer(
-	name string,
-	tagKeys []string,
-	desc string,
-	opts *promreporter.RegisterTimerOptions,
-) (promreporter.TimerUnion, error) {
-	return r.reporter.RegisterTimer(name, tagKeys, desc, opts)
-}
-
-// AllocateTimer implements tally.CachedStatsReporter.
-func (r *promReporter) AllocateTimer(name string, tags map[string]string) tally.CachedTimer {
-	return r.reporter.AllocateTimer(name, tags)
-}
-
-func (r *promReporter) AllocateHistogram(
-	name string,
-	tags map[string]string,
-	buckets tally.Buckets,
-) tally.CachedHistogram {
-	return r.reporter.AllocateHistogram(name, tags, buckets)
-}
-
-func (r *promReporter) Capabilities() tally.Capabilities {
-	return r
-}
-
-func (r *promReporter) Reporting() bool {
-	return true
-}
-
-func (r *promReporter) Tagging() bool {
-	return true
-}
-
-// Flush does nothing for prometheus
-func (r *promReporter) Flush() {
-
-}
-
 func (r *promReporter) Close() error {
-	//TODO: Timeout here?
-	return r.server.Shutdown(context.Background())
-}
-
-func (r *promReporter) Start() error {
-	return r.server.ListenAndServe()
+	//TODO: Shutdown server gracefully?
+	// Close() is not a graceful way since it closes server immediately
+	err := r.server.Close()
+	r.listener.Close()
+	return err
 }
 
 func (r *promReporter) HTTPHandler() http.Handler {
-	return promReporterHttpHandler(r.registry)
+	return promReporterHTTPHandler(r.registry)
 }
 
-func (s *scope) fullyQualifiedName(name string) string {
-	if len(s.prefix) == 0 {
-		return name
-	}
-	return fmt.Sprintf("%s%s%s", s.prefix, s.separator, name)
-}
-
-// mergeRightTags merges 2 sets of tags with the tags from tagsRight overriding values from tagsLeft
-func mergeRightTags(tagsLeft, tagsRight map[string]string) map[string]string {
-	if tagsLeft == nil && tagsRight == nil {
-		return nil
-	}
-	if len(tagsRight) == 0 {
-		return tagsLeft
-	}
-	if len(tagsLeft) == 0 {
-		return tagsRight
-	}
-
-	result := make(map[string]string, len(tagsLeft)+len(tagsRight))
-	for k, v := range tagsLeft {
-		result[k] = v
-	}
-	for k, v := range tagsRight {
-		result[k] = v
-	}
-	return result
-}
-
-func copyStringMap(stringMap map[string]string) map[string]string {
-	result := make(map[string]string, len(stringMap))
-	for k, v := range stringMap {
-		result[k] = v
-	}
-	return result
+func promReporterHTTPHandler(registry *prometheus.Registry) http.Handler {
+	return promhttp.HandlerFor(registry, promhttp.HandlerOpts{})
 }
 
 func tagsToName(name string, tags map[string]string) string {
@@ -447,12 +169,8 @@ func tagsToName(name string, tags map[string]string) string {
 	sort.Strings(keys)
 
 	for _, k := range keys {
-		name = name + tally.DefaultSeparator + k + "-" + tags[k]
+		name = name + promreporter.DefaultSeparator + k + "-" + tags[k]
 	}
 
 	return name
 }
-
-func promReporterHttpHandler(registry *prometheus.Registry) http.Handler {
-	return promhttp.HandlerFor(registry, promhttp.HandlerOpts{})
-}
diff --git a/common/metrics/tally_provider_test.go b/common/metrics/tally_provider_test.go
deleted file mode 100644
index 9e911c275..000000000
--- a/common/metrics/tally_provider_test.go
+++ /dev/null
@@ -1,462 +0,0 @@
-/*
-Copyright IBM Corp. All Rights Reserved.
-
-SPDX-License-Identifier: Apache-2.0
-*/
-
-package metrics
-
-import (
-	"fmt"
-	"io"
-	"io/ioutil"
-	"net"
-	"net/http"
-	"strings"
-	"sync"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/uber-go/tally"
-	promreporter "github.com/uber-go/tally/prometheus"
-)
-
-const (
-	statsdAddress = "127.0.0.1:8125"
-	promAddress   = "127.0.0.1:8082"
-)
-
-type testIntValue struct {
-	val      int64
-	tags     map[string]string
-	reporter *testStatsReporter
-}
-
-func (m *testIntValue) ReportCount(value int64) {
-	m.val = value
-	m.reporter.cg.Done()
-}
-
-type testFloatValue struct {
-	val      float64
-	tags     map[string]string
-	reporter *testStatsReporter
-}
-
-func (m *testFloatValue) ReportGauge(value float64) {
-	m.val = value
-	m.reporter.gg.Done()
-}
-
-type testStatsReporter struct {
-	cg sync.WaitGroup
-	gg sync.WaitGroup
-
-	scope Scope
-
-	counters map[string]*testIntValue
-	gauges   map[string]*testFloatValue
-
-	flushes int32
-}
-
-// newTestStatsReporter returns a new TestStatsReporter
-func newTestStatsReporter() *testStatsReporter {
-	return &testStatsReporter{
-		counters: make(map[string]*testIntValue),
-		gauges:   make(map[string]*testFloatValue)}
-}
-
-func (r *testStatsReporter) WaitAll() {
-	r.cg.Wait()
-	r.gg.Wait()
-}
-
-func (r *testStatsReporter) AllocateCounter(
-	name string, tags map[string]string,
-) tally.CachedCount {
-	counter := &testIntValue{
-		val:      0,
-		tags:     tags,
-		reporter: r,
-	}
-	r.counters[name] = counter
-	return counter
-}
-
-func (r *testStatsReporter) ReportCounter(name string, tags map[string]string, value int64) {
-	r.counters[name] = &testIntValue{
-		val:  value,
-		tags: tags,
-	}
-	r.cg.Done()
-}
-
-func (r *testStatsReporter) AllocateGauge(
-	name string, tags map[string]string,
-) tally.CachedGauge {
-	gauge := &testFloatValue{
-		val:      0,
-		tags:     tags,
-		reporter: r,
-	}
-	r.gauges[name] = gauge
-	return gauge
-}
-
-func (r *testStatsReporter) ReportGauge(name string, tags map[string]string, value float64) {
-	r.gauges[name] = &testFloatValue{
-		val:  value,
-		tags: tags,
-	}
-	r.gg.Done()
-}
-
-func (r *testStatsReporter) AllocateTimer(
-	name string, tags map[string]string,
-) tally.CachedTimer {
-	return nil
-}
-
-func (r *testStatsReporter) ReportTimer(name string, tags map[string]string, interval time.Duration) {
-
-}
-
-func (r *testStatsReporter) AllocateHistogram(
-	name string,
-	tags map[string]string,
-	buckets tally.Buckets,
-) tally.CachedHistogram {
-	return nil
-}
-
-func (r *testStatsReporter) ReportHistogramValueSamples(
-	name string,
-	tags map[string]string,
-	buckets tally.Buckets,
-	bucketLowerBound,
-	bucketUpperBound float64,
-	samples int64,
-) {
-
-}
-
-func (r *testStatsReporter) ReportHistogramDurationSamples(
-	name string,
-	tags map[string]string,
-	buckets tally.Buckets,
-	bucketLowerBound,
-	bucketUpperBound time.Duration,
-	samples int64,
-) {
-
-}
-
-func (r *testStatsReporter) Capabilities() tally.Capabilities {
-	return nil
-}
-
-func (r *testStatsReporter) Flush() {
-	atomic.AddInt32(&r.flushes, 1)
-}
-
-func TestCounter(t *testing.T) {
-	t.Parallel()
-	r := newTestStatsReporter()
-	opts := tally.ScopeOptions{
-		Prefix:    namespace,
-		Separator: tally.DefaultSeparator,
-		Reporter:  r}
-
-	s := newRootScope(opts, 1*time.Second)
-	go s.Start()
-	defer s.Close()
-	r.cg.Add(1)
-	s.Counter("foo").Inc(1)
-	r.cg.Wait()
-
-	assert.Equal(t, int64(1), r.counters[namespace+".foo"].val)
-
-	defer func() {
-		if r := recover(); r == nil {
-			t.Errorf("Should panic when wrong key used")
-		}
-	}()
-	assert.Equal(t, int64(1), r.counters[namespace+".foo1"].val)
-}
-
-func TestMultiCounterReport(t *testing.T) {
-	t.Parallel()
-	r := newTestStatsReporter()
-	opts := tally.ScopeOptions{
-		Prefix:    namespace,
-		Separator: tally.DefaultSeparator,
-		Reporter:  r}
-
-	s := newRootScope(opts, 2*time.Second)
-	go s.Start()
-	defer s.Close()
-	r.cg.Add(1)
-	go s.Counter("foo").Inc(1)
-	go s.Counter("foo").Inc(3)
-	go s.Counter("foo").Inc(5)
-	r.cg.Wait()
-
-	assert.Equal(t, int64(9), r.counters[namespace+".foo"].val)
-}
-
-func TestGauge(t *testing.T) {
-	t.Parallel()
-	r := newTestStatsReporter()
-	opts := tally.ScopeOptions{
-		Prefix:    namespace,
-		Separator: tally.DefaultSeparator,
-		Reporter:  r}
-
-	s := newRootScope(opts, 1*time.Second)
-	go s.Start()
-	defer s.Close()
-	r.gg.Add(1)
-	s.Gauge("foo").Update(float64(1.33))
-	r.gg.Wait()
-
-	assert.Equal(t, float64(1.33), r.gauges[namespace+".foo"].val)
-}
-
-func TestMultiGaugeReport(t *testing.T) {
-	t.Parallel()
-	r := newTestStatsReporter()
-	opts := tally.ScopeOptions{
-		Prefix:    namespace,
-		Separator: tally.DefaultSeparator,
-		Reporter:  r}
-
-	s := newRootScope(opts, 1*time.Second)
-	go s.Start()
-	defer s.Close()
-
-	r.gg.Add(1)
-	s.Gauge("foo").Update(float64(1.33))
-	s.Gauge("foo").Update(float64(3.33))
-	r.gg.Wait()
-
-	assert.Equal(t, float64(3.33), r.gauges[namespace+".foo"].val)
-}
-
-func TestSubScope(t *testing.T) {
-	t.Parallel()
-	r := newTestStatsReporter()
-	opts := tally.ScopeOptions{
-		Prefix:    namespace,
-		Separator: tally.DefaultSeparator,
-		Reporter:  r}
-
-	s := newRootScope(opts, 1*time.Second)
-	go s.Start()
-	defer s.Close()
-	subs := s.SubScope("foo")
-
-	r.gg.Add(1)
-	subs.Gauge("bar").Update(float64(1.33))
-	r.gg.Wait()
-
-	assert.Equal(t, float64(1.33), r.gauges[namespace+".foo.bar"].val)
-
-	r.cg.Add(1)
-	subs.Counter("haha").Inc(1)
-	r.cg.Wait()
-
-	assert.Equal(t, int64(1), r.counters[namespace+".foo.haha"].val)
-}
-
-func TestTagged(t *testing.T) {
-	t.Parallel()
-	r := newTestStatsReporter()
-	opts := tally.ScopeOptions{
-		Prefix:    namespace,
-		Separator: tally.DefaultSeparator,
-		Reporter:  r}
-
-	s := newRootScope(opts, 1*time.Second)
-	go s.Start()
-	defer s.Close()
-	subs := s.Tagged(map[string]string{"env": "test"})
-
-	r.gg.Add(1)
-	subs.Gauge("bar").Update(float64(1.33))
-	r.gg.Wait()
-
-	assert.Equal(t, float64(1.33), r.gauges[namespace+".bar"].val)
-	assert.EqualValues(t, map[string]string{
-		"env": "test",
-	}, r.gauges[namespace+".bar"].tags)
-
-	r.cg.Add(1)
-	subs.Counter("haha").Inc(1)
-	r.cg.Wait()
-
-	assert.Equal(t, int64(1), r.counters[namespace+".haha"].val)
-	assert.EqualValues(t, map[string]string{
-		"env": "test",
-	}, r.counters[namespace+".haha"].tags)
-}
-
-func TestTaggedExistingReturnsSameScope(t *testing.T) {
-	t.Parallel()
-	r := newTestStatsReporter()
-
-	for _, initialTags := range []map[string]string{
-		nil,
-		{"env": "test"},
-	} {
-		root := newRootScope(tally.ScopeOptions{Prefix: "foo", Tags: initialTags, Reporter: r}, 0)
-		go root.Start()
-		rootScope := root.(*scope)
-		fooScope := root.Tagged(map[string]string{"foo": "bar"}).(*scope)
-
-		assert.NotEqual(t, rootScope, fooScope)
-		assert.Equal(t, fooScope, fooScope.Tagged(nil))
-
-		fooBarScope := fooScope.Tagged(map[string]string{"bar": "baz"}).(*scope)
-
-		assert.NotEqual(t, fooScope, fooBarScope)
-		assert.Equal(t, fooBarScope, fooScope.Tagged(map[string]string{"bar": "baz"}).(*scope))
-		root.Close()
-	}
-}
-
-func TestSubScopeTagged(t *testing.T) {
-	t.Parallel()
-	r := newTestStatsReporter()
-	opts := tally.ScopeOptions{
-		Prefix:    namespace,
-		Separator: tally.DefaultSeparator,
-		Reporter:  r}
-
-	s := newRootScope(opts, 1*time.Second)
-	go s.Start()
-	defer s.Close()
-	subs := s.SubScope("sub")
-	subtags := subs.Tagged(map[string]string{"env": "test"})
-
-	r.gg.Add(1)
-	subtags.Gauge("bar").Update(float64(1.33))
-	r.gg.Wait()
-
-	assert.Equal(t, float64(1.33), r.gauges[namespace+".sub.bar"].val)
-	assert.EqualValues(t, map[string]string{
-		"env": "test",
-	}, r.gauges[namespace+".sub.bar"].tags)
-
-	r.cg.Add(1)
-	subtags.Counter("haha").Inc(1)
-	r.cg.Wait()
-
-	assert.Equal(t, int64(1), r.counters[namespace+".sub.haha"].val)
-	assert.EqualValues(t, map[string]string{
-		"env": "test",
-	}, r.counters[namespace+".sub.haha"].tags)
-}
-
-func TestMetricsByStatsdReporter(t *testing.T) {
-	t.Parallel()
-	udpAddr, err := net.ResolveUDPAddr("udp", statsdAddress)
-	if err != nil {
-		t.Fatal(err)
-	}
-
-	server, err := net.ListenUDP("udp", udpAddr)
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer server.Close()
-
-	r, _ := newTestStatsdReporter()
-	opts := tally.ScopeOptions{
-		Prefix:    namespace,
-		Separator: tally.DefaultSeparator,
-		Reporter:  r}
-
-	s := newRootScope(opts, 1*time.Second)
-	go s.Start()
-	defer s.Close()
-	subs := s.SubScope("peer").Tagged(map[string]string{"component": "committer", "env": "test"})
-	subs.Counter("success_total").Inc(1)
-	subs.Gauge("channel_total").Update(4)
-
-	buffer := make([]byte, 4096)
-	n, _ := io.ReadAtLeast(server, buffer, 1)
-	result := string(buffer[:n])
-
-	expected := []string{
-		`hyperledger_fabric.peer.success_total.component-committer.env-test:1|c`,
-		`hyperledger_fabric.peer.channel_total.component-committer.env-test:4|g`,
-	}
-
-	for i, res := range strings.Split(result, "\n") {
-		if res != expected[i] {
-			t.Errorf("Got `%s`, expected `%s`", res, expected[i])
-		}
-	}
-}
-
-func TestMetricsByPrometheusReporter(t *testing.T) {
-	t.Parallel()
-	r, _ := newTestPrometheusReporter()
-
-	opts := tally.ScopeOptions{
-		Prefix:         namespace,
-		Separator:      promreporter.DefaultSeparator,
-		CachedReporter: r}
-
-	s := newRootScope(opts, 1*time.Second)
-	go s.Start()
-	defer s.Close()
-
-	scrape := func() string {
-		resp, _ := http.Get(fmt.Sprintf("http://%s/metrics", promAddress))
-		buf, _ := ioutil.ReadAll(resp.Body)
-		return string(buf)
-	}
-	subs := s.SubScope("peer").Tagged(map[string]string{"component": "committer", "env": "test"})
-	subs.Counter("success_total").Inc(1)
-	subs.Gauge("channel_total").Update(4)
-
-	time.Sleep(2 * time.Second)
-
-	expected := []string{
-		`# HELP hyperledger_fabric_peer_channel_total hyperledger_fabric_peer_channel_total gauge`,
-		`# TYPE hyperledger_fabric_peer_channel_total gauge`,
-		`hyperledger_fabric_peer_channel_total{component="committer",env="test"} 4`,
-		`# HELP hyperledger_fabric_peer_success_total hyperledger_fabric_peer_success_total counter`,
-		`# TYPE hyperledger_fabric_peer_success_total counter`,
-		`hyperledger_fabric_peer_success_total{component="committer",env="test"} 1`,
-		``,
-	}
-
-	result := strings.Split(scrape(), "\n")
-
-	for i, res := range result {
-		if res != expected[i] {
-			t.Errorf("Got `%s`, expected `%s`", res, expected[i])
-		}
-	}
-}
-
-func newTestStatsdReporter() (tally.StatsReporter, error) {
-	opts := StatsdReporterOpts{
-		Address:       statsdAddress,
-		FlushInterval: defaultStatsdReporterFlushInterval,
-		FlushBytes:    defaultStatsdReporterFlushBytes,
-	}
-	return newStatsdReporter(opts)
-}
-
-func newTestPrometheusReporter() (promreporter.Reporter, error) {
-	opts := PromReporterOpts{
-		ListenAddress: promAddress,
-	}
-	return newPromReporter(opts)
-}
diff --git a/common/metrics/types.go b/common/metrics/types.go
deleted file mode 100644
index c70001ea1..000000000
--- a/common/metrics/types.go
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
-Copyright IBM Corp. All Rights Reserved.
-
-SPDX-License-Identifier: Apache-2.0
-*/
-
-package metrics
-
-import "io"
-
-// Counter is the interface for emitting Counter type metrics.
-type Counter interface {
-	// Inc increments the Counter by a delta.
-	Inc(delta int64)
-}
-
-// Gauge is the interface for emitting Gauge metrics.
-type Gauge interface {
-	// Update sets the gauges absolute value.
-	Update(value float64)
-}
-
-// Scope is a namespace wrapper around a stats Reporter, ensuring that
-// all emitted values have a given prefix or set of tags.
-type Scope interface {
-	serve
-	// Counter returns the Counter object corresponding to the name.
-	Counter(name string) Counter
-
-	// Gauge returns the Gauge object corresponding to the name.
-	Gauge(name string) Gauge
-
-	// Tagged returns a new child Scope with the given tags and current tags.
-	Tagged(tags map[string]string) Scope
-
-	// SubScope returns a new child Scope appending a further name prefix.
-	SubScope(name string) Scope
-}
-
-// serve is the interface represents who can provide service
-type serve interface {
-	io.Closer
-	// Start starts the server
-	Start() error
-}
diff --git a/core/endorser/endorser.go b/core/endorser/endorser.go
index 2d29f43a4..7db5235b6 100644
--- a/core/endorser/endorser.go
+++ b/core/endorser/endorser.go
@@ -25,10 +25,38 @@ import (
 	putils "github.com/hyperledger/fabric/protos/utils"
 	"github.com/pkg/errors"
 	"golang.org/x/net/context"
+	"github.com/hyperledger/fabric/util/concurrent/lazycache"
+	"github.com/hyperledger/fabric/common/metrics"
+
+	"github.com/uber-go/tally"
 )
 
 var endorserLogger = flogging.MustGetLogger("endorser")
 
+var callChaincodeTimersCache *lazycache.Cache
+
+
+func init() {
+	callChaincodeTimersCache = lazycache.New(
+		"CC_Timer_Resolver_Cache",
+		func(key lazycache.Key) (interface{}, error) {
+			return metrics.RootScope.Timer(key.String()), nil
+		})
+}
+
+
+// timerCCKey contain ccName,fName
+type timerCCKey struct {
+	ccName string
+	fName  string
+}
+
+//String return string value for config key
+func (timerCCKey *timerCCKey) String() string {
+	return fmt.Sprintf("endorsement_CC_callChaincode_%s_%s_processing_time_seconds", timerCCKey.ccName, timerCCKey.fName)
+}
+
+
 // The Jira issue that documents Endorser flow along with its relationship to
 // the lifecycle chaincode - https://jira.hyperledger.org/browse/FAB-181
 
@@ -122,7 +150,20 @@ func NewEndorserServer(privDist privateDataDistributor, s Support) *Endorser {
 func (e *Endorser) callChaincode(ctxt context.Context, chainID string, version string, txid string, signedProp *pb.SignedProposal, prop *pb.Proposal, cis *pb.ChaincodeInvocationSpec, cid *pb.ChaincodeID, txsim ledger.TxSimulator) (*pb.Response, *pb.ChaincodeEvent, error) {
 	endorserLogger.Debugf("[%s][%s] Entry chaincode: %s version: %s", chainID, txid, cid, version)
 	defer endorserLogger.Debugf("[%s][%s] Exit", chainID, txid)
-	var err error
+
+	// Report on the CC processing time
+	ccName := cis.ChaincodeSpec.ChaincodeId.Name
+	fName := "NIL"
+	if len(cis.ChaincodeSpec.Input.Args) > 0 {
+		fName = string(cis.ChaincodeSpec.Input.Args[0])
+	}
+	value, err := callChaincodeTimersCache.Get(&timerCCKey{ccName: ccName, fName: fName})
+	if err != nil {
+		return nil, nil, err
+	}
+	ccTimer := value.(tally.Timer)
+	ccStopWatch := ccTimer.Start()
+	defer ccStopWatch.Stop()
 	var res *pb.Response
 	var ccevent *pb.ChaincodeEvent
 
diff --git a/core/ledger/ledgerstorage/store.go b/core/ledger/ledgerstorage/store.go
index 5655969d5..356a97357 100644
--- a/core/ledger/ledgerstorage/store.go
+++ b/core/ledger/ledgerstorage/store.go
@@ -23,13 +23,25 @@ import (
 	"github.com/hyperledger/fabric/common/flogging"
 	"github.com/hyperledger/fabric/common/ledger/blkstorage"
 	"github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage"
+	"github.com/hyperledger/fabric/common/metrics"
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
 	"github.com/hyperledger/fabric/core/ledger/pvtdatapolicy"
 	"github.com/hyperledger/fabric/core/ledger/pvtdatastorage"
 	"github.com/hyperledger/fabric/protos/common"
+	"github.com/uber-go/tally"
 )
 
+var commitWithPvtDataTimer tally.Timer
+var pvtDataAndBlockByNumTimer tally.Timer
+var pvtDataByNumTimer tally.Timer
+
+func init() {
+	commitWithPvtDataTimer = metrics.RootScope.Timer("ledgerstorage_CommitWithPvtData_time_seconds")
+	pvtDataAndBlockByNumTimer = metrics.RootScope.Timer("ledgerstorage_GetPvtDataAndBlockByNum_time_seconds")
+	pvtDataByNumTimer = metrics.RootScope.Timer("ledgerstorage_GetPvtDataByNum_time_seconds")
+}
+
 var logger = flogging.MustGetLogger("ledgerstorage")
 
 // Provider encapusaltes two providers 1) block store provider and 2) and pvt data store provider
@@ -97,6 +109,8 @@ func (s *Store) Init(btlPolicy pvtdatapolicy.BTLPolicy) {
 
 // CommitWithPvtData commits the block and the corresponding pvt data in an atomic operation
 func (s *Store) CommitWithPvtData(blockAndPvtdata *ledger.BlockAndPvtData) error {
+	stopWatch := commitWithPvtDataTimer.Start()
+	defer stopWatch.Stop()
 	blockNum := blockAndPvtdata.Block.Header.Number
 	s.rwlock.Lock()
 	defer s.rwlock.Unlock()
@@ -137,6 +151,8 @@ func (s *Store) CommitWithPvtData(blockAndPvtdata *ledger.BlockAndPvtData) error
 // GetPvtDataAndBlockByNum returns the block and the corresponding pvt data.
 // The pvt data is filtered by the list of 'collections' supplied
 func (s *Store) GetPvtDataAndBlockByNum(blockNum uint64, filter ledger.PvtNsCollFilter) (*ledger.BlockAndPvtData, error) {
+	stopWatch := pvtDataAndBlockByNumTimer.Start()
+	defer stopWatch.Stop()
 	s.rwlock.RLock()
 	defer s.rwlock.RUnlock()
 
@@ -156,6 +172,8 @@ func (s *Store) GetPvtDataAndBlockByNum(blockNum uint64, filter ledger.PvtNsColl
 // The pvt data is filtered by the list of 'ns/collections' supplied in the filter
 // A nil filter does not filter any results
 func (s *Store) GetPvtDataByNum(blockNum uint64, filter ledger.PvtNsCollFilter) ([]*ledger.TxPvtData, error) {
+	stopWatch := pvtDataByNumTimer.Start()
+	defer stopWatch.Stop()
 	s.rwlock.RLock()
 	defer s.rwlock.RUnlock()
 	return s.getPvtDataByNumWithoutLock(blockNum, filter)
diff --git a/util/concurrent/futurevalue/futurevalue.go b/util/concurrent/futurevalue/futurevalue.go
new file mode 100644
index 000000000..834c961e1
--- /dev/null
+++ b/util/concurrent/futurevalue/futurevalue.go
@@ -0,0 +1,102 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package futurevalue
+
+import (
+	"fmt"
+	"sync"
+	"sync/atomic"
+	"unsafe"
+)
+
+// Initializer initializes the value
+type Initializer func() (interface{}, error)
+
+// valueHolder holds the actual value
+type valueHolder struct {
+	value interface{}
+	err   error
+}
+
+// Value implements a Future Value in which a reference is initialized once
+// (and only once) using the Initialize function. Only one Go routine can call
+// Initialize whereas multiple Go routines may invoke Get, and will wait
+// until the reference has been initialized.
+// Regardless of whether Initialize returns success or error,
+// the value cannot be initialized again.
+type Value struct {
+	sync.RWMutex
+	ref         unsafe.Pointer
+	initializer Initializer
+}
+
+// New returns a new future value
+func New(initializer Initializer) *Value {
+	f := &Value{
+		initializer: initializer,
+	}
+	f.Lock()
+	return f
+}
+
+// Initialize initializes the future value.
+// This function must be called only once. Subsequent
+// calls may result in deadlock.
+func (f *Value) Initialize() (interface{}, error) {
+	value, err := f.initializer()
+	f.set(value, err)
+	f.Unlock()
+
+	return value, err
+}
+
+// Get returns the value and/or error that occurred during initialization.
+func (f *Value) Get() (interface{}, error) {
+	// Try outside of a lock
+	if ok, value, err := f.get(); ok {
+		return value, err
+	}
+
+	f.RLock()
+	defer f.RUnlock()
+
+	_, value, err := f.get()
+	return value, err
+}
+
+// MustGet returns the value. If an error resulted
+// during initialization then this function will panic.
+func (f *Value) MustGet() interface{} {
+	value, err := f.Get()
+	if err != nil {
+		panic(fmt.Sprintf("get returned error: %s", err))
+	}
+	return value
+}
+
+// IsSet returns true if the value has been set, otherwise false is returned
+func (f *Value) IsSet() bool {
+	p := atomic.LoadPointer(&f.ref)
+	return p != nil
+}
+
+func (f *Value) get() (bool, interface{}, error) {
+	p := atomic.LoadPointer(&f.ref)
+	if p == nil {
+		return false, nil, nil
+	}
+	holder := (*valueHolder)(p)
+	return true, holder.value, holder.err
+}
+
+func (f *Value) set(value interface{}, err error) {
+	holder := &valueHolder{
+		value: value,
+		err:   err,
+	}
+	atomic.StorePointer(&f.ref, unsafe.Pointer(holder)) //nolint
+}
diff --git a/util/concurrent/lazycache/keys.go b/util/concurrent/lazycache/keys.go
new file mode 100644
index 000000000..047c99fef
--- /dev/null
+++ b/util/concurrent/lazycache/keys.go
@@ -0,0 +1,22 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package lazycache
+
+// StringKey is a simple string cache key
+type StringKey struct {
+	key string
+}
+
+// NewStringKey returns a new StringKey
+func NewStringKey(key string) *StringKey {
+	return &StringKey{key: key}
+}
+
+// String returns the key as a string
+func (k *StringKey) String() string {
+	return k.key
+}
diff --git a/util/concurrent/lazycache/lazycache.go b/util/concurrent/lazycache/lazycache.go
new file mode 100644
index 000000000..33ab3aeba
--- /dev/null
+++ b/util/concurrent/lazycache/lazycache.go
@@ -0,0 +1,258 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package lazycache
+
+import (
+	"fmt"
+	"sync"
+	"sync/atomic"
+
+	"github.com/hyperledger/fabric/common/flogging"
+	"github.com/hyperledger/fabric/util/concurrent/futurevalue"
+	"github.com/hyperledger/fabric/util/concurrent/lazyref"
+	"github.com/pkg/errors"
+	"github.com/hyperledger/fabric/util/concurrent/options"
+)
+
+var logger = flogging.MustGetLogger("fabsdk/util")
+
+// Key holds the string key for the cache entry
+type Key interface {
+	String() string
+}
+
+// EntryInitializer creates a cache value for the given key
+type EntryInitializer func(key Key) (interface{}, error)
+
+// EntryInitializerWithData creates a cache value for the given key and the
+// additional data passed in from Get(). With expiring cache entries, the
+// initializer is called with the same key, but the latest data is passed from
+// the Get() call that triggered the data to be cached/re-cached.
+type EntryInitializerWithData func(key Key, data interface{}) (interface{}, error)
+
+type future interface {
+	Get() (interface{}, error)
+	MustGet() interface{}
+	IsSet() bool
+}
+
+type closable interface {
+	Close()
+}
+
+// Cache implements a lazy initializing cache. A cache entry is created
+// the first time a value is accessed (via Get or MustGet) by invoking
+// the provided Initializer. If the Initializer returns an error then the
+// entry will not be added.
+type Cache struct {
+	// name is useful for debugging
+	name        string
+	m           sync.Map
+	initializer EntryInitializerWithData
+	closed      int32
+	useRef      bool
+}
+
+// New creates a new lazy cache.
+// - name is the name of the cache and is only used for debugging purpose
+// - initializer is invoked the first time an entry is being cached
+// - opts are options for the cache. If any lazyref option is passed then a lazy reference
+//   is created for each of the cache entries to hold the actual value. This makes it possible
+//   to have expiring values and values that proactively refresh.
+func New(name string, initializer EntryInitializer, opts ...options.Opt) *Cache {
+	return NewWithData(name,
+		func(key Key, data interface{}) (interface{}, error) {
+			return initializer(key)
+		},
+		opts...,
+	)
+}
+
+// NewWithData creates a new lazy cache. The provided initializer accepts optional data that
+// is passed in from Get().
+// - name is the name of the cache and is only used for debugging purpose
+// - initializer is invoked the first time an entry is being cached
+// - opts are options for the cache. If any lazyref option is passed then a lazy reference
+//   is created for each of the cache entries to hold the actual value. This makes it possible
+//   to have expiring values and values that proactively refresh.
+func NewWithData(name string, initializer EntryInitializerWithData, opts ...options.Opt) *Cache {
+	useRef := useLazyRef(opts...)
+	if useRef {
+		initializer = newLazyRefInitializer(name, initializer, opts...)
+	}
+	return &Cache{
+		name:        name,
+		initializer: initializer,
+		useRef:      useRef,
+	}
+}
+
+// Name returns the name of the cache (useful for debugging)
+func (c *Cache) Name() string {
+	return c.name
+}
+
+// Get returns the value for the given key. If the
+// key doesn't exist then the initializer is invoked
+// to create the value, and the key is inserted. If the
+// initializer returns an error then the key is removed
+// from the cache.
+func (c *Cache) Get(key Key, data ...interface{}) (interface{}, error) {
+	keyStr := key.String()
+
+	f, ok := c.m.Load(keyStr)
+	if ok {
+		v, err := f.(future).Get()
+		if err != nil {
+			return nil, err
+		}
+		return c.value(v, first(data))
+	}
+
+	// The key wasn't found. Attempt to add one.
+	newFuture := futurevalue.New(
+		func() (interface{}, error) {
+			if closed := atomic.LoadInt32(&c.closed); closed == 1 {
+				return nil, errors.Errorf("%s - cache is closed", c.name)
+			}
+			return c.initializer(key, first(data))
+		},
+	)
+
+	f, loaded := c.m.LoadOrStore(keyStr, newFuture)
+	if loaded {
+		// Another thread has added the key before us. Return the value.
+		v, err := f.(future).Get()
+		if err != nil {
+			return nil, err
+		}
+		return c.value(v, first(data))
+	}
+
+	// We added the key. It must be initialized.
+	value, err := newFuture.Initialize()
+	if err != nil {
+		// Failed. Delete the key.
+		logger.Debugf("%s - Failed to initialize key [%s]: %s. Deleting key.", c.name, keyStr, err)
+		c.m.Delete(keyStr)
+		return nil, err
+	}
+	return c.value(value, first(data))
+}
+
+// MustGet returns the value for the given key. If the key doesn't
+// exist then the initializer is invoked to create the value and the
+// key is inserted. If an error is returned during initialization of the
+// value then this function will panic.
+func (c *Cache) MustGet(key Key) interface{} {
+	value, err := c.Get(key)
+	if err != nil {
+		panic(fmt.Sprintf("error returned from Get: %s", err))
+	}
+	return value
+}
+
+// Close does the following:
+// - calls Close on all values that implement a Close() function
+// - deletes all entries from the cache
+// - prevents further calls to the cache
+func (c *Cache) Close() {
+	if !atomic.CompareAndSwapInt32(&c.closed, 0, 1) {
+		// Already closed
+		return
+	}
+	logger.Debugf("%s - Closing cache", c.name)
+	c.DeleteAll()
+}
+
+// DeleteAll does the following:
+// - calls Close on all values that implement a Close() function
+// - deletes all entries from the cache
+func (c *Cache) DeleteAll() {
+	var keys []interface{}
+	c.m.Range(func(key interface{}, value interface{}) bool {
+		c.close(key.(string), value.(future))
+		keys = append(keys, key)
+		return true
+	})
+
+	for _, key := range keys {
+		c.m.Delete(key)
+	}
+}
+
+// Delete does the following:
+// - calls Close on all values that implement a Close() function
+// - deletes key from the cache
+func (c *Cache) Delete(key Key) {
+	logger.Debugf("%s - Deleting cache key", key.String())
+	value, ok := c.m.Load(key.String())
+	if ok {
+		c.close(key.String(), value.(future))
+		c.m.Delete(key.String())
+	}
+}
+
+func (c *Cache) close(key string, f future) {
+	if !f.IsSet() {
+		logger.Debugf("%s - Reference for [%q] is not set", c.name, key)
+		return
+	}
+	value, err := f.Get()
+	if err == nil && value != nil {
+		if clos, ok := value.(closable); ok && c != nil {
+			logger.Debugf("%s - Invoking Close on value for key [%q].", c.name, key)
+			clos.Close()
+		}
+	}
+}
+
+func newLazyRefInitializer(name string, initializer EntryInitializerWithData, opts ...options.Opt) EntryInitializerWithData {
+	return func(key Key, data interface{}) (interface{}, error) {
+		logger.Debugf("%s - Calling initializer for [%s], data [%#v]", name, key, data)
+		ref := lazyref.NewWithData(
+			func(data interface{}) (interface{}, error) {
+				logger.Debugf("%s - Calling lazyref initializer for [%s], data [%#v]", name, key, data)
+				return initializer(key, data)
+			},
+			opts...,
+		)
+
+		// Make sure no error is returned from lazyref.Get(). If there is
+		// then return the error. We don't want to cache a reference that always
+		// returns an error, especially if it's a refreshing reference.
+		_, err := ref.Get(data)
+		if err != nil {
+			logger.Debugf("%s - Error returned from lazyref initializer [%s], data [%#v]: %s", name, key, data, err)
+			ref.Close()
+			return nil, err
+		}
+		logger.Debugf("%s - Returning lazyref for [%s], data [%#v]", name, key, data)
+		return ref, nil
+	}
+}
+
+func (c *Cache) value(value interface{}, data interface{}) (interface{}, error) {
+	if value != nil && c.useRef {
+		return value.(*lazyref.Reference).Get(data)
+	}
+	return value, nil
+}
+
+func first(data []interface{}) interface{} {
+	if len(data) == 0 {
+		return nil
+	}
+	return data[0]
+}
+
+// useLazyRef returns true if the cache should used lazy references to hold the actual value
+func useLazyRef(opts ...options.Opt) bool {
+	chk := &refOptCheck{}
+	options.Apply(chk, opts)
+	return chk.useRef
+}
diff --git a/util/concurrent/lazycache/refoptcheck.go b/util/concurrent/lazycache/refoptcheck.go
new file mode 100644
index 000000000..c6e6a2e4b
--- /dev/null
+++ b/util/concurrent/lazycache/refoptcheck.go
@@ -0,0 +1,38 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package lazycache
+
+import (
+	"time"
+
+	"github.com/hyperledger/fabric/util/concurrent/lazyref"
+)
+
+// refOptCheck is used to test whether any of the lazyref options have been passed in
+type refOptCheck struct {
+	useRef bool
+}
+
+func (p *refOptCheck) SetIdleExpiration(expiration time.Duration) {
+	p.useRef = true
+}
+
+func (p *refOptCheck) SetAbsoluteExpiration(expiration time.Duration) {
+	p.useRef = true
+}
+
+func (p *refOptCheck) SetExpirationProvider(expirationProvider lazyref.ExpirationProvider, expiryType lazyref.ExpirationType) {
+	p.useRef = true
+}
+
+func (p *refOptCheck) SetFinalizer(value lazyref.Finalizer) {
+	p.useRef = true
+}
+
+func (p *refOptCheck) SetRefreshInterval(initialInit, refreshPeriod time.Duration) {
+	p.useRef = true
+}
diff --git a/util/concurrent/lazyref/expiration.go b/util/concurrent/lazyref/expiration.go
new file mode 100644
index 000000000..fc62048fd
--- /dev/null
+++ b/util/concurrent/lazyref/expiration.go
@@ -0,0 +1,32 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package lazyref
+
+import "time"
+
+// NewSimpleExpirationProvider returns an expiration provider
+// that sets the given expiration period
+func NewSimpleExpirationProvider(expiry time.Duration) ExpirationProvider {
+	return func() time.Duration {
+		return expiry
+	}
+}
+
+// NewGraduatingExpirationProvider returns an expiration provider
+// that has an initial expiration and then expires in graduated increments
+// with a maximum expiration time.
+func NewGraduatingExpirationProvider(initialExpiry, increments, maxExpiry time.Duration) ExpirationProvider {
+	var iteration uint32
+	return func() time.Duration {
+		expiry := initialExpiry + time.Duration(iteration)*increments
+		if expiry > maxExpiry {
+			return maxExpiry
+		}
+		iteration++
+		return expiry
+	}
+}
diff --git a/util/concurrent/lazyref/lazyref.go b/util/concurrent/lazyref/lazyref.go
new file mode 100644
index 000000000..86b6386a8
--- /dev/null
+++ b/util/concurrent/lazyref/lazyref.go
@@ -0,0 +1,375 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package lazyref
+
+import (
+	"errors"
+	"fmt"
+	"sync"
+	"sync/atomic"
+	"time"
+	"unsafe"
+
+	"github.com/hyperledger/fabric/common/flogging"
+	"github.com/hyperledger/fabric/util/concurrent/options"
+)
+
+var logger = flogging.MustGetLogger("fabsdk/util")
+
+// Initializer is a function that initializes the value
+type Initializer func() (interface{}, error)
+
+// InitializerWithData is a function that initializes the value
+// using the optional data.
+type InitializerWithData func(data interface{}) (interface{}, error)
+
+// Finalizer is a function that is called when the reference
+// is closed
+type Finalizer func(value interface{})
+
+// ExpirationProvider is a function that returns the
+// expiration time of a reference
+type ExpirationProvider func() time.Duration
+
+// valueHolder holds the actual value
+type valueHolder struct {
+	value interface{}
+}
+
+// expirationHandler is invoked when the
+// reference expires
+type expirationHandler func()
+
+// ExpirationType indicates how to handle expiration of the reference
+type ExpirationType uint
+
+const (
+	// LastAccessed specifies that the expiration time is calculated
+	// from the last access time
+	LastAccessed ExpirationType = iota
+
+	// LastInitialized specifies that the expiration time is calculated
+	// from the time the reference was initialized
+	LastInitialized
+
+	// Refreshing indicates that the reference should be periodically refreshed
+	Refreshing
+)
+
+// Reference holds a value that is initialized on first access using the provided
+// Initializer function. The Reference has an optional expiring feature
+// wherin the value is reset after the provided period of time. A subsequent call
+// to Get or MustGet causes the Initializer function to be invoked again.
+// The Reference also has a proactive refresh capability, in which the Initializer
+// function is periodically called out of band (out of band means that the caller
+// of Get or MustGet does not need to wait for the initializer function to complete:
+// the old value will be used until the new value has finished initializing).
+// An optional Finalizer function may be provided to be invoked whenever the Reference
+// is closed (via a call to Close) or if it expires. (Note: The Finalizer function
+// is not called every time the value is refreshed with the periodic refresh feature.)
+type Reference struct {
+	params
+	wg                sync.WaitGroup
+	expirationHandler expirationHandler
+	initializer       InitializerWithData
+	ref               unsafe.Pointer
+	lastTimeAccessed  unsafe.Pointer
+	closed            bool
+	running           bool
+	lock              sync.RWMutex
+	closech           chan bool
+}
+
+// New creates a new reference
+func New(initializer Initializer, opts ...options.Opt) *Reference {
+	return NewWithData(func(interface{}) (interface{}, error) {
+		return initializer()
+	}, opts...)
+}
+
+// NewWithData creates a new reference where data is passed from the Get
+// function to the initializer. This is useful for refreshing the reference
+// with dynamic data.
+func NewWithData(initializer InitializerWithData, opts ...options.Opt) *Reference {
+	lazyRef := &Reference{
+		params: params{
+			initialInit: InitOnFirstAccess,
+		},
+		initializer: initializer,
+	}
+
+	options.Apply(lazyRef, opts)
+
+	if lazyRef.expirationProvider != nil {
+		// This is an expiring reference. After the initializer is
+		// called, set a timer that will call the expiration handler.
+		initializer := lazyRef.initializer
+		initialExpiration := lazyRef.expirationProvider()
+		lazyRef.initializer = func(data interface{}) (interface{}, error) {
+			value, err := initializer(data)
+			if err == nil {
+				lazyRef.ensureTimerStarted(initialExpiration)
+			}
+			return value, err
+		}
+
+		lazyRef.closech = make(chan bool, 1)
+
+		if lazyRef.expirationHandler == nil {
+			if lazyRef.expiryType == Refreshing {
+				lazyRef.expirationHandler = lazyRef.refreshValue
+			} else {
+				lazyRef.expirationHandler = lazyRef.resetValue
+			}
+		}
+
+		if lazyRef.initialInit >= 0 {
+			lazyRef.ensureTimerStarted(lazyRef.initialInit)
+		}
+	}
+
+	return lazyRef
+}
+
+// Get returns the value, or an error if the initialiser returned an error.
+func (r *Reference) Get(data ...interface{}) (interface{}, error) {
+	// Try outside of a lock
+	if value, ok := r.get(); ok {
+		return value, nil
+	}
+
+	r.lock.Lock()
+	defer r.lock.Unlock()
+
+	if r.closed {
+		return nil, errors.New("reference is already closed")
+	}
+
+	// Try again inside the lock
+	if value, ok := r.get(); ok {
+		return value, nil
+	}
+
+	// Value hasn't been set yet
+	value, err := r.initializer(first(data))
+	if err != nil {
+		return nil, err
+	}
+	r.set(value)
+
+	return value, nil
+}
+
+// MustGet returns the value. If an error is returned
+// during initialization of the value then this function
+// will panic.
+func (r *Reference) MustGet() interface{} {
+	value, err := r.Get()
+	if err != nil {
+		panic(fmt.Sprintf("error returned from Get: %s", err))
+	}
+	return value
+}
+
+// Close ensures that the finalizer (if provided) is called.
+// Close should be called for expiring references and
+// rerences that specify finalizers.
+func (r *Reference) Close() {
+	if !r.setClosed() {
+		// Already closed
+		return
+	}
+
+	logger.Debug("Closing reference")
+
+	r.notifyClosing()
+	r.wg.Wait()
+	r.finalize()
+}
+
+func (r *Reference) setClosed() bool {
+	r.lock.Lock()
+	defer r.lock.Unlock()
+	if r.closed {
+		return false
+	}
+	r.closed = true
+	return true
+}
+
+func (r *Reference) notifyClosing() {
+	r.lock.Lock()
+	defer r.lock.Unlock()
+	if r.running {
+		logger.Debugf("Sending closed event...")
+		r.closech <- true
+	}
+}
+
+func (r *Reference) get() (interface{}, bool) {
+	r.setLastAccessed()
+	p := atomic.LoadPointer(&r.ref)
+	if p == nil {
+		return nil, false
+	}
+	return (*valueHolder)(p).value, true
+}
+
+func (r *Reference) isSet() bool {
+	return atomic.LoadPointer(&r.ref) != nil
+}
+
+func (r *Reference) set(value interface{}) {
+	atomic.StorePointer(&r.ref, unsafe.Pointer(&valueHolder{value: value})) // nolint: gas
+}
+
+func (r *Reference) setLastAccessed() {
+	now := time.Now()
+	atomic.StorePointer(&r.lastTimeAccessed, unsafe.Pointer(&now)) // nolint: gas
+}
+
+func (r *Reference) lastAccessed() time.Time {
+	p := atomic.LoadPointer(&r.lastTimeAccessed)
+	return *(*time.Time)(p)
+}
+
+func (r *Reference) setTimerRunning() bool {
+	r.lock.Lock()
+	defer r.lock.Unlock()
+
+	if r.running || r.closed {
+		logger.Debug("Cannot start timer since timer is either already running or it is closed")
+		return false
+	}
+
+	r.running = true
+	r.wg.Add(1)
+	logger.Debug("Timer started")
+	return true
+}
+
+func (r *Reference) setTimerStopped() {
+	r.lock.Lock()
+	defer r.lock.Unlock()
+	logger.Debug("Timer stopped")
+	r.running = false
+	r.wg.Done()
+}
+
+func (r *Reference) ensureTimerStarted(initialExpiration time.Duration) {
+	if r.running {
+		logger.Debug("Timer is already running")
+		return
+	}
+
+	r.setLastAccessed()
+
+	go checkTimeStarted(r, initialExpiration)
+}
+
+func checkTimeStarted(r *Reference, initialExpiration time.Duration) {
+	if !r.setTimerRunning() {
+		logger.Debug("Timer is already running")
+		return
+	}
+	defer r.setTimerStopped()
+
+	logger.Debug("Starting timer")
+
+	expiry := initialExpiration
+	for {
+		select {
+		case <-r.closech:
+			logger.Debug("Got closed event. Exiting timer.")
+			return
+
+		case <-time.After(expiry):
+			expiration := r.expirationProvider()
+
+			if !r.isSet() && r.expiryType != Refreshing {
+				expiry = expiration
+				logger.Debugf("Reference is not set. Will expire again in %s", expiry)
+				continue
+			}
+
+			if r.expiryType == LastInitialized || r.expiryType == Refreshing {
+				logger.Debugf("Handling expiration...")
+				r.handleExpiration()
+				expiry = expiration
+				logger.Debugf("... finished handling expiration. Setting expiration to %s", expiry)
+			} else {
+				// Check how long it's been since last access
+				durSinceLastAccess := time.Since(r.lastAccessed())
+				logger.Debugf("Duration since last access is %s", durSinceLastAccess)
+				if durSinceLastAccess > expiration {
+					logger.Debugf("... handling expiration...")
+					r.handleExpiration()
+					expiry = expiration
+					logger.Debugf("... finished handling expiration. Setting expiration to %s", expiry)
+				} else {
+					// Set another expiry for the remainder of the time
+					expiry = expiration - durSinceLastAccess
+					logger.Debugf("Not expired yet. Will check again in %s", expiry)
+				}
+			}
+		}
+	}
+}
+
+func (r *Reference) finalize() {
+	if r.finalizer == nil {
+		return
+	}
+
+	r.lock.Lock()
+	defer r.lock.Unlock()
+
+	if r.isSet() {
+		value, _ := r.get()
+		r.finalizer(value)
+	}
+}
+
+func (r *Reference) handleExpiration() {
+	r.lock.Lock()
+	defer r.lock.Unlock()
+
+	logger.Debug("Invoking expiration handler")
+	r.expirationHandler()
+}
+
+// resetValue is an expiration handler that calls the
+// finalizer and resets the reference to nil.
+// Note: This function is invoked from inside a write
+// lock so there's no need to lock
+func (r *Reference) resetValue() {
+	if r.finalizer != nil {
+		value, _ := r.get()
+		r.finalizer(value)
+	}
+	atomic.StorePointer(&r.ref, nil)
+}
+
+// refreshValue is an expiration handler that calls the
+// initializer and, if the initializer was successful, resets
+// the reference with the new value.
+// Note: This function is invoked from inside a write
+// lock so there's no need to lock
+func (r *Reference) refreshValue() {
+	if value, err := r.initializer(nil); err != nil {
+		logger.Warningf("Error - initializer returned error: %s. Will retry again later", err)
+	} else {
+		r.set(value)
+	}
+}
+
+func first(data []interface{}) interface{} {
+	if len(data) == 0 {
+		return nil
+	}
+	return data[0]
+}
diff --git a/util/concurrent/lazyref/options.go b/util/concurrent/lazyref/options.go
new file mode 100644
index 000000000..64e54c571
--- /dev/null
+++ b/util/concurrent/lazyref/options.go
@@ -0,0 +1,133 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package lazyref
+
+import (
+	"time"
+
+	"github.com/hyperledger/fabric-sdk-go/pkg/common/options"
+)
+
+// WithIdleExpiration sets the idle-time expiration for the reference.
+// The reference is expired after not being accessed for the given duration.
+func WithIdleExpiration(value time.Duration) options.Opt {
+	return func(p options.Params) {
+		logger.Debug("Checking idleExpirationSetter")
+		if setter, ok := p.(idleExpirationSetter); ok {
+			setter.SetIdleExpiration(value)
+		}
+	}
+}
+
+// WithAbsoluteExpiration sets the expiration time for the reference.
+// It will expire after this time period, regardless of whether or not
+// it has been recently accessed.
+func WithAbsoluteExpiration(value time.Duration) options.Opt {
+	return func(p options.Params) {
+		logger.Debug("Checking absoluteExpirationSetter")
+		if setter, ok := p.(absoluteExpirationSetter); ok {
+			setter.SetAbsoluteExpiration(value)
+		}
+	}
+}
+
+// WithExpirationProvider sets the expiration provider, which determines
+// the expiration time of the reference
+func WithExpirationProvider(expirationProvider ExpirationProvider, expiryType ExpirationType) options.Opt {
+	return func(p options.Params) {
+		logger.Debug("Checking expirationProviderSetter")
+		if setter, ok := p.(expirationProviderSetter); ok {
+			setter.SetExpirationProvider(expirationProvider, expiryType)
+		}
+	}
+}
+
+// WithFinalizer sets a finalizer function that is called when the
+// reference is closed or if it expires
+func WithFinalizer(finalizer Finalizer) options.Opt {
+	return func(p options.Params) {
+		logger.Debug("Checking finalizerSetter")
+		if setter, ok := p.(finalizerSetter); ok {
+			setter.SetFinalizer(finalizer)
+		}
+	}
+}
+
+const (
+	// InitOnFirstAccess specifies that the reference should be initialized the first time it is accessed
+	InitOnFirstAccess time.Duration = time.Duration(-1)
+
+	// InitImmediately specifies that the reference should be initialized immediately after it is created
+	InitImmediately time.Duration = time.Duration(0)
+)
+
+// WithRefreshInterval specifies that the reference should be proactively refreshed.
+// Argument, initialInit, if greater than or equal to 0, indicates that the reference
+// should be initialized after this duration. If less than 0, the reference will be
+// initialized on first access.
+// Argument, refreshPeriod, is the period at which the reference will be refreshed.
+// Note that the Finalizer will not be invoked each time the value is refreshed.
+func WithRefreshInterval(initialInit, refreshPeriod time.Duration) options.Opt {
+	return func(p options.Params) {
+		logger.Debug("Checking refreshIntervalSetter")
+		if setter, ok := p.(refreshIntervalSetter); ok {
+			setter.SetRefreshInterval(initialInit, refreshPeriod)
+		}
+	}
+}
+
+type idleExpirationSetter interface {
+	SetIdleExpiration(expiration time.Duration)
+}
+
+type absoluteExpirationSetter interface {
+	SetAbsoluteExpiration(expiration time.Duration)
+}
+
+type expirationProviderSetter interface {
+	SetExpirationProvider(expirationProvider ExpirationProvider, expiryType ExpirationType)
+}
+
+type finalizerSetter interface {
+	SetFinalizer(value Finalizer)
+}
+
+type refreshIntervalSetter interface {
+	SetRefreshInterval(initialInit, refreshPeriod time.Duration)
+}
+
+type params struct {
+	initialInit        time.Duration
+	finalizer          Finalizer
+	expirationProvider ExpirationProvider
+	expiryType         ExpirationType
+}
+
+func (p *params) SetIdleExpiration(expiration time.Duration) {
+	p.expirationProvider = NewSimpleExpirationProvider(expiration)
+	p.expiryType = LastAccessed
+}
+
+func (p *params) SetAbsoluteExpiration(expiration time.Duration) {
+	p.expirationProvider = NewSimpleExpirationProvider(expiration)
+	p.expiryType = LastInitialized
+}
+
+func (p *params) SetExpirationProvider(expirationProvider ExpirationProvider, expiryType ExpirationType) {
+	p.expirationProvider = expirationProvider
+	p.expiryType = expiryType
+}
+
+func (p *params) SetFinalizer(value Finalizer) {
+	p.finalizer = value
+}
+
+func (p *params) SetRefreshInterval(initialInit, refreshPeriod time.Duration) {
+	p.expiryType = Refreshing
+	p.expirationProvider = NewSimpleExpirationProvider(refreshPeriod)
+	p.initialInit = initialInit
+}
diff --git a/util/concurrent/options/options.go b/util/concurrent/options/options.go
new file mode 100644
index 000000000..1f5e935e5
--- /dev/null
+++ b/util/concurrent/options/options.go
@@ -0,0 +1,21 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package options
+
+// Params represents a construct that holds
+// a set of parameters
+type Params interface{}
+
+// Opt is an option that is applied to Params
+type Opt func(opts Params)
+
+// Apply applies the given options to the given Params
+func Apply(params Params, opts []Opt) {
+	for _, opt := range opts {
+		opt(params)
+	}
+}
-- 
2.15.2 (Apple Git-101.1)

