diff a/core/ledger/kvledger/kv_ledger_provider.go b/core/ledger/kvledger/kv_ledger_provider.go	(rejected hunks)
@@ -7,24 +7,22 @@ SPDX-License-Identifier: Apache-2.0
 package kvledger
 
 import (
-	"bytes"
 	"errors"
 	"fmt"
 
-	"github.com/hyperledger/fabric/core/ledger/confighistory"
-
-	"github.com/golang/protobuf/proto"
-	"github.com/hyperledger/fabric/common/ledger/util/leveldbhelper"
 	"github.com/hyperledger/fabric/core/ledger"
+	"github.com/hyperledger/fabric/core/ledger/confighistory"
+	"github.com/hyperledger/fabric/core/ledger/confighistory/cdbconfighistory"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/bookkeeping"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb"
-	"github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb/historyleveldb"
+	"github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb/historydbprovider"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/privacyenabledstate"
 	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
 	"github.com/hyperledger/fabric/core/ledger/ledgerstorage"
+	"github.com/hyperledger/fabric/core/ledger/util"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/utils"
-	"github.com/syndtr/goleveldb/leveldb"
+	"golang.org/x/net/context"
 )
 
 var (
@@ -34,14 +32,11 @@ var (
 	ErrNonExistingLedgerID = errors.New("LedgerID does not exist")
 	// ErrLedgerNotOpened is thrown by a CloseLedger call if a ledger with the given id has not been opened
 	ErrLedgerNotOpened = errors.New("Ledger is not opened yet")
-
-	underConstructionLedgerKey = []byte("underConstructionLedgerKey")
-	ledgerKeyPrefix            = []byte("l")
 )
 
 // Provider implements interface ledger.PeerLedgerProvider
 type Provider struct {
-	idStore             *idStore
+	idStore             idStore
 	ledgerStoreProvider *ledgerstorage.Provider
 	vdbProvider         privacyenabledstate.DBProvider
 	historydbProvider   historydb.HistoryDBProvider
@@ -57,9 +52,15 @@ func NewProvider() (ledger.PeerLedgerProvider, error) {
 	logger.Info("Initializing ledger provider")
 
 	// Initialize the ID store (inventory of chainIds/ledgerIds)
-	idStore := openIDStore(ledgerconfig.GetLedgerProviderPath())
+	idStore, err := openIDStore()
+	if err != nil {
+		return nil, err
+	}
 
-	ledgerStoreProvider := ledgerstorage.NewProvider()
+	ledgerStoreProvider, err := ledgerstorage.NewProvider()
+	if err != nil {
+		return nil, err
+	}
 
 	// Initialize the versioned database (state database)
 	vdbProvider, err := privacyenabledstate.NewCommonStorageDBProvider()
@@ -68,10 +69,25 @@ func NewProvider() (ledger.PeerLedgerProvider, error) {
 	}
 
 	// Initialize the history database (index for history of values by key)
-	historydbProvider := historyleveldb.NewHistoryDBProvider()
+	historydbProvider, err := historydbprovider.NewHistoryDBProvider()
+	if err != nil {
+		return nil, err
+	}
+
 	bookkeepingProvider := bookkeeping.NewProvider()
-	// Initialize config history mgr
-	configHistoryMgr := confighistory.NewMgr()
+
+	configHistoryStorageConfig := ledgerconfig.GetConfigHistoryStoreProvider()
+	var configHistoryMgr confighistory.Mgr
+	switch configHistoryStorageConfig {
+	case ledgerconfig.LevelDBConfigHistoryStorage:
+		configHistoryMgr = confighistory.NewMgr()
+	case ledgerconfig.CouchDBConfigHistoryStorage:
+		configHistoryMgr, err = cdbconfighistory.NewMgr()
+		if err != nil {
+			return nil, err
+		}
+	}
+
 	logger.Info("ledger provider Initialized")
 	provider := &Provider{idStore, ledgerStoreProvider, vdbProvider, historydbProvider, configHistoryMgr, nil, bookkeepingProvider}
 	provider.recoverUnderConstructionLedger()
@@ -93,21 +109,32 @@ func (provider *Provider) Create(genesisBlock *common.Block) (ledger.PeerLedger,
 	if err != nil {
 		return nil, err
 	}
-	exists, err := provider.idStore.ledgerIDExists(ledgerID)
+	exists, err := provider.idStore.LedgerIDExists(ledgerID)
 	if err != nil {
 		return nil, err
 	}
 	if exists {
 		return nil, ErrLedgerIDExists
 	}
-	if err = provider.idStore.setUnderConstructionFlag(ledgerID); err != nil {
+	if err = provider.idStore.SetUnderConstructionFlag(ledgerID); err != nil {
 		return nil, err
 	}
 	lgr, err := provider.openInternal(ledgerID)
 	if err != nil {
 		logger.Errorf("Error in opening a new empty ledger. Unsetting under construction flag. Err: %s", err)
 		panicOnErr(provider.runCleanup(ledgerID), "Error while running cleanup for ledger id [%s]", ledgerID)
-		panicOnErr(provider.idStore.unsetUnderConstructionFlag(), "Error while unsetting under construction flag")
+		panicOnErr(provider.idStore.UnsetUnderConstructionFlag(), "Error while unsetting under construction flag")
+		return nil, err
+	}
+	txFlags := util.TxValidationFlags(genesisBlock.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER])
+	if err := lgr.ValidateMVCC(context.Background(), genesisBlock, txFlags, util.TxFilterAcceptAll); err != nil {
+		lgr.Close()
+		return nil, err
+	}
+	if err := lgr.ValidateBlockWithPvtData(&ledger.BlockAndPvtData{
+		Block: genesisBlock,
+	}); err != nil {
+		lgr.Close()
 		return nil, err
 	}
 	if err := lgr.CommitWithPvtData(&ledger.BlockAndPvtData{
@@ -205,12 +232,12 @@ func (provider *Provider) recoverUnderConstructionLedger() {
 	case 0:
 		logger.Infof("Genesis block was not committed. Hence, the peer ledger not created. unsetting the under construction flag")
 		panicOnErr(provider.runCleanup(ledgerID), "Error while running cleanup for ledger id [%s]", ledgerID)
-		panicOnErr(provider.idStore.unsetUnderConstructionFlag(), "Error while unsetting under construction flag")
+		panicOnErr(provider.idStore.UnsetUnderConstructionFlag(), "Error while unsetting under construction flag")
 	case 1:
 		logger.Infof("Genesis block was committed. Hence, marking the peer ledger as created")
 		genesisBlock, err := ledger.GetBlockByNumber(0)
 		panicOnErr(err, "Error while retrieving genesis block from blockchain for ledger [%s]", ledgerID)
-		panicOnErr(provider.idStore.createLedgerID(ledgerID, genesisBlock), "Error while adding ledgerID [%s] to created list", ledgerID)
+		panicOnErr(provider.idStore.CreateLedgerID(ledgerID, genesisBlock), "Error while adding ledgerID [%s] to created list", ledgerID)
 	default:
 		panic(fmt.Errorf(
 			"Data inconsistency: under construction flag is set for ledger [%s] while the height of the blockchain is [%d]",
@@ -237,89 +264,3 @@ func panicOnErr(err error, mgsFormat string, args ...interface{}) {
 	args = append(args, err)
 	panic(fmt.Sprintf(mgsFormat+" Err:%s ", args...))
 }
-
-//////////////////////////////////////////////////////////////////////
-// Ledger id persistence related code
-///////////////////////////////////////////////////////////////////////
-type idStore struct {
-	db *leveldbhelper.DB
-}
-
-func openIDStore(path string) *idStore {
-	db := leveldbhelper.CreateDB(&leveldbhelper.Conf{DBPath: path})
-	db.Open()
-	return &idStore{db}
-}
-
-func (s *idStore) setUnderConstructionFlag(ledgerID string) error {
-	return s.db.Put(underConstructionLedgerKey, []byte(ledgerID), true)
-}
-
-func (s *idStore) unsetUnderConstructionFlag() error {
-	return s.db.Delete(underConstructionLedgerKey, true)
-}
-
-func (s *idStore) getUnderConstructionFlag() (string, error) {
-	val, err := s.db.Get(underConstructionLedgerKey)
-	if err != nil {
-		return "", err
-	}
-	return string(val), nil
-}
-
-func (s *idStore) createLedgerID(ledgerID string, gb *common.Block) error {
-	key := s.encodeLedgerKey(ledgerID)
-	var val []byte
-	var err error
-	if val, err = proto.Marshal(gb); err != nil {
-		return err
-	}
-	if val, err = s.db.Get(key); err != nil {
-		return err
-	}
-	if val != nil {
-		return ErrLedgerIDExists
-	}
-	batch := &leveldb.Batch{}
-	batch.Put(key, val)
-	batch.Delete(underConstructionLedgerKey)
-	return s.db.WriteBatch(batch, true)
-}
-
-func (s *idStore) ledgerIDExists(ledgerID string) (bool, error) {
-	key := s.encodeLedgerKey(ledgerID)
-	val := []byte{}
-	err := error(nil)
-	if val, err = s.db.Get(key); err != nil {
-		return false, err
-	}
-	return val != nil, nil
-}
-
-func (s *idStore) getAllLedgerIds() ([]string, error) {
-	var ids []string
-	itr := s.db.GetIterator(nil, nil)
-	defer itr.Release()
-	itr.First()
-	for itr.Valid() {
-		if bytes.Equal(itr.Key(), underConstructionLedgerKey) {
-			continue
-		}
-		id := string(s.decodeLedgerID(itr.Key()))
-		ids = append(ids, id)
-		itr.Next()
-	}
-	return ids, nil
-}
-
-func (s *idStore) close() {
-	s.db.Close()
-}
-
-func (s *idStore) encodeLedgerKey(ledgerID string) []byte {
-	return append(ledgerKeyPrefix, []byte(ledgerID)...)
-}
-
-func (s *idStore) decodeLedgerID(key []byte) string {
-	return string(key[len(ledgerKeyPrefix):])
-}
