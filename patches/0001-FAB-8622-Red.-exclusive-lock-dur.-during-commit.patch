From 5591ae7d4f8a02dd790f4277002a97c65be189a5 Mon Sep 17 00:00:00 2001
From: senthil <cendhu@gmail.com>
Date: Wed, 16 May 2018 14:20:49 +0530
Subject: [PATCH] [FAB-8622] Red. exclusive lock dur. during commit

Currently, the ledger transaction manager acquires an exclusive lock
on the database before calling ApplyPrivacyAwareUpdates() (i.e., final
commit of valid write sets). Within this locking period only, for
CouchDB, we fetch the revision number of missing keys, check whether the
document is either JSON or attachment, and add certain metadata field
to the document. As this exclusive lock affects the time taken to simulate
a transaction and hence the overall throughput and latency, this CR
removes certain operation such as loading missing keys revisions, checking
json struct, and wrapping the doc with metadata out of the lock holding
period and acquire the lock only during the final bulk update REST API
call to couchDB.

This CR splits the existing ApplyPrivacyAwareUpdates() in DB interface
into three following APIs
(i) PrepareForPrivacyAwareUpdates()() -- retrieve missing revision
numbers, check whether the document is either JSON or attached, etc...
(ii) ApplyPrivacyAwareUpdates() -- commit to state database. An
exclusive lock is required for this operation alone.
(iii) PostUpdateProcessing() -- updates the savepoint value.

Similarly, the ApplyUpdate() in VersionedDB interface is split into
(i) PrepareForUpdates()
(ii) ApplyUpdates()
(iii) PostUpdateProcessing()
to support the three APIs defined in DB interface.

A minor fix to transaction manager. The exclusive lock was released in
a defer func in Commit(). As a result, even without acquiring a lock, we
would end up releasing the lock which would result in a panic. Further,
the lock holding duration would be high if we release in a defer
function. Hence, this CR acquires an exclusive lock only for
ApplyPrivacyAwareUpdates() call.

To maintain consistency with golevelDB implementation, this CR made
similar API changes to golevelDB too.

Change-Id: Id92732424efe934d7501523de5e72a8a2a587156
Signed-off-by: senthil <cendhu@gmail.com>
---
 .../privacyenabledstate/common_storage_db.go       |  18 ++--
 .../kvledger/txmgmt/privacyenabledstate/db.go      |   3 +-
 .../kvledger/txmgmt/privacyenabledstate/db_test.go |  26 +++--
 .../txmgmt/pvtstatepurgemgmt/purge_mgr_test.go     |   4 +-
 .../txmgmt/statedb/commontests/test_common.go      | 116 +++++++++++++++++----
 .../txmgmt/statedb/statecouchdb/statecouchdb.go    |  51 +++++----
 .../statedb/statecouchdb/statecouchdb_test.go      |  17 +--
 core/ledger/kvledger/txmgmt/statedb/statedb.go     |  14 ++-
 .../txmgmt/statedb/stateleveldb/stateleveldb.go    |  52 ++++++---
 .../statedb/stateleveldb/stateleveldb_test.go      |   7 +-
 .../txmgmt/txmgr/lockbasedtxmgr/helper_test.go     |   4 +-
 .../txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go |  23 ++--
 .../txmgmt/txmgr/lockbasedtxmgr/pkg_test.go        |   4 +-
 .../txmgmt/txmgr/lockbasedtxmgr/txmgr_test.go      |   8 +-
 .../statebasedval/combined_iterator_test.go        |   4 +-
 .../statebasedval/range_query_validator_test.go    |   4 +-
 .../statebasedval/state_based_validator_test.go    |  16 ++-
 17 files changed, 274 insertions(+), 97 deletions(-)

diff --git a/core/ledger/kvledger/txmgmt/privacyenabledstate/common_storage_db.go b/core/ledger/kvledger/txmgmt/privacyenabledstate/common_storage_db.go
index e48aa6b0a..acc26c42d 100644
--- a/core/ledger/kvledger/txmgmt/privacyenabledstate/common_storage_db.go
+++ b/core/ledger/kvledger/txmgmt/privacyenabledstate/common_storage_db.go
@@ -192,17 +192,15 @@ func (s CommonStorageDB) ExecuteQueryOnPrivateData(namespace, collection, query
 	return s.ExecuteQuery(derivePvtDataNs(namespace, collection), query)
 }
 
-// ApplyUpdates overrides the funciton in statedb.VersionedDB and throws appropriate error message
-// Otherwise, somewhere in the code, usage of this function could lead to updating only public data.
-func (s *CommonStorageDB) ApplyUpdates(batch *statedb.UpdateBatch, height *version.Height) error {
-	return fmt.Errorf("This function should not be invoked on this type. Please invoke function 'ApplyPrivacyAwareUpdates'")
+func (s *CommonStorageDB) PrepareForPrivacyAwareUpdates(updates *UpdateBatch, height *version.Height) error {
+	addPvtUpdates(updates.PubUpdates, updates.PvtUpdates)
+	addHashedUpdates(updates.PubUpdates, updates.HashUpdates, !s.BytesKeySuppoted())
+	return s.VersionedDB.PrepareForUpdates(updates.PubUpdates.UpdateBatch, height)
 }
 
 // ApplyPrivacyAwareUpdates implements corresponding function in interface DB
-func (s *CommonStorageDB) ApplyPrivacyAwareUpdates(updates *UpdateBatch, height *version.Height) error {
-	addPvtUpdates(updates.PubUpdates, updates.PvtUpdates)
-	addHashedUpdates(updates.PubUpdates, updates.HashUpdates, !s.BytesKeySuppoted())
-	return s.VersionedDB.ApplyUpdates(updates.PubUpdates.UpdateBatch, height)
+func (s *CommonStorageDB) ApplyPrivacyAwareUpdates() error {
+	return s.VersionedDB.ApplyUpdates()
 }
 
 // HandleChaincodeDeploy initializes database artifacts for the database associated with the namespace
@@ -258,6 +256,10 @@ func (s *CommonStorageDB) ChaincodeDeployDone(succeeded bool) {
 	// NOOP
 }
 
+func (s *CommonStorageDB) PostUpdateProcessing() error {
+	return s.VersionedDB.PostUpdateProcessing()
+}
+
 func derivePvtDataNs(namespace, collection string) string {
 	return namespace + nsJoiner + pvtDataPrefix + collection
 }
diff --git a/core/ledger/kvledger/txmgmt/privacyenabledstate/db.go b/core/ledger/kvledger/txmgmt/privacyenabledstate/db.go
index 78030dbbe..fdf1429ff 100644
--- a/core/ledger/kvledger/txmgmt/privacyenabledstate/db.go
+++ b/core/ledger/kvledger/txmgmt/privacyenabledstate/db.go
@@ -36,7 +36,8 @@ type DB interface {
 	GetPrivateDataMultipleKeys(namespace, collection string, keys []string) ([]*statedb.VersionedValue, error)
 	GetPrivateDataRangeScanIterator(namespace, collection, startKey, endKey string) (statedb.ResultsIterator, error)
 	ExecuteQueryOnPrivateData(namespace, collection, query string) (statedb.ResultsIterator, error)
-	ApplyPrivacyAwareUpdates(updates *UpdateBatch, height *version.Height) error
+	PrepareForPrivacyAwareUpdates(updates *UpdateBatch, height *version.Height) error
+	ApplyPrivacyAwareUpdates() error
 }
 
 // PvtdataCompositeKey encloses Namespace, CollectionName and Key components
diff --git a/core/ledger/kvledger/txmgmt/privacyenabledstate/db_test.go b/core/ledger/kvledger/txmgmt/privacyenabledstate/db_test.go
index 810c85a35..b04be50c4 100644
--- a/core/ledger/kvledger/txmgmt/privacyenabledstate/db_test.go
+++ b/core/ledger/kvledger/txmgmt/privacyenabledstate/db_test.go
@@ -91,7 +91,10 @@ func testDB(t *testing.T, env TestEnv) {
 	putPvtUpdates(t, updates, "ns1", "coll1", "key1", []byte("pvt_value1"), version.NewHeight(1, 4))
 	putPvtUpdates(t, updates, "ns1", "coll1", "key2", []byte("pvt_value2"), version.NewHeight(1, 5))
 	putPvtUpdates(t, updates, "ns2", "coll1", "key3", []byte("pvt_value3"), version.NewHeight(1, 6))
-	db.ApplyPrivacyAwareUpdates(updates, version.NewHeight(2, 6))
+	db.PrepareForPrivacyAwareUpdates(updates, version.NewHeight(2, 6))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
+
 	commonStorageDB := db.(*CommonStorageDB)
 	bulkOptimizable, ok := commonStorageDB.VersionedDB.(statedb.BulkOptimizable)
 	if ok {
@@ -117,7 +120,9 @@ func testDB(t *testing.T, env TestEnv) {
 	updates = NewUpdateBatch()
 	updates.PubUpdates.Delete("ns1", "key1", version.NewHeight(2, 7))
 	deletePvtUpdates(t, updates, "ns1", "coll1", "key1", version.NewHeight(2, 7))
-	db.ApplyPrivacyAwareUpdates(updates, version.NewHeight(2, 7))
+	db.PrepareForPrivacyAwareUpdates(updates, version.NewHeight(2, 7))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	vv, err = db.GetState("ns1", "key1")
 	assert.NoError(t, err)
@@ -153,7 +158,9 @@ func testGetStateMultipleKeys(t *testing.T, env TestEnv) {
 	putPvtUpdates(t, updates, "ns1", "coll1", "key1", []byte("pvt_value1"), version.NewHeight(1, 4))
 	putPvtUpdates(t, updates, "ns1", "coll1", "key2", []byte("pvt_value2"), version.NewHeight(1, 5))
 	putPvtUpdates(t, updates, "ns1", "coll1", "key3", []byte("pvt_value3"), version.NewHeight(1, 6))
-	db.ApplyPrivacyAwareUpdates(updates, version.NewHeight(2, 6))
+	db.PrepareForPrivacyAwareUpdates(updates, version.NewHeight(2, 6))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	versionedVals, err := db.GetStateMultipleKeys("ns1", []string{"key1", "key3"})
 	assert.NoError(t, err)
@@ -204,7 +211,9 @@ func testGetStateRangeScanIterator(t *testing.T, env TestEnv) {
 	putPvtUpdates(t, updates, "ns2", "coll1", "key5", []byte("pvt_value5"), version.NewHeight(1, 5))
 	putPvtUpdates(t, updates, "ns2", "coll1", "key6", []byte("pvt_value6"), version.NewHeight(1, 6))
 	putPvtUpdates(t, updates, "ns3", "coll1", "key7", []byte("pvt_value7"), version.NewHeight(1, 7))
-	db.ApplyPrivacyAwareUpdates(updates, version.NewHeight(2, 7))
+	db.PrepareForPrivacyAwareUpdates(updates, version.NewHeight(2, 7))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	itr1, _ := db.GetStateRangeScanIterator("ns1", "key1", "")
 	testItr(t, itr1, []string{"key1", "key2", "key3", "key4"})
@@ -269,7 +278,9 @@ func testQueryOnCouchDB(t *testing.T, env TestEnv) {
 		putPvtUpdates(t, updates, "ns1", "coll1", testKey(i), []byte(jsonValue), version.NewHeight(1, uint64(i)))
 		putPvtUpdates(t, updates, "ns2", "coll1", testKey(i), []byte(jsonValue), version.NewHeight(1, uint64(i)))
 	}
-	db.ApplyPrivacyAwareUpdates(updates, version.NewHeight(1, 11))
+	db.PrepareForPrivacyAwareUpdates(updates, version.NewHeight(1, 11))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	// query for owner=jerry, use namespace "ns1"
 	itr, err := db.ExecuteQuery("ns1", `{"selector":{"owner":"jerry"}}`)
@@ -341,8 +352,9 @@ func testLongDBNameOnCouchDB(t *testing.T, env TestEnv) {
 	updates.PubUpdates.Put(ns, "key1", []byte("value1"), version.NewHeight(1, 1))
 	updates.PvtUpdates.Put(ns, coll, "key1", []byte("pvt_value"), version.NewHeight(1, 2))
 	updates.HashUpdates.Put(ns, coll, util.ComputeStringHash("key1"), util.ComputeHash([]byte("pvt_value")), version.NewHeight(1, 2))
-
-	db.ApplyPrivacyAwareUpdates(updates, version.NewHeight(2, 6))
+	db.PrepareForPrivacyAwareUpdates(updates, version.NewHeight(2, 6))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	vv, err := db.GetState(ns, "key1")
 	assert.NoError(t, err)
diff --git a/core/ledger/kvledger/txmgmt/pvtstatepurgemgmt/purge_mgr_test.go b/core/ledger/kvledger/txmgmt/pvtstatepurgemgmt/purge_mgr_test.go
index f301e0b17..9e7ced32f 100644
--- a/core/ledger/kvledger/txmgmt/pvtstatepurgemgmt/purge_mgr_test.go
+++ b/core/ledger/kvledger/txmgmt/pvtstatepurgemgmt/purge_mgr_test.go
@@ -240,7 +240,9 @@ func (h *testHelper) cleanup() {
 func (h *testHelper) commitUpdatesForTesting(blkNum uint64, updates *privacyenabledstate.UpdateBatch) {
 	h.purgeMgr.PrepareForExpiringKeys(blkNum)
 	assert.NoError(h.t, h.purgeMgr.DeleteExpiredAndUpdateBookkeeping(updates.PvtUpdates, updates.HashUpdates))
-	assert.NoError(h.t, h.db.ApplyPrivacyAwareUpdates(updates, version.NewHeight(blkNum, 1)))
+	assert.NoError(h.t, h.db.PrepareForPrivacyAwareUpdates(updates, version.NewHeight(blkNum, 1)))
+	assert.NoError(h.t, h.db.ApplyPrivacyAwareUpdates())
+	assert.NoError(h.t, h.db.PostUpdateProcessing())
 	h.db.ClearCachedVersions()
 	h.purgeMgr.BlockCommitDone()
 }
diff --git a/core/ledger/kvledger/txmgmt/statedb/commontests/test_common.go b/core/ledger/kvledger/txmgmt/statedb/commontests/test_common.go
index 4b1c85dd7..456a4a364 100644
--- a/core/ledger/kvledger/txmgmt/statedb/commontests/test_common.go
+++ b/core/ledger/kvledger/txmgmt/statedb/commontests/test_common.go
@@ -48,7 +48,12 @@ func TestGetStateMultipleKeys(t *testing.T, dbProvider statedb.VersionedDBProvid
 	batch.Put("ns2", "key3", vv3.Value, vv3.Version)
 	batch.Put("ns2", "key4", vv4.Value, vv4.Version)
 	savePoint := version.NewHeight(2, 5)
-	db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
+	testutil.AssertNoError(t, err, "")
 
 	actualValues, _ := db.GetStateMultipleKeys("ns1", []string{"key1", "key2"})
 	testutil.AssertEquals(t, actualValues, expectedValues)
@@ -82,7 +87,12 @@ func TestBasicRW(t *testing.T, dbProvider statedb.VersionedDBProvider) {
 	batch.Put("ns2", "key4", vv4.Value, vv4.Version)
 	batch.Put("ns2", "key5", vv5.Value, vv5.Version)
 	savePoint := version.NewHeight(2, 5)
-	db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
+	testutil.AssertNoError(t, err, "")
 
 	vv, _ := db.GetState("ns1", "key1")
 	testutil.AssertEquals(t, vv, &vv1)
@@ -113,7 +123,12 @@ func TestMultiDBBasicRW(t *testing.T, dbProvider statedb.VersionedDBProvider) {
 	batch1.Put("ns1", "key1", vv1.Value, vv1.Version)
 	batch1.Put("ns1", "key2", vv2.Value, vv2.Version)
 	savePoint1 := version.NewHeight(1, 2)
-	db1.ApplyUpdates(batch1, savePoint1)
+	err = db1.PrepareForUpdates(batch1, savePoint1)
+	testutil.AssertNoError(t, err, "")
+	err = db1.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db1.PostUpdateProcessing()
+	testutil.AssertNoError(t, err, "")
 
 	batch2 := statedb.NewUpdateBatch()
 	vv3 := statedb.VersionedValue{Value: []byte("value1_db2"), Version: version.NewHeight(1, 4)}
@@ -121,7 +136,12 @@ func TestMultiDBBasicRW(t *testing.T, dbProvider statedb.VersionedDBProvider) {
 	batch2.Put("ns1", "key1", vv3.Value, vv3.Version)
 	batch2.Put("ns1", "key2", vv4.Value, vv4.Version)
 	savePoint2 := version.NewHeight(1, 5)
-	db2.ApplyUpdates(batch2, savePoint2)
+	err = db2.PrepareForUpdates(batch2, savePoint2)
+	testutil.AssertNoError(t, err, "")
+	err = db2.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db2.PostUpdateProcessing()
+	testutil.AssertNoError(t, err, "")
 
 	vv, _ := db1.GetState("ns1", "key1")
 	testutil.AssertEquals(t, vv, &vv1)
@@ -155,8 +175,13 @@ func TestDeletes(t *testing.T, dbProvider statedb.VersionedDBProvider) {
 	batch.Put("ns", "key4", vv2.Value, vv4.Version)
 	batch.Delete("ns", "key3", version.NewHeight(1, 5))
 	savePoint := version.NewHeight(1, 5)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
+
 	vv, _ := db.GetState("ns", "key2")
 	testutil.AssertEquals(t, vv, &vv2)
 
@@ -166,7 +191,11 @@ func TestDeletes(t *testing.T, dbProvider statedb.VersionedDBProvider) {
 
 	batch = statedb.NewUpdateBatch()
 	batch.Delete("ns", "key2", version.NewHeight(1, 6))
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 	vv, err = db.GetState("ns", "key2")
 	testutil.AssertNoError(t, err, "")
@@ -188,7 +217,12 @@ func TestIterator(t *testing.T, dbProvider statedb.VersionedDBProvider) {
 	batch.Put("ns2", "key6", []byte("value6"), version.NewHeight(1, 6))
 	batch.Put("ns3", "key7", []byte("value7"), version.NewHeight(1, 7))
 	savePoint := version.NewHeight(2, 5)
-	db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
+	testutil.AssertNoError(t, err, "")
 
 	itr1, _ := db.GetStateRangeScanIterator("ns1", "key1", "")
 	testItr(t, itr1, []string{"key1", "key2", "key3", "key4"})
@@ -259,7 +293,12 @@ func TestQuery(t *testing.T, dbProvider statedb.VersionedDBProvider) {
 	batch.Put("ns2", "key10", []byte(jsonValue10), version.NewHeight(1, 21))
 
 	savePoint := version.NewHeight(2, 22)
-	db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
+	testutil.AssertNoError(t, err, "")
 
 	// query for owner=jerry, use namespace "ns1"
 	itr, err := db.ExecuteQuery("ns1", "{\"selector\":{\"owner\":\"jerry\"}}")
@@ -512,7 +551,11 @@ func TestGetVersion(t *testing.T, dbProvider statedb.VersionedDBProvider) {
 	batch.Put("ns", "key3", vv2.Value, vv3.Version)
 	batch.Put("ns", "key4", vv2.Value, vv4.Version)
 	savePoint := version.NewHeight(1, 5)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 
 	//check to see if the bulk optimizable interface is supported (couchdb)
@@ -584,7 +627,12 @@ func TestSmallBatchSize(t *testing.T, dbProvider statedb.VersionedDBProvider) {
 	batch.Put("ns1", "key11", jsonValue11, version.NewHeight(1, 11))
 
 	savePoint := version.NewHeight(1, 12)
-	db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
+	testutil.AssertNoError(t, err, "")
 
 	//Verify all marbles were added
 
@@ -639,7 +687,11 @@ func TestBatchWithIndividualRetry(t *testing.T, dbProvider statedb.VersionedDBPr
 	batch.Put("ns", "key3", vv3.Value, vv3.Version)
 	batch.Put("ns", "key4", vv4.Value, vv4.Version)
 	savePoint := version.NewHeight(1, 5)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 
 	// Clear the cache for the next batch, in place of simulation
@@ -654,7 +706,11 @@ func TestBatchWithIndividualRetry(t *testing.T, dbProvider statedb.VersionedDBPr
 	batch.Put("ns", "key3", vv3.Value, vv3.Version)
 	batch.Put("ns", "key4", vv4.Value, vv4.Version)
 	savePoint = version.NewHeight(1, 6)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 
 	// Update document key3
@@ -662,7 +718,11 @@ func TestBatchWithIndividualRetry(t *testing.T, dbProvider statedb.VersionedDBPr
 	batch.Delete("ns", "key2", vv2.Version)
 	batch.Put("ns", "key3", vv3.Value, vv3.Version)
 	savePoint = version.NewHeight(1, 7)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 
 	// This should force a retry for couchdb revision conflict for both delete and update
@@ -671,7 +731,11 @@ func TestBatchWithIndividualRetry(t *testing.T, dbProvider statedb.VersionedDBPr
 	batch.Delete("ns", "key2", vv2.Version)
 	batch.Put("ns", "key3", vv3.Value, vv3.Version)
 	savePoint = version.NewHeight(1, 8)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 
 	//Create a new set of values that use JSONs instead of binary
@@ -692,7 +756,11 @@ func TestBatchWithIndividualRetry(t *testing.T, dbProvider statedb.VersionedDBPr
 	batch.Put("ns1", "key7", jsonValue7, version.NewHeight(1, 11))
 	batch.Put("ns1", "key8", jsonValue8, version.NewHeight(1, 12))
 	savePoint = version.NewHeight(1, 6)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 
 	// Clear the cache for the next batch, in place of simulation
@@ -708,7 +776,11 @@ func TestBatchWithIndividualRetry(t *testing.T, dbProvider statedb.VersionedDBPr
 	batch.Put("ns1", "key7", jsonValue7, version.NewHeight(1, 11))
 	batch.Put("ns1", "key8", jsonValue8, version.NewHeight(1, 12))
 	savePoint = version.NewHeight(1, 6)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 
 	// Update document key3
@@ -717,7 +789,11 @@ func TestBatchWithIndividualRetry(t *testing.T, dbProvider statedb.VersionedDBPr
 	batch.Delete("ns1", "key6", version.NewHeight(1, 13))
 	batch.Put("ns1", "key7", jsonValue7, version.NewHeight(1, 14))
 	savePoint = version.NewHeight(1, 15)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 
 	// This should force a retry for couchdb revision conflict for both delete and update
@@ -726,7 +802,11 @@ func TestBatchWithIndividualRetry(t *testing.T, dbProvider statedb.VersionedDBPr
 	batch.Delete("ns1", "key6", version.NewHeight(1, 16))
 	batch.Put("ns1", "key7", jsonValue7, version.NewHeight(1, 17))
 	savePoint = version.NewHeight(1, 18)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
 	testutil.AssertNoError(t, err, "")
 
 }
diff --git a/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb.go b/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb.go
index d0db360b8..4405166b7 100644
--- a/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb.go
+++ b/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb.go
@@ -74,6 +74,15 @@ func (provider *VersionedDBProvider) Close() {
 	// No close needed on Couch
 }
 
+type stateUpdates struct {
+	updateBatches []batch
+}
+
+type savePointUpdate struct {
+	height     *version.Height
+	namespaces []string
+}
+
 // VersionedDB implements VersionedDB interface
 type VersionedDB struct {
 	couchInstance      *couchdb.CouchInstance
@@ -83,6 +92,8 @@ type VersionedDB struct {
 	committedDataCache *versionsCache                    // Used as a local cache during bulk processing of a block.
 	verCacheLock       sync.RWMutex
 	mux                sync.RWMutex
+	stateUpdates       *stateUpdates
+	savePointUpdate    *savePointUpdate
 }
 
 // newVersionedDB constructs an instance of VersionedDB
@@ -296,33 +307,33 @@ func (vdb *VersionedDB) ExecuteQuery(namespace, query string) (statedb.ResultsIt
 	return newQueryScanner(namespace, *queryResult), nil
 }
 
-// ApplyUpdates implements method in VersionedDB interface
-func (vdb *VersionedDB) ApplyUpdates(updates *statedb.UpdateBatch, height *version.Height) error {
+func (vdb *VersionedDB) PrepareForUpdates(updates *statedb.UpdateBatch, height *version.Height) error {
+	updateBatches, err := vdb.buildCommitters(updates)
+	if err != nil {
+		return err
+	}
 
-	stopWatch := applyUpdatesTimer.Start()
-	defer stopWatch.Stop()
+	vdb.stateUpdates = &stateUpdates{updateBatches}
+	vdb.savePointUpdate = &savePointUpdate{height, updates.GetUpdatedNamespaces()}
 
-	// TODO a note about https://jira.hyperledger.org/browse/FAB-8622
-	// the function `Apply update can be split into three functions. Each carrying out one of the following three stages`.
-	// The write lock is needed only for the stage 2.
+	return nil
+}
 
-	// stage 1 - PrepareForUpdates - db transforms the given batch in the form of underlying db
-	// and keep it in memory
-	var updateBatches []batch
-	var err error
-	if updateBatches, err = vdb.buildCommitters(updates); err != nil {
-		return err
-	}
-	// stage 2 - ApplyUpdates push the changes to the DB
-	if err = executeBatches(updateBatches); err != nil {
+// ApplyUpdates implements method in VersionedDB interface
+func (vdb *VersionedDB) ApplyUpdates() error {
+	stopWatch := applyUpdatesTimer.Start()
+	defer stopWatch.Stop()
+	// ApplyUpdates push the changes to the DB
+	if err := executeBatches(vdb.stateUpdates.updateBatches); err != nil {
 		return err
 	}
+	return nil
+}
 
-	// Stgae 3 - PostUpdateProcessing - flush and record savepoint.
-	namespaces := updates.GetUpdatedNamespaces()
+func (vdb *VersionedDB) PostUpdateProcessing() error {
 	// Record a savepoint at a given height
-	if err = vdb.ensureFullCommitAndRecordSavepoint(height, namespaces); err != nil {
-		logger.Errorf("Error during recordSavepoint: %s\n", err.Error())
+	if err := vdb.ensureFullCommitAndRecordSavepoint(vdb.savePointUpdate.height, vdb.savePointUpdate.namespaces); err != nil {
+		logger.Errorf("Error during recordSavepoint: %s", err.Error())
 		return err
 	}
 	return nil
diff --git a/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb_test.go b/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb_test.go
index 4ae67e122..5f5f3593b 100644
--- a/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb_test.go
+++ b/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb_test.go
@@ -244,7 +244,8 @@ func TestInvalidJSONFields(t *testing.T) {
 	batch.Put("ns1", "key1", []byte(jsonValue1), version.NewHeight(1, 1))
 
 	savePoint := version.NewHeight(1, 2)
-	err = db.ApplyUpdates(batch, savePoint)
+
+	err = db.PrepareForUpdates(batch, savePoint)
 	testutil.AssertError(t, err, "Invalid field _id should have thrown an error")
 
 	batch = statedb.NewUpdateBatch()
@@ -252,7 +253,7 @@ func TestInvalidJSONFields(t *testing.T) {
 	batch.Put("ns1", "key1", []byte(jsonValue1), version.NewHeight(1, 1))
 
 	savePoint = version.NewHeight(1, 2)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
 	testutil.AssertError(t, err, "Invalid field _rev should have thrown an error")
 
 	batch = statedb.NewUpdateBatch()
@@ -260,15 +261,14 @@ func TestInvalidJSONFields(t *testing.T) {
 	batch.Put("ns1", "key1", []byte(jsonValue1), version.NewHeight(1, 1))
 
 	savePoint = version.NewHeight(1, 2)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
 	testutil.AssertError(t, err, "Invalid field _deleted should have thrown an error")
 
 	batch = statedb.NewUpdateBatch()
 	jsonValue1 = `{"~version":"v1","asset_name":"marble1","color":"blue","size":1,"owner":"tom"}`
 	batch.Put("ns1", "key1", []byte(jsonValue1), version.NewHeight(1, 1))
-
 	savePoint = version.NewHeight(1, 2)
-	err = db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
 	testutil.AssertError(t, err, "Invalid field ~version should have thrown an error")
 }
 
@@ -338,7 +338,12 @@ func TestHandleChaincodeDeploy(t *testing.T) {
 	batch.Put("ns2", "key10", []byte(jsonValue10), version.NewHeight(1, 21))
 
 	savePoint := version.NewHeight(2, 22)
-	db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
+	testutil.AssertNoError(t, err, "")
 
 	//Create a tar file for test with 4 index definitions and 2 side dbs
 	dbArtifactsTarBytes := testutil.CreateTarBytesForTest(
diff --git a/core/ledger/kvledger/txmgmt/statedb/statedb.go b/core/ledger/kvledger/txmgmt/statedb/statedb.go
index 0fda8c149..560a02932 100644
--- a/core/ledger/kvledger/txmgmt/statedb/statedb.go
+++ b/core/ledger/kvledger/txmgmt/statedb/statedb.go
@@ -36,10 +36,16 @@ type VersionedDB interface {
 	GetStateRangeScanIterator(namespace string, startKey string, endKey string) (ResultsIterator, error)
 	// ExecuteQuery executes the given query and returns an iterator that contains results of type *VersionedKV.
 	ExecuteQuery(namespace, query string) (ResultsIterator, error)
-	// ApplyUpdates applies the batch to the underlying db.
-	// height is the height of the highest transaction in the Batch that
-	// a state db implementation is expected to ues as a save point
-	ApplyUpdates(batch *UpdateBatch, height *version.Height) error
+	// PrepareForUpdates constructs the final batch, which would be committed
+	// to the state database, from the updateBatch and height.
+	// Height is the height of the highest transaction in the Batch that
+	// a state db implementation is expected to use as a save point
+	PrepareForUpdates(batch *UpdateBatch, height *version.Height) error
+	// ApplyUpdates applies the final batch to the underlying db.
+	ApplyUpdates() error
+	// PostUpdateProcessing performs task such as storing save point that needs to be performed after updating
+	// the state database (i.e., after ApplyUpdate()) .
+	PostUpdateProcessing() error
 	// GetLatestSavePoint returns the height of the highest transaction upto which
 	// the state db is consistent
 	GetLatestSavePoint() (*version.Height, error)
diff --git a/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb.go b/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb.go
index e925d38e4..79138eb7e 100644
--- a/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb.go
+++ b/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb.go
@@ -54,15 +54,25 @@ func (provider *VersionedDBProvider) Close() {
 	provider.dbProvider.Close()
 }
 
+type stateUpdates struct {
+	updateBatch *leveldbhelper.UpdateBatch
+}
+
+type savePointUpdate struct {
+	height *version.Height
+}
+
 // VersionedDB implements VersionedDB interface
 type versionedDB struct {
-	db     *leveldbhelper.DBHandle
-	dbName string
+	db              *leveldbhelper.DBHandle
+	dbName          string
+	stateUpdates    *stateUpdates
+	savePointUpdate *savePointUpdate
 }
 
 // newVersionedDB constructs an instance of VersionedDB
 func newVersionedDB(db *leveldbhelper.DBHandle, dbName string) *versionedDB {
-	return &versionedDB{db, dbName}
+	return &versionedDB{db, dbName, nil, nil}
 }
 
 // Open implements method in VersionedDB interface
@@ -144,13 +154,8 @@ func (vdb *versionedDB) ExecuteQuery(namespace, query string) (statedb.ResultsIt
 	return nil, errors.New("ExecuteQuery not supported for leveldb")
 }
 
-// ApplyUpdates implements method in VersionedDB interface
-func (vdb *versionedDB) ApplyUpdates(batch *statedb.UpdateBatch, height *version.Height) error {
-
-	stopWatch := applyUpdatesTimer.Start()
-	defer stopWatch.Stop()
-
-	dbBatch := leveldbhelper.NewUpdateBatch()
+func (vdb *versionedDB) PrepareForUpdates(batch *statedb.UpdateBatch, height *version.Height) error {
+	stateUpdates := &stateUpdates{leveldbhelper.NewUpdateBatch()}
 	namespaces := batch.GetUpdatedNamespaces()
 	for _, ns := range namespaces {
 		updates := batch.GetUpdates(ns)
@@ -159,17 +164,36 @@ func (vdb *versionedDB) ApplyUpdates(batch *statedb.UpdateBatch, height *version
 			logger.Debugf("Channel [%s]: Applying key(string)=[%s] key(bytes)=[%#v]", vdb.dbName, string(compositeKey), compositeKey)
 
 			if vv.Value == nil {
-				dbBatch.Delete(compositeKey)
+				stateUpdates.updateBatch.Delete(compositeKey)
 			} else {
-				dbBatch.Put(compositeKey, EncodeValue(vv.Value, vv.Version))
+				stateUpdates.updateBatch.Put(compositeKey, EncodeValue(vv.Value, vv.Version))
 			}
 		}
 	}
-	dbBatch.Put(savePointKey, height.ToBytes())
+
+	vdb.stateUpdates = stateUpdates
+	vdb.savePointUpdate = &savePointUpdate{height}
+
+	return nil
+}
+
+// ApplyUpdates implements method in VersionedDB interface
+func (vdb *versionedDB) ApplyUpdates() error {
+	stopWatch := applyUpdatesTimer.Start()
+	defer stopWatch.Stop()
 	// Setting snyc to true as a precaution, false may be an ok optimization after further testing.
-	if err := vdb.db.WriteBatch(dbBatch, true); err != nil {
+	if err := vdb.db.WriteBatch(vdb.stateUpdates.updateBatch, true); err != nil {
+		return err
+	}
+	vdb.stateUpdates = nil
+	return nil
+}
+
+func (vdb *versionedDB) PostUpdateProcessing() error {
+	if err := vdb.db.Put(savePointKey, vdb.savePointUpdate.height.ToBytes(), true); err != nil {
 		return err
 	}
+	vdb.savePointUpdate = nil
 	return nil
 }
 
diff --git a/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb_test.go b/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb_test.go
index 66f2fd00e..9431421b5 100644
--- a/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb_test.go
+++ b/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb_test.go
@@ -94,7 +94,12 @@ func TestQueryOnLevelDB(t *testing.T) {
 	batch.Put("ns1", "key1", []byte(jsonValue1), version.NewHeight(1, 1))
 
 	savePoint := version.NewHeight(2, 22)
-	db.ApplyUpdates(batch, savePoint)
+	err = db.PrepareForUpdates(batch, savePoint)
+	testutil.AssertNoError(t, err, "")
+	err = db.ApplyUpdates()
+	testutil.AssertNoError(t, err, "")
+	err = db.PostUpdateProcessing()
+	testutil.AssertNoError(t, err, "")
 
 	// query for owner=jerry, use namespace "ns1"
 	// As queries are not supported in levelDB, call to ExecuteQuery()
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper_test.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper_test.go
index 69bbb8a31..0ed9fba47 100644
--- a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper_test.go
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper_test.go
@@ -53,7 +53,9 @@ func TestPvtdataResultsItr(t *testing.T) {
 	putPvtUpdates(t, updates, "ns2", "coll1", "key5", []byte("pvt_value5"), version.NewHeight(1, 5))
 	putPvtUpdates(t, updates, "ns2", "coll1", "key6", []byte("pvt_value6"), version.NewHeight(1, 6))
 	putPvtUpdates(t, updates, "ns3", "coll1", "key7", []byte("pvt_value7"), version.NewHeight(1, 7))
-	txMgr.db.ApplyPrivacyAwareUpdates(updates, version.NewHeight(2, 7))
+	txMgr.db.PrepareForPrivacyAwareUpdates(updates, version.NewHeight(2, 7))
+	txMgr.db.ApplyPrivacyAwareUpdates()
+	txMgr.db.PostUpdateProcessing()
 	queryHelper := newQueryHelper(txMgr, nil)
 
 	resItr, err := queryHelper.getPrivateDataRangeScanIterator("ns1", "coll1", "key1", "key3")
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go
index 0e94e6813..9f9e4d47f 100644
--- a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go
@@ -177,19 +177,28 @@ func (txmgr *LockBasedTxMgr) Commit() error {
 		return err
 	}
 
-	// Measure acquiring the lock
+	// Stage 1: PreUpdateProcessing
+	commitHeight := version.NewHeight(txmgr.current.blockNum(), txmgr.current.maxTxNumber())
+	if err := txmgr.db.PrepareForPrivacyAwareUpdates(txmgr.current.batch, commitHeight); err != nil {
+		return err
+	}
+
+	// Stage 2: ApplyPrivacyAwareUpdates
 	lockStopWatch := commitLockTimer.Start()
 	txmgr.commitRWLock.Lock()
-	defer txmgr.commitRWLock.Unlock()
 	lockStopWatch.Stop()
-
 	// Measure after acquiring the lock
 	afterLockStopWatch := commitAfterLockTimer.Start()
-	defer afterLockStopWatch.Stop()
-
 	logger.Debugf("Write lock acquired for committing updates to state database")
-	commitHeight := version.NewHeight(txmgr.current.blockNum(), txmgr.current.maxTxNumber())
-	if err := txmgr.db.ApplyPrivacyAwareUpdates(txmgr.current.batch, commitHeight); err != nil {
+	if err := txmgr.db.ApplyPrivacyAwareUpdates(); err != nil {
+		txmgr.commitRWLock.Unlock()
+		afterLockStopWatch.Stop()
+		return err
+	}
+	txmgr.commitRWLock.Unlock()
+	afterLockStopWatch.Stop()
+
+	if err := txmgr.db.PostUpdateProcessing(); err != nil {
 		return err
 	}
 	logger.Debugf("Updates committed to state database")
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pkg_test.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pkg_test.go
index 41a3ff1a0..a5d3c9885 100644
--- a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pkg_test.go
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pkg_test.go
@@ -169,5 +169,7 @@ func populateCollConfigForTest(t *testing.T, txMgr *LockBasedTxMgr, nsColls []co
 		testutil.AssertNoError(t, err, "")
 		updates.PubUpdates.Put(lsccNamespace, constructCollectionConfigKey(ns), pkgBytes, ht)
 	}
-	txMgr.db.ApplyPrivacyAwareUpdates(updates, ht)
+	txMgr.db.PrepareForPrivacyAwareUpdates(updates, ht)
+	txMgr.db.ApplyPrivacyAwareUpdates()
+	txMgr.db.PostUpdateProcessing()
 }
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/txmgr_test.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/txmgr_test.go
index 01aa05e9f..48aea24fc 100644
--- a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/txmgr_test.go
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/txmgr_test.go
@@ -737,7 +737,9 @@ func TestTxSimulatorMissingPvtdata(t *testing.T) {
 	updateBatch := privacyenabledstate.NewUpdateBatch()
 	updateBatch.HashUpdates.Put("ns1", "coll1", util.ComputeStringHash("key1"), util.ComputeStringHash("value1"), version.NewHeight(1, 1))
 	updateBatch.PvtUpdates.Put("ns1", "coll1", "key1", []byte("value1"), version.NewHeight(1, 1))
-	db.ApplyPrivacyAwareUpdates(updateBatch, version.NewHeight(1, 1))
+	db.PrepareForPrivacyAwareUpdates(updateBatch, version.NewHeight(1, 1))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	simulator, _ := txMgr.NewTxSimulator("testTxid1")
 	val, _ := simulator.GetPrivateData("ns1", "coll1", "key1")
@@ -749,7 +751,9 @@ func TestTxSimulatorMissingPvtdata(t *testing.T) {
 	updateBatch.HashUpdates.Put("ns1", "coll2", util.ComputeStringHash("key2"), util.ComputeStringHash("value2"), version.NewHeight(2, 1))
 	updateBatch.HashUpdates.Put("ns1", "coll3", util.ComputeStringHash("key3"), util.ComputeStringHash("value3"), version.NewHeight(2, 1))
 	updateBatch.PvtUpdates.Put("ns1", "coll3", "key3", []byte("value3"), version.NewHeight(2, 1))
-	db.ApplyPrivacyAwareUpdates(updateBatch, version.NewHeight(2, 1))
+	db.PrepareForPrivacyAwareUpdates(updateBatch, version.NewHeight(2, 1))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 	simulator, _ = txMgr.NewTxSimulator("testTxid2")
 	defer simulator.Done()
 
diff --git a/core/ledger/kvledger/txmgmt/validator/statebasedval/combined_iterator_test.go b/core/ledger/kvledger/txmgmt/validator/statebasedval/combined_iterator_test.go
index ccca4e55d..6800bbb41 100644
--- a/core/ledger/kvledger/txmgmt/validator/statebasedval/combined_iterator_test.go
+++ b/core/ledger/kvledger/txmgmt/validator/statebasedval/combined_iterator_test.go
@@ -38,7 +38,9 @@ func TestCombinedIterator(t *testing.T) {
 	batch.Put("ns", "key4", []byte("value4"), version.NewHeight(1, 1))
 	batch.Put("ns", "key6", []byte("value6"), version.NewHeight(1, 1))
 	batch.Put("ns", "key8", []byte("value8"), version.NewHeight(1, 1))
-	db.ApplyUpdates(batch, version.NewHeight(1, 5))
+	db.PrepareForUpdates(batch, version.NewHeight(1, 5))
+	db.ApplyUpdates()
+	db.PostUpdateProcessing()
 
 	// prepare batch1
 	batch1 := statedb.NewUpdateBatch()
diff --git a/core/ledger/kvledger/txmgmt/validator/statebasedval/range_query_validator_test.go b/core/ledger/kvledger/txmgmt/validator/statebasedval/range_query_validator_test.go
index d29cc8cc6..8c39bfed3 100644
--- a/core/ledger/kvledger/txmgmt/validator/statebasedval/range_query_validator_test.go
+++ b/core/ledger/kvledger/txmgmt/validator/statebasedval/range_query_validator_test.go
@@ -70,7 +70,9 @@ func testRangeQuery(t *testing.T, testcase string, stateData *statedb.UpdateBatc
 		db, err := testDBEnv.DBProvider.GetDBHandle("TestDB")
 		testutil.AssertNoError(t, err, "")
 		if stateData != nil {
-			db.ApplyUpdates(stateData, savepoint)
+			db.PrepareForUpdates(stateData, savepoint)
+			db.ApplyUpdates()
+			db.PostUpdateProcessing()
 		}
 
 		itr, err := db.GetStateRangeScanIterator(ns, rqi.StartKey, rqi.EndKey)
diff --git a/core/ledger/kvledger/txmgmt/validator/statebasedval/state_based_validator_test.go b/core/ledger/kvledger/txmgmt/validator/statebasedval/state_based_validator_test.go
index 37a1c5603..783452eee 100644
--- a/core/ledger/kvledger/txmgmt/validator/statebasedval/state_based_validator_test.go
+++ b/core/ledger/kvledger/txmgmt/validator/statebasedval/state_based_validator_test.go
@@ -80,7 +80,9 @@ func TestValidatorBulkLoadingOfCache(t *testing.T) {
 	batch.HashUpdates.Put(hashedKV1.namespace, hashedKV1.collection, hashedKV1.keyHash, hashedKV1.value, hashedKV1.version)
 	batch.HashUpdates.Put(hashedKV2.namespace, hashedKV2.collection, hashedKV2.keyHash, hashedKV2.value, hashedKV2.version)
 
-	db.ApplyPrivacyAwareUpdates(batch, version.NewHeight(1, 4))
+	db.PrepareForPrivacyAwareUpdates(batch, version.NewHeight(1, 4))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	// Construct read set for transaction 1. It contains two public KV pairs (pubKV1, pubKV2) and two
 	// hashed KV pairs (hashedKV1, hashedKV2).
@@ -191,7 +193,9 @@ func TestValidator(t *testing.T) {
 	batch.PubUpdates.Put("ns1", "key3", []byte("value3"), version.NewHeight(1, 2))
 	batch.PubUpdates.Put("ns1", "key4", []byte("value4"), version.NewHeight(1, 3))
 	batch.PubUpdates.Put("ns1", "key5", []byte("value5"), version.NewHeight(1, 4))
-	db.ApplyPrivacyAwareUpdates(batch, version.NewHeight(1, 4))
+	db.PrepareForPrivacyAwareUpdates(batch, version.NewHeight(1, 4))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	validator := NewValidator(db)
 
@@ -234,7 +238,9 @@ func TestPhantomValidation(t *testing.T) {
 	batch.PubUpdates.Put("ns1", "key3", []byte("value3"), version.NewHeight(1, 2))
 	batch.PubUpdates.Put("ns1", "key4", []byte("value4"), version.NewHeight(1, 3))
 	batch.PubUpdates.Put("ns1", "key5", []byte("value5"), version.NewHeight(1, 4))
-	db.ApplyPrivacyAwareUpdates(batch, version.NewHeight(1, 4))
+	db.PrepareForPrivacyAwareUpdates(batch, version.NewHeight(1, 4))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	validator := NewValidator(db)
 
@@ -309,7 +315,9 @@ func TestPhantomHashBasedValidation(t *testing.T) {
 	batch.PubUpdates.Put("ns1", "key7", []byte("value7"), version.NewHeight(1, 6))
 	batch.PubUpdates.Put("ns1", "key8", []byte("value8"), version.NewHeight(1, 7))
 	batch.PubUpdates.Put("ns1", "key9", []byte("value9"), version.NewHeight(1, 8))
-	db.ApplyPrivacyAwareUpdates(batch, version.NewHeight(1, 8))
+	db.PrepareForPrivacyAwareUpdates(batch, version.NewHeight(1, 8))
+	db.ApplyPrivacyAwareUpdates()
+	db.PostUpdateProcessing()
 
 	validator := NewValidator(db)
 
-- 
2.15.2 (Apple Git-101.1)

