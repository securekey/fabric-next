diff a/core/ledger/ledgerstorage/store.go b/core/ledger/ledgerstorage/store.go	(rejected hunks)
@@ -20,14 +20,25 @@ import (
 	"fmt"
 	"sync"
 
-	"github.com/hyperledger/fabric/common/flogging"
-	"github.com/hyperledger/fabric/common/ledger/blkstorage"
+	"github.com/hyperledger/fabric/common/ledger/blkstorage/cachedblkstore"
+	"github.com/hyperledger/fabric/common/ledger/blkstorage/ldbblkindex"
+	"github.com/hyperledger/fabric/common/ledger/blkstorage/memblkcache"
+
 	"github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage"
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
 	"github.com/hyperledger/fabric/core/ledger/pvtdatapolicy"
-	"github.com/hyperledger/fabric/core/ledger/pvtdatastorage"
 	"github.com/hyperledger/fabric/protos/common"
+	"github.com/pkg/errors"
+
+	"github.com/hyperledger/fabric/common/flogging"
+	"github.com/hyperledger/fabric/common/ledger/blkstorage"
+	"github.com/hyperledger/fabric/common/ledger/blkstorage/cdbblkstorage"
+	"github.com/hyperledger/fabric/common/metrics"
+	"github.com/hyperledger/fabric/core/ledger/pvtdatastorage"
+	"github.com/hyperledger/fabric/core/ledger/pvtdatastorage/cachedpvtdatastore"
+	"github.com/hyperledger/fabric/core/ledger/pvtdatastorage/cdbpvtdata"
+	"github.com/hyperledger/fabric/core/ledger/pvtdatastorage/mempvtdatacache"
 )
 
 var logger = flogging.MustGetLogger("ledgerstorage")
@@ -163,7 +237,7 @@ func (s *Store) GetPvtDataByNum(blockNum uint64, filter ledger.PvtNsCollFilter)
 
 // getPvtDataByNumWithoutLock returns only the pvt data  corresponding to the given block number.
 // This function does not acquire a readlock and it is expected that in most of the circumstances, the caller
-// posesses a read lock on `s.rwlock`
+// possesses a read lock on `s.rwlock`
 func (s *Store) getPvtDataByNumWithoutLock(blockNum uint64, filter ledger.PvtNsCollFilter) ([]*ledger.TxPvtData, error) {
 	var pvtdata []*ledger.TxPvtData
 	var err error
@@ -192,7 +280,7 @@ func (s *Store) init() error {
 // This situation is expected to happen when a peer is upgrated from version 1.0
 // and an existing blockchain is present that was generated with version 1.0.
 // Under this scenario, the pvtdata store is brought upto the point as if it has
-// processed exisitng blocks with no pvt data. This function returns true if the
+// processed existng blocks with no pvt data. This function returns true if the
 // above mentioned condition is found to be true and pvtdata store is successfully updated
 func (s *Store) initPvtdataStoreFromExistingBlockchain() (bool, error) {
 	var bcInfo *common.BlockchainInfo
@@ -251,6 +339,35 @@ func (s *Store) syncPvtdataStoreWithBlockStore() error {
 	return fmt.Errorf("This is not expected. blockStoreHeight=%d, pvtdataStoreHeight=%d", bcInfo.Height, pvtdataStoreHt)
 }
 
+func (s *Store) initCouchDB() error {
+	if !ledgerconfig.IsCommitter() {
+		return s.initPvtdataStoreFromExistingBlockchainCouchDB()
+	}
+
+	return nil
+}
+
+// initPvtdataStoreFromExistingBlockchainCouchDB updates the initial state of the pvtdata store
+// if an existing block store has a blockchain and the pvtdata store is empty. Scenario for CouchDB
+func (s *Store) initPvtdataStoreFromExistingBlockchainCouchDB() error {
+	var bcInfo *common.BlockchainInfo
+	var err error
+
+	if bcInfo, err = s.BlockStore.GetBlockchainInfo(); err != nil {
+		return err
+	}
+	if _, err = s.pvtdataStore.IsEmpty(); err != nil {
+		return err
+	}
+	if bcInfo.Height > 0 {
+		if err = s.pvtdataStore.InitLastCommittedBlock(bcInfo.Height - 1); err != nil {
+			return err
+		}
+		return nil
+	}
+	return nil
+}
+
 func constructPvtdataMap(pvtdata []*ledger.TxPvtData) map[uint64]*ledger.TxPvtData {
 	if pvtdata == nil {
 		return nil
