diff a/core/peer/peer.go b/core/peer/peer.go	(rejected hunks)
@@ -19,7 +19,7 @@ import (
 	"github.com/hyperledger/fabric/common/flogging"
 	commonledger "github.com/hyperledger/fabric/common/ledger"
 	"github.com/hyperledger/fabric/common/ledger/blockledger"
-	fileledger "github.com/hyperledger/fabric/common/ledger/blockledger/file"
+	"github.com/hyperledger/fabric/common/ledger/blockledger/file"
 	"github.com/hyperledger/fabric/common/policies"
 	"github.com/hyperledger/fabric/core/comm"
 	"github.com/hyperledger/fabric/core/committer"
@@ -197,35 +217,50 @@ func Initialize(init func(string), ccp ccprovider.ChaincodeProvider, sccp sysccp
 
 	pluginMapper = pm
 	chainInitializer = init
+	ccProvider = ccp
+	sccProvider = sccp
 
-	var cb *common.Block
-	var ledger ledger.PeerLedger
 	ledgermgmt.Initialize(ConfigTxProcessors)
 	ledgerIds, err := ledgermgmt.GetLedgerIDs()
 	if err != nil {
 		panic(fmt.Errorf("Error in initializing ledgermgmt: %s", err))
 	}
 	for _, cid := range ledgerIds {
-		peerLogger.Infof("Loading chain %s", cid)
-		if ledger, err = ledgermgmt.OpenLedger(cid); err != nil {
-			peerLogger.Warningf("Failed to load ledger %s(%s)", cid, err)
-			peerLogger.Debugf("Error while loading ledger %s with message %s. We continue to the next ledger rather than abort.", cid, err)
-			continue
-		}
-		if cb, err = getCurrConfigBlockFromLedger(ledger); err != nil {
-			peerLogger.Warningf("Failed to find config block on ledger %s(%s)", cid, err)
-			peerLogger.Debugf("Error while looking for config block on ledger %s with message %s. We continue to the next ledger rather than abort.", cid, err)
-			continue
-		}
-		// Create a chain if we get a valid ledger with config block
-		if err = createChain(cid, ledger, cb, ccp, sccp, pm); err != nil {
-			peerLogger.Warningf("Failed to load chain %s(%s)", cid, err)
-			peerLogger.Debugf("Error reloading chain %s with message %s. We continue to the next chain rather than abort.", cid, err)
+		if err := InitializeChannel(cid); err != nil {
+			peerLogger.Warningf("Failed to initialize channel [%s]: err", cid, err)
 			continue
 		}
+	}
+}
+
+// InitializeChannel initializes the given channel from persistence
+func InitializeChannel(cid string) error {
+	peerLogger.Infof("Loading channel [%s]", cid)
+
+	var err error
+	var ledger ledger.PeerLedger
+	if ledger, err = ledgermgmt.OpenLedger(cid); err != nil {
+		peerLogger.Warningf("Failed to load ledger %s(%s)", cid, err)
+		peerLogger.Debugf("Error while loading ledger %s with message %s. We continue to the next ledger rather than abort.", cid, err)
+		return err
+	}
+
+	var cb *common.Block
+	if cb, err = getCurrConfigBlockFromLedger(ledger); err != nil {
+		peerLogger.Warningf("Failed to find config block on ledger %s(%s)", cid, err)
+		peerLogger.Debugf("Error while looking for config block on ledger %s with message %s. We continue to the next ledger rather than abort.", cid, err)
+		return err
+	}
 
-		InitChain(cid)
+	// Create a chain if we get a valid ledger with config block
+	if err = createChain(cid, ledger, cb, ccProvider, sccProvider, pluginMapper); err != nil {
+		peerLogger.Warningf("Failed to load chain %s(%s)", cid, err)
+		peerLogger.Debugf("Error reloading chain %s with message %s. We continue to the next chain rather than abort.", cid, err)
+		return err
 	}
+
+	InitChain(cid)
+	return nil
 }
 
 // InitChain takes care to initialize chain after peer joined, for example deploys system CCs
