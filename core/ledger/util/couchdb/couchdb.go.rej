diff a/core/ledger/util/couchdb/couchdb.go b/core/ledger/util/couchdb/couchdb.go	(rejected hunks)
@@ -27,8 +29,12 @@ import (
 	"unicode/utf8"
 
 	"github.com/hyperledger/fabric/common/flogging"
+
+	"github.com/hyperledger/fabric/common/metrics"
+	"github.com/hyperledger/fabric/common/util/retry"
 	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
-	logging "github.com/op/go-logging"
+	"github.com/op/go-logging"
+	"github.com/pkg/errors"
 )
 
 var logger = flogging.MustGetLogger("couchdb")
@@ -117,12 +122,13 @@ type QueryResult struct {
 
 //CouchConnectionDef contains parameters
 type CouchConnectionDef struct {
-	URL                 string
-	Username            string
-	Password            string
-	MaxRetries          int
-	MaxRetriesOnStartup int
-	RequestTimeout      time.Duration
+	URL                   string
+	Username              string
+	Password              string
+	MaxRetries            int
+	MaxRetriesOnStartup   int
+	RequestTimeout        time.Duration
+	CreateGlobalChangesDB bool
 }
 
 //CouchInstance represents a CouchDB instance
@@ -156,10 +162,18 @@ type CreateIndexResponse struct {
 type AttachmentInfo struct {
 	Name            string
 	ContentType     string
-	Length          uint64
 	AttachmentBytes []byte
 }
 
+//AttachmentResponse contains the definition for an attached inline file for couchdb
+type AttachmentResponse struct {
+	ContentType string `json:"content_type"`
+	RevPos      int    `json:"revpos"`
+	Digest      string `json:"digest"`
+	Data        string `json:"data"`
+	Stub        bool   `json:"stub"`
+}
+
 //FileDetails defines the structure needed to send an attachment to couchdb
 type FileDetails struct {
 	Follows     bool   `json:"follows"`
@@ -230,7 +265,7 @@ func closeResponseBody(resp *http.Response) {
 
 //CreateConnectionDefinition for a new client connection
 func CreateConnectionDefinition(couchDBAddress, username, password string, maxRetries,
-	maxRetriesOnStartup int, requestTimeout time.Duration) (*CouchConnectionDef, error) {
+	maxRetriesOnStartup int, requestTimeout time.Duration, createGlobalChangesDB bool) (*CouchConnectionDef, error) {
 
 	logger.Debugf("Entering CreateConnectionDefinition()")
 
@@ -251,7 +286,7 @@ func CreateConnectionDefinition(couchDBAddress, username, password string, maxRe
 
 	//return an object containing the connection information
 	return &CouchConnectionDef{finalURL.String(), username, password, maxRetries,
-		maxRetriesOnStartup, requestTimeout}, nil
+		maxRetriesOnStartup, requestTimeout, createGlobalChangesDB}, nil
 
 }
 
@@ -260,15 +295,18 @@ func (dbclient *CouchDatabase) CreateDatabaseIfNotExist() error {
 
 	logger.Debugf("Entering CreateDatabaseIfNotExist()")
 
-	dbInfo, couchDBReturn, err := dbclient.GetDatabaseInfo()
+	exists := true
+
+	_, err := dbclient.GetDatabaseInfo()
 	if err != nil {
-		if couchDBReturn == nil || couchDBReturn.StatusCode != 404 {
+		dbErr, ok := err.(*dbResponseError)
+		if !ok || dbErr.StatusCode != http.StatusNotFound {
 			return err
 		}
+		exists = false
 	}
 
-	//If the dbInfo returns populated and status code is 200, then the database exists
-	if dbInfo != nil && couchDBReturn.StatusCode == 200 {
+	if exists {
 
 		//Apply database security if needed
 		errSecurity := dbclient.applyDatabasePermissions()
@@ -276,15 +314,34 @@ func (dbclient *CouchDatabase) CreateDatabaseIfNotExist() error {
 			return errSecurity
 		}
 
-		logger.Debugf("Database %s already exists", dbclient.DBName)
+		logger.Infof("Database %s already exists", dbclient.DBName)
 
 		logger.Debugf("Exiting CreateDatabaseIfNotExist()")
 
 		return nil
 	}
 
-	logger.Debugf("Database %s does not exist.", dbclient.DBName)
+	logger.Infof("Database %s does not exist.", dbclient.DBName)
+
+	err = dbclient.createDatabase()
+	if err != nil {
+		return err
+	}
+
+	errSecurity := dbclient.applyDatabasePermissions()
+	if errSecurity != nil {
+		return errSecurity
+	}
+
+	logger.Infof("Created database %s", dbclient.DBName)
+
+	logger.Debugf("Exiting CreateDatabaseIfNotExist()")
+
+	return nil
 
+}
+
+func (dbclient *CouchDatabase) createDatabase() error {
 	connectURL, err := url.Parse(dbclient.CouchInstance.conf.URL)
 	if err != nil {
 		logger.Errorf("URL parse error: %s", err.Error())
@@ -296,7 +353,7 @@ func (dbclient *CouchDatabase) CreateDatabaseIfNotExist() error {
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
 	//process the URL with a PUT, creates the database
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodPut, connectURL.String(), nil, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodPut, connectURL.String(), nil, "", "", maxRetries, true)
 
 	if err != nil {
 
@@ -305,16 +362,16 @@ func (dbclient *CouchDatabase) CreateDatabaseIfNotExist() error {
 		// database may have been created and a false error
 		// returned due to a timeout or race condition.
 		// Do a final check to see if the database really got created.
-		dbInfo, couchDBReturn, errDbInfo := dbclient.GetDatabaseInfo()
+		_, errDbInfo := dbclient.GetDatabaseInfo()
 		//If there is no error, then the database exists,  return without an error
-		if errDbInfo == nil && dbInfo != nil && couchDBReturn.StatusCode == 200 {
+		if errDbInfo == nil {
 
 			errSecurity := dbclient.applyDatabasePermissions()
 			if errSecurity != nil {
 				return errSecurity
 			}
 
-			logger.Infof("Created state database %s", dbclient.DBName)
+			logger.Infof("Database [%s] was already created", dbclient.DBName)
 			logger.Debugf("Exiting CreateDatabaseIfNotExist()")
 			return nil
 		}
@@ -324,17 +381,7 @@ func (dbclient *CouchDatabase) CreateDatabaseIfNotExist() error {
 	}
 	defer closeResponseBody(resp)
 
-	errSecurity := dbclient.applyDatabasePermissions()
-	if errSecurity != nil {
-		return errSecurity
-	}
-
-	logger.Infof("Created state database %s", dbclient.DBName)
-
-	logger.Debugf("Exiting CreateDatabaseIfNotExist()")
-
 	return nil
-
 }
 
 //applyDatabaseSecurity
@@ -359,28 +406,32 @@ func (dbclient *CouchDatabase) applyDatabasePermissions() error {
 }
 
 //GetDatabaseInfo method provides function to retrieve database information
-func (dbclient *CouchDatabase) GetDatabaseInfo() (*DBInfo, *DBReturn, error) {
+func (dbclient *CouchDatabase) GetDatabaseInfo() (*DBInfo, error) {
 
 	connectURL, err := url.Parse(dbclient.CouchInstance.conf.URL)
 	if err != nil {
 		logger.Errorf("URL parse error: %s", err.Error())
-		return nil, nil, err
+		return nil, err
 	}
 	connectURL.Path = dbclient.DBName
 
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, couchDBReturn, err := dbclient.CouchInstance.handleRequest(http.MethodGet, connectURL.String(), nil, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodGet, connectURL.String(), nil, "", "", maxRetries, true)
 	if err != nil {
-		return nil, couchDBReturn, err
+		return nil, err
 	}
 	defer closeResponseBody(resp)
 
+	if resp.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf("CouchDB error, expecting return code of 200, received %v", resp.StatusCode)
+	}
+
 	dbResponse := &DBInfo{}
 	decodeErr := json.NewDecoder(resp.Body).Decode(&dbResponse)
 	if decodeErr != nil {
-		return nil, nil, decodeErr
+		return nil, decodeErr
 	}
 
 	// trace the database info response
@@ -391,38 +442,61 @@ func (dbclient *CouchDatabase) GetDatabaseInfo() (*DBInfo, *DBReturn, error) {
 		}
 	}
 
-	return dbResponse, couchDBReturn, nil
+	return dbResponse, nil
 
 }
 
 //VerifyCouchConfig method provides function to verify the connection information
-func (couchInstance *CouchInstance) VerifyCouchConfig() (*ConnectionInfo, *DBReturn, error) {
+func (couchInstance *CouchInstance) VerifyCouchConfig() (*ConnectionInfo, error) {
 
 	logger.Debugf("Entering VerifyCouchConfig()")
 	defer logger.Debugf("Exiting VerifyCouchConfig()")
 
+	dbResponse, err := couchInstance.getConnectionInfo()
+	if err != nil {
+		return nil, err
+	}
+
+	//check to see if the system databases exist
+	//Verifying the existence of the system database accomplishes two steps
+	//1.  Ensures the system databases are created
+	//2.  Verifies the username password provided in the CouchDB config are valid for system admin
+	err = CreateSystemDatabasesIfNotExist(couchInstance)
+	if err != nil {
+		logger.Errorf("Unable to connect to CouchDB,  error: %s   Check the admin username and password.\n", err.Error())
+		return nil, fmt.Errorf("Unable to connect to CouchDB,  error: %s   Check the admin username and password.\n", err.Error())
+	}
+
+	return dbResponse, nil
+}
+
+func (couchInstance *CouchInstance) getConnectionInfo() (*ConnectionInfo, error) {
 	connectURL, err := url.Parse(couchInstance.conf.URL)
 	if err != nil {
 		logger.Errorf("URL parse error: %s", err.Error())
-		return nil, nil, err
+		return nil, err
 	}
 	connectURL.Path = "/"
 
 	//get the number of retries for startup
 	maxRetriesOnStartup := couchInstance.conf.MaxRetriesOnStartup
 
-	resp, couchDBReturn, err := couchInstance.handleRequest(http.MethodGet, connectURL.String(), nil,
+	resp, err := couchInstance.handleRequest(http.MethodGet, connectURL.String(), nil,
 		couchInstance.conf.Username, couchInstance.conf.Password, maxRetriesOnStartup, true)
 
 	if err != nil {
-		return nil, couchDBReturn, fmt.Errorf("Unable to connect to CouchDB, check the hostname and port: %s", err.Error())
+		return nil, fmt.Errorf("Unable to connect to CouchDB, check the hostname and port: %s", err.Error())
 	}
 	defer closeResponseBody(resp)
 
+	if resp.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf("CouchDB connection error, expecting return code of 200, received %v", resp.StatusCode)
+	}
+
 	dbResponse := &ConnectionInfo{}
 	decodeErr := json.NewDecoder(resp.Body).Decode(&dbResponse)
 	if decodeErr != nil {
-		return nil, nil, decodeErr
+		return nil, decodeErr
 	}
 
 	// trace the database info response
@@ -432,17 +506,8 @@ func (couchInstance *CouchInstance) VerifyCouchConfig() (*ConnectionInfo, *DBRet
 			logger.Debugf("VerifyConnection() dbResponseJSON: %s", dbResponseJSON)
 		}
 	}
-	//check to see if the system databases exist
-	//Verifying the existence of the system database accomplishes two steps
-	//1.  Ensures the system databases are created
-	//2.  Verifies the username password provided in the CouchDB config are valid for system admin
-	err = CreateSystemDatabasesIfNotExist(couchInstance)
-	if err != nil {
-		logger.Errorf("Unable to connect to CouchDB,  error: %s   Check the admin username and password.\n", err.Error())
-		return nil, nil, fmt.Errorf("Unable to connect to CouchDB,  error: %s   Check the admin username and password.\n", err.Error())
-	}
 
-	return dbResponse, couchDBReturn, nil
+	return dbResponse, nil
 }
 
 //DropDatabase provides method to drop an existing database
@@ -460,7 +525,7 @@ func (dbclient *CouchDatabase) DropDatabase() (*DBOperationResponse, error) {
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodDelete, connectURL.String(), nil, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodDelete, connectURL.String(), nil, "", "", maxRetries, true)
 	if err != nil {
 		return nil, err
 	}
@@ -485,27 +550,22 @@ func (dbclient *CouchDatabase) DropDatabase() (*DBOperationResponse, error) {
 	}
 
 	return dbResponse, fmt.Errorf("Error dropping database")
-
 }
 
-// EnsureFullCommit calls _ensure_full_commit for explicit fsync
-func (dbclient *CouchDatabase) EnsureFullCommit() (*DBOperationResponse, error) {
-
-	logger.Debugf("Entering EnsureFullCommit()")
-
+func (dbclient *CouchDatabase) dbOperation(op string) (*DBOperationResponse, error) {
 	connectURL, err := url.Parse(dbclient.CouchInstance.conf.URL)
 	if err != nil {
 		logger.Errorf("URL parse error: %s", err.Error())
 		return nil, err
 	}
-	connectURL.Path = dbclient.DBName + "/_ensure_full_commit"
+	connectURL.Path = dbclient.DBName + op
 
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodPost, connectURL.String(), nil, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodPost, connectURL.String(), nil, "", "", maxRetries, true)
 	if err != nil {
-		logger.Errorf("Failed to invoke _ensure_full_commit Error: %s\n", err.Error())
+		logger.Errorf("Failed to invoke %s Error: %s\n", op, err.Error())
 		return nil, err
 	}
 	defer closeResponseBody(resp)
@@ -515,39 +575,23 @@ func (dbclient *CouchDatabase) EnsureFullCommit() (*DBOperationResponse, error)
 	if decodeErr != nil {
 		return nil, decodeErr
 	}
+	return dbResponse, nil
+}
 
-	if dbResponse.Ok == true {
-		logger.Debugf("_ensure_full_commit database %s ", dbclient.DBName)
-	}
-
-	//Check to see if autoWarmIndexes is enabled
-	//If autoWarmIndexes is enabled, indexes will be refreshed after the number of blocks
-	//in GetWarmIndexesAfterNBlocks() have been committed to the state database
-	//Check to see if the number of blocks committed exceeds the threshold for index warming
-	//Use a go routine to launch WarmIndexAllIndexes(), this will execute as a background process
-	if ledgerconfig.IsAutoWarmIndexesEnabled() {
-
-		if dbclient.IndexWarmCounter >= ledgerconfig.GetWarmIndexesAfterNBlocks() {
-			go dbclient.runWarmIndexAllIndexes()
-			dbclient.IndexWarmCounter = 0
-		}
-		dbclient.IndexWarmCounter++
-
-	}
-
-	logger.Debugf("Exiting EnsureFullCommit()")
-
-	if dbResponse.Ok == true {
-
-		return dbResponse, nil
-
+//SaveDoc method provides a function to save a document, id and byte array. The revision is populated if not provided.
+// TODO: Remove explicit rev argument.
+func (dbclient *CouchDatabase) SaveDoc(id string, rev string, couchDoc *CouchDoc) (string, error) {
+	if rev == "" {
+		rev = dbclient.getDocumentRevision(id)
 	}
-
-	return dbResponse, fmt.Errorf("Error syncing database")
+	return dbclient.UpdateDoc(id, rev, couchDoc)
 }
 
-//SaveDoc method provides a function to save a document, id and byte array
-func (dbclient *CouchDatabase) SaveDoc(id string, rev string, couchDoc *CouchDoc) (string, error) {
+//UpdateDoc method provides a function to update or create a document, id and byte array. The revision must be provided
+//for document updates.
+func (dbclient *CouchDatabase) UpdateDoc(id string, rev string, couchDoc *CouchDoc) (string, error) {
+	stopWatch := metrics.StopWatch("couchdb_saveDoc_duration")
+	defer stopWatch()
 
 	logger.Debugf("Entering SaveDoc()  id=[%s]", id)
 
@@ -614,7 +659,8 @@ func (dbclient *CouchDatabase) SaveDoc(id string, rev string, couchDoc *CouchDoc
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
 	//handle the request for saving document with a retry if there is a revision conflict
-	resp, _, err := dbclient.handleRequestWithRevisionRetry(id, http.MethodPut,
+	// TODO: think about if retries make sense if an explicit revision was passed in.
+	resp, err := dbclient.handleRequestWithRevisionRetry(id, http.MethodPut,
 		*saveURL, data, rev, defaultBoundary, maxRetries, keepConnectionOpen)
 
 	if err != nil {
@@ -748,9 +798,6 @@ func getRevisionHeader(resp *http.Response) (string, error) {
 //ReadDoc method provides function to retrieve a document and its revision
 //from the database by id
 func (dbclient *CouchDatabase) ReadDoc(id string) (*CouchDoc, string, error) {
-	var couchDoc CouchDoc
-	attachments := []*AttachmentInfo{}
-
 	logger.Debugf("Entering ReadDoc()  id=[%s]", id)
 	if !utf8.ValidString(id) {
 		return nil, "", fmt.Errorf("doc id [%x] not a valid utf8 string", id)
@@ -773,122 +820,196 @@ func (dbclient *CouchDatabase) ReadDoc(id string) (*CouchDoc, string, error) {
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, couchDBReturn, err := dbclient.CouchInstance.handleRequest(http.MethodGet, readURL.String(), nil, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodGet, readURL.String(), nil, "", "", maxRetries, true)
 	if err != nil {
-		if couchDBReturn != nil && couchDBReturn.StatusCode == 404 {
+		dbErr, ok := err.(*dbResponseError)
+		if ok && dbErr.StatusCode == http.StatusNotFound {
 			logger.Debug("Document not found (404), returning nil value instead of 404 error")
 			// non-existent document should return nil value instead of a 404 error
 			// for details see https://github.com/hyperledger-archives/fabric/issues/936
 			return nil, "", nil
 		}
-		logger.Debugf("couchDBReturn=%v\n", couchDBReturn)
 		return nil, "", err
 	}
 	defer closeResponseBody(resp)
 
-	//Get the media type from the Content-Type header
-	mediaType, params, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
+	//Get the revision from header
+	revision, err := getRevisionHeader(resp)
 	if err != nil {
-		log.Fatal(err)
+		return nil, "", err
 	}
 
-	//Get the revision from header
-	revision, err := getRevisionHeader(resp)
+	couchDoc, err := createCouchDocFromResponse(resp)
 	if err != nil {
 		return nil, "", err
 	}
 
+	return couchDoc, revision, nil
+}
+
+func createCouchDocFromResponse(resp *http.Response) (*CouchDoc, error) {
+	//Get the media type from the Content-Type header
+	mediaType, params, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
+	if err != nil {
+		logger.Errorf("couchdb returned an invalid content type [%s]", err)
+		return nil, err
+	}
+
 	//check to see if the is multipart,  handle as attachment if multipart is detected
+	var couchDoc CouchDoc
 	if strings.HasPrefix(mediaType, "multipart/") {
 		//Set up the multipart reader based on the boundary
 		multipartReader := multipart.NewReader(resp.Body, params["boundary"])
+
 		for {
-			p, err := multipartReader.NextPart()
+			err := populateCouchDocFromMultipartReader(multipartReader, &couchDoc)
 			if err == io.EOF {
 				break // processed all parts
 			}
 			if err != nil {
-				return nil, "", err
+				return nil, err
 			}
+		}
 
-			defer p.Close()
+		return &couchDoc, nil
+	}
 
-			logger.Debugf("part header=%s", p.Header)
-			switch p.Header.Get("Content-Type") {
-			case "application/json":
-				partdata, err := ioutil.ReadAll(p)
+	//handle as JSON document
+	couchDoc.JSONValue, err = ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return nil, err
+	}
+
+	logger.Debugf("Exiting ReadDoc()")
+	return &couchDoc, nil
+}
+
+func populateCouchDocFromMultipartReader(multipartReader *multipart.Reader, couchDoc *CouchDoc) error {
+	p, err := multipartReader.NextPart()
+	if err != nil {
+		return err
+	}
+	defer p.Close()
+
+	logger.Debugf("part header=%s", p.Header)
+	switch p.Header.Get("Content-Type") {
+	case "application/json":
+		partdata, err := ioutil.ReadAll(p)
+		if err != nil {
+			return err
+		}
+		couchDoc.JSONValue = partdata
+	default:
+
+		//Create an attachment structure and load it
+		attachment := &AttachmentInfo{}
+		attachment.ContentType = p.Header.Get("Content-Type")
+		contentDispositionParts := strings.Split(p.Header.Get("Content-Disposition"), ";")
+		if strings.TrimSpace(contentDispositionParts[0]) == "attachment" {
+			switch p.Header.Get("Content-Encoding") {
+			case "gzip": //See if the part is gzip encoded
+
+				var respBody []byte
+
+				gr, err := gzip.NewReader(p)
 				if err != nil {
-					return nil, "", err
+					return err
 				}
-				couchDoc.JSONValue = partdata
+				respBody, err = ioutil.ReadAll(gr)
+				if err != nil {
+					return err
+				}
+
+				logger.Debugf("Retrieved attachment data")
+				attachment.AttachmentBytes = respBody
+				attachment.Name = p.FileName()
+				couchDoc.Attachments = append(couchDoc.Attachments, attachment)
+
 			default:
 
-				//Create an attachment structure and load it
-				attachment := &AttachmentInfo{}
-				attachment.ContentType = p.Header.Get("Content-Type")
-				contentDispositionParts := strings.Split(p.Header.Get("Content-Disposition"), ";")
-				if strings.TrimSpace(contentDispositionParts[0]) == "attachment" {
-					switch p.Header.Get("Content-Encoding") {
-					case "gzip": //See if the part is gzip encoded
+				//retrieve the data,  this is not gzip
+				partdata, err := ioutil.ReadAll(p)
+				if err != nil {
+					return err
+				}
+				logger.Debugf("Retrieved attachment data")
+				attachment.AttachmentBytes = partdata
+				attachment.Name = p.FileName()
+				couchDoc.Attachments = append(couchDoc.Attachments, attachment)
+
+			} // end content-encoding switch
+		} // end if attachment
+	} // end content-type switch
+	return nil
+}
 
-						var respBody []byte
+//ReadDocRange method provides function to a range of documents based on the start and end keys
+//startKey and endKey can also be empty strings.  If startKey and endKey are empty, all documents are returned
+//This function provides a limit option to specify the max number of entries and is supplied by config.
+//Skip is reserved for possible future future use.
+func (dbclient *CouchDatabase) ReadDocRange(startKey, endKey string, limit, skip int, descending bool) ([]*QueryResult, error) {
 
-						gr, err := gzip.NewReader(p)
-						if err != nil {
-							return nil, "", err
-						}
-						respBody, err = ioutil.ReadAll(gr)
-						if err != nil {
-							return nil, "", err
-						}
+	logger.Debugf("Entering ReadDocRange()  startKey=%s, endKey=%s", startKey, endKey)
 
-						logger.Debugf("Retrieved attachment data")
-						attachment.AttachmentBytes = respBody
-						attachment.Name = p.FileName()
-						attachments = append(attachments, attachment)
+	var results []*QueryResult
+	var orderedDocs []*DocMetadata
+	var bulkQueryIDs []string
+	resultsMap := make(map[string]*QueryResult)
 
-					default:
+	jsonResponse, err := dbclient.rangeQuery(startKey, endKey, limit, skip, descending)
+	if err != nil {
+		return nil, err
+	}
+
+	for _, row := range jsonResponse.Rows {
 
-						//retrieve the data,  this is not gzip
-						partdata, err := ioutil.ReadAll(p)
-						if err != nil {
-							return nil, "", err
-						}
-						logger.Debugf("Retrieved attachment data")
-						attachment.AttachmentBytes = partdata
-						attachment.Name = p.FileName()
-						attachments = append(attachments, attachment)
+		var docMetadata = &DocMetadata{}
+		err3 := json.Unmarshal(row.Doc, &docMetadata)
+		if err3 != nil {
+			return nil, err3
+		}
 
-					} // end content-encoding switch
-				} // end if attachment
-			} // end content-type switch
-		} // for all multiparts
+		orderedDocs = append(orderedDocs, docMetadata)
 
-		couchDoc.Attachments = attachments
+		if docMetadata.AttachmentsInfo != nil {
+			// Delay appending this document until we retrieve attachments using a bulk query.
+			logger.Debugf("Adding json document and attachments for id: %s", docMetadata.ID)
+			bulkQueryIDs = append(bulkQueryIDs, docMetadata.ID)
+		} else {
+			logger.Debugf("Adding json document for id: %s", docMetadata.ID)
+			var addDocument = QueryResult{docMetadata.ID, row.Doc, nil}
+			resultsMap[docMetadata.ID] = &addDocument
+		}
 
-		return &couchDoc, revision, nil
 	}
 
-	//handle as JSON document
-	couchDoc.JSONValue, err = ioutil.ReadAll(resp.Body)
-	if err != nil {
-		return nil, "", err
+	if len(bulkQueryIDs) > 0 {
+		docs, err := dbclient.BatchRetrieveDocument(bulkQueryIDs)
+		if err != nil {
+			return nil, err
+		}
+		for _, namedDoc := range docs {
+			addDocument := QueryResult{ID: namedDoc.ID, Value: namedDoc.Doc.JSONValue, Attachments: namedDoc.Doc.Attachments}
+			resultsMap[namedDoc.ID] = &addDocument
+		}
+
 	}
 
-	logger.Debugf("Exiting ReadDoc()")
-	return &couchDoc, revision, nil
-}
+	for _, doc := range orderedDocs {
+		addDocument, ok := resultsMap[doc.ID]
+		if !ok {
+			return nil, errors.Errorf("Missing document during bulk retrieval [%s]", doc.ID)
+		}
+		results = append(results, addDocument)
+	}
 
-//ReadDocRange method provides function to a range of documents based on the start and end keys
-//startKey and endKey can also be empty strings.  If startKey and endKey are empty, all documents are returned
-//This function provides a limit option to specify the max number of entries and is supplied by config.
-//Skip is reserved for possible future future use.
-func (dbclient *CouchDatabase) ReadDocRange(startKey, endKey string, limit, skip int) (*[]QueryResult, error) {
+	logger.Debugf("Exiting ReadDocRange()")
 
-	logger.Debugf("Entering ReadDocRange()  startKey=%s, endKey=%s", startKey, endKey)
+	return results, nil
 
-	var results []QueryResult
+}
 
+func (dbclient *CouchDatabase) rangeQuery(startKey, endKey string, limit, skip int, descending bool) (*RangeQueryResponse, error) {
 	rangeURL, err := url.Parse(dbclient.CouchInstance.conf.URL)
 	if err != nil {
 		logger.Errorf("URL parse error: %s", err.Error())
@@ -900,6 +1021,7 @@ func (dbclient *CouchDatabase) ReadDocRange(startKey, endKey string, limit, skip
 	queryParms.Set("limit", strconv.Itoa(limit))
 	queryParms.Add("skip", strconv.Itoa(skip))
 	queryParms.Add("include_docs", "true")
+	queryParms.Add("descending", fmt.Sprintf("%t", descending))
 	queryParms.Add("inclusive_end", "false") // endkey should be exclusive to be consistent with goleveldb
 
 	//Append the startKey if provided
@@ -925,7 +1047,7 @@ func (dbclient *CouchDatabase) ReadDocRange(startKey, endKey string, limit, skip
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodGet, rangeURL.String(), nil, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodGet, rangeURL.String(), nil, "", "", maxRetries, true)
 	if err != nil {
 		return nil, err
 	}
@@ -952,42 +1074,7 @@ func (dbclient *CouchDatabase) ReadDocRange(startKey, endKey string, limit, skip
 	}
 
 	logger.Debugf("Total Rows: %d", jsonResponse.TotalRows)
-
-	for _, row := range jsonResponse.Rows {
-
-		var docMetadata = &DocMetadata{}
-		err3 := json.Unmarshal(row.Doc, &docMetadata)
-		if err3 != nil {
-			return nil, err3
-		}
-
-		if docMetadata.AttachmentsInfo != nil {
-
-			logger.Debugf("Adding JSON document and attachments for id: %s", docMetadata.ID)
-
-			couchDoc, _, err := dbclient.ReadDoc(docMetadata.ID)
-			if err != nil {
-				return nil, err
-			}
-
-			var addDocument = &QueryResult{docMetadata.ID, couchDoc.JSONValue, couchDoc.Attachments}
-			results = append(results, *addDocument)
-
-		} else {
-
-			logger.Debugf("Adding json docment for id: %s", docMetadata.ID)
-
-			var addDocument = &QueryResult{docMetadata.ID, row.Doc, nil}
-			results = append(results, *addDocument)
-
-		}
-
-	}
-
-	logger.Debugf("Exiting ReadDocRange()")
-
-	return &results, nil
-
+	return jsonResponse, nil
 }
 
 //DeleteDoc method provides function to delete a document from the database by id
@@ -1008,12 +1095,19 @@ func (dbclient *CouchDatabase) DeleteDoc(id, rev string) error {
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
+	// Document deletion requires the revision.
+	if rev == "" {
+		rev = dbclient.getDocumentRevision(id)
+	}
+
 	//handle the request for saving document with a retry if there is a revision conflict
-	resp, couchDBReturn, err := dbclient.handleRequestWithRevisionRetry(id, http.MethodDelete,
-		*deleteURL, nil, "", "", maxRetries, true)
+	resp, err := dbclient.handleRequestWithRevisionRetry(id, http.MethodDelete,
+		*deleteURL, nil, rev, "", maxRetries, true)
 
 	if err != nil {
-		if couchDBReturn != nil && couchDBReturn.StatusCode == 404 {
+		dbErr, ok := err.(*dbResponseError)
+
+		if ok && dbErr.StatusCode == http.StatusNotFound {
 			logger.Debug("Document not found (404), returning nil value instead of 404 error")
 			// non-existent document should return nil value instead of a 404 error
 			// for details see https://github.com/hyperledger-archives/fabric/issues/936
@@ -1030,12 +1124,67 @@ func (dbclient *CouchDatabase) DeleteDoc(id, rev string) error {
 }
 
 //QueryDocuments method provides function for processing a query
-func (dbclient *CouchDatabase) QueryDocuments(query string) (*[]QueryResult, error) {
+func (dbclient *CouchDatabase) QueryDocuments(query string) ([]*QueryResult, error) {
 
 	logger.Debugf("Entering QueryDocuments()  query=%s", query)
 
-	var results []QueryResult
+	var results []*QueryResult
+	var orderedDocs []*DocMetadata
+	var bulkQueryIDs []string
+	resultsMap := make(map[string]*QueryResult)
+
+	jsonResponse, err := dbclient.Query(query)
+	if err != nil {
+		return nil, err
+	}
+
+	for _, row := range jsonResponse.Docs {
+
+		var docMetadata = &DocMetadata{}
+		err := json.Unmarshal(row, &docMetadata)
+		if err != nil {
+			return nil, err
+		}
+
+		orderedDocs = append(orderedDocs, docMetadata)
+
+		if docMetadata.AttachmentsInfo != nil {
+			// Delay appending this document until we retrieve attachments using a bulk query.
+			logger.Debugf("Adding json document and attachments for id: %s", docMetadata.ID)
+			bulkQueryIDs = append(bulkQueryIDs, docMetadata.ID)
+		} else {
+			logger.Debugf("Adding json document for id: %s", docMetadata.ID)
+			addDocument := QueryResult{ID: docMetadata.ID, Value: row, Attachments: nil}
+			resultsMap[docMetadata.ID] = &addDocument
+		}
+	}
+
+	if len(bulkQueryIDs) > 0 {
+		docs, err := dbclient.BatchRetrieveDocument(bulkQueryIDs)
+		if err != nil {
+			return nil, err
+		}
+		for _, namedDoc := range docs {
+			addDocument := QueryResult{ID: namedDoc.ID, Value: namedDoc.Doc.JSONValue, Attachments: namedDoc.Doc.Attachments}
+			resultsMap[namedDoc.ID] = &addDocument
+		}
+
+	}
+
+	for _, doc := range orderedDocs {
+		addDocument, ok := resultsMap[doc.ID]
+		if !ok {
+			return nil, errors.Errorf("Missing document during bulk retrieval [%s]", doc.ID)
+		}
+		results = append(results, addDocument)
+	}
+
+	logger.Debugf("Exiting QueryDocuments()")
+
+	return results, nil
+}
 
+func (dbclient *CouchDatabase) Query(query string) (*QueryResponse, error) {
 	queryURL, err := url.Parse(dbclient.CouchInstance.conf.URL)
 	if err != nil {
 		logger.Errorf("URL parse error: %s", err.Error())
@@ -1047,7 +1196,7 @@ func (dbclient *CouchDatabase) QueryDocuments(query string) (*[]QueryResult, err
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodPost, queryURL.String(), []byte(query), "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodPost, queryURL.String(), []byte(query), "", "", maxRetries, true)
 	if err != nil {
 		return nil, err
 	}
@@ -1078,38 +1227,22 @@ func (dbclient *CouchDatabase) QueryDocuments(query string) (*[]QueryResult, err
 		logger.Warningf("The query [%s] caused the following warning: [%s]", query, jsonResponse.Warning)
 	}
 
-	for _, row := range jsonResponse.Docs {
-
-		var docMetadata = &DocMetadata{}
-		err3 := json.Unmarshal(row, &docMetadata)
-		if err3 != nil {
-			return nil, err3
-		}
-
-		if docMetadata.AttachmentsInfo != nil {
-
-			logger.Debugf("Adding JSON docment and attachments for id: %s", docMetadata.ID)
-
-			couchDoc, _, err := dbclient.ReadDoc(docMetadata.ID)
-			if err != nil {
-				return nil, err
-			}
-			var addDocument = &QueryResult{ID: docMetadata.ID, Value: couchDoc.JSONValue, Attachments: couchDoc.Attachments}
-			results = append(results, *addDocument)
-
-		} else {
-			logger.Debugf("Adding json docment for id: %s", docMetadata.ID)
-			var addDocument = &QueryResult{ID: docMetadata.ID, Value: row, Attachments: nil}
-
-			results = append(results, *addDocument)
+	return jsonResponse, nil
+}
 
-		}
+/*
+func (dbclient *CouchDatabase) createQueryResultWithExternalAttachment(docMetadata *DocMetadata) (*QueryResult, error) {
+	couchDoc, _, err := dbclient.ReadDoc(docMetadata.ID)
+	if err != nil {
+		return nil, err
 	}
-	logger.Debugf("Exiting QueryDocuments()")
-
-	return &results, nil
-
+	if couchDoc == nil {
+		return nil, errors.Errorf("document not found [%s]", docMetadata.ID)
+	}
+	doc := QueryResult{ID: docMetadata.ID, Value: couchDoc.JSONValue, Attachments: couchDoc.Attachments}
+	return &doc, nil
 }
+*/
 
 // ListIndex method lists the defined indexes for a database
 func (dbclient *CouchDatabase) ListIndex() ([]*IndexResult, error) {
@@ -1141,7 +1274,7 @@ func (dbclient *CouchDatabase) ListIndex() ([]*IndexResult, error) {
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodGet, indexURL.String(), nil, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodGet, indexURL.String(), nil, "", "", maxRetries, true)
 	if err != nil {
 		return nil, err
 	}
@@ -1186,7 +1319,6 @@ func (dbclient *CouchDatabase) ListIndex() ([]*IndexResult, error) {
 
 // CreateIndex method provides a function creating an index
 func (dbclient *CouchDatabase) CreateIndex(indexdefinition string) (*CreateIndexResponse, error) {
-
 	logger.Debugf("Entering CreateIndex()  indexdefinition=%s", indexdefinition)
 
 	//Test to see if this is a valid JSON
@@ -1205,7 +1337,7 @@ func (dbclient *CouchDatabase) CreateIndex(indexdefinition string) (*CreateIndex
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodPost, indexURL.String(), []byte(indexdefinition), "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodPost, indexURL.String(), []byte(indexdefinition), "", "", maxRetries, true)
 	if err != nil {
 		return nil, err
 	}
@@ -1260,7 +1392,7 @@ func (dbclient *CouchDatabase) DeleteIndex(designdoc, indexname string) error {
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodDelete, indexURL.String(), nil, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodDelete, indexURL.String(), nil, "", "", maxRetries, true)
 	if err != nil {
 		return err
 	}
@@ -1284,6 +1416,9 @@ func (dbclient *CouchDatabase) WarmIndex(designdoc, indexname string) error {
 	//URL to execute the view function associated with the index
 	indexURL.Path = dbclient.DBName + "/_design/" + designdoc + "/_view/" + indexname
 
+	stopWatch := metrics.StopWatch("couchdb_WarmIndex")
+	defer stopWatch()
+
 	queryParms := indexURL.Query()
 	//Query parameter that allows the execution of the URL to return immediately
 	//The update_after will cause the index update to run after the URL returns
@@ -1293,7 +1428,7 @@ func (dbclient *CouchDatabase) WarmIndex(designdoc, indexname string) error {
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodGet, indexURL.String(), nil, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodGet, indexURL.String(), nil, "", "", maxRetries, true)
 	if err != nil {
 		return err
 	}
@@ -1303,41 +1438,53 @@ func (dbclient *CouchDatabase) WarmIndex(designdoc, indexname string) error {
 
 }
 
-//runWarmIndexAllIndexes is a wrapper for WarmIndexAllIndexes to catch and report any errors
-func (dbclient *CouchDatabase) runWarmIndexAllIndexes() {
-
-	err := dbclient.WarmIndexAllIndexes()
-	if err != nil {
-		logger.Errorf("Error detected during WarmIndexAllIndexes(): %s", err.Error())
-	}
-
-}
-
-//WarmIndexAllIndexes method provides a function for warming all indexes for a database
-func (dbclient *CouchDatabase) WarmIndexAllIndexes() error {
-
-	logger.Debugf("Entering WarmIndexAllIndexes()")
-
+// Warms up all indexes.
+func (db *CouchDatabase) doAllIndexWarmup() {
+	stopWatch := metrics.StopWatch("couchdb_allIndexWarmup_duration")
+	defer stopWatch()
 	//Retrieve all indexes
-	listResult, err := dbclient.ListIndex()
+	listResult, err := db.ListIndex()
 	if err != nil {
-		return err
+		logger.Errorf("failed to list all indexes - aborting warmup due to error: %s", err)
+		return
 	}
-
 	//For each index definition, execute an index refresh
 	for _, elem := range listResult {
-
-		err := dbclient.WarmIndex(elem.DesignDocument, elem.Name)
+		err := db.WarmIndex(elem.DesignDocument, elem.Name)
 		if err != nil {
-			return err
+			logger.Errorf(
+				"failed to warm up ddoc=%s index=%s - aborting warmup due to error: %s",
+				elem.DesignDocument, elem.Name, err)
+			return
 		}
 
 	}
+}
 
-	logger.Debugf("Exiting WarmIndexAllIndexes()")
-
-	return nil
-
+// WarmUpAllIndexes 'warms up' all indexes in this database in a background routine.
+//
+// This is a no-op if the "ledger.state.couchDBConfig.autoWarmIndexes" configuration is set to 'false', otherwise
+// it is enabled by default. Also, the indexes are warmed up only after the threshold number of blocks defined by
+// "ledger.state.couchDBConfig.warmIndexesAfterNBlocks" is reached.
+func (dbclient *CouchDatabase) WarmUpAllIndexes() {
+	logger.Debugf("Entering WarmUpAllIndexes()")
+	//Check to see if autoWarmIndexes is enabled
+	//If autoWarmIndexes is enabled, indexes will be refreshed after the number of blocks
+	//in GetWarmIndexesAfterNBlocks() have been committed to the state database
+	//Check to see if the number of blocks committed exceeds the threshold for index warming
+	//Use a go routine to launch doAllIndexWarmup(), this will execute as a background process
+	if ledgerconfig.IsAutoWarmIndexesEnabled() {
+		logger.Debugf("autoWarmIndexes enabled")
+		if dbclient.IndexWarmCounter >= ledgerconfig.GetWarmIndexesAfterNBlocks() {
+			logger.Debugf(
+				"index warmup triggered: indexWarmCounter=%d, warmIndexersAfterNBlocks=%d",
+				dbclient.IndexWarmCounter, ledgerconfig.GetWarmIndexesAfterNBlocks())
+			go dbclient.doAllIndexWarmup()
+			dbclient.IndexWarmCounter = 0
+		}
+		dbclient.IndexWarmCounter++
+	}
+	logger.Debugf("Exiting WarmUpAllIndexes()")
 }
 
 //GetDatabaseSecurity method provides function to retrieve the security config for a database
@@ -1356,7 +1503,7 @@ func (dbclient *CouchDatabase) GetDatabaseSecurity() (*DatabaseSecurity, error)
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodGet, securityURL.String(),
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodGet, securityURL.String(),
 		nil, "", "", maxRetries, true)
 
 	if err != nil {
@@ -1420,7 +1567,7 @@ func (dbclient *CouchDatabase) ApplyDatabaseSecurity(databaseSecurity *DatabaseS
 
 	logger.Debugf("Applying security to database [%s]: %s", dbclient.DBName, string(databaseSecurityJSON))
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodPut, securityURL.String(), databaseSecurityJSON, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodPut, securityURL.String(), databaseSecurityJSON, "", "", maxRetries, true)
 
 	if err != nil {
 		return err
@@ -1433,11 +1580,127 @@ func (dbclient *CouchDatabase) ApplyDatabaseSecurity(databaseSecurity *DatabaseS
 
 }
 
+//BatchRetrieveDocument - batch method to retrieve document  for  a set of keys,
+// including ID, couchdb revision number, ledger version, and attachments
+func (dbclient *CouchDatabase) BatchRetrieveDocument(keys []string) ([]*NamedCouchDoc, error) {
+
+	logger.Debugf("Entering BatchRetrieveDocumentMetadata()  keys=%s", keys)
+
+	batchRetrieveURL, err := url.Parse(dbclient.CouchInstance.conf.URL)
+	if err != nil {
+		logger.Errorf("URL parse error: %s", err.Error())
+		return nil, err
+	}
+	batchRetrieveURL.Path = dbclient.DBName + "/_all_docs"
+
+	queryParms := batchRetrieveURL.Query()
+
+	queryParms.Add("include_docs", "true")
+	queryParms.Add("attachments", "true")
+
+	batchRetrieveURL.RawQuery = queryParms.Encode()
+
+	keymap := make(map[string]interface{})
+
+	keymap["keys"] = keys
+
+	jsonKeys, err := json.Marshal(keymap)
+	if err != nil {
+		return nil, err
+	}
+
+	//get the number of retries
+	maxRetries := dbclient.CouchInstance.conf.MaxRetries
+
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodPost, batchRetrieveURL.String(), jsonKeys, "", "", maxRetries, true)
+	if err != nil {
+		return nil, err
+	}
+	defer closeResponseBody(resp)
+
+	if logger.IsEnabledFor(logging.DEBUG) {
+		dump, _ := httputil.DumpResponse(resp, false)
+		// compact debug log by replacing carriage return / line feed with dashes to separate http headers
+		logger.Debugf("HTTP Response: %s", bytes.Replace(dump, []byte{0x0d, 0x0a}, []byte{0x20, 0x7c, 0x20}, -1))
+	}
+
+	//handle as JSON document
+	jsonResponseRaw, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return nil, err
+	}
+
+	var jsonResponse BatchRetreiveDocValueResponse
+	err = json.Unmarshal(jsonResponseRaw, &jsonResponse)
+	if err != nil {
+		return nil, err
+	}
+
+	var docs []*NamedCouchDoc
+	for _, row := range jsonResponse.Rows {
+		attachments, err := createAttachmentsFromBatchResponse(row.Doc["_attachments"])
+		if err != nil {
+			return nil, err
+		}
+
+		delete(row.Doc, "_attachments")
+
+		jsonValue, err := json.Marshal(&row.Doc)
+		if err != nil {
+			return nil, err
+		}
+
+		doc := CouchDoc{JSONValue: jsonValue, Attachments: attachments}
+		namedDoc := NamedCouchDoc{ID: row.ID, Doc: &doc}
+		docs = append(docs, &namedDoc)
+	}
+
+	logger.Debugf("Exiting BatchRetrieveDocumentMetadata()")
+	return docs, nil
+}
+
+func createAttachmentsFromBatchResponse(attachmentsInfo json.RawMessage) ([]*AttachmentInfo, error) {
+	if len(attachmentsInfo) == 0 {
+		// TODO: prefer to return zero-value but there seems to be code checking for nil rather than length.
+		return nil, nil
+	}
+
+	var attachMap map[string]json.RawMessage
+	err := json.Unmarshal(attachmentsInfo, &attachMap)
+	if err != nil {
+		return nil, err
+	}
+
+	var attachments []*AttachmentInfo
+
+	for name, attachRaw := range attachMap {
+		var attachmentResponse AttachmentResponse
+		err := json.Unmarshal(attachRaw, &attachmentResponse)
+		if err != nil {
+			return nil, err
+		}
+
+		bytes, err := base64.StdEncoding.DecodeString(attachmentResponse.Data)
+		if err != nil {
+			return nil, err
+		}
+
+		attachment := AttachmentInfo{
+			Name:            name,
+			ContentType:     attachmentResponse.ContentType,
+			AttachmentBytes: bytes,
+		}
+		attachments = append(attachments, &attachment)
+	}
+
+	return attachments, nil
+}
+
 //BatchRetrieveDocumentMetadata - batch method to retrieve document metadata for  a set of keys,
 // including ID, couchdb revision number, and ledger version
-func (dbclient *CouchDatabase) BatchRetrieveDocumentMetadata(keys []string) ([]*DocMetadata, error) {
+func (dbclient *CouchDatabase) BatchRetrieveDocumentMetadata(keys []string, includeDocs bool) ([]*DocMetadata, error) {
 
-	logger.Debugf("Entering BatchRetrieveDocumentMetadata()  keys=%s", keys)
+	logger.Debugf("Entering BatchRetrieveDocumentMetadata() [keys=%s, includeDocs=%t]", keys, includeDocs)
 
 	batchRetrieveURL, err := url.Parse(dbclient.CouchInstance.conf.URL)
 	if err != nil {
@@ -1450,11 +1713,13 @@ func (dbclient *CouchDatabase) BatchRetrieveDocumentMetadata(keys []string) ([]*
 
 	// While BatchRetrieveDocumentMetadata() does not return the entire document,
 	// for reads/writes, we do need to get document so that we can get the ledger version of the key.
-	// TODO For blind writes we do not need to get the version, therefore when we bulk get
+	// For blind writes we do not need to get the version, therefore when we bulk get
 	// the revision numbers for the write keys that were not represented in read set
 	// (the second time BatchRetrieveDocumentMetadata is called during block processing),
 	// we could set include_docs to false to optimize the response.
-	queryParms.Add("include_docs", "true")
+	if includeDocs {
+		queryParms.Add("include_docs", "true")
+	}
 	batchRetrieveURL.RawQuery = queryParms.Encode()
 
 	keymap := make(map[string]interface{})
@@ -1469,7 +1734,7 @@ func (dbclient *CouchDatabase) BatchRetrieveDocumentMetadata(keys []string) ([]*
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodPost, batchRetrieveURL.String(), jsonKeys, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodPost, batchRetrieveURL.String(), jsonKeys, "", "", maxRetries, true)
 	if err != nil {
 		return nil, err
 	}
@@ -1487,7 +1752,7 @@ func (dbclient *CouchDatabase) BatchRetrieveDocumentMetadata(keys []string) ([]*
 		return nil, err
 	}
 
-	var jsonResponse = &BatchRetrieveDocMetadataResponse{}
+	var jsonResponse = &BatchRetrieveDocResponse{}
 
 	err2 := json.Unmarshal(jsonResponseRaw, &jsonResponse)
 	if err2 != nil {
@@ -1497,8 +1762,10 @@ func (dbclient *CouchDatabase) BatchRetrieveDocumentMetadata(keys []string) ([]*
 	docMetadataArray := []*DocMetadata{}
 
 	for _, row := range jsonResponse.Rows {
-		docMetadata := &DocMetadata{ID: row.ID, Rev: row.DocMetadata.Rev, Version: row.DocMetadata.Version}
-		docMetadataArray = append(docMetadataArray, docMetadata)
+		if row.ID != "" { // Key doesn't exist (note: row.Key will be set to the ID that wasn't found).
+			docMetadata := DocMetadata{ID: row.ID, Rev: row.Value.Rev, Version: row.Doc.Version}
+			docMetadataArray = append(docMetadataArray, &docMetadata)
+		}
 	}
 
 	logger.Debugf("Exiting BatchRetrieveDocumentMetadata()")
@@ -1575,7 +1842,7 @@ func (dbclient *CouchDatabase) BatchUpdateDocuments(documents []*CouchDoc) ([]*B
 	//get the number of retries
 	maxRetries := dbclient.CouchInstance.conf.MaxRetries
 
-	resp, _, err := dbclient.CouchInstance.handleRequest(http.MethodPost, batchUpdateURL.String(), bulkDocsJSON, "", "", maxRetries, true)
+	resp, err := dbclient.CouchInstance.handleRequest(http.MethodPost, batchUpdateURL.String(), bulkDocsJSON, "", "", maxRetries, true)
 	if err != nil {
 		return nil, err
 	}
@@ -1610,41 +1877,43 @@ func (dbclient *CouchDatabase) BatchUpdateDocuments(documents []*CouchDoc) ([]*B
 //which may be detected during saves or deletes that timed out from client http perspective,
 //but which eventually succeeded in couchdb
 func (dbclient *CouchDatabase) handleRequestWithRevisionRetry(id, method string, connectURL url.URL, data []byte, rev string,
-	multipartBoundary string, maxRetries int, keepConnectionOpen bool) (*http.Response, *DBReturn, error) {
-
-	//Initialize a flag for the revision conflict
-	revisionConflictDetected := false
-	var resp *http.Response
-	var couchDBReturn *DBReturn
-	var errResp error
-
-	//attempt the http request for the max number of retries
-	//In this case, the retry is to catch problems where a client timeout may miss a
-	//successful CouchDB update and cause a document revision conflict on a retry in handleRequest
-	for attempts := 0; attempts <= maxRetries; attempts++ {
-
-		//if the revision was not passed in, or if a revision conflict is detected on prior attempt,
-		//query CouchDB for the document revision
-		if rev == "" || revisionConflictDetected {
-			rev = dbclient.getDocumentRevision(id)
-		}
+	multipartBoundary string, maxRetries int, keepConnectionOpen bool) (*http.Response, error) {
+
+	respUT, err := retry.Invoke(
+		func() (interface{}, error) {
+			return dbclient.CouchInstance.handleRequest(method, connectURL.String(), data, rev, multipartBoundary, maxRetries, keepConnectionOpen)
+		},
+		retry.WithMaxAttempts(maxRetries+1), // TODO: does it make sense to have the same maxRetries as is passed-in to handleRequest?
+		retry.WithBackoffFactor(1),
+		retry.WithInitialBackoff(0),
+		retry.WithBeforeRetry(func(err error, attempt int, backoff time.Duration) bool {
+
+			dbErr, ok := err.(*dbResponseError)
+			if ok && dbErr.StatusCode == http.StatusConflict {
+				logger.Warningf("couchdb document revision conflict detected, retrying. [attempt:%v, wait: %s]", attempt, backoff.String())
+				rev = dbclient.getDocumentRevision(id)
+				return true
+			}
 
-		//handle the request for saving/deleting the couchdb data
-		resp, couchDBReturn, errResp = dbclient.CouchInstance.handleRequest(method, connectURL.String(),
-			data, rev, multipartBoundary, maxRetries, keepConnectionOpen)
+			// Retries were already attempted inside handleRequest on an errResp.
+			return false
+		}),
+	)
 
-		//If there was a 409 conflict error during the save/delete, log it and retry it.
-		//Otherwise, break out of the retry loop
-		if couchDBReturn != nil && couchDBReturn.StatusCode == 409 {
-			logger.Warningf("CouchDB document revision conflict detected, retrying. Attempt:%v", attempts+1)
-			revisionConflictDetected = true
-		} else {
-			break
-		}
+	if err != nil {
+		return nil, err
 	}
 
-	// return the handleRequest results
-	return resp, couchDBReturn, errResp
+	resp := respUT.(*http.Response)
+	return resp, nil
+}
+
+type dbResponseError struct {
+	*DBReturn
+}
+
+func (err *dbResponseError) Error() string {
+	return fmt.Sprintf("HTTP response contains unsuccesful status [%d, %s]", err.StatusCode, err.Reason)
 }
 
 //handleRequest method is a generic http request handler.
@@ -1652,199 +1921,149 @@ func (dbclient *CouchDatabase) handleRequestWithRevisionRetry(id, method string,
 // callee's responsibility to close response correctly.
 // Any http error or CouchDB error (4XX or 500) will result in a golang error getting returned
 func (couchInstance *CouchInstance) handleRequest(method, connectURL string, data []byte, rev string,
-	multipartBoundary string, maxRetries int, keepConnectionOpen bool) (*http.Response, *DBReturn, error) {
-
-	logger.Debugf("Entering handleRequest()  method=%s  url=%v", method, connectURL)
+	multipartBoundary string, maxRetries int, keepConnectionOpen bool) (*http.Response, error) {
 
-	//create the return objects for couchDB
-	var resp *http.Response
-	var errResp error
-	couchDBReturn := &DBReturn{}
+	stopWatch := metrics.StopWatch("couchdb_handleRequest_duration")
+	defer stopWatch()
 
-	//set initial wait duration for retries
-	waitDuration := retryWaitTime * time.Millisecond
+	logger.Debugf("Entering handleRequest()  method=%s  url=%v", method, connectURL)
 
 	if maxRetries < 0 {
-		return nil, nil, fmt.Errorf("Number of retries must be zero or greater.")
+		return nil, errors.New("Number of retries must be zero or greater.")
 	}
 
-	//attempt the http request for the max number of retries
-	// if maxRetries is 0, the database creation will be attempted once and will
-	//    return an error if unsuccessful
-	// if maxRetries is 3 (default), a maximum of 4 attempts (one attempt with 3 retries)
-	//    will be made with warning entries for unsuccessful attempts
-	for attempts := 0; attempts <= maxRetries; attempts++ {
-
-		//Set up a buffer for the payload data
-		payloadData := new(bytes.Buffer)
-
-		payloadData.ReadFrom(bytes.NewReader(data))
-
-		//Create request based on URL for couchdb operation
-		req, err := http.NewRequest(method, connectURL, payloadData)
-		if err != nil {
-			return nil, nil, err
-		}
-
-		//set the request to close on completion if shared connections are not allowSharedConnection
-		//Current CouchDB has a problem with zero length attachments, do not allow the connection to be reused.
-		//Apache JIRA item for CouchDB   https://issues.apache.org/jira/browse/COUCHDB-3394
-		if !keepConnectionOpen {
-			req.Close = true
-		}
-
-		//add content header for PUT
-		if method == http.MethodPut || method == http.MethodPost || method == http.MethodDelete {
-
-			//If the multipartBoundary is not set, then this is a JSON and content-type should be set
-			//to application/json.   Else, this is contains an attachment and needs to be multipart
-			if multipartBoundary == "" {
-				req.Header.Set("Content-Type", "application/json")
-			} else {
-				req.Header.Set("Content-Type", "multipart/related;boundary=\""+multipartBoundary+"\"")
+	respUT, err := retry.Invoke(
+		func() (interface{}, error) {
+			req, err := createCouchHTTPRequest(&couchInstance.conf, method, connectURL, data, rev, multipartBoundary, keepConnectionOpen)
+			if err != nil {
+				return nil, err
 			}
 
-			//check to see if the revision is set,  if so, pass as a header
-			if rev != "" {
-				req.Header.Set("If-Match", rev)
+			//Execute http request
+			resp, err := couchInstance.client.Do(req)
+			if err != nil {
+				return nil, err
 			}
-		}
-
-		//add content header for PUT
-		if method == http.MethodPut || method == http.MethodPost {
-			req.Header.Set("Accept", "application/json")
-		}
-
-		//add content header for GET
-		if method == http.MethodGet {
-			req.Header.Set("Accept", "multipart/related")
-		}
-
-		//If username and password are set the use basic auth
-		if couchInstance.conf.Username != "" && couchInstance.conf.Password != "" {
-			//req.Header.Set("Authorization", "Basic YWRtaW46YWRtaW5w")
-			req.SetBasicAuth(couchInstance.conf.Username, couchInstance.conf.Password)
-		}
-
-		if logger.IsEnabledFor(logging.DEBUG) {
-			dump, _ := httputil.DumpRequestOut(req, false)
-			// compact debug log by replacing carriage return / line feed with dashes to separate http headers
-			logger.Debugf("HTTP Request: %s", bytes.Replace(dump, []byte{0x0d, 0x0a}, []byte{0x20, 0x7c, 0x20}, -1))
-		}
-
-		//Execute http request
-		resp, errResp = couchInstance.client.Do(req)
-
-		//check to see if the return from CouchDB is valid
-		if invalidCouchDBReturn(resp, errResp) {
-			continue
-		}
 
-		//if there is no golang http error and no CouchDB 500 error, then drop out of the retry
-		if errResp == nil && resp != nil && resp.StatusCode < 500 {
-			// if this is an error, then populate the couchDBReturn
-			if resp.StatusCode >= 400 {
-				//Read the response body and close it for next attempt
-				jsonError, err := ioutil.ReadAll(resp.Body)
-				if err != nil {
-					return nil, nil, err
-				}
+			if resp.StatusCode >= http.StatusBadRequest {
 				defer closeResponseBody(resp)
-
-				errorBytes := []byte(jsonError)
-				//Unmarshal the response
-				err = json.Unmarshal(errorBytes, &couchDBReturn)
+				dbReturn, err := newDBReturn(resp)
 				if err != nil {
-					return nil, nil, err
+					return nil, err
 				}
+				return resp, &dbResponseError{dbReturn}
 			}
 
-			break
-		}
+			return resp, nil
+		},
+		retry.WithMaxAttempts(maxRetries+1),
+		retry.WithBackoffFactor(2),
+		retry.WithInitialBackoff(retryWaitTime*time.Millisecond),
+		retry.WithBeforeRetry(func(err error, attempt int, backoff time.Duration) bool {
+			dbErr, ok := err.(*dbResponseError)
+			if ok && dbErr.StatusCode < http.StatusInternalServerError {
+				return false
+			}
 
-		// If the maxRetries is greater than 0, then log the retry info
-		if maxRetries > 0 {
+			//Log the error with the retry count and continue
+			logger.Infof("retrying couchdb request [attempt:%v, wait: %s, error: %s]", attempt, backoff.String(), err.Error())
+			return true
+		}),
+	)
 
-			//if this is an unexpected golang http error, log the error and retry
-			if errResp != nil {
+	if err != nil {
+		_, ok := err.(*dbResponseError)
+		if !ok {
+			logger.Warningf("couchdb request failed [%s]", err.Error())
+		} else {
+			logger.Debugf("couchdb request failed [%s]", err.Error())
+		}
+		return nil, err
+	}
 
-				//Log the error with the retry count and continue
-				logger.Warningf("Retrying couchdb request in %s. Attempt:%v  Error:%v",
-					waitDuration.String(), attempts+1, errResp.Error())
+	resp := respUT.(*http.Response)
+	logger.Debugf("Exiting handleRequest()")
+	return resp, nil
+}
 
-				//otherwise this is an unexpected 500 error from CouchDB. Log the error and retry.
-			} else {
-				//Read the response body and close it for next attempt
-				jsonError, err := ioutil.ReadAll(resp.Body)
-				defer closeResponseBody(resp)
-				if err != nil {
-					return nil, nil, err
-				}
+func createCouchHTTPRequest(conf *CouchConnectionDef, method, connectURL string, data []byte, rev string, multipartBoundary string, keepConnectionOpen bool) (*http.Request, error) {
+	//Set up a buffer for the payload data
+	payloadData := new(bytes.Buffer)
 
-				errorBytes := []byte(jsonError)
-				//Unmarshal the response
-				err = json.Unmarshal(errorBytes, &couchDBReturn)
-				if err != nil {
-					return nil, nil, err
-				}
+	payloadData.ReadFrom(bytes.NewReader(data))
 
-				//Log the 500 error with the retry count and continue
-				logger.Warningf("Retrying couchdb request in %s. Attempt:%v  Couch DB Error:%s,  Status Code:%v  Reason:%v",
-					waitDuration.String(), attempts+1, couchDBmake , resp.Status, couchDBReturn.Reason)
+	//Create request based on URL for couchdb operation
+	req, err := newHTTPRequest(method, connectURL, payloadData)
+	if err != nil {
+		return nil, err
+	}
 
-			}
-			//sleep for specified sleep time, then retry
-			time.Sleep(waitDuration)
+	//set the request to close on completion if shared connections are not allowSharedConnection
+	//Current CouchDB has a problem with zero length attachments, do not allow the connection to be reused.
+	//Apache JIRA item for CouchDB   https://issues.apache.org/jira/browse/COUCHDB-3394
+	if !keepConnectionOpen {
+		logger.Warningf("CouchDB connection will not be re-used.")
+		req.Close = true
+	}
 
-			//backoff, doubling the retry time for next attempt
-			waitDuration *= 2
+	//add content header for PUT
+	if method == http.MethodPut || method == http.MethodPost || method == http.MethodDelete {
 
+		//If the multipartBoundary is not set, then this is a JSON and content-type should be set
+		//to application/json.   Else, this is contains an attachment and needs to be multipart
+		if multipartBoundary == "" {
+			req.Header.Set("Content-Type", "application/json")
+		} else {
+			req.Header.Set("Content-Type", "multipart/related;boundary=\""+multipartBoundary+"\"")
 		}
 
-	} // end retry loop
+		//check to see if the revision is set,  if so, pass as a header
+		if rev != "" {
+			req.Header.Set("If-Match", rev)
+		}
+	}
 
-	//if a golang http error is still present after retries are exhausted, return the error
-	if errResp != nil {
-		return nil, couchDBReturn, errResp
+	//add content header for PUT
+	if method == http.MethodPut || method == http.MethodPost {
+		req.Header.Set("Accept", "application/json")
 	}
 
-	//This situation should not occur according to the golang spec.
-	//if this error returned (errResp) from an http call, then the resp should be not nil,
-	//this is a structure and StatusCode is an int
-	//This is meant to provide a more graceful error if this should occur
-	if invalidCouchDBReturn(resp, errResp) {
-		return nil, nil, fmt.Errorf("Unable to connect to CouchDB, check the hostname and port.")
+	//add content header for GET
+	if method == http.MethodGet {
+		req.Header.Set("Accept", "multipart/related")
 	}
 
-	//set the return code for the couchDB request
-	couchDBReturn.StatusCode = resp.StatusCode
+	//If username and password are set the use basic auth
+	if conf.Username != "" && conf.Password != "" {
+		//req.Header.Set("Authorization", "Basic YWRtaW46YWRtaW5w")
+		req.SetBasicAuth(conf.Username, conf.Password)
+	}
 
-	// check to see if the status code from couchdb is 400 or higher
-	// response codes 4XX and 500 will be treated as errors -
-	// golang error will be created from the couchDBReturn contents and both will be returned
-	if resp.StatusCode >= 400 {
+	if logger.IsEnabledFor(logging.DEBUG) {
+		dump, _ := httputil.DumpRequestOut(req, false)
+		// compact debug log by replacing carriage return / line feed with dashes to separate http headers
+		logger.Debugf("HTTP Request: %s", bytes.Replace(dump, []byte{0x0d, 0x0a}, []byte{0x20, 0x7c, 0x20}, -1))
+	}
 
-		// if the status code is 400 or greater, log and return an error
-		logger.Debugf("Couch DB Error:%s,  Status Code:%v,  Reason:%s",
-			couchDBReturn.Error, resp.StatusCode, couchDBReturn.Reason)
+	return req, nil
+}
 
-		return nil, couchDBReturn, fmt.Errorf("Couch DB Error:%s,  Status Code:%v,  Reason:%s",
-			couchDBReturn.Error, resp.StatusCode, couchDBReturn.Reason)
+func newDBReturn(resp *http.Response) (*DBReturn, error) {
+	var couchDBReturn DBReturn
 
+	jsonError, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return nil, err
 	}
 
-	logger.Debugf("Exiting handleRequest()")
-
-	//If no errors, then return the http response and the couchdb return object
-	return resp, couchDBReturn, nil
-}
-
-//invalidCouchDBResponse checks to make sure either a valid response or error is returned
-func invalidCouchDBReturn(resp *http.Response, errResp error) bool {
-	if resp == nil && errResp == nil {
-		return true
+	errorBytes := []byte(jsonError)
+	err = json.Unmarshal(errorBytes, &couchDBReturn)
+	if err != nil {
+		return nil, err
 	}
-	return false
+	couchDBReturn.StatusCode = resp.StatusCode
+
+	return &couchDBReturn, nil
 }
 
 //IsJSON tests a string to determine if a valid JSON
