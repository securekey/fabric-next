diff a/gossip/state/state.go b/gossip/state/state.go	(rejected hunks)
@@ -142,18 +177,30 @@ type GossipStateProviderImpl struct {
 
 	stopCh chan struct{}
 
+	validationResponseChan chan *txvalidator.ValidationResults
+
+	pendingValidations *blockCache
+
 	done sync.WaitGroup
 
 	once sync.Once
 
 	stateTransferActive int32
+
+	peerLedger ledger.PeerLedger
+
+	blockPublisher *publisher
+
+	ctxProvider *validationctx.Provider
+
+	roleUtil *roleutil.RoleUtil
 }
 
 var logger = util.GetLogger(util.LoggingStateModule, "")
 
 // NewGossipStateProvider creates state provider with coordinator instance
 // to orchestrate arrival of private rwsets and blocks before committing them into the ledger.
-func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger ledgerResources) GossipStateProvider {
+func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger ledgerResources, peerLedger ledger.PeerLedger, transientStore privdata2.TransientStore) GossipStateProvider {
 
 	gossipChan, _ := services.Accept(func(message interface{}) bool {
 		// Get only data messages
@@ -676,6 +909,36 @@ func (s *GossipStateProviderImpl) requestBlocksInRange(start uint64, end uint64)
 	}
 }
 
+func (s *GossipStateProviderImpl) loadBlocksInRange(fromBlock, toBlock uint64) ([]*proto.Payload, error) {
+	logger.Debugf("Loading blocks in range %d to %d for channel [%s]", fromBlock, toBlock, s.chainID)
+
+	var payloads []*proto.Payload
+
+	for num := fromBlock; num <= toBlock; num++ {
+		// Don't need to load the private data since we don't actually do anything with it on the endorser.
+		logger.Debugf("Getting block %d for channel [%s]...", num, s.chainID)
+		block, err := s.peerLedger.GetBlockByNumber(num)
+		if err != nil {
+			return nil, errors.WithMessage(err, fmt.Sprintf("Error reading block and private data for block %d", num))
+		}
+
+		blockBytes, err := pb.Marshal(block)
+		if err != nil {
+			logger.Errorf("Could not marshal block: %+v", errors.WithStack(err))
+			return nil, errors.WithMessage(err, fmt.Sprintf("Error marshalling block %d", num))
+		}
+
+		payloads = append(payloads,
+			&proto.Payload{
+				SeqNum: num,
+				Data:   blockBytes,
+			},
+		)
+	}
+
+	return payloads, nil
+}
+
 // Generate state request message for given blocks in range [beginSeq...endSeq]
 func (s *GossipStateProviderImpl) stateRequestMessage(beginSeq uint64, endSeq uint64) *proto.GossipMessage {
 	return &proto.GossipMessage{
@@ -732,10 +1003,28 @@ func (s *GossipStateProviderImpl) hasRequiredHeight(height uint64) func(peer dis
 
 // AddPayload add new payload into state.
 func (s *GossipStateProviderImpl) AddPayload(payload *proto.Payload) error {
+	if !ledgerconfig.IsCommitter() {
+		// Only the committer processes the payload from the orderer.
+		// Other roles receive the block via gossip.
+		return nil
+	}
+
+	// Gossip the unvalidated block to other validators (if any)
+	// so that they can perform validation on the block.
+	validators := s.roleUtil.Validators(false)
+	if len(validators) > 0 {
+		gossipMsg := createValidationRequestGossipMsg(s.chainID, payload)
+		logger.Debugf("[%s] Gossiping block [%d] to [%d] validator(s)", s.chainID, payload.SeqNum, len(validators))
+		s.mediator.Send(gossipMsg, asRemotePeers(validators)...)
+	} else {
+		logger.Debugf("[%s] Not gossiping block [%d] since no other validators were found", s.chainID, payload.SeqNum)
+	}
+
 	blockingMode := blocking
 	if viper.GetBool("peer.gossip.nonBlockingCommitMode") {
 		blockingMode = false
 	}
+
 	return s.addPayload(payload, blockingMode)
 }
 
