diff a/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb.go b/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb.go	(rejected hunks)
@@ -12,8 +12,10 @@ import (
 	"sync"
 
 	"github.com/hyperledger/fabric/common/flogging"
+	"github.com/hyperledger/fabric/common/metrics"
 	"github.com/hyperledger/fabric/core/common/ccprovider"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
+	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/kvcache"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
 	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
 	"github.com/hyperledger/fabric/core/ledger/util/couchdb"
@@ -38,7 +40,7 @@ func NewVersionedDBProvider() (*VersionedDBProvider, error) {
 	logger.Debugf("constructing CouchDB VersionedDBProvider")
 	couchDBDef := couchdb.GetCouchDBDefinition()
 	couchInstance, err := couchdb.CreateCouchInstance(couchDBDef.URL, couchDBDef.Username, couchDBDef.Password,
-		couchDBDef.MaxRetries, couchDBDef.MaxRetriesOnStartup, couchDBDef.RequestTimeout)
+		couchDBDef.MaxRetries, couchDBDef.MaxRetriesOnStartup, couchDBDef.RequestTimeout, couchDBDef.CreateGlobalChangesDB)
 	if err != nil {
 		return nil, err
 	}
@@ -145,37 +203,78 @@ func (vdb *VersionedDB) GetDBType() string {
 // A bulk retrieve from couchdb is used to populate the cache.
 // committedVersions cache will be used for state validation of readsets
 // revisionNumbers cache will be used during commit phase for couchdb bulk updates
-func (vdb *VersionedDB) LoadCommittedVersions(keys []*statedb.CompositeKey) error {
-	nsKeysMap := map[string][]string{}
+func (vdb *VersionedDB) LoadCommittedVersions(notPreloaded []*statedb.CompositeKey, preLoaded map[*statedb.CompositeKey]*version.Height) error {
+	nsKeysMap := make(map[string][]string)
 	committedDataCache := newVersionCache()
-	for _, compositeKey := range keys {
+	for _, compositeKey := range notPreloaded {
 		ns, key := compositeKey.Namespace, compositeKey.Key
-		committedDataCache.setVerAndRev(ns, key, nil, "")
+		committedDataCache.setVer(ns, key, nil)
 		logger.Debugf("Load into version cache: %s~%s", ns, key)
 		nsKeysMap[ns] = append(nsKeysMap[ns], key)
 	}
-	nsMetadataMap, err := vdb.retrieveMetadata(nsKeysMap)
-	logger.Debugf("nsKeysMap=%s", nsKeysMap)
-	logger.Debugf("nsMetadataMap=%s", nsMetadataMap)
-	if err != nil {
-		return err
+	//nsMetadataMap, err := vdb.retrieveMetadata(nsKeysMap, true)
+	//nsMetadataMap := make(map[string][]*couchdb.DocMetadata)
+	//logger.Debugf("nsKeysMap=%s", nsKeysMap)
+	//logger.Debugf("nsMetadataMap=%s", nsMetadataMap)
+	//for ns, nsMetadata := range nsMetadataMap {
+	//	for _, keyMetadata := range nsMetadata {
+	//		// TODO - why would version be ever zero if loaded from db?
+	//		if len(keyMetadata.Version) != 0 {
+	//			committedDataCache.setVerAndRev(ns, keyMetadata.ID, createVersionHeightFromVersionString(keyMetadata.Version), keyMetadata.Rev)
+	//		}
+	//	}
+	//}
+	vdb.verCacheLock.Lock()
+	defer vdb.verCacheLock.Unlock()
+	vdb.committedDataCache = committedDataCache
+	for key, height := range preLoaded {
+		vdb.committedDataCache.setVer(key.Namespace, key.Key, height)
 	}
-	for ns, nsMetadata := range nsMetadataMap {
-		for _, keyMetadata := range nsMetadata {
-			// TODO - why would version be ever zero if loaded from db?
-			if len(keyMetadata.Version) != 0 {
-				committedDataCache.setVerAndRev(ns, keyMetadata.ID, createVersionHeightFromVersionString(keyMetadata.Version), keyMetadata.Rev)
+	return nil
+}
+
+func (vdb *VersionedDB) GetWSetCacheLock() *sync.RWMutex {
+	return vdb.verWSetCacheLock
+}
+
+func (vdb *VersionedDB) LoadWSetCommittedVersions(keys []*statedb.CompositeKey, keysExist []*statedb.CompositeKey, blockNum uint64) error {
+	nsKeysMap := map[string][]string{}
+	committedWSetDataCache := newVersionCache()
+	for _, compositeKey := range keys {
+		ns, key := compositeKey.Namespace, compositeKey.Key
+		committedWSetDataCache.setRev(ns, key, "")
+		logger.Debugf("Load into version cache: %s~%s", ns, key)
+	}
+
+	for _, compositeKey := range keysExist {
+		ns, key := compositeKey.Namespace, compositeKey.Key
+		nsKeysMap[ns] = append(nsKeysMap[ns], key)
+		// in case if we didn't find key metadata in couchdb
+		committedWSetDataCache.setRev(ns, key, "")
+	}
+
+	if len(nsKeysMap) > 0 {
+		nsMetadataMap, err := vdb.retrieveMetadata(nsKeysMap, true)
+		logger.Debugf("nsKeysMap=%s", nsKeysMap)
+		logger.Debugf("nsMetadataMap=%s", nsMetadataMap)
+		if err != nil {
+			return err
+		}
+		for ns, nsMetadata := range nsMetadataMap {
+			for _, keyMetadata := range nsMetadata {
+				logger.Debugf("Load into version cache: %s~%s", ns, keyMetadata.ID)
+				committedWSetDataCache.setRev(ns, keyMetadata.ID, keyMetadata.Rev)
 			}
 		}
+
 	}
-	vdb.verCacheLock.Lock()
-	defer vdb.verCacheLock.Unlock()
-	vdb.committedDataCache = committedDataCache
+	vdb.committedWSetDataCache[blockNum] = committedWSetDataCache
 	return nil
 }
 
 // GetVersion implements method in VersionedDB interface
 func (vdb *VersionedDB) GetVersion(namespace string, key string) (*version.Height, error) {
+	panic("unreachable (the logic moved to cached state store)")
 	returnVersion, keyFound := vdb.GetCachedVersion(namespace, key)
 	if !keyFound {
 		// This if block get executed only during simulation because during commit
@@ -253,15 +361,27 @@ func (vdb *VersionedDB) GetStateRangeScanIterator(namespace string, startKey str
 	queryLimit := ledgerconfig.GetQueryLimit()
 	db, err := vdb.getNamespaceDBHandle(namespace)
 	if err != nil {
+		if isDBNotFoundForEndorser(err) {
+			logger.Debugf("DB [%s] Not Found. Returning empty range scanner since I'm an endorser.", namespace)
+			return newQueryScanner(namespace, nil), nil
+		}
 		return nil, err
 	}
-	queryResult, err := db.ReadDocRange(startKey, endKey, queryLimit, querySkip)
+	queryResult, err := db.ReadDocRange(startKey, endKey, queryLimit, querySkip, false)
 	if err != nil {
 		logger.Debugf("Error calling ReadDocRange(): %s\n", err.Error())
 		return nil, err
 	}
+	if len(queryResult) != 0 {
+		metrics.IncrementCounter("cachestatestore_getstaterangescaniterator_cache_request_miss")
+	}
+
 	logger.Debugf("Exiting GetStateRangeScanIterator")
-	return newQueryScanner(namespace, *queryResult), nil
+	return newQueryScanner(namespace, queryResult), nil
+}
+
+func (vdb *VersionedDB) GetNonDurableStateRangeScanIterator(namespace string, startKey string, endKey string) (statedb.ResultsIterator, error) {
+	return vdb.GetStateRangeScanIterator(namespace, startKey, endKey)
 }
 
 // ExecuteQuery implements method in VersionedDB interface
@@ -277,6 +397,10 @@ func (vdb *VersionedDB) ExecuteQuery(namespace, query string) (statedb.ResultsIt
 	}
 	db, err := vdb.getNamespaceDBHandle(namespace)
 	if err != nil {
+		if isDBNotFoundForEndorser(err) {
+			logger.Debugf("DB [%s] Not Found. Returning empty range scanner since I'm an endorser.", namespace)
+			return newQueryScanner(namespace, nil), nil
+		}
 		return nil, err
 	}
 	queryResult, err := db.QueryDocuments(queryString)
@@ -285,11 +409,14 @@ func (vdb *VersionedDB) ExecuteQuery(namespace, query string) (statedb.ResultsIt
 		return nil, err
 	}
 	logger.Debugf("Exiting ExecuteQuery")
-	return newQueryScanner(namespace, *queryResult), nil
+	return newQueryScanner(namespace, queryResult), nil
 }
 
 // ApplyUpdates implements method in VersionedDB interface
 func (vdb *VersionedDB) ApplyUpdates(updates *statedb.UpdateBatch, height *version.Height) error {
+	stopWatch := metrics.StopWatch("statecouchdb_ApplyUpdates_duration")
+	defer stopWatch()
+
 	// TODO a note about https://jira.hyperledger.org/browse/FAB-8622
 	// the function `Apply update can be split into three functions. Each carrying out one of the following three stages`.
 	// The write lock is needed only for the stage 2.
@@ -355,19 +482,22 @@ func (vdb *VersionedDB) ensureFullCommitAndRecordSavepoint(height *version.Heigh
 		}
 		dbs = append(dbs, db)
 	}
-	if err := vdb.ensureFullCommit(dbs); err != nil {
-		return err
-	}
+
+	vdb.warmupAllIndexes(dbs)
+
 	// construct savepoint document and save
 	savepointCouchDoc, err := encodeSavepoint(height)
 	if err != nil {
 		return err
 	}
-	_, err = vdb.metadataDB.SaveDoc(savepointDocID, "", savepointCouchDoc)
+	rev, err := vdb.metadataDB.SaveDoc(savepointDocID, vdb.couchCheckpointRev, savepointCouchDoc)
 	if err != nil {
 		logger.Errorf("Failed to save the savepoint to DB %s\n", err.Error())
 		return err
 	}
+
+	vdb.couchCheckpointRev = rev
+
 	// Note: Ensure full commit on metadataDB after storing the savepoint is not necessary
 	// as CouchDB syncs states to disk periodically (every 1 second). If peer fails before
 	// syncing the savepoint to disk, ledger recovery process kicks in to ensure consistency
@@ -434,10 +564,10 @@ func applyAdditionalQueryOptions(queryString string, queryLimit, querySkip int)
 type queryScanner struct {
 	cursor    int
 	namespace string
-	results   []couchdb.QueryResult
+	results   []*couchdb.QueryResult
 }
 
-func newQueryScanner(namespace string, queryResults []couchdb.QueryResult) *queryScanner {
+func newQueryScanner(namespace string, queryResults []*couchdb.QueryResult) *queryScanner {
 	return &queryScanner{-1, namespace, queryResults}
 }
 
