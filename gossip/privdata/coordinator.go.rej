diff a/gossip/privdata/coordinator.go b/gossip/privdata/coordinator.go	(rejected hunks)
@@ -13,6 +13,7 @@ import (
 	"time"
 
 	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/common/metrics"
 	util2 "github.com/hyperledger/fabric/common/util"
 	"github.com/hyperledger/fabric/core/committer"
 	"github.com/hyperledger/fabric/core/committer/txvalidator"
@@ -31,6 +32,8 @@ import (
 	"github.com/op/go-logging"
 	"github.com/pkg/errors"
 	"github.com/spf13/viper"
+	"github.com/uber-go/tally"
+	"golang.org/x/net/context"
 )
 
 const (
@@ -149,24 +163,30 @@ func (c *coordinator) StorePvtData(txID string, privData *transientstore2.TxPvtR
 	return c.TransientStore.PersistWithConfig(txID, blkHeight, privData)
 }
 
-// StoreBlock stores block with private data into the ledger
-func (c *coordinator) StoreBlock(block *common.Block, privateDataSets util.PvtDataCollections) error {
+func (c *coordinator) ValidateBlock(block *common.Block, privateDataSets util.PvtDataCollections, resultsChan chan *txvalidator.ValidationResults) (*ledger.BlockAndPvtData, []string, error) {
 	if block.Data == nil {
-		return errors.New("Block data is empty")
+		return nil, nil, errors.New("Block data is empty")
 	}
 	if block.Header == nil {
-		return errors.New("Block header is nil")
+		return nil, nil, errors.New("Block header is nil")
 	}
 
-	logger.Infof("[%s] Received block [%d] from buffer", c.ChainID, block.Header.Number)
+	// FIXME: Change to Debug
+	logger.Infof("[%s] Starting first phase validation of %d transactions in block %d against committed data...", c.ChainID, len(block.Data.Data), block.Header.Number)
+
+	begin := time.Now()
 
-	logger.Debugf("[%s] Validating block [%d]", c.ChainID, block.Header.Number)
-	err := c.Validator.Validate(block)
+	err := c.Validator.Validate(block, resultsChan)
 	if err != nil {
 		logger.Errorf("Validation failed: %+v", err)
-		return err
+		return nil, nil, err
 	}
 
+	// FIXME: Change to Debug
+	logger.Infof("[%s] ... finished first phase validation of %d transactions in block %d against committed data in %s. Starting second phase...", c.ChainID, len(block.Data.Data), block.Header.Number, time.Since(begin))
+
+	begin2 := time.Now()
+
 	blockAndPvtData := &ledger.BlockAndPvtData{
 		Block:        block,
 		BlockPvtData: make(map[uint64]*ledger.TxPvtData),
@@ -235,29 +265,66 @@ func (c *coordinator) StoreBlock(block *common.Block, privateDataSets util.PvtDa
 			SeqInBlock: int(missingRWS.seqInBlock),
 		})
 	}
+	err = c.Committer.ValidateBlock(blockAndPvtData)
+	if err != nil {
+		return nil, nil, err
+	}
+	// FIXME: Change to Debug
+	logger.Infof("[%s] ... finished second phase validation of %d transactions in block %d in %s", c.ChainID, len(block.Data.Data), blockAndPvtData.Block.Header.Number, time.Since(begin2))
+	logger.Infof("[%s] Finished validating %d transactions in block %d in %s", c.ChainID, len(block.Data.Data), blockAndPvtData.Block.Header.Number, time.Since(begin))
+
+	return blockAndPvtData, privateInfo.txns, nil
+}
+
+func (c *coordinator) ValidatePartialBlock(ctx context.Context, block *common.Block) {
+	// This can be done in the background
+	go c.Validator.ValidatePartial(ctx, block)
+}
 
-	// commit block and private data
-	err = c.CommitWithPvtData(blockAndPvtData)
+// StoreBlock stores block with private data into the ledger
+func (c *coordinator) StoreBlock(blockAndPvtData *ledger.BlockAndPvtData, pvtTxns []string) error {
+	return c.storeBlock(blockAndPvtData, pvtTxns, c.Committer.CommitWithPvtData)
+}
+
+// PublishBlock stores a validated block into local caches and indexes (for a peer that does endorsement).
+func (c *coordinator) PublishBlock(blockAndPvtData *ledger.BlockAndPvtData, pvtTxns []string) error {
+	return c.storeBlock(blockAndPvtData, pvtTxns, c.Committer.AddBlock)
+}
+
+func (c *coordinator) storeBlock(blockAndPvtData *ledger.BlockAndPvtData, pvtTxns []string, store func(blockAndPvtData *ledger.BlockAndPvtData) error) error {
+	err := store(blockAndPvtData)
 	if err != nil {
-		return errors.Wrap(err, "commit failed")
+		return errors.WithMessage(err, "store block failed")
 	}
 
-	if len(blockAndPvtData.BlockPvtData) > 0 {
-		// Finally, purge all transactions in block - valid or not valid.
-		if err := c.PurgeByTxids(privateInfo.txns); err != nil {
-			logger.Error("Purging transactions", privateInfo.txns, "failed:", err)
-		}
+	block := blockAndPvtData.Block
+	if len(pvtTxns) > 0 || (block.Header.Number%c.transientBlockRetention == 0 && block.Header.Number > c.transientBlockRetention) {
+		go c.purgePrivateTransientData(block.Header.Number, pvtTxns)
 	}
 
-	seq := block.Header.Number
-	if seq%c.transientBlockRetention == 0 && seq > c.transientBlockRetention {
-		err := c.PurgeByHeight(seq - c.transientBlockRetention)
-		if err != nil {
-			logger.Error("Failed purging data from transient store at block", seq, ":", err)
+	return nil
+}
+
+func (c *coordinator) purgePrivateTransientData(blockNum uint64, pvtDataTxIDs []string) {
+	maxBlockNumToRetain := blockNum - c.transientBlockRetention
+	if len(pvtDataTxIDs) > 0 {
+		// Purge all transactions in block - valid or not valid.
+		logger.Debugf("Purging transient private data for transactions %s ...", pvtDataTxIDs)
+		if err := c.PurgeByTxids(pvtDataTxIDs); err != nil {
+			logger.Errorf("Purging transient private data for transactions %s failed: %s", pvtDataTxIDs, err)
+		} else {
+			logger.Debugf("Purging transient private data for transactions %s succeeded", pvtDataTxIDs)
 		}
 	}
 
-	return nil
+	if blockNum%c.transientBlockRetention == 0 && blockNum > c.transientBlockRetention {
+		logger.Debugf("Purging transient private data with maxBlockNumToRetain [%d]...", maxBlockNumToRetain)
+		if err := c.PurgeByHeight(maxBlockNumToRetain); err != nil {
+			logger.Errorf("Failed purging data from transient store with maxBlockNumToRetain [%d]: %s", maxBlockNumToRetain, err)
+		} else {
+			logger.Debugf("... finished running PurgeByHeight with maxBlockNumToRetain [%d]", maxBlockNumToRetain)
+		}
+	}
 }
 
 func (c *coordinator) fetchFromPeers(blockSeq uint64, ownedRWsets map[rwSetKey][]byte, privateInfo *privateDataInfo) {
