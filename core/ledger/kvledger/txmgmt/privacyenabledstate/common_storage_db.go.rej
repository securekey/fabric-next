diff a/core/ledger/kvledger/txmgmt/privacyenabledstate/common_storage_db.go b/core/ledger/kvledger/txmgmt/privacyenabledstate/common_storage_db.go	(rejected hunks)
@@ -11,11 +11,17 @@ import (
 	"fmt"
 	"strings"
 
+	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/statekeyindex"
+	"github.com/pkg/errors"
+
 	"github.com/hyperledger/fabric/common/flogging"
 	"github.com/hyperledger/fabric/core/common/ccprovider"
 	"github.com/hyperledger/fabric/core/ledger/cceventmgmt"
 
+	"sync"
+
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
+	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/statecachedstore"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/statecouchdb"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/stateleveldb"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
@@ -33,6 +39,7 @@ const (
 // CommonStorageDBProvider implements interface DBProvider
 type CommonStorageDBProvider struct {
 	statedb.VersionedDBProvider
+	stateKeyIndexProvider statekeyindex.StateKeyIndexProvider
 }
 
 // NewCommonStorageDBProvider constructs an instance of DBProvider
@@ -46,7 +53,15 @@ func NewCommonStorageDBProvider() (DBProvider, error) {
 	} else {
 		vdbProvider = stateleveldb.NewVersionedDBProvider()
 	}
-	return &CommonStorageDBProvider{vdbProvider}, nil
+
+	stateKeyIndexProvider := statekeyindex.NewProvider()
+
+	return &CommonStorageDBProvider{
+		statecachedstore.NewProvider(
+			vdbProvider,
+			stateKeyIndexProvider,
+		), stateKeyIndexProvider,
+	}, nil
 }
 
 // GetDBHandle implements function from interface DBProvider
@@ -55,7 +70,11 @@ func (p *CommonStorageDBProvider) GetDBHandle(id string) (DB, error) {
 	if err != nil {
 		return nil, err
 	}
-	return NewCommonStorageDB(vdb, id)
+	stateKeyIndex, err := p.stateKeyIndexProvider.OpenStateKeyIndex(id)
+	if err != nil {
+		return nil, err
+	}
+	return NewCommonStorageDB(vdb, stateKeyIndex, id)
 }
 
 // Close implements function from interface DBProvider
@@ -67,12 +86,14 @@ func (p *CommonStorageDBProvider) Close() {
 // both the public and private data
 type CommonStorageDB struct {
 	statedb.VersionedDB
+	ledgerID      string
+	stateKeyIndex statekeyindex.StateKeyIndex
 }
 
 // NewCommonStorageDB wraps a VersionedDB instance. The public data is managed directly by the wrapped versionedDB.
 // For managing the hashed data and private data, this implementation creates separate namespaces in the wrapped db
-func NewCommonStorageDB(vdb statedb.VersionedDB, ledgerid string) (DB, error) {
-	return &CommonStorageDB{VersionedDB: vdb}, nil
+func NewCommonStorageDB(vdb statedb.VersionedDB, stateKeyIndex statekeyindex.StateKeyIndex, ledgerID string) (DB, error) {
+	return &CommonStorageDB{VersionedDB: vdb, stateKeyIndex: stateKeyIndex, ledgerID: ledgerID}, nil
 }
 
 // IsBulkOptimizable implements corresponding function in interface DB
@@ -89,9 +110,49 @@ func (s *CommonStorageDB) LoadCommittedVersionsOfPubAndHashedKeys(pubKeys []*sta
 	if !ok {
 		return nil
 	}
+	deriveKeys := s.deriveHashedKeysAndPvtKeys(hashedKeys, nil)
+	pubKeys = append(pubKeys, deriveKeys...)
+
+	err := bulkOptimizable.LoadCommittedVersions(pubKeys, make(map[*statedb.CompositeKey]*version.Height))
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func (s *CommonStorageDB) GetWSetCacheLock() *sync.RWMutex {
+	bulkOptimizable, ok := s.VersionedDB.(statedb.BulkOptimizable)
+	if !ok {
+		return nil
+	}
+	//TODO find better way to acquire lock not through interface
+	return bulkOptimizable.GetWSetCacheLock()
+}
+
+// LoadWSetCommittedVersionsOfPubAndHashedKeys implements corresponding function in interface DB
+func (s *CommonStorageDB) LoadWSetCommittedVersionsOfPubAndHashedKeys(pubKeys []*statedb.CompositeKey,
+	hashedKeys []*HashedCompositeKey, pvtKeys []*PvtdataCompositeKey, blockNum uint64) error {
+
+	bulkOptimizable, ok := s.VersionedDB.(statedb.BulkOptimizable)
+	if !ok {
+		return nil
+	}
+	deriveKeys := s.deriveHashedKeysAndPvtKeys(hashedKeys, pvtKeys)
+	pubKeys = append(pubKeys, deriveKeys...)
+	err := bulkOptimizable.LoadWSetCommittedVersions(pubKeys, nil, blockNum)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func (s *CommonStorageDB) deriveHashedKeysAndPvtKeys(hashedKeys []*HashedCompositeKey, pvtKeys []*PvtdataCompositeKey) []*statedb.CompositeKey {
+	deriveKeys := make([]*statedb.CompositeKey, 0)
 	// Here, hashedKeys are merged into pubKeys to get a combined set of keys for combined loading
 	for _, key := range hashedKeys {
-		ns := deriveHashedDataNs(key.Namespace, key.CollectionName)
+		ns := DeriveHashedDataNs(key.Namespace, key.CollectionName)
 		// No need to check for duplicates as hashedKeys are in separate namespace
 		var keyHashStr string
 		if !s.BytesKeySuppoted() {
@@ -141,7 +204,7 @@ func (s *CommonStorageDB) GetValueHash(namespace, collection string, keyHash []b
 	if !s.BytesKeySuppoted() {
 		keyHashStr = base64.StdEncoding.EncodeToString(keyHash)
 	}
-	return s.GetState(deriveHashedDataNs(namespace, collection), keyHashStr)
+	return s.GetState(DeriveHashedDataNs(namespace, collection), keyHashStr)
 }
 
 // GetKeyHashVersion implements corresponding function in interface DB
@@ -150,7 +213,20 @@ func (s *CommonStorageDB) GetKeyHashVersion(namespace, collection string, keyHas
 	if !s.BytesKeySuppoted() {
 		keyHashStr = base64.StdEncoding.EncodeToString(keyHash)
 	}
-	return s.GetVersion(deriveHashedDataNs(namespace, collection), keyHashStr)
+
+	versionedValue, ok := s.GetKVCacheProvider().GetFromKVCache(s.ledgerID, DeriveHashedDataNs(namespace, collection), keyHashStr)
+	if !ok {
+		metadata, found, err := s.stateKeyIndex.GetMetadata(&statekeyindex.CompositeKey{Key: keyHashStr, Namespace: DeriveHashedDataNs(namespace, collection)})
+		if err != nil {
+			return nil, errors.Wrapf(err, "failed to retrieve metadata from the stateindex for key: %v", keyHashStr)
+		}
+		if !found {
+			return nil, nil
+		}
+		return version.NewHeight(metadata.BlockNumber, metadata.TxNumber), nil
+
+	}
+	return versionedValue.Version, nil
 }
 
 // GetCachedKeyHashVersion retrieves the keyhash version from cache
@@ -164,22 +240,27 @@ func (s *CommonStorageDB) GetCachedKeyHashVersion(namespace, collection string,
 	if !s.BytesKeySuppoted() {
 		keyHashStr = base64.StdEncoding.EncodeToString(keyHash)
 	}
-	return bulkOptimizable.GetCachedVersion(deriveHashedDataNs(namespace, collection), keyHashStr)
+	return bulkOptimizable.GetCachedVersion(DeriveHashedDataNs(namespace, collection), keyHashStr)
 }
 
 // GetPrivateDataMultipleKeys implements corresponding function in interface DB
 func (s *CommonStorageDB) GetPrivateDataMultipleKeys(namespace, collection string, keys []string) ([]*statedb.VersionedValue, error) {
-	return s.GetStateMultipleKeys(derivePvtDataNs(namespace, collection), keys)
+	return s.GetStateMultipleKeys(DerivePvtDataNs(namespace, collection), keys)
 }
 
 // GetPrivateDataRangeScanIterator implements corresponding function in interface DB
 func (s *CommonStorageDB) GetPrivateDataRangeScanIterator(namespace, collection, startKey, endKey string) (statedb.ResultsIterator, error) {
-	return s.GetStateRangeScanIterator(derivePvtDataNs(namespace, collection), startKey, endKey)
+	return s.GetStateRangeScanIterator(DerivePvtDataNs(namespace, collection), startKey, endKey)
+}
+
+// GetNonDurablePrivateDataRangeScanIterator implements corresponding function in interface DB
+func (s *CommonStorageDB) GetNonDurablePrivateDataRangeScanIterator(namespace, collection, startKey, endKey string) (statedb.ResultsIterator, error) {
+	return s.GetNonDurableStateRangeScanIterator(DerivePvtDataNs(namespace, collection), startKey, endKey)
 }
 
 // ExecuteQueryOnPrivateData implements corresponding function in interface DB
 func (s CommonStorageDB) ExecuteQueryOnPrivateData(namespace, collection, query string) (statedb.ResultsIterator, error) {
-	return s.ExecuteQuery(derivePvtDataNs(namespace, collection), query)
+	return s.ExecuteQuery(DerivePvtDataNs(namespace, collection), query)
 }
 
 // ApplyUpdates overrides the funciton in statedb.VersionedDB and throws appropriate error message
@@ -233,7 +314,7 @@ func (s *CommonStorageDB) HandleChaincodeDeploy(chaincodeDefinition *cceventmgmt
 		// check for the indexes directory for the collection
 		if directoryPathArray[3] == "collections" && directoryPathArray[5] == "indexes" {
 			collectionName := directoryPathArray[4]
-			err := indexCapable.ProcessIndexesForChaincodeDeploy(derivePvtDataNs(chaincodeDefinition.Name, collectionName),
+			err := indexCapable.ProcessIndexesForChaincodeDeploy(DerivePvtDataNs(chaincodeDefinition.Name, collectionName),
 				archiveDirectoryEntries)
 			if err != nil {
 				logger.Errorf(err.Error())
