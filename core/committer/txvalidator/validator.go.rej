diff a/core/committer/txvalidator/validator.go b/core/committer/txvalidator/validator.go	(rejected hunks)
@@ -8,6 +8,9 @@ package txvalidator
 
 import (
 	"fmt"
+	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
+	"sort"
+	"sync"
 	"time"
 
 	"github.com/golang/protobuf/proto"
@@ -68,17 +78,27 @@ type vsccValidator interface {
 	VSCCValidateTx(seq int, payload *common.Payload, envBytes []byte, block *common.Block) (error, peer.TxValidationCode)
 }
 
+type mvccValidator interface {
+	ValidateMVCC(ctx context.Context, block *common.Block, txFlags util.TxValidationFlags, filter util.TxFilter) error
+}
+
 // implementation of Validator interface, keeps
 // reference to the ledger to enable tx simulation
 // and execution of vscc
 type TxValidator struct {
-	ChainID string
-	Support Support
-	Vscc    vsccValidator
+	ChainID       string
+	Support       Support
+	Vscc          vsccValidator
+	gossip        gossip2.Gossip
+	mvccValidator mvccValidator
+	roleUtil      *roleutil.RoleUtil
 }
 
 var logger *logging.Logger // package-level logger
 
+// ignoreCancel is a cancel function that does nothing
+var ignoreCancel = func() {}
+
 func init() {
 	// Init logger with module name
 	logger = flogging.MustGetLogger("committer/txvalidator")
@@ -340,7 +667,7 @@ func (v *TxValidator) validateTx(req *blockValidationRequest, results chan<- *bl
 			_, err := v.Support.Ledger().GetTransactionByID(txID)
 			// 1) err == nil => there is already a tx in the ledger with the supplied id
 			if err == nil {
-				logger.Error("Duplicate transaction found, ", txID, ", skipping")
+				logger.Info("Duplicate transaction found, ", txID, ", skipping")
 				results <- &blockValidationResult{
 					tIdx:           tIdx,
 					validationCode: peer.TxValidationCode_DUPLICATE_TXID,
@@ -629,3 +956,53 @@ func (ds *dynamicCapabilities) V1_1Validation() bool {
 func (ds *dynamicCapabilities) V1_2Validation() bool {
 	return ds.support.Capabilities().V1_2Validation()
 }
+
+type validators []*roleutil.Member
+
+func (p validators) Len() int {
+	return len(p)
+}
+
+func (p validators) Less(i, j int) bool {
+	// Committers should always come first
+	if p.isCommitter(i) {
+		return true
+	}
+	if p.isCommitter(j) {
+		return false
+	}
+	return p[i].Endpoint < p[j].Endpoint
+}
+
+func (p validators) Swap(i, j int) {
+	p[i], p[j] = p[j], p[i]
+}
+
+func (p validators) isCommitter(i int) bool {
+	if p[i].Properties == nil {
+		return false
+	}
+	roles := gossipimpl.Roles(p[i].Properties.Roles)
+	return roles.HasRole(ledgerconfig.CommitterRole)
+}
+
+func getValidationWaitTime(numTransactions int) time.Duration {
+	minWaitTime := ledgerconfig.GetValidationMinWaitTime()
+	waitTime := time.Duration(numTransactions) * ledgerconfig.GetValidationWaitTimePerTx()
+	if waitTime < minWaitTime {
+		return minWaitTime
+	}
+	return waitTime
+}
+
+// flagsToString used in debugging
+func flagsToString(flags ledgerUtil.TxValidationFlags) string {
+	str := "["
+	for i := range flags {
+		str += fmt.Sprintf("[%d]=[%s]", i, flags.Flag(i))
+		if i+1 < len(flags) {
+			str += ","
+		}
+	}
+	return str + "]"
+}
