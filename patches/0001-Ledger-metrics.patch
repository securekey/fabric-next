From c462f46b51b079cd36f14c7b23cb22c482e871ce Mon Sep 17 00:00:00 2001
From: Reza Mirzeinolabedin <reza.mirzeinolabedin@securekey.com>
Date: Fri, 28 Sep 2018 15:11:32 -0400
Subject: [PATCH] [DEV-9612] Apply some modifications to ledger metrics patch
 to exclude chainID from payload_buffer and state

Change-Id: I3dd384516be575f3367cfc6d11ac4c714921a9e5
Signed-off-by: Reza Mirzeinolabedin <reza.mirzeinolabedin@securekey.com>
---
 gossip/state/payloads_buffer.go | 21 ++++++---------------
 gossip/state/state.go           |  7 +++++--
 2 files changed, 11 insertions(+), 17 deletions(-)

diff --git a/gossip/state/payloads_buffer.go b/gossip/state/payloads_buffer.go
index 0d2d17991..232485341 100644
--- a/gossip/state/payloads_buffer.go
+++ b/gossip/state/payloads_buffer.go
@@ -10,9 +10,6 @@ import (
 	"sync"
 	"sync/atomic"
 
-	"fmt"
-
-	"github.com/hyperledger/fabric/common/metrics"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/op/go-logging"
@@ -24,7 +21,7 @@ import (
 // to signal whenever expected block has arrived.
 type PayloadsBuffer interface {
 	// Adds new block into the buffer
-	Push(payload *proto.Payload)
+	Push(payload *proto.Payload) bool
 
 	// Returns next expected sequence number
 	Next() uint64
@@ -54,18 +51,15 @@ type PayloadsBufferImpl struct {
 	mutex sync.RWMutex
 
 	logger *logging.Logger
-
-	chainID string
 }
 
 // NewPayloadsBuffer is factory function to create new payloads buffer
-func NewPayloadsBuffer(chainID string, next uint64) PayloadsBuffer {
+func NewPayloadsBuffer(next uint64) PayloadsBuffer {
 	return &PayloadsBufferImpl{
 		buf:       make(map[uint64]*proto.Payload),
 		readyChan: make(chan struct{}, 1),
 		next:      next,
 		logger:    util.GetLogger(util.LoggingStateModule, ""),
-		chainID:   chainID,
 	}
 }
 
@@ -80,7 +74,7 @@ func (b *PayloadsBufferImpl) Ready() chan struct{} {
 // sequence number is below the expected next block number payload will be
 // thrown away.
 // TODO return bool to indicate if payload was added or not, so that caller can log result.
-func (b *PayloadsBufferImpl) Push(payload *proto.Payload) {
+func (b *PayloadsBufferImpl) Push(payload *proto.Payload) bool {
 	b.mutex.Lock()
 	defer b.mutex.Unlock()
 
@@ -88,11 +82,7 @@ func (b *PayloadsBufferImpl) Push(payload *proto.Payload) {
 
 	if seqNum < b.next || b.buf[seqNum] != nil {
 		logger.Debugf("Payload with sequence number = %d has been already processed", payload.SeqNum)
-		return
-	}
-
-	if metrics.IsDebug() {
-		metrics.RootScope.Gauge(fmt.Sprintf("payloadbuffer_%s_push_block_number", metrics.FilterMetricName(b.chainID))).Update(float64(seqNum))
+		return false
 	}
 
 	b.buf[seqNum] = payload
@@ -100,9 +90,10 @@ func (b *PayloadsBufferImpl) Push(payload *proto.Payload) {
 	// Send notification that next sequence has arrived
 
 	if seqNum == b.next && len(b.readyChan) == 0 {
-		metrics.RootScope.Gauge(fmt.Sprintf("payloadbuffer_%s_notify_block_number", metrics.FilterMetricName(b.chainID))).Update(float64(seqNum))
 		b.readyChan <- struct{}{}
 	}
+
+	return true
 }
 
 // Next function provides the number of the next expected block
diff --git a/gossip/state/state.go b/gossip/state/state.go
index 50a9dc536..dd7eb2863 100644
--- a/gossip/state/state.go
+++ b/gossip/state/state.go
@@ -214,7 +214,7 @@ func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger l
 		commChan: commChan,
 
 		// Create a queue for payload received
-		payloads: NewPayloadsBuffer(chainID, height),
+		payloads: NewPayloadsBuffer(height),
 
 		ledger: ledger,
 
@@ -779,7 +779,10 @@ func (s *GossipStateProviderImpl) addPayload(payload *proto.Payload, blockingMod
 		time.Sleep(enqueueRetryInterval)
 	}
 
-	s.payloads.Push(payload)
+	if s.payloads.Push(payload) {
+		metrics.RootScope.Gauge(fmt.Sprintf("addPayload[%s]", metrics.FilterMetricName(s.chainID))).Update(float64(payload.SeqNum))
+		logger.Debugf("[%s] Adding Payload to local buffer done, blockNum = [%d]", s.chainID, payload.SeqNum)
+	}
 	return nil
 }
 
-- 
2.17.1 (Apple Git-112)

