From aadbb308d1f2f0be818bb3a54fb42924030b0b6b Mon Sep 17 00:00:00 2001
From: Baha Shaaban <baha.shaaban@securekey.com>
Date: Thu, 30 May 2019 19:46:43 -0400
Subject: [PATCH 3/3] Backport Transient Data to Fabric 1.4.1

	Transient Data updates picked up from:
	trustblock/fabric-peer-ext
	trustblock/fabric-mod

Change-Id: I0db0a7bfb74111ee91b2e8a85bef8b794f4757da
Signed-off-by: Baha Shaaban <baha.shaaban@securekey.com>
---
 core/chaincode/exectransaction_test.go             |   2 +-
 core/endorser/endorser.go                          |   9 +-
 .../history/historydb/historyleveldb/pkg_test.go   |   2 +-
 core/ledger/kvledger/idstore/idstore.go            |  25 +
 core/ledger/kvledger/idstore/readme.md             |   2 +
 core/ledger/kvledger/kv_ledger.go                  |   9 +-
 core/ledger/kvledger/kv_ledger_provider.go         |   7 +-
 .../kvledger/txmgmt/rwsetutil/rwset_builder.go     |   2 +-
 .../kvledger/txmgmt/rwsetutil/rwset_proto_util.go  |   5 +-
 .../txmgmt/rwsetutil/rwset_proto_util_test.go      |   2 +-
 .../txmgmt/txmgr/lockbasedtxmgr/collection_val.go  |  13 +-
 .../txmgr/lockbasedtxmgr/collection_val_ext.go     |  35 +
 .../lockbasedtxmgr/collection_val_ext_test.go      |  66 ++
 .../kvledger/txmgmt/txmgr/lockbasedtxmgr/helper.go |   9 +
 .../lockbasedtxmgr/lockbased_query_executer.go     |   4 +-
 .../txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go |  14 +-
 .../txmgmt/txmgr/lockbasedtxmgr/pkg_test.go        |   4 +-
 .../txmgmt/txmgr/lockbasedtxmgr/pvtdatahandler.go  |  65 ++
 core/ledger/ledger_interface.go                    |   2 +
 core/ledger/ledgermgmt/ledger_mgmt.go              |   3 +
 core/ledger/pvtdatastorage/store.go                |  10 +
 core/ledger/util/couchdb/couchdb_ext.go            |  12 +
 core/peer/configtx_test.go                         |   5 +
 core/peer/mock_helpers.go                          |   2 +
 core/peer/peer.go                                  |  50 +-
 core/peer/peer_impl.go                             |  10 +-
 core/peer/peer_test.go                             |  11 +-
 go.mod                                             |   7 +
 go.sum                                             |  13 +
 gossip/privdata/coordinator.go                     |  19 +-
 gossip/privdata/coordinator_test.go                |  18 +
 gossip/privdata/dissemination.go                   |  33 +
 gossip/privdata/distributor.go                     |  22 +-
 gossip/privdata/distributor_test.go                |   4 +
 gossip/protoext/extensions.go                      |   7 +
 gossip/service/gossip_service.go                   |  13 +-
 gossip/service/gossip_service_test.go              |  20 +-
 gossip/service/integration_test.go                 |   8 +-
 gossip/state/state.go                              |  23 +-
 gossip/state/state_test.go                         |   8 +-
 peer/chaincode/common.go                           |  58 +-
 peer/chaincode/transientcollconfig_test.go         |  64 ++
 peer/node/start.go                                 |  15 +-
 protos/common/collection.pb.go                     | 147 ++--
 protos/common/collection.proto                     |  19 +-
 protos/gossip/message.pb.go                        | 738 ++++++++++++++++-----
 protos/gossip/message.proto                        |  45 ++
 protoutil/blockutils.go                            | 124 ++++
 protoutil/blockutils_test.go                       | 206 ++++++
 protoutil/chaincodeutils.go                        |  25 +
 protoutil/commonutils.go                           | 339 ++++++++++
 protoutil/commonutils_test.go                      | 429 ++++++++++++
 protoutil/proputils.go                             | 642 ++++++++++++++++++
 protoutil/proputils_test.go                        | 665 +++++++++++++++++++
 protoutil/readme.md                                |   3 +
 protoutil/txutils.go                               | 453 +++++++++++++
 protoutil/txutils_test.go                          | 522 +++++++++++++++
 57 files changed, 4770 insertions(+), 299 deletions(-)
 create mode 100644 core/ledger/kvledger/idstore/idstore.go
 create mode 100644 core/ledger/kvledger/idstore/readme.md
 create mode 100644 core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val_ext.go
 create mode 100644 core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val_ext_test.go
 create mode 100644 core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pvtdatahandler.go
 create mode 100644 core/ledger/util/couchdb/couchdb_ext.go
 create mode 100644 gossip/privdata/dissemination.go
 create mode 100644 peer/chaincode/transientcollconfig_test.go
 create mode 100644 protoutil/blockutils.go
 create mode 100644 protoutil/blockutils_test.go
 create mode 100644 protoutil/chaincodeutils.go
 create mode 100644 protoutil/commonutils.go
 create mode 100644 protoutil/commonutils_test.go
 create mode 100644 protoutil/proputils.go
 create mode 100644 protoutil/proputils_test.go
 create mode 100644 protoutil/readme.md
 create mode 100644 protoutil/txutils.go
 create mode 100644 protoutil/txutils_test.go

diff --git a/core/chaincode/exectransaction_test.go b/core/chaincode/exectransaction_test.go
index 9cb40e23..158fbf12 100644
--- a/core/chaincode/exectransaction_test.go
+++ b/core/chaincode/exectransaction_test.go
@@ -59,7 +59,7 @@ import (
 	"github.com/hyperledger/fabric/core/scc/lscc"
 	"github.com/hyperledger/fabric/msp"
 	mspmgmt "github.com/hyperledger/fabric/msp/mgmt"
-	"github.com/hyperledger/fabric/msp/mgmt/testtools"
+	msptesttools "github.com/hyperledger/fabric/msp/mgmt/testtools"
 	"github.com/hyperledger/fabric/protos/common"
 	pb "github.com/hyperledger/fabric/protos/peer"
 	putils "github.com/hyperledger/fabric/protos/utils"
diff --git a/core/endorser/endorser.go b/core/endorser/endorser.go
index 3a891394..e8b8d267 100644
--- a/core/endorser/endorser.go
+++ b/core/endorser/endorser.go
@@ -23,6 +23,7 @@ import (
 	"github.com/hyperledger/fabric/core/common/ccprovider"
 	"github.com/hyperledger/fabric/core/common/validation"
 	"github.com/hyperledger/fabric/core/ledger"
+	xendorser "github.com/hyperledger/fabric/extensions/endorser"
 	"github.com/hyperledger/fabric/protos/common"
 	pb "github.com/hyperledger/fabric/protos/peer"
 	"github.com/hyperledger/fabric/protos/transientstore"
@@ -256,6 +257,7 @@ func (e *Endorser) SimulateProposal(txParams *ccprovider.TransactionParams, cid
 			return nil, nil, nil, nil, err
 		}
 
+		var collConfigs map[string]*common.CollectionConfigPackage
 		if simResult.PvtSimulationResults != nil {
 			if cid.Name == "lscc" {
 				// TODO: remove once we can store collection configuration outside of LSCC
@@ -283,10 +285,15 @@ func (e *Endorser) SimulateProposal(txParams *ccprovider.TransactionParams, cid
 			if err := e.distributePrivateData(txParams.ChannelID, txParams.TxID, pvtDataWithConfig, endorsedAt); err != nil {
 				return nil, nil, nil, nil, err
 			}
+			collConfigs = pvtDataWithConfig.CollectionConfigs
 		}
 
 		txParams.TXSimulator.Done()
-		if pubSimResBytes, err = simResult.GetPubSimulationBytes(); err != nil {
+		pubSimRes, err := xendorser.FilterPubSimulationResults(collConfigs, simResult.PubSimulationResults)
+		if err != nil {
+			return nil, nil, nil, nil, err
+		}
+		if pubSimResBytes, err = proto.Marshal(pubSimRes); err != nil {
 			return nil, nil, nil, nil, err
 		}
 	}
diff --git a/core/ledger/kvledger/history/historydb/historyleveldb/pkg_test.go b/core/ledger/kvledger/history/historydb/historyleveldb/pkg_test.go
index 1af8eaa9..d64803d3 100644
--- a/core/ledger/kvledger/history/historydb/historyleveldb/pkg_test.go
+++ b/core/ledger/kvledger/history/historydb/historyleveldb/pkg_test.go
@@ -60,7 +60,7 @@ func newTestHistoryEnv(t *testing.T) *levelDBLockBasedHistoryEnv {
 	testDB := testDBEnv.GetDBHandle(testLedgerID)
 	testBookkeepingEnv := bookkeeping.NewTestEnv(t)
 
-	txMgr, err := lockbasedtxmgr.NewLockBasedTxMgr(testLedgerID, testDB, nil, nil, testBookkeepingEnv.TestProvider, &mock.DeployedChaincodeInfoProvider{})
+	txMgr, err := lockbasedtxmgr.NewLockBasedTxMgr(testLedgerID, testDB, nil, nil, testBookkeepingEnv.TestProvider, &mock.DeployedChaincodeInfoProvider{}, nil)
 	assert.NoError(t, err)
 	testHistoryDBProvider := NewHistoryDBProvider()
 	testHistoryDB, err := testHistoryDBProvider.GetDBHandle("TestHistoryDB")
diff --git a/core/ledger/kvledger/idstore/idstore.go b/core/ledger/kvledger/idstore/idstore.go
new file mode 100644
index 00000000..9e22b45f
--- /dev/null
+++ b/core/ledger/kvledger/idstore/idstore.go
@@ -0,0 +1,25 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package idstore
+
+import "github.com/hyperledger/fabric/protos/common"
+
+type IDStore interface {
+	SetUnderConstructionFlag(string) error
+	UnsetUnderConstructionFlag() error
+	GetUnderConstructionFlag() (string, error)
+	CreateLedgerID(ledgerID string, gb *common.Block) error
+	LedgerIDExists(ledgerID string) (bool, error)
+	GetAllLedgerIds() ([]string, error)
+	GetLedgeIDValue(ledgerID string) ([]byte, error)
+	Close()
+}
+
+// not implemented for Fabric 1.4.1
+func OpenIDStore(path string) IDStore {
+	return nil
+}
diff --git a/core/ledger/kvledger/idstore/readme.md b/core/ledger/kvledger/idstore/readme.md
new file mode 100644
index 00000000..8f58e92a
--- /dev/null
+++ b/core/ledger/kvledger/idstore/readme.md
@@ -0,0 +1,2 @@
+idstore was added with an empty OpenStore call
+it has been created for trustbloc/fabric-peer-ext dependency
\ No newline at end of file
diff --git a/core/ledger/kvledger/kv_ledger.go b/core/ledger/kvledger/kv_ledger.go
index 271655b2..6caa486f 100644
--- a/core/ledger/kvledger/kv_ledger.go
+++ b/core/ledger/kvledger/kv_ledger.go
@@ -24,6 +24,7 @@ import (
 	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
 	"github.com/hyperledger/fabric/core/ledger/ledgerstorage"
 	"github.com/hyperledger/fabric/core/ledger/pvtdatapolicy"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/peer"
 	"github.com/pkg/errors"
@@ -54,6 +55,7 @@ func newKVLedger(
 	bookkeeperProvider bookkeeping.Provider,
 	ccInfoProvider ledger.DeployedChaincodeInfoProvider,
 	stats *ledgerStats,
+	collDataProvider storeapi.Provider,
 ) (*kvLedger, error) {
 	logger.Debugf("Creating KVLedger ledgerID=%s: ", ledgerID)
 	// Create a kvLedger for this chain/ledger, which encasulates the underlying
@@ -69,7 +71,7 @@ func newKVLedger(
 		cceventmgmt.GetMgr().Register(ledgerID, ccEventListener)
 	}
 	btlPolicy := pvtdatapolicy.ConstructBTLPolicy(&collectionInfoRetriever{l, ccInfoProvider})
-	if err := l.initTxMgr(versionedDB, stateListeners, btlPolicy, bookkeeperProvider, ccInfoProvider); err != nil {
+	if err := l.initTxMgr(versionedDB, stateListeners, btlPolicy, bookkeeperProvider, ccInfoProvider, collDataProvider); err != nil {
 		return nil, err
 	}
 	l.initBlockStore(btlPolicy)
@@ -90,9 +92,10 @@ func newKVLedger(
 }
 
 func (l *kvLedger) initTxMgr(versionedDB privacyenabledstate.DB, stateListeners []ledger.StateListener,
-	btlPolicy pvtdatapolicy.BTLPolicy, bookkeeperProvider bookkeeping.Provider, ccInfoProvider ledger.DeployedChaincodeInfoProvider) error {
+	btlPolicy pvtdatapolicy.BTLPolicy, bookkeeperProvider bookkeeping.Provider, ccInfoProvider ledger.DeployedChaincodeInfoProvider,
+	collDataProvider storeapi.Provider) error {
 	var err error
-	l.txtmgmt, err = lockbasedtxmgr.NewLockBasedTxMgr(l.ledgerID, versionedDB, stateListeners, btlPolicy, bookkeeperProvider, ccInfoProvider)
+	l.txtmgmt, err = lockbasedtxmgr.NewLockBasedTxMgr(l.ledgerID, versionedDB, stateListeners, btlPolicy, bookkeeperProvider, ccInfoProvider, collDataProvider)
 	return err
 }
 
diff --git a/core/ledger/kvledger/kv_ledger_provider.go b/core/ledger/kvledger/kv_ledger_provider.go
index ebe6903c..ba8bb17c 100644
--- a/core/ledger/kvledger/kv_ledger_provider.go
+++ b/core/ledger/kvledger/kv_ledger_provider.go
@@ -20,6 +20,7 @@ import (
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/privacyenabledstate"
 	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
 	"github.com/hyperledger/fabric/core/ledger/ledgerstorage"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/utils"
 	"github.com/pkg/errors"
@@ -50,6 +51,8 @@ type Provider struct {
 	initializer         *ledger.Initializer
 	collElgNotifier     *collElgNotifier
 	stats               *stats
+
+	collDataProvider storeapi.Provider
 }
 
 // NewProvider instantiates a new Provider.
@@ -63,7 +66,7 @@ func NewProvider() (ledger.PeerLedgerProvider, error) {
 	historydbProvider := historyleveldb.NewHistoryDBProvider()
 	logger.Info("ledger provider Initialized")
 	provider := &Provider{idStore, ledgerStoreProvider,
-		nil, historydbProvider, nil, nil, nil, nil, nil, nil}
+		nil, historydbProvider, nil, nil, nil, nil, nil, nil, nil}
 	return provider, nil
 }
 
@@ -91,6 +94,7 @@ func (provider *Provider) Initialize(initializer *ledger.Initializer) error {
 	}
 	provider.stats = newStats(initializer.MetricsProvider)
 	provider.recoverUnderConstructionLedger()
+	provider.collDataProvider = initializer.CollDataProvider
 	return nil
 }
 
@@ -172,6 +176,7 @@ func (provider *Provider) openInternal(ledgerID string) (ledger.PeerLedger, erro
 		provider.stateListeners, provider.bookkeepingProvider,
 		provider.initializer.DeployedChaincodeInfoProvider,
 		provider.stats.ledgerStats(ledgerID),
+		provider.collDataProvider,
 	)
 	if err != nil {
 		return nil, err
diff --git a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_builder.go b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_builder.go
index 83041964..b3e7b2cc 100644
--- a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_builder.go
+++ b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_builder.go
@@ -138,7 +138,7 @@ func (b *RWSetBuilder) GetTxSimulationResults() (*ledger.TxSimulationResults, er
 
 	// Populate the collection-level hashes into pub rwset and compute the proto bytes for pvt rwset
 	if pvtData != nil {
-		if pvtDataProto, err = pvtData.toProtoMsg(); err != nil {
+		if pvtDataProto, err = pvtData.ToProtoMsg(); err != nil {
 			return nil, err
 		}
 		for _, ns := range pvtDataProto.NsPvtRwset {
diff --git a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go
index 0851b1ab..c48fb86b 100644
--- a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go
+++ b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go
@@ -128,7 +128,7 @@ func (txRwSet *TxRwSet) FromProtoBytes(protoBytes []byte) error {
 func (txPvtRwSet *TxPvtRwSet) ToProtoBytes() ([]byte, error) {
 	var protoMsg *rwset.TxPvtReadWriteSet
 	var err error
-	if protoMsg, err = txPvtRwSet.toProtoMsg(); err != nil {
+	if protoMsg, err = txPvtRwSet.ToProtoMsg(); err != nil {
 		return nil, err
 	}
 	return proto.Marshal(protoMsg)
@@ -249,7 +249,8 @@ func (txRwSet *TxRwSet) NumCollections() int {
 // functions for private read-write set
 ///////////////////////////////////////////////////////////////////////////////
 
-func (txPvtRwSet *TxPvtRwSet) toProtoMsg() (*rwset.TxPvtReadWriteSet, error) {
+// ToProtoMsg returns a TxPvtReadWriteSet from the current TxPvtRwSet
+func (txPvtRwSet *TxPvtRwSet) ToProtoMsg() (*rwset.TxPvtReadWriteSet, error) {
 	protoMsg := &rwset.TxPvtReadWriteSet{DataModel: rwset.TxReadWriteSet_KV}
 	var nsProtoMsg *rwset.NsPvtReadWriteSet
 	var err error
diff --git a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util_test.go b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util_test.go
index c7baf57d..2a5922ac 100644
--- a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util_test.go
+++ b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util_test.go
@@ -193,7 +193,7 @@ func sampleCollHashedRwSet(collectionName string) *CollHashedRwSet {
 
 func TestTxPvtRwSetConversion(t *testing.T) {
 	txPvtRwSet := sampleTxPvtRwSet()
-	protoMsg, err := txPvtRwSet.toProtoMsg()
+	protoMsg, err := txPvtRwSet.ToProtoMsg()
 	assert.NoError(t, err)
 	txPvtRwSet1, err := TxPvtRwSetFromProtoMsg(protoMsg)
 	assert.NoError(t, err)
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val.go
index cc1d0acf..95a60fad 100644
--- a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val.go
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val.go
@@ -53,7 +53,7 @@ func (v *collNameValidator) retrieveCollConfigFromStateDB(ns string) (*common.Co
 	return confPkg, nil
 }
 
-type collConfigCache map[collConfigkey]bool
+type collConfigCache map[collConfigkey]*common.CollectionConfig
 
 type collConfigkey struct {
 	ns, coll string
@@ -62,20 +62,23 @@ type collConfigkey struct {
 func (c collConfigCache) populate(ns string, pkg *common.CollectionConfigPackage) {
 	// an entry with an empty collection name to indicate that the cache is populated for the namespace 'ns'
 	// see function 'isPopulatedFor'
-	c[collConfigkey{ns, ""}] = true
+	c[collConfigkey{ns, ""}] = nil
 	for _, config := range pkg.Config {
 		sConfig := config.GetStaticCollectionConfig()
 		if sConfig == nil {
+			logger.Warningf("Error getting collection name in namespace [%s]", ns)
 			continue
 		}
-		c[collConfigkey{ns, sConfig.Name}] = true
+		c[collConfigkey{ns, sConfig.Name}] = config
 	}
 }
 
 func (c collConfigCache) isPopulatedFor(ns string) bool {
-	return c[collConfigkey{ns, ""}]
+	_, ok := c[collConfigkey{ns, ""}]
+	return ok
 }
 
 func (c collConfigCache) containsCollName(ns, coll string) bool {
-	return c[collConfigkey{ns, coll}]
+	_, ok := c[collConfigkey{ns, coll}]
+	return ok
 }
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val_ext.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val_ext.go
new file mode 100644
index 00000000..89022e52
--- /dev/null
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val_ext.go
@@ -0,0 +1,35 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package lockbasedtxmgr
+
+import (
+	"github.com/hyperledger/fabric/core/ledger"
+	"github.com/hyperledger/fabric/protos/common"
+)
+
+func (v *collNameValidator) getCollConfig(ns, coll string) (*common.CollectionConfig, error) {
+	if !v.cache.isPopulatedFor(ns) {
+		conf, err := v.retrieveCollConfigFromStateDB(ns)
+		if err != nil {
+			return nil, err
+		}
+		v.cache.populate(ns, conf)
+	}
+	config, ok := v.cache.getCollConfig(ns, coll)
+	if !ok {
+		return nil, &ledger.InvalidCollNameError{
+			Ns:   ns,
+			Coll: coll,
+		}
+	}
+	return config, nil
+}
+
+func (c collConfigCache) getCollConfig(ns, coll string) (*common.CollectionConfig, bool) {
+	config, ok := c[collConfigkey{ns, coll}]
+	return config, ok
+}
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val_ext_test.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val_ext_test.go
new file mode 100644
index 00000000..754f6d00
--- /dev/null
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val_ext_test.go
@@ -0,0 +1,66 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package lockbasedtxmgr
+
+import (
+	"testing"
+
+	"github.com/hyperledger/fabric/core/ledger"
+	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
+	"github.com/hyperledger/fabric/core/ledger/mock"
+	"github.com/hyperledger/fabric/protos/common"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestUnknownCollectionValidation(t *testing.T) {
+	testEnv := testEnvsMap[levelDBtestEnvName]
+	testEnv.init(t, "testLedger", nil)
+	txMgr := testEnv.getTxMgr()
+
+	populateUnknownCollConfigForTest(t, txMgr.(*LockBasedTxMgr),
+		[]collConfigkey{
+			{"ns1", "coll1"},
+		},
+		version.NewHeight(1, 1),
+	)
+
+	sim, err := txMgr.NewTxSimulator("tx-id1")
+	assert.NoError(t, err)
+
+	const key1 = "key1"
+	const key2 = "key1"
+
+	_, err = sim.GetPrivateData("ns1", "coll1", key1)
+	assert.NoError(t, err)
+
+	_, err = sim.GetPrivateDataMultipleKeys("ns1", "coll1", []string{key1, key2})
+	assert.NoError(t, err)
+}
+
+func populateUnknownCollConfigForTest(t *testing.T, txMgr *LockBasedTxMgr, nsColls []collConfigkey, ht *version.Height) {
+	m := map[string]*common.CollectionConfigPackage{}
+	for _, nsColl := range nsColls {
+		ns, coll := nsColl.ns, nsColl.coll
+		pkg, ok := m[ns]
+		if !ok {
+			pkg = &common.CollectionConfigPackage{}
+			m[ns] = pkg
+		}
+		tCollConfig := &common.CollectionConfig_StaticCollectionConfig{
+			StaticCollectionConfig: &common.StaticCollectionConfig{
+				Name: coll,
+				Type: common.CollectionType_COL_UNKNOWN,
+			},
+		}
+		pkg.Config = append(pkg.Config, &common.CollectionConfig{Payload: tCollConfig})
+	}
+	ccInfoProvider := &mock.DeployedChaincodeInfoProvider{}
+	ccInfoProvider.ChaincodeInfoStub = func(ccName string, qe ledger.SimpleQueryExecutor) (*ledger.DeployedChaincodeInfo, error) {
+		return &ledger.DeployedChaincodeInfo{Name: ccName, CollectionConfigPkg: m[ccName]}, nil
+	}
+	txMgr.ccInfoProvider = ccInfoProvider
+}
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper.go
index 4533e4c3..2fe7b884 100644
--- a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper.go
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper.go
@@ -17,11 +17,18 @@ import (
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
 	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
 	"github.com/hyperledger/fabric/core/ledger/util"
+	"github.com/hyperledger/fabric/extensions/collections/pvtdatahandler"
+	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/ledger/queryresult"
 	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
 	"github.com/pkg/errors"
 )
 
+type pvtDataHandler interface {
+	HandleGetPrivateData(txID, ns string, config *common.StaticCollectionConfig, key string) ([]byte, bool, error)
+	HandleGetPrivateDataMultipleKeys(txID, ns string, config *common.StaticCollectionConfig, keys []string) ([][]byte, bool, error)
+}
+
 type queryHelper struct {
 	txmgr             *LockBasedTxMgr
 	collNameValidator *collNameValidator
@@ -29,12 +36,14 @@ type queryHelper struct {
 	itrs              []*resultsItr
 	err               error
 	doneInvoked       bool
+	pvtDataHandler    pvtDataHandler
 }
 
 func newQueryHelper(txmgr *LockBasedTxMgr, rwsetBuilder *rwsetutil.RWSetBuilder) *queryHelper {
 	helper := &queryHelper{txmgr: txmgr, rwsetBuilder: rwsetBuilder}
 	validator := newCollNameValidator(txmgr.ccInfoProvider, &lockBasedQueryExecutor{helper: helper})
 	helper.collNameValidator = validator
+	helper.pvtDataHandler = pvtdatahandler.New(txmgr.ledgerid, txmgr.collDataProvider)
 	return helper
 }
 
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_query_executer.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_query_executer.go
index 83ef9fcd..d65ae9eb 100644
--- a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_query_executer.go
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_query_executer.go
@@ -67,7 +67,7 @@ func (q *lockBasedQueryExecutor) ExecuteQueryWithMetadata(namespace, query strin
 
 // GetPrivateData implements method in interface `ledger.QueryExecutor`
 func (q *lockBasedQueryExecutor) GetPrivateData(namespace, collection, key string) ([]byte, error) {
-	return q.helper.getPrivateData(namespace, collection, key)
+	return q.helper.handleGetPrivateData(q.txid, namespace, collection, key)
 }
 
 // GetPrivateDataMetadata implements method in interface `ledger.QueryExecutor`
@@ -82,7 +82,7 @@ func (q *lockBasedQueryExecutor) GetPrivateDataMetadataByHash(namespace, collect
 
 // GetPrivateDataMultipleKeys implements method in interface `ledger.QueryExecutor`
 func (q *lockBasedQueryExecutor) GetPrivateDataMultipleKeys(namespace, collection string, keys []string) ([][]byte, error) {
-	return q.helper.getPrivateDataMultipleKeys(namespace, collection, keys)
+	return q.helper.handleGetPrivateDataMultipleKeys(q.txid, namespace, collection, keys)
 }
 
 // GetPrivateDataRangeScanIterator implements method in interface `ledger.QueryExecutor`
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go
index ece061ef..dc6cb0eb 100644
--- a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_txmgr.go
@@ -22,6 +22,7 @@ import (
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
 	"github.com/hyperledger/fabric/core/ledger/pvtdatapolicy"
 	"github.com/hyperledger/fabric/core/ledger/util"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/ledger/rwset"
 	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
@@ -41,6 +42,8 @@ type LockBasedTxMgr struct {
 	commitRWLock    sync.RWMutex
 	oldBlockCommit  sync.Mutex
 	current         *current
+
+	collDataProvider storeapi.Provider
 }
 
 type current struct {
@@ -59,7 +62,8 @@ func (c *current) maxTxNumber() uint64 {
 
 // NewLockBasedTxMgr constructs a new instance of NewLockBasedTxMgr
 func NewLockBasedTxMgr(ledgerid string, db privacyenabledstate.DB, stateListeners []ledger.StateListener,
-	btlPolicy pvtdatapolicy.BTLPolicy, bookkeepingProvider bookkeeping.Provider, ccInfoProvider ledger.DeployedChaincodeInfoProvider) (*LockBasedTxMgr, error) {
+	btlPolicy pvtdatapolicy.BTLPolicy, bookkeepingProvider bookkeeping.Provider, ccInfoProvider ledger.DeployedChaincodeInfoProvider,
+	collDataProvider storeapi.Provider) (*LockBasedTxMgr, error) {
 	db.Open()
 	txmgr := &LockBasedTxMgr{
 		ledgerid:       ledgerid,
@@ -67,6 +71,8 @@ func NewLockBasedTxMgr(ledgerid string, db privacyenabledstate.DB, stateListener
 		stateListeners: stateListeners,
 		ccInfoProvider: ccInfoProvider,
 	}
+	txmgr.collDataProvider = collDataProvider
+
 	pvtstatePurgeMgr, err := pvtstatepurgemgmt.InstantiatePurgeMgr(ledgerid, db, btlPolicy, bookkeepingProvider)
 	if err != nil {
 		return nil, err
@@ -113,7 +119,7 @@ func (txmgr *LockBasedTxMgr) ValidateAndPrepare(blockAndPvtdata *ledger.BlockAnd
 	// interleave and nullify the optimization provided by the bulk read API.
 	// Once the ledger cache (FAB-103) is introduced and existing
 	// LoadCommittedVersions() is refactored to return a map, we can allow
-	// these three functions to execute parallely.
+	// these three functions to execute parallelly.
 	logger.Debugf("Waiting for purge mgr to finish the background job of computing expirying keys for the block")
 	txmgr.pvtdataPurgeMgr.WaitForPrepareToFinish()
 	txmgr.oldBlockCommit.Lock()
@@ -165,7 +171,7 @@ func (txmgr *LockBasedTxMgr) RemoveStaleAndCommitPvtDataOfOldBlocks(blocksPvtDat
 	// interleave and nullify the optimization provided by the bulk read API.
 	// Once the ledger cache (FAB-103) is introduced and existing
 	// LoadCommittedVersions() is refactored to return a map, we can allow
-	// these three functions to execute parallely. However, we cannot remove
+	// these three functions to execute parallelly. However, we cannot remove
 	// the lock on oldBlockCommit as it is also used to avoid interleaving
 	// between Commit() and execution of this function for the correctness.
 	logger.Debug("Waiting for purge mgr to finish the background job of computing expirying keys for the block")
@@ -492,7 +498,7 @@ func (txmgr *LockBasedTxMgr) Commit() error {
 	if err := txmgr.pvtdataPurgeMgr.BlockCommitDone(); err != nil {
 		return err
 	}
-	// In the case of error state listeners will not recieve this call - instead a peer panic is caused by the ledger upon receiveing
+	// In the case of error state listeners will not receive this call - instead a peer panic is caused by the ledger upon receiveing
 	// an error from this function
 	txmgr.updateStateListeners()
 	return nil
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pkg_test.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pkg_test.go
index cece1e3c..29ebbbb9 100644
--- a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pkg_test.go
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pkg_test.go
@@ -30,6 +30,7 @@ import (
 	"github.com/hyperledger/fabric/core/ledger/mock"
 	"github.com/hyperledger/fabric/core/ledger/pvtdatapolicy"
 	"github.com/hyperledger/fabric/core/ledger/util"
+	"github.com/hyperledger/fabric/extensions/mocks"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/ledger/queryresult"
 	"github.com/hyperledger/fabric/protos/ledger/rwset"
@@ -90,7 +91,8 @@ func (env *lockBasedEnv) init(t *testing.T, testLedgerID string, btlPolicy pvtda
 	env.txmgr, err = NewLockBasedTxMgr(
 		testLedgerID, env.testDB, nil,
 		btlPolicy, env.testBookkeepingEnv.TestProvider,
-		&mock.DeployedChaincodeInfoProvider{})
+		&mock.DeployedChaincodeInfoProvider{},
+		&mocks.DataProvider{})
 	assert.NoError(t, err)
 
 }
diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pvtdatahandler.go b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pvtdatahandler.go
new file mode 100644
index 00000000..987225ad
--- /dev/null
+++ b/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/pvtdatahandler.go
@@ -0,0 +1,65 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package lockbasedtxmgr
+
+import (
+	"github.com/pkg/errors"
+)
+
+func (h *queryHelper) handleGetPrivateData(txID, ns, coll, key string) ([]byte, error) {
+	if err := h.checkDone(); err != nil {
+		return nil, err
+	}
+
+	config, err := h.collNameValidator.getCollConfig(ns, coll)
+	if err != nil {
+		return nil, err
+	}
+
+	staticConfig := config.GetStaticCollectionConfig()
+	if staticConfig == nil {
+		return nil, errors.New("invalid collection config")
+	}
+
+	value, handled, err := h.pvtDataHandler.HandleGetPrivateData(txID, ns, staticConfig, key)
+	if err != nil {
+		return nil, err
+	}
+
+	if handled {
+		return value, nil
+	}
+
+	return h.getPrivateData(ns, coll, key)
+}
+
+func (h *queryHelper) handleGetPrivateDataMultipleKeys(txID, ns, coll string, keys []string) ([][]byte, error) {
+	if err := h.checkDone(); err != nil {
+		return nil, err
+	}
+
+	config, err := h.collNameValidator.getCollConfig(ns, coll)
+	if err != nil {
+		return nil, err
+	}
+
+	staticConfig := config.GetStaticCollectionConfig()
+	if staticConfig == nil {
+		return nil, errors.New("invalid collection config")
+	}
+
+	value, handled, err := h.pvtDataHandler.HandleGetPrivateDataMultipleKeys(txID, ns, staticConfig, keys)
+	if err != nil {
+		return nil, err
+	}
+
+	if handled {
+		return value, nil
+	}
+
+	return h.getPrivateDataMultipleKeys(ns, coll, keys)
+}
diff --git a/core/ledger/ledger_interface.go b/core/ledger/ledger_interface.go
index 929df1d5..69a54984 100644
--- a/core/ledger/ledger_interface.go
+++ b/core/ledger/ledger_interface.go
@@ -13,6 +13,7 @@ import (
 	"github.com/hyperledger/fabric-lib-go/healthz"
 	commonledger "github.com/hyperledger/fabric/common/ledger"
 	"github.com/hyperledger/fabric/common/metrics"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/ledger/rwset"
 	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
@@ -26,6 +27,7 @@ type Initializer struct {
 	MembershipInfoProvider        MembershipInfoProvider
 	MetricsProvider               metrics.Provider
 	HealthCheckRegistry           HealthCheckRegistry
+	CollDataProvider              storeapi.Provider
 }
 
 // PeerLedgerProvider provides handle to ledger instances
diff --git a/core/ledger/ledgermgmt/ledger_mgmt.go b/core/ledger/ledgermgmt/ledger_mgmt.go
index eb92047f..bfb0ac6e 100644
--- a/core/ledger/ledgermgmt/ledger_mgmt.go
+++ b/core/ledger/ledgermgmt/ledger_mgmt.go
@@ -18,6 +18,7 @@ import (
 	"github.com/hyperledger/fabric/core/ledger/cceventmgmt"
 	"github.com/hyperledger/fabric/core/ledger/customtx"
 	"github.com/hyperledger/fabric/core/ledger/kvledger"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/utils"
 	"github.com/pkg/errors"
@@ -45,6 +46,7 @@ type Initializer struct {
 	MembershipInfoProvider        ledger.MembershipInfoProvider
 	MetricsProvider               metrics.Provider
 	HealthCheckRegistry           ledger.HealthCheckRegistry
+	CollDataProvider              storeapi.Provider
 }
 
 // Initialize initializes ledgermgmt
@@ -76,6 +78,7 @@ func initialize(initializer *Initializer) {
 		MembershipInfoProvider:        initializer.MembershipInfoProvider,
 		MetricsProvider:               initializer.MetricsProvider,
 		HealthCheckRegistry:           initializer.HealthCheckRegistry,
+		CollDataProvider:              initializer.CollDataProvider,
 	})
 	if err != nil {
 		panic(errors.WithMessage(err, "Error initializing ledger provider"))
diff --git a/core/ledger/pvtdatastorage/store.go b/core/ledger/pvtdatastorage/store.go
index 62ea1070..8d06fc7b 100644
--- a/core/ledger/pvtdatastorage/store.go
+++ b/core/ledger/pvtdatastorage/store.go
@@ -86,6 +86,11 @@ type Store interface {
 	Shutdown()
 }
 
+// NewErrIllegalCall creates an illegal call error
+func NewErrIllegalCall(msg string) *ErrIllegalCall {
+	return &ErrIllegalCall{msg: msg}
+}
+
 // ErrIllegalCall is to be thrown by a store impl if the store does not expect a call to Prepare/Commit/Rollback/InitLastCommittedBlock
 type ErrIllegalCall struct {
 	msg string
@@ -104,6 +109,11 @@ func (err *ErrIllegalArgs) Error() string {
 	return err.msg
 }
 
+// NewErrOutOfRange creates an out of range error
+func NewErrOutOfRange(msg string) *ErrOutOfRange {
+	return &ErrOutOfRange{msg: msg}
+}
+
 // ErrOutOfRange is to be thrown for the request for the data that is not yet committed
 type ErrOutOfRange struct {
 	msg string
diff --git a/core/ledger/util/couchdb/couchdb_ext.go b/core/ledger/util/couchdb/couchdb_ext.go
new file mode 100644
index 00000000..ceee7809
--- /dev/null
+++ b/core/ledger/util/couchdb/couchdb_ext.go
@@ -0,0 +1,12 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package couchdb
+
+// CreateNewIndexWithRetry added to match Fabric 2.0 but not used in 1.4.1
+func (dbclient *CouchDatabase) CreateNewIndexWithRetry(indexdefinition string, designDoc string) error {
+	return nil
+}
diff --git a/core/peer/configtx_test.go b/core/peer/configtx_test.go
index c36a596c..928da35d 100644
--- a/core/peer/configtx_test.go
+++ b/core/peer/configtx_test.go
@@ -26,6 +26,7 @@ import (
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/ledger/customtx"
 	"github.com/hyperledger/fabric/core/ledger/ledgermgmt"
+	"github.com/hyperledger/fabric/extensions/mocks"
 	mspmgmt "github.com/hyperledger/fabric/msp/mgmt"
 	ordererconfig "github.com/hyperledger/fabric/orderer/common/localconfig"
 	"github.com/hyperledger/fabric/protos/common"
@@ -52,6 +53,7 @@ func TestConfigTxCreateLedger(t *testing.T) {
 	ledgermgmt.InitializeTestEnvWithInitializer(
 		&ledgermgmt.Initializer{
 			CustomTxProcessors: ConfigTxProcessors,
+			CollDataProvider:   &mocks.DataProvider{},
 		},
 	)
 
@@ -76,6 +78,7 @@ func TestConfigTxUpdateChanConfig(t *testing.T) {
 	ledgermgmt.InitializeTestEnvWithInitializer(
 		&ledgermgmt.Initializer{
 			CustomTxProcessors: ConfigTxProcessors,
+			CollDataProvider:   &mocks.DataProvider{},
 		},
 	)
 
@@ -118,6 +121,7 @@ func TestGenesisBlockCreateLedger(t *testing.T) {
 	ledgermgmt.InitializeTestEnvWithInitializer(
 		&ledgermgmt.Initializer{
 			CustomTxProcessors: ConfigTxProcessors,
+			CollDataProvider:   &mocks.DataProvider{},
 		},
 	)
 
@@ -137,6 +141,7 @@ func TestCustomTxProcessors(t *testing.T) {
 
 	ledgermgmt.InitializeExistingTestEnvWithInitializer(&ledgermgmt.Initializer{
 		CustomTxProcessors: ConfigTxProcessors,
+		CollDataProvider:   &mocks.DataProvider{},
 	})
 	defer ledgermgmt.CleanupTestEnv()
 
diff --git a/core/peer/mock_helpers.go b/core/peer/mock_helpers.go
index dfd5695c..5c44e9f3 100644
--- a/core/peer/mock_helpers.go
+++ b/core/peer/mock_helpers.go
@@ -13,6 +13,7 @@ import (
 	mockpolicies "github.com/hyperledger/fabric/common/mocks/policies"
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/ledger/ledgermgmt"
+	"github.com/hyperledger/fabric/extensions/mocks"
 )
 
 //MockInitialize resets chains for test env
@@ -20,6 +21,7 @@ func MockInitialize() {
 	ledgermgmt.InitializeTestEnvWithInitializer(
 		&ledgermgmt.Initializer{
 			CustomTxProcessors: ConfigTxProcessors,
+			CollDataProvider:   &mocks.DataProvider{},
 		},
 	)
 	chains.list = make(map[string]*chain)
diff --git a/core/peer/peer.go b/core/peer/peer.go
index d73e27ad..90dc931b 100644
--- a/core/peer/peer.go
+++ b/core/peer/peer.go
@@ -33,6 +33,9 @@ import (
 	"github.com/hyperledger/fabric/core/ledger/customtx"
 	"github.com/hyperledger/fabric/core/ledger/ledgermgmt"
 	"github.com/hyperledger/fabric/core/transientstore"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
+	"github.com/hyperledger/fabric/extensions/collections/storeprovider"
+	"github.com/hyperledger/fabric/extensions/gossip/blockpublisher"
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/service"
 	"github.com/hyperledger/fabric/msp"
@@ -78,6 +81,26 @@ type chainSupport struct {
 
 var TransientStoreFactory = &storeProvider{stores: make(map[string]transientstore.Store)}
 
+var collectionDataStoreFactory CollStoreProvider
+var initCollDataStoreFactoryOnce sync.Once
+
+// CollStoreProvider manages the collection stores for multiple channels
+type CollStoreProvider interface {
+	StoreForChannel(channelID string) storeapi.Store
+	OpenStore(channelID string) (storeapi.Store, error)
+}
+
+// CollectionDataStoreFactory returns transient data stores by channel ID
+func CollectionDataStoreFactory() CollStoreProvider {
+	initCollDataStoreFactoryOnce.Do(func() {
+		collectionDataStoreFactory = storeprovider.NewProviderFactory()
+	})
+	return collectionDataStoreFactory
+}
+
+// publisher manages the block publishers for all channels
+var BlockPublisher = blockpublisher.NewProvider()
+
 type storeProvider struct {
 	stores map[string]transientstore.Store
 	transientstore.StoreProvider
@@ -206,7 +229,8 @@ var validationWorkersSemaphore *semaphore.Weighted
 // ready
 func Initialize(init func(string), ccp ccprovider.ChaincodeProvider, sccp sysccprovider.SystemChaincodeProvider,
 	pm txvalidator.PluginMapper, pr *platforms.Registry, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider,
-	membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider) {
+	membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider,
+	collDataProvider storeapi.Provider) {
 	nWorkers := viper.GetInt("peer.validatorPoolSize")
 	if nWorkers <= 0 {
 		nWorkers = runtime.NumCPU()
@@ -224,6 +248,7 @@ func Initialize(init func(string), ccp ccprovider.ChaincodeProvider, sccp sysccp
 		DeployedChaincodeInfoProvider: deployedCCInfoProvider,
 		MembershipInfoProvider:        membershipProvider,
 		MetricsProvider:               metricsProvider,
+		CollDataProvider:              collDataProvider,
 	})
 	ledgerIds, err := ledgermgmt.GetLedgerIDs()
 	if err != nil {
@@ -385,12 +410,20 @@ func createChain(cid string, ledger ledger.PeerLedger, cb *common.Block, ccp ccp
 		*semaphore.Weighted
 	}{cs, validationWorkersSemaphore}
 	validator := txvalidator.NewTxValidator(cid, vcs, sccp, pm)
+
+	blockPublisher := BlockPublisher.ForChannel(cid)
 	c := committer.NewLedgerCommitterReactive(ledger, func(block *common.Block) error {
-		chainID, err := utils.GetChainIDFromBlock(block)
-		if err != nil {
-			return err
+		// Updating CSCC with new configuration block
+		if utils.IsConfigBlock(block) {
+			logger.Debug("Received configuration update, calling CSCC ConfigUpdate")
+			err := SetCurrConfigBlock(block, cid)
+			if err != nil {
+				return err
+			}
 		}
-		return SetCurrConfigBlock(block, chainID)
+		// Inform applicable registered handlers of the new block
+		blockPublisher.Publish(block)
+		return nil
 	})
 
 	ordererAddresses := bundle.ChannelConfig().OrdererAddresses()
@@ -403,6 +436,10 @@ func createChain(cid string, ledger ledger.PeerLedger, cb *common.Block, ccp ccp
 	if err != nil {
 		return errors.Wrapf(err, "[channel %s] failed opening transient store", bundle.ConfigtxValidator().ChainID())
 	}
+	collDataStore, err := CollectionDataStoreFactory().OpenStore(bundle.ConfigtxValidator().ChainID())
+	if err != nil {
+		return errors.Wrapf(err, "[channel %s] failed opening transient data store", bundle.ConfigtxValidator().ChainID())
+	}
 	csStoreSupport := &CollectionSupport{
 		PeerLedger: ledger,
 	}
@@ -412,8 +449,11 @@ func createChain(cid string, ledger ledger.PeerLedger, cb *common.Block, ccp ccp
 		Validator:            validator,
 		Committer:            c,
 		Store:                store,
+		CollDataStore:        collDataStore,
 		Cs:                   simpleCollectionStore,
 		IdDeserializeFactory: csStoreSupport,
+		Ledger:               ledger,
+		BlockPublisher:       blockPublisher,
 	})
 
 	chains.Lock()
diff --git a/core/peer/peer_impl.go b/core/peer/peer_impl.go
index 7e33563d..8665c040 100644
--- a/core/peer/peer_impl.go
+++ b/core/peer/peer_impl.go
@@ -15,6 +15,7 @@ import (
 	"github.com/hyperledger/fabric/core/common/ccprovider"
 	"github.com/hyperledger/fabric/core/common/sysccprovider"
 	"github.com/hyperledger/fabric/core/ledger"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
 	"github.com/hyperledger/fabric/protos/common"
 	pb "github.com/hyperledger/fabric/protos/peer"
 )
@@ -31,7 +32,7 @@ type Operations interface {
 	GetMSPIDs(cid string) []string
 	GetPolicyManager(cid string) policies.Manager
 	InitChain(cid string)
-	Initialize(init func(string), ccp ccprovider.ChaincodeProvider, sccp sysccprovider.SystemChaincodeProvider, pm txvalidator.PluginMapper, pr *platforms.Registry, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider)
+	Initialize(init func(string), ccp ccprovider.ChaincodeProvider, sccp sysccprovider.SystemChaincodeProvider, pm txvalidator.PluginMapper, pr *platforms.Registry, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider, collDataProvider storeapi.Provider)
 }
 
 type peerImpl struct {
@@ -43,7 +44,8 @@ type peerImpl struct {
 	getMSPIDs            func(cid string) []string
 	getPolicyManager     func(cid string) policies.Manager
 	initChain            func(cid string)
-	initialize           func(init func(string), ccp ccprovider.ChaincodeProvider, sccp sysccprovider.SystemChaincodeProvider, mapper txvalidator.PluginMapper, pr *platforms.Registry, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider)
+	initialize           func(init func(string), ccp ccprovider.ChaincodeProvider, sccp sysccprovider.SystemChaincodeProvider, mapper txvalidator.PluginMapper, pr *platforms.Registry, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider,
+		collDataProvider storeapi.Provider)
 }
 
 // Default provides in implementation of the Peer interface that provides
@@ -74,6 +76,6 @@ func (p *peerImpl) GetLedger(cid string) ledger.PeerLedger       { return p.getL
 func (p *peerImpl) GetMSPIDs(cid string) []string                { return p.getMSPIDs(cid) }
 func (p *peerImpl) GetPolicyManager(cid string) policies.Manager { return p.getPolicyManager(cid) }
 func (p *peerImpl) InitChain(cid string)                         { p.initChain(cid) }
-func (p *peerImpl) Initialize(init func(string), ccp ccprovider.ChaincodeProvider, sccp sysccprovider.SystemChaincodeProvider, mapper txvalidator.PluginMapper, pr *platforms.Registry, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider) {
-	p.initialize(init, ccp, sccp, mapper, pr, deployedCCInfoProvider, membershipProvider, metricsProvider)
+func (p *peerImpl) Initialize(init func(string), ccp ccprovider.ChaincodeProvider, sccp sysccprovider.SystemChaincodeProvider, mapper txvalidator.PluginMapper, pr *platforms.Registry, deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider, membershipProvider ledger.MembershipInfoProvider, metricsProvider metrics.Provider, tdp storeapi.Provider) {
+	p.initialize(init, ccp, sccp, mapper, pr, deployedCCInfoProvider, membershipProvider, metricsProvider, tdp)
 }
diff --git a/core/peer/peer_test.go b/core/peer/peer_test.go
index 82290674..4539db51 100644
--- a/core/peer/peer_test.go
+++ b/core/peer/peer_test.go
@@ -19,15 +19,16 @@ import (
 	"github.com/hyperledger/fabric/core/chaincode/platforms"
 	"github.com/hyperledger/fabric/core/comm"
 	"github.com/hyperledger/fabric/core/committer/txvalidator"
-	"github.com/hyperledger/fabric/core/deliverservice"
+	deliverclient "github.com/hyperledger/fabric/core/deliverservice"
 	"github.com/hyperledger/fabric/core/deliverservice/blocksprovider"
-	"github.com/hyperledger/fabric/core/handlers/validation/api"
+	validation "github.com/hyperledger/fabric/core/handlers/validation/api"
 	ledgermocks "github.com/hyperledger/fabric/core/ledger/mock"
 	"github.com/hyperledger/fabric/core/mocks/ccprovider"
+	storemocks "github.com/hyperledger/fabric/extensions/mocks"
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/service"
 	"github.com/hyperledger/fabric/msp/mgmt"
-	"github.com/hyperledger/fabric/msp/mgmt/testtools"
+	msptesttools "github.com/hyperledger/fabric/msp/mgmt/testtools"
 	peergossip "github.com/hyperledger/fabric/peer/gossip"
 	"github.com/hyperledger/fabric/peer/gossip/mocks"
 	"github.com/stretchr/testify/assert"
@@ -87,14 +88,14 @@ func TestInitialize(t *testing.T) {
 	cleanup := setupPeerFS(t)
 	defer cleanup()
 
-	Initialize(nil, &ccprovider.MockCcProviderImpl{}, (&mscc.MocksccProviderFactory{}).NewSystemChaincodeProvider(), txvalidator.MapBasedPluginMapper(map[string]validation.PluginFactory{}), nil, &ledgermocks.DeployedChaincodeInfoProvider{}, nil, &disabled.Provider{})
+	Initialize(nil, &ccprovider.MockCcProviderImpl{}, (&mscc.MocksccProviderFactory{}).NewSystemChaincodeProvider(), txvalidator.MapBasedPluginMapper(map[string]validation.PluginFactory{}), nil, &ledgermocks.DeployedChaincodeInfoProvider{}, nil, &disabled.Provider{}, &storemocks.DataProvider{})
 }
 
 func TestCreateChainFromBlock(t *testing.T) {
 	cleanup := setupPeerFS(t)
 	defer cleanup()
 
-	Initialize(nil, &ccprovider.MockCcProviderImpl{}, (&mscc.MocksccProviderFactory{}).NewSystemChaincodeProvider(), txvalidator.MapBasedPluginMapper(map[string]validation.PluginFactory{}), &platforms.Registry{}, &ledgermocks.DeployedChaincodeInfoProvider{}, nil, &disabled.Provider{})
+	Initialize(nil, &ccprovider.MockCcProviderImpl{}, (&mscc.MocksccProviderFactory{}).NewSystemChaincodeProvider(), txvalidator.MapBasedPluginMapper(map[string]validation.PluginFactory{}), &platforms.Registry{}, &ledgermocks.DeployedChaincodeInfoProvider{}, nil, &disabled.Provider{}, &storemocks.DataProvider{})
 	testChainID := fmt.Sprintf("mytestchainid-%d", rand.Int())
 	block, err := configtxtest.MakeGenesisBlock(testChainID)
 	if err != nil {
diff --git a/go.mod b/go.mod
index add2a530..13dfe4ab 100644
--- a/go.mod
+++ b/go.mod
@@ -9,6 +9,7 @@ require (
 	github.com/VividCortex/gohistogram v1.0.0 // indirect
 	github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc // indirect
 	github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf // indirect
+	github.com/bluele/gcache v0.0.0-20190301044115-79ae3b2d8680
 	github.com/containerd/continuity v0.0.0-20181003075958-be9bd761db19 // indirect
 	github.com/coreos/etcd v3.3.9+incompatible
 	github.com/coreos/pkg v0.0.0-20180108230652-97fdf19511ea // indirect
@@ -30,6 +31,7 @@ require (
 	github.com/hashicorp/hcl v1.0.0 // indirect
 	github.com/hyperledger/fabric-amcl v0.0.0-20180903120555-6b78f7a22d95
 	github.com/hyperledger/fabric-lib-go v1.0.0
+	github.com/hyperledger/fabric/extensions v0.0.0
 	github.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515 // indirect
 	github.com/kr/pretty v0.1.0
 	github.com/magiconair/properties v1.8.0 // indirect
@@ -61,6 +63,7 @@ require (
 	github.com/sykesm/zap-logfmt v0.0.2
 	github.com/syndtr/goleveldb v0.0.0-20180815032940-ae2bd5eed72d
 	github.com/tedsuo/ifrit v0.0.0-20180802180643-bea94bb476cc
+	github.com/trustbloc/fabric-peer-ext v0.0.0
 	github.com/willf/bitset v1.1.9
 	go.etcd.io/etcd v0.0.0-20181228115726-23731bf9ba55
 	go.uber.org/zap v1.9.1
@@ -81,3 +84,7 @@ replace github.com/docker/libnetwork => github.com/docker/libnetwork v0.0.0-2018
 replace github.com/docker/docker => github.com/docker/docker v0.0.0-20180827131323-0c5f8d2b9b23
 
 replace golang.org/x/crypto => golang.org/x/crypto v0.0.0-20180827131323-e3636079e1a4
+
+replace github.com/hyperledger/fabric/extensions => github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190528231123-9b2d0053a5e4
+
+replace github.com/trustbloc/fabric-peer-ext => github.com/trustbloc/fabric-peer-ext v0.0.0-20190528231123-9b2d0053a5e4
diff --git a/go.sum b/go.sum
index 6a3d8db5..9e20fe11 100644
--- a/go.sum
+++ b/go.sum
@@ -24,6 +24,10 @@ github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRF
 github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973 h1:xJ4a3vCFaGF/jqvzLMYoU8P317H5OQ+Via4RmuPwCS0=
 github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=
 github.com/bgentry/speakeasy v0.1.0/go.mod h1:+zsyZBPWlz7T6j88CTgSN5bM796AkVf0kBD4zp0CCIs=
+github.com/bluele/gcache v0.0.0-20190301044115-79ae3b2d8680 h1:jk2k2FUNIg9ogv9yFIzjA5NTrJeaAkHev4AFspbmyvo=
+github.com/bluele/gcache v0.0.0-20190301044115-79ae3b2d8680/go.mod h1:8c4/i2VlovMO2gBnHGQPN5EJw+H0lx1u/5p+cgsXtCk=
+github.com/btcsuite/btcutil v0.0.0-20170419141449-a5ecb5d9547a h1:UwuNC3d8iGIAwMyAO92ZGuVQYmdGkWXtQEGZdiIrJQs=
+github.com/btcsuite/btcutil v0.0.0-20170419141449-a5ecb5d9547a/go.mod h1:+5NJ2+qvTyV9exUAL/rxXi3DcLg2Ts+ymUAY5y4NvMg=
 github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
 github.com/containerd/continuity v0.0.0-20180814194400-c7c5070e6f6e/go.mod h1:GL3xCUCBDV3CZiTSEKksMWbLE66hEyuu9qyDOOqM47Y=
 github.com/containerd/continuity v0.0.0-20181003075958-be9bd761db19 h1:HSgjWPBWohO3kHDPwCPUGSLqJjXCjA7ad5057beR2ZU=
@@ -102,6 +106,7 @@ github.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=
 github.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=
 github.com/hpcloud/tail v1.0.0 h1:nfCOvKYfkgYP8hkirhJocXT2+zOD8yUNjXaWfTlyFKI=
 github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
+github.com/hyperledger/fabric v1.4.1/go.mod h1:tGFAOCT696D3rG0Vofd2dyWYLySHlh0aQjf7Q1HAju0=
 github.com/hyperledger/fabric-amcl v0.0.0-20180903120555-6b78f7a22d95 h1:owonHPXrnEIdS/G3kZa0Ipc59pY4MjxtHlMleFdRLcw=
 github.com/hyperledger/fabric-amcl v0.0.0-20180903120555-6b78f7a22d95/go.mod h1:X+DIyUsaTmalOpmpQfIvFZjKHQedrURQ5t4YqquX7lE=
 github.com/hyperledger/fabric-lib-go v1.0.0 h1:UL1w7c9LvHZUSkIvHTDGklxFv2kTeva1QI2emOVc324=
@@ -210,6 +215,14 @@ github.com/syndtr/goleveldb v0.0.0-20180815032940-ae2bd5eed72d/go.mod h1:Z4AUp2K
 github.com/tedsuo/ifrit v0.0.0-20180802180643-bea94bb476cc h1:LUUe4cdABGrIJAhl1P1ZpWY76AwukVszFdwkVFVLwIk=
 github.com/tedsuo/ifrit v0.0.0-20180802180643-bea94bb476cc/go.mod h1:eyZnKCc955uh98WQvzOm0dgAeLnf2O0Rz0LPoC5ze+0=
 github.com/tmc/grpc-websocket-proxy v0.0.0-20170815181823-89b8d40f7ca8/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=
+github.com/trustbloc/fabric-peer-ext v0.0.0-20190521162923-e85101b1c766 h1:8JCqNy4axsRfKZ6SDR+pNBIxZmDR5BDGWkQ2Uh4Bfk0=
+github.com/trustbloc/fabric-peer-ext v0.0.0-20190521162923-e85101b1c766/go.mod h1:iCK/9BGKwgGghd49gKiZuj8M5/oF9TEIuXi2xdWxARw=
+github.com/trustbloc/fabric-peer-ext v0.0.0-20190528231123-9b2d0053a5e4 h1:jc+YAMYAfpTbs6jLRXM3gt7pvHJryZTSYCfoASjqoDQ=
+github.com/trustbloc/fabric-peer-ext v0.0.0-20190528231123-9b2d0053a5e4/go.mod h1:8chTtto3TQYM5wxox915j4Rr3ZbkB10eHCKRqATF70c=
+github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190521162923-e85101b1c766 h1:37PEc6OPnTs7W7TWM1Ht+fdQ3q7CMH541pya86fPEF8=
+github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190521162923-e85101b1c766/go.mod h1:FS/JZ44vp5uSBuMaD0zCyilOAdQuyCfDoGUscj+ngfI=
+github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190528231123-9b2d0053a5e4 h1:/XeRyoLuyshcJrciQ5aUHT40TwPcY3GntXUHYiYk9lk=
+github.com/trustbloc/fabric-peer-ext/mod/peer v0.0.0-20190528231123-9b2d0053a5e4/go.mod h1:AZAS2bv+VPiYazIJhQmwnHvS3LKXTQCld2Ph7qk3uZ8=
 github.com/ugorji/go v1.1.1/go.mod h1:hnLbHMwcvSihnDhEfx2/BzKp2xb0Y+ErdfYcrs9tkJQ=
 github.com/urfave/cli v1.18.0/go.mod h1:70zkFmudgCuE/ngEzBv17Jvp/497gISqfk5gWijbERA=
 github.com/vishvananda/netlink v1.0.0 h1:bqNY2lgheFIu1meHUFSH3d7vG93AFyqg3oGbJCOJgSM=
diff --git a/gossip/privdata/coordinator.go b/gossip/privdata/coordinator.go
index 89038246..a3e6d348 100644
--- a/gossip/privdata/coordinator.go
+++ b/gossip/privdata/coordinator.go
@@ -21,6 +21,8 @@ import (
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil"
 	"github.com/hyperledger/fabric/core/transientstore"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
+	extcoord "github.com/hyperledger/fabric/extensions/gossip/coordinator"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	privdatacommon "github.com/hyperledger/fabric/gossip/privdata/common"
 	"github.com/hyperledger/fabric/gossip/util"
@@ -113,15 +115,21 @@ type Support struct {
 	txvalidator.Validator
 	committer.Committer
 	TransientStore
+	CollDataStore storeapi.Store
 	Fetcher
 }
 
+type pvtDataStore interface {
+	StorePvtData(txID string, privData *transientstore2.TxPvtReadWriteSetWithConfigInfo, blkHeight uint64) error
+}
+
 type coordinator struct {
 	selfSignedData common.SignedData
 	Support
 	transientBlockRetention uint64
 	metrics                 *metrics.PrivdataMetrics
 	pullRetryThreshold      time.Duration
+	pvtDataStore            pvtDataStore
 }
 
 type CoordinatorConfig struct {
@@ -129,17 +137,24 @@ type CoordinatorConfig struct {
 	PullRetryThreshold      time.Duration
 }
 
+// getPvtDataStore may be overridden by unit tests
+var getPvtDataStore = func(channelID string, transientStore TransientStore, collDataStore storeapi.Store) pvtDataStore {
+	return extcoord.New(channelID, transientStore, collDataStore)
+}
+
 // NewCoordinator creates a new instance of coordinator
 func NewCoordinator(support Support, selfSignedData common.SignedData, metrics *metrics.PrivdataMetrics,
 	config CoordinatorConfig) Coordinator {
 	return &coordinator{Support: support, selfSignedData: selfSignedData,
 		transientBlockRetention: config.TransientBlockRetention, metrics: metrics,
-		pullRetryThreshold: config.PullRetryThreshold}
+		pullRetryThreshold: config.PullRetryThreshold,
+		pvtDataStore:       getPvtDataStore(support.ChainID, support.TransientStore, support.CollDataStore),
+	}
 }
 
 // StorePvtData used to persist private date into transient store
 func (c *coordinator) StorePvtData(txID string, privData *transientstore2.TxPvtReadWriteSetWithConfigInfo, blkHeight uint64) error {
-	return c.TransientStore.PersistWithConfig(txID, blkHeight, privData)
+	return c.pvtDataStore.StorePvtData(txID, privData, blkHeight)
 }
 
 // StoreBlock stores block with private data into the ledger
diff --git a/gossip/privdata/coordinator_test.go b/gossip/privdata/coordinator_test.go
index f7fb1411..14cda60a 100644
--- a/gossip/privdata/coordinator_test.go
+++ b/gossip/privdata/coordinator_test.go
@@ -23,6 +23,8 @@ import (
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil"
 	"github.com/hyperledger/fabric/core/transientstore"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
+	extmocks "github.com/hyperledger/fabric/extensions/mocks"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	gmetricsmocks "github.com/hyperledger/fabric/gossip/metrics/mocks"
 	privdatacommon "github.com/hyperledger/fabric/gossip/privdata/common"
@@ -34,6 +36,7 @@ import (
 	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
 	"github.com/hyperledger/fabric/protos/msp"
 	"github.com/hyperledger/fabric/protos/peer"
+	tp "github.com/hyperledger/fabric/protos/transientstore"
 	transientstore2 "github.com/hyperledger/fabric/protos/transientstore"
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/mock"
@@ -416,6 +419,15 @@ func (cap *collectionAccessPolicy) AccessFilter() privdata.Filter {
 	}
 }
 
+type mockPvtDataStore struct {
+	transientStore TransientStore
+}
+
+// StorePvtData redirects the call to the transient store
+func (m *mockPvtDataStore) StorePvtData(txID string, privData *tp.TxPvtReadWriteSetWithConfigInfo, blkHeight uint64) error {
+	return m.transientStore.PersistWithConfig(txID, blkHeight, privData)
+}
+
 func TestPvtDataCollections_FailOnEmptyPayload(t *testing.T) {
 	collection := &util.PvtDataCollections{
 		&ledger.TxPvtData{
@@ -1350,18 +1362,24 @@ func TestPurgeByHeight(t *testing.T) {
 }
 
 func TestCoordinatorStorePvtData(t *testing.T) {
+	getPvtDataStore = func(channelID string, transientStore TransientStore, collDataStore storeapi.Store) pvtDataStore {
+		return &mockPvtDataStore{transientStore: transientStore}
+	}
+
 	metrics := metrics.NewGossipMetrics(&disabled.Provider{}).PrivdataMetrics
 	cs := createcollectionStore(common.SignedData{}).thatAcceptsAll()
 	committer := &mocks.Committer{}
 	store := &mockTransientStore{t: t}
 	store.On("PersistWithConfig", mock.Anything, uint64(5), mock.Anything).
 		expectRWSet("ns1", "c1", []byte("rws-pre-image")).Return(nil)
+	tdStore := extmocks.NewDataStore()
 	fetcher := &fetcherMock{t: t}
 	coordinator := NewCoordinator(Support{
 		CollectionStore: cs,
 		Committer:       committer,
 		Fetcher:         fetcher,
 		TransientStore:  store,
+		CollDataStore:   tdStore,
 		Validator:       &validatorMock{},
 	}, common.SignedData{}, metrics, testConfig)
 	pvtData := (&pvtDataFactory{}).addRWSet().addNSRWSet("ns1", "c1").create()
diff --git a/gossip/privdata/dissemination.go b/gossip/privdata/dissemination.go
new file mode 100644
index 00000000..f6466551
--- /dev/null
+++ b/gossip/privdata/dissemination.go
@@ -0,0 +1,33 @@
+/*
+	Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+	SPDX-License-Identifier: Apache-2.0
+*/
+
+package privdata
+
+import (
+	"github.com/hyperledger/fabric/core/common/privdata"
+	extdissemination "github.com/hyperledger/fabric/extensions/collections/dissemination"
+	"github.com/hyperledger/fabric/gossip/protoext"
+	"github.com/hyperledger/fabric/protos/common"
+	"github.com/hyperledger/fabric/protos/ledger/rwset"
+)
+
+func (d *distributorImpl) disseminationPlanForExt(ns string, rwSet *rwset.CollectionPvtReadWriteSet, colCP *common.CollectionConfig, colAP privdata.CollectionAccessPolicy, pvtDataMsg *protoext.SignedGossipMessage) ([]*dissemination, error) {
+	dissPlan, handled, err := extdissemination.ComputeDisseminationPlan(d.chainID, ns, rwSet, colCP, colAP, pvtDataMsg, d.gossipAdapter)
+	if err != nil {
+		return nil, err
+	}
+
+	if !handled {
+		// Use default dissemination plan
+		return d.disseminationPlanForMsg(colAP, colAP.AccessFilter(), pvtDataMsg)
+	}
+
+	dPlan := make([]*dissemination, len(dissPlan))
+	for i, dp := range dissPlan {
+		dPlan[i] = &dissemination{msg: dp.Msg, criteria: dp.Criteria}
+	}
+	return dPlan, nil
+}
diff --git a/gossip/privdata/distributor.go b/gossip/privdata/distributor.go
index c68face5..bbc6085d 100644
--- a/gossip/privdata/distributor.go
+++ b/gossip/privdata/distributor.go
@@ -47,6 +47,9 @@ type gossipAdapter interface {
 	// PeersOfChannel returns the NetworkMembers considered alive
 	// and also subscribed to the channel given
 	PeersOfChannel(gossipCommon.ChainID) []discovery.NetworkMember
+
+	// SelfMembershipInfo returns the peer's membership information
+	SelfMembershipInfo() discovery.NetworkMember
 }
 
 // PvtDataDistributor interface to defines API of distributing private data
@@ -91,10 +94,10 @@ func (p *policyAccessFactory) AccessPolicy(config *common.CollectionConfig, chai
 		if err != nil {
 			return nil, errors.WithMessage(err, fmt.Sprintf("error setting up collection  %#v", cconf.StaticCollectionConfig.Name))
 		}
+		return colAP, nil
 	default:
 		return nil, errors.New("unexpected collection type")
 	}
-	return colAP, nil
 }
 
 // NewCollectionAccessFactory
@@ -169,9 +172,20 @@ func (d *distributorImpl) computeDisseminationPlan(txID string,
 				return nil, errors.WithStack(err)
 			}
 
-			dPlan, err := d.disseminationPlanForMsg(colAP, colFilter, pvtDataMsg)
-			if err != nil {
-				return nil, errors.WithStack(err)
+			collType := colCP.GetStaticCollectionConfig().Type
+
+			var dPlan []*dissemination
+			switch {
+			case collType == common.CollectionType_COL_PRIVATE || collType == common.CollectionType_COL_UNKNOWN:
+				dPlan, err = d.disseminationPlanForMsg(colAP, colFilter, pvtDataMsg)
+				if err != nil {
+					return nil, errors.WithStack(err)
+				}
+			default:
+				dPlan, err = d.disseminationPlanForExt(namespace, collection, colCP, colAP, pvtDataMsg)
+				if err != nil {
+					return nil, errors.WithStack(err)
+				}
 			}
 			disseminationPlan = append(disseminationPlan, dPlan...)
 		}
diff --git a/gossip/privdata/distributor_test.go b/gossip/privdata/distributor_test.go
index 22f66060..8bf1221d 100644
--- a/gossip/privdata/distributor_test.go
+++ b/gossip/privdata/distributor_test.go
@@ -105,6 +105,10 @@ func (g *gossipMock) PeerFilter(channel gcommon.ChainID, messagePredicate api.Su
 	}, nil
 }
 
+func (g *gossipMock) SelfMembershipInfo() discovery.NetworkMember {
+	panic("not implemented")
+}
+
 func TestDistributor(t *testing.T) {
 	channelID := "test"
 
diff --git a/gossip/protoext/extensions.go b/gossip/protoext/extensions.go
index 18ca8208..dc8659a4 100644
--- a/gossip/protoext/extensions.go
+++ b/gossip/protoext/extensions.go
@@ -298,6 +298,13 @@ func IsTagLegal(m *gossip.GossipMessage) error {
 		return nil
 	}
 
+	if m.GetCollDataReq() != nil || m.GetCollDataRes() != nil {
+		if m.Tag != gossip.GossipMessage_CHAN_ONLY {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_ONLY)])
+		}
+		return nil
+	}
+
 	return fmt.Errorf("Unknown message type: %v", m)
 }
 
diff --git a/gossip/service/gossip_service.go b/gossip/service/gossip_service.go
index 8fb34292..29266fb2 100644
--- a/gossip/service/gossip_service.go
+++ b/gossip/service/gossip_service.go
@@ -13,8 +13,12 @@ import (
 	"github.com/hyperledger/fabric/core/committer"
 	"github.com/hyperledger/fabric/core/committer/txvalidator"
 	"github.com/hyperledger/fabric/core/common/privdata"
-	"github.com/hyperledger/fabric/core/deliverservice"
+	deliverclient "github.com/hyperledger/fabric/core/deliverservice"
 	"github.com/hyperledger/fabric/core/deliverservice/blocksprovider"
+	"github.com/hyperledger/fabric/core/ledger"
+	storeapi "github.com/hyperledger/fabric/extensions/collections/api/store"
+	extgossipapi "github.com/hyperledger/fabric/extensions/gossip/api"
+	"github.com/hyperledger/fabric/extensions/gossip/dispatcher"
 	"github.com/hyperledger/fabric/gossip/api"
 	gossipCommon "github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/election"
@@ -214,6 +218,9 @@ type Support struct {
 	Store                privdata2.TransientStore
 	Cs                   privdata.CollectionStore
 	IdDeserializeFactory privdata2.IdentityDeserializerFactory
+	CollDataStore        storeapi.Store
+	Ledger               ledger.PeerLedger
+	BlockPublisher       extgossipapi.BlockPublisher
 }
 
 // DataStoreSupport aggregates interfaces capable
@@ -253,6 +260,7 @@ func (g *gossipServiceImpl) InitializeChannel(chainID string, endpoints []string
 		CollectionStore: support.Cs,
 		Validator:       support.Validator,
 		TransientStore:  support.Store,
+		CollDataStore:   support.CollDataStore,
 		Committer:       support.Committer,
 		Fetcher:         fetcher,
 	}, g.createSelfSignedData(), g.metrics.PrivdataMetrics, coordinatorConfig)
@@ -277,7 +285,8 @@ func (g *gossipServiceImpl) InitializeChannel(chainID string, endpoints []string
 	g.privateHandlers[chainID].reconciler.Start()
 
 	g.chains[chainID] = state.NewGossipStateProvider(chainID, servicesAdapter, coordinator,
-		g.metrics.StateMetrics, getStateConfiguration())
+		g.metrics.StateMetrics, getStateConfiguration(),
+		dispatcher.New(chainID, support.CollDataStore, servicesAdapter, support.Ledger, support.BlockPublisher))
 	if g.deliveryService[chainID] == nil {
 		var err error
 		g.deliveryService[chainID], err = g.deliveryFactory.Service(g, endpoints, g.mcs)
diff --git a/gossip/service/gossip_service_test.go b/gossip/service/gossip_service_test.go
index 62ce04ea..f7c6619e 100644
--- a/gossip/service/gossip_service_test.go
+++ b/gossip/service/gossip_service_test.go
@@ -18,10 +18,11 @@ import (
 	"github.com/hyperledger/fabric/common/localmsp"
 	"github.com/hyperledger/fabric/common/metrics/disabled"
 	"github.com/hyperledger/fabric/core/comm"
-	"github.com/hyperledger/fabric/core/deliverservice"
+	deliverclient "github.com/hyperledger/fabric/core/deliverservice"
 	"github.com/hyperledger/fabric/core/deliverservice/blocksprovider"
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/transientstore"
+	kmocks "github.com/hyperledger/fabric/extensions/gossip/mocks"
 	"github.com/hyperledger/fabric/gossip/api"
 	gcomm "github.com/hyperledger/fabric/gossip/comm"
 	gossipCommon "github.com/hyperledger/fabric/gossip/common"
@@ -34,7 +35,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/state"
 	"github.com/hyperledger/fabric/gossip/util"
 	"github.com/hyperledger/fabric/msp/mgmt"
-	"github.com/hyperledger/fabric/msp/mgmt/testtools"
+	msptesttools "github.com/hyperledger/fabric/msp/mgmt/testtools"
 	peergossip "github.com/hyperledger/fabric/peer/gossip"
 	"github.com/hyperledger/fabric/peer/gossip/mocks"
 	"github.com/hyperledger/fabric/protos/common"
@@ -148,8 +149,9 @@ func TestLeaderElectionWithDeliverClient(t *testing.T) {
 		deliverServiceFactory.service.running[channelName] = false
 
 		gossips[i].InitializeChannel(channelName, []string{"endpoint"}, Support{
-			Store:     &mockTransientStore{},
-			Committer: &mockLedgerInfo{1},
+			Store:          &mockTransientStore{},
+			Committer:      &mockLedgerInfo{1},
+			BlockPublisher: kmocks.NewBlockPublisher(),
 		})
 		service, exist := gossips[i].(*gossipGRPC).gossipServiceImpl.leaderElection[channelName]
 		assert.True(t, exist, "Leader election service should be created for peer %d and channel %s", i, channelName)
@@ -206,8 +208,9 @@ func TestWithStaticDeliverClientLeader(t *testing.T) {
 		gossips[i].(*gossipGRPC).gossipServiceImpl.deliveryFactory = deliverServiceFactory
 		deliverServiceFactory.service.running[channelName] = false
 		gossips[i].InitializeChannel(channelName, []string{"endpoint"}, Support{
-			Committer: &mockLedgerInfo{1},
-			Store:     &mockTransientStore{},
+			Committer:      &mockLedgerInfo{1},
+			Store:          &mockTransientStore{},
+			BlockPublisher: kmocks.NewBlockPublisher(),
 		})
 	}
 
@@ -220,8 +223,9 @@ func TestWithStaticDeliverClientLeader(t *testing.T) {
 	for i := 0; i < n; i++ {
 		deliverServiceFactory.service.running[channelName] = false
 		gossips[i].InitializeChannel(channelName, []string{"endpoint"}, Support{
-			Committer: &mockLedgerInfo{1},
-			Store:     &mockTransientStore{},
+			Committer:      &mockLedgerInfo{1},
+			Store:          &mockTransientStore{},
+			BlockPublisher: kmocks.NewBlockPublisher(),
 		})
 	}
 
diff --git a/gossip/service/integration_test.go b/gossip/service/integration_test.go
index 20cbf18d..68a49785 100644
--- a/gossip/service/integration_test.go
+++ b/gossip/service/integration_test.go
@@ -11,10 +11,11 @@ import (
 	"testing"
 	"time"
 
-	"github.com/hyperledger/fabric/core/deliverservice"
+	deliverclient "github.com/hyperledger/fabric/core/deliverservice"
 	"github.com/hyperledger/fabric/core/deliverservice/blocksprovider"
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/transientstore"
+	kmocks "github.com/hyperledger/fabric/extensions/gossip/mocks"
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/util"
 	"github.com/hyperledger/fabric/protos/ledger/rwset"
@@ -137,8 +138,9 @@ func TestLeaderYield(t *testing.T) {
 		gs.deliveryFactory = &embeddingDeliveryServiceFactory{&deliveryFactoryImpl{}}
 		gossipServiceInstance = gs
 		gs.InitializeChannel(channelName, []string{endpoint}, Support{
-			Committer: &mockLedgerInfo{1},
-			Store:     &transientStoreMock{},
+			Committer:      &mockLedgerInfo{1},
+			Store:          &transientStoreMock{},
+			BlockPublisher: kmocks.NewBlockPublisher(),
 		})
 		return gs
 	}
diff --git a/gossip/state/state.go b/gossip/state/state.go
index a905a9df..0bf845a2 100644
--- a/gossip/state/state.go
+++ b/gossip/state/state.go
@@ -84,6 +84,12 @@ type GossipAdapter interface {
 	// PeersOfChannel returns the NetworkMembers considered alive
 	// and also subscribed to the channel given
 	PeersOfChannel(common2.ChainID) []discovery.NetworkMember
+
+	// SelfMembershipInfo returns the peer's membership information
+	SelfMembershipInfo() discovery.NetworkMember
+
+	// IdentityInfo returns information known peer identities
+	IdentityInfo() api.PeerIdentitySet
 }
 
 // MCSAdapter adapter of message crypto service interface to bound
@@ -130,6 +136,10 @@ type ServicesMediator struct {
 	MCSAdapter
 }
 
+type messageDispatcher interface {
+	Dispatch(msg protoext.ReceivedMessage) bool
+}
+
 // GossipStateProviderImpl the implementation of the GossipStateProvider interface
 // the struct to handle in memory sliding window of
 // new ledger block to be acquired by hyper ledger
@@ -166,6 +176,8 @@ type GossipStateProviderImpl struct {
 	config *Configuration
 
 	stateMetrics *metrics.StateMetrics
+
+	msgDispatcher messageDispatcher
 }
 
 var logger = util.GetLogger(util.StateLogger, "")
@@ -189,7 +201,7 @@ func (v *stateRequestValidator) validate(request *proto.RemoteStateRequest, batc
 
 // NewGossipStateProvider creates state provider with coordinator instance
 // to orchestrate arrival of private rwsets and blocks before committing them into the ledger.
-func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger ledgerResources, stateMetrics *metrics.StateMetrics, config *Configuration) GossipStateProvider {
+func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger ledgerResources, stateMetrics *metrics.StateMetrics, config *Configuration, msgDispatcher messageDispatcher) GossipStateProvider {
 
 	gossipChan, _ := services.Accept(func(message interface{}) bool {
 		// Get only data messages
@@ -200,7 +212,8 @@ func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger l
 	remoteStateMsgFilter := func(message interface{}) bool {
 		receivedMsg := message.(protoext.ReceivedMessage)
 		msg := receivedMsg.GetGossipMessage()
-		if !(protoext.IsRemoteStateMessage(msg.GossipMessage) || msg.GetPrivateData() != nil) {
+		if !(protoext.IsRemoteStateMessage(msg.GossipMessage) || msg.GetPrivateData() != nil ||
+			msg.GetCollDataReq() != nil || msg.GetCollDataRes() != nil) {
 			return false
 		}
 		// Ensure we deal only with messages that belong to this channel
@@ -270,6 +283,8 @@ func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger l
 		config: config,
 
 		stateMetrics: stateMetrics,
+
+		msgDispatcher: msgDispatcher,
 	}
 
 	logger.Infof("Updating metadata information, "+
@@ -321,6 +336,10 @@ func (s *GossipStateProviderImpl) dispatch(msg protoext.ReceivedMessage) {
 		logger.Debug("Handling private data collection message")
 		// Handling private data replication message
 		s.privateDataMessage(msg)
+	} else if s.msgDispatcher != nil {
+		if dispatched := s.msgDispatcher.Dispatch(msg); dispatched {
+			logger.Debug("Handled Extensions message")
+		}
 	}
 
 }
diff --git a/gossip/state/state_test.go b/gossip/state/state_test.go
index 08f2cf34..3b136a84 100644
--- a/gossip/state/state_test.go
+++ b/gossip/state/state_test.go
@@ -419,7 +419,7 @@ func newPeerNodeWithGossipWithValidatorWithMetrics(id int, committer committer.C
 		TransientStore: &mockTransientStore{},
 		Committer:      committer,
 	}, pcomm.SignedData{}, gossipMetrics.PrivdataMetrics, coordConfig)
-	sp := NewGossipStateProvider(util.GetTestChainID(), servicesAdapater, coord, gossipMetrics.StateMetrics, config)
+	sp := NewGossipStateProvider(util.GetTestChainID(), servicesAdapater, coord, gossipMetrics.StateMetrics, config, nil)
 	if sp == nil {
 		gRPCServer.Stop()
 		return nil, port
@@ -1466,7 +1466,7 @@ func TestTransferOfPrivateRWSet(t *testing.T) {
 
 	servicesAdapater := &ServicesMediator{GossipAdapter: g, MCSAdapter: &cryptoServiceMock{acceptor: noopPeerIdentityAcceptor}}
 	stateMetrics := metrics.NewGossipMetrics(&disabled.Provider{}).StateMetrics
-	st := NewGossipStateProvider(chainID, servicesAdapater, coord1, stateMetrics, config)
+	st := NewGossipStateProvider(chainID, servicesAdapater, coord1, stateMetrics, config, nil)
 	defer st.Stop()
 
 	// Mocked state request message
@@ -1700,11 +1700,11 @@ func TestTransferOfPvtDataBetweenPeers(t *testing.T) {
 	stateMetrics := metrics.NewGossipMetrics(&disabled.Provider{}).StateMetrics
 
 	mediator := &ServicesMediator{GossipAdapter: peers["peer1"], MCSAdapter: cryptoService}
-	peer1State := NewGossipStateProvider(chainID, mediator, peers["peer1"].coord, stateMetrics, config)
+	peer1State := NewGossipStateProvider(chainID, mediator, peers["peer1"].coord, stateMetrics, config, nil)
 	defer peer1State.Stop()
 
 	mediator = &ServicesMediator{GossipAdapter: peers["peer2"], MCSAdapter: cryptoService}
-	peer2State := NewGossipStateProvider(chainID, mediator, peers["peer2"].coord, stateMetrics, config)
+	peer2State := NewGossipStateProvider(chainID, mediator, peers["peer2"].coord, stateMetrics, config, nil)
 	defer peer2State.Stop()
 
 	// Make sure state was replicated
diff --git a/peer/chaincode/common.go b/peer/chaincode/common.go
index d259a225..b6c26d25 100644
--- a/peer/chaincode/common.go
+++ b/peer/chaincode/common.go
@@ -152,6 +152,14 @@ func chaincodeInvokeOrQuery(cmd *cobra.Command, invoke bool, cf *ChaincodeCmdFac
 	return nil
 }
 
+// CollectionType enumerates the various types of private data collections.
+type CollectionType string
+
+const (
+	CollectionType_PRIVATE   CollectionType = "PRIVATE"
+	CollectionType_TRANSIENT CollectionType = "TRANSIENT"
+)
+
 type collectionConfigJson struct {
 	Name           string `json:"name"`
 	Policy         string `json:"policy"`
@@ -159,6 +167,9 @@ type collectionConfigJson struct {
 	MaxPeerCount   int32  `json:"maxPeerCount"`
 	BlockToLive    uint64 `json:"blockToLive"`
 	MemberOnlyRead bool   `json:"memberOnlyRead"`
+
+	Type       CollectionType `json:"type"`
+	TimeToLive string         `json:"timeToLive"`
 }
 
 // getCollectionConfig retrieves the collection configuration
@@ -196,17 +207,44 @@ func getCollectionConfigFromBytes(cconfBytes []byte) ([]byte, error) {
 			},
 		}
 
-		cc := &pcommon.CollectionConfig{
-			Payload: &pcommon.CollectionConfig_StaticCollectionConfig{
-				StaticCollectionConfig: &pcommon.StaticCollectionConfig{
-					Name:              cconfitem.Name,
-					MemberOrgsPolicy:  cpc,
-					RequiredPeerCount: cconfitem.RequiredCount,
-					MaximumPeerCount:  cconfitem.MaxPeerCount,
-					BlockToLive:       cconfitem.BlockToLive,
-					MemberOnlyRead:    cconfitem.MemberOnlyRead,
+		var cc *pcommon.CollectionConfig
+		switch cconfitem.Type {
+		case CollectionType_TRANSIENT:
+			cc = &pcommon.CollectionConfig{
+				Payload: &pcommon.CollectionConfig_StaticCollectionConfig{
+					StaticCollectionConfig: &pcommon.StaticCollectionConfig{
+						Name:              cconfitem.Name,
+						MemberOrgsPolicy:  cpc,
+						RequiredPeerCount: cconfitem.RequiredCount,
+						MaximumPeerCount:  cconfitem.MaxPeerCount,
+						MemberOnlyRead:    cconfitem.MemberOnlyRead,
+						//MemberOnlyWrite is added post Fabric 1.4.1
+						//MemberOnlyWrite:   cconfitem.MemberOnlyWrite,
+
+						Type:       pcommon.CollectionType_COL_TRANSIENT,
+						TimeToLive: cconfitem.TimeToLive,
+					},
 				},
-			},
+			}
+		case CollectionType_PRIVATE:
+			fallthrough
+		case "":
+			cc = &pcommon.CollectionConfig{
+				Payload: &pcommon.CollectionConfig_StaticCollectionConfig{
+					StaticCollectionConfig: &pcommon.StaticCollectionConfig{
+						Name:              cconfitem.Name,
+						MemberOrgsPolicy:  cpc,
+						RequiredPeerCount: cconfitem.RequiredCount,
+						MaximumPeerCount:  cconfitem.MaxPeerCount,
+						BlockToLive:       cconfitem.BlockToLive,
+						MemberOnlyRead:    cconfitem.MemberOnlyRead,
+						//MemberOnlyWrite is added post Fabric 1.4.1
+						//MemberOnlyWrite:   cconfitem.MemberOnlyWrite,
+					},
+				},
+			}
+		default:
+			return nil, errors.Errorf("unsupported collection configuration type [%s]", cconfitem.Type)
 		}
 
 		ccarray = append(ccarray, cc)
diff --git a/peer/chaincode/transientcollconfig_test.go b/peer/chaincode/transientcollconfig_test.go
new file mode 100644
index 00000000..c16087d1
--- /dev/null
+++ b/peer/chaincode/transientcollconfig_test.go
@@ -0,0 +1,64 @@
+/*
+	Copyright Digital Asset Holdings, LLC. All Rights Reserved.
+	Copyright IBM Corp. All Rights Reserved.
+
+	SPDX-License-Identifier: Apache-2.0
+*/
+
+package chaincode
+
+import (
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/common/cauthdsl"
+	pcommon "github.com/hyperledger/fabric/protos/common"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+)
+
+const sampleCollectionConfigTransient = `[
+		{
+			"name": "foo",
+			"policy": "OR('A.member', 'B.member')",
+			"requiredPeerCount": 3,
+			"maxPeerCount": 5,
+			"type": "TRANSIENT",
+			"timeToLive": "2m"
+		}
+	]`
+
+const sampleCollectionConfigInvalidType = `[
+		{
+			"name": "foo",
+			"policy": "OR('A.member', 'B.member')",
+			"requiredPeerCount": 3,
+			"maxPeerCount": 5,
+			"type": "INVALID"
+		}
+	]`
+
+func TestCollectionTypeParsing(t *testing.T) {
+	pol, _ := cauthdsl.FromString("OR('A.member', 'B.member')")
+
+	t.Run("Invalid Collection Config Type", func(t *testing.T) {
+		_, err := getCollectionConfigFromBytes([]byte(sampleCollectionConfigInvalidType))
+		assert.Error(t, err)
+	})
+
+	t.Run("Transient Collection Config", func(t *testing.T) {
+		cc, err := getCollectionConfigFromBytes([]byte(sampleCollectionConfigTransient))
+		assert.NoError(t, err)
+		assert.NotNil(t, cc)
+		ccp := &pcommon.CollectionConfigPackage{Config: []*pcommon.CollectionConfig{}}
+		err = proto.Unmarshal(cc, ccp)
+		assert.NoError(t, err)
+		conf := ccp.Config[0].GetStaticCollectionConfig()
+		require.NotNil(t, conf)
+		assert.Equal(t, "foo", conf.Name)
+		assert.Equal(t, int32(3), conf.RequiredPeerCount)
+		assert.Equal(t, int32(5), conf.MaximumPeerCount)
+		assert.True(t, proto.Equal(pol, conf.MemberOrgsPolicy.GetSignaturePolicy()))
+		assert.Equal(t, "2m", conf.TimeToLive)
+	})
+}
diff --git a/peer/node/start.go b/peer/node/start.go
index ba7329ce..9ccb0944 100644
--- a/peer/node/start.go
+++ b/peer/node/start.go
@@ -70,6 +70,8 @@ import (
 	ccsupport "github.com/hyperledger/fabric/discovery/support/chaincode"
 	"github.com/hyperledger/fabric/discovery/support/config"
 	"github.com/hyperledger/fabric/discovery/support/gossip"
+	supportapi "github.com/hyperledger/fabric/extensions/collections/api/support"
+	collretriever "github.com/hyperledger/fabric/extensions/collections/retriever"
 	gossipcommon "github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/service"
 	"github.com/hyperledger/fabric/msp"
@@ -172,6 +174,16 @@ func serve(args []string) error {
 	flogging.Global.SetObserver(logObserver)
 
 	membershipInfoProvider := privdata.NewMembershipInfoProvider(createSelfSignedData(), identityDeserializerFactory)
+
+	transientDataProvider := collretriever.NewProvider(
+		peer.CollectionDataStoreFactory().StoreForChannel,
+		peer.GetLedger,
+		func() supportapi.GossipAdapter {
+			return service.GetGossipService()
+		},
+		peer.BlockPublisher.ForChannel,
+	)
+
 	//initialize resource management exit
 	ledgermgmt.Initialize(
 		&ledgermgmt.Initializer{
@@ -181,6 +193,7 @@ func serve(args []string) error {
 			MembershipInfoProvider:        membershipInfoProvider,
 			MetricsProvider:               metricsProvider,
 			HealthCheckRegistry:           opsSystem,
+			CollDataProvider:              transientDataProvider,
 		},
 	)
 
@@ -359,7 +372,7 @@ func serve(args []string) error {
 		}
 		cceventmgmt.GetMgr().Register(cid, sub)
 	}, ccp, sccp, txvalidator.MapBasedPluginMapper(validationPluginsByName),
-		pr, deployedCCInfoProvider, membershipInfoProvider, metricsProvider)
+		pr, deployedCCInfoProvider, membershipInfoProvider, metricsProvider, transientDataProvider)
 
 	if viper.GetBool("peer.discovery.enabled") {
 		registerDiscoveryService(peerServer, policyMgr, lifecycle)
diff --git a/protos/common/collection.pb.go b/protos/common/collection.pb.go
index e4d93634..237f4141 100644
--- a/protos/common/collection.pb.go
+++ b/protos/common/collection.pb.go
@@ -18,6 +18,39 @@ var _ = math.Inf
 // proto package needs to be updated.
 const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package
 
+// CollectionType enumerates the various types of private data collections.
+type CollectionType int32
+
+const (
+	CollectionType_COL_UNKNOWN   CollectionType = 0
+	CollectionType_COL_PRIVATE   CollectionType = 1
+	CollectionType_COL_TRANSIENT CollectionType = 2
+	CollectionType_COL_OFFLEDGER CollectionType = 3
+	CollectionType_COL_DCAS      CollectionType = 4
+)
+
+var CollectionType_name = map[int32]string{
+	0: "COL_UNKNOWN",
+	1: "COL_PRIVATE",
+	2: "COL_TRANSIENT",
+	3: "COL_OFFLEDGER",
+	4: "COL_DCAS",
+}
+var CollectionType_value = map[string]int32{
+	"COL_UNKNOWN":   0,
+	"COL_PRIVATE":   1,
+	"COL_TRANSIENT": 2,
+	"COL_OFFLEDGER": 3,
+	"COL_DCAS":      4,
+}
+
+func (x CollectionType) String() string {
+	return proto.EnumName(CollectionType_name, int32(x))
+}
+func (CollectionType) EnumDescriptor() ([]byte, []int) {
+	return fileDescriptor_collection_59b2e02e8b8b23b5, []int{0}
+}
+
 // CollectionConfigPackage represents an array of CollectionConfig
 // messages; the extra struct is required because repeated oneof is
 // forbidden by the protobuf syntax
@@ -32,7 +65,7 @@ func (m *CollectionConfigPackage) Reset()         { *m = CollectionConfigPackage
 func (m *CollectionConfigPackage) String() string { return proto.CompactTextString(m) }
 func (*CollectionConfigPackage) ProtoMessage()    {}
 func (*CollectionConfigPackage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_12a2cf6632dc7d83, []int{0}
+	return fileDescriptor_collection_59b2e02e8b8b23b5, []int{0}
 }
 func (m *CollectionConfigPackage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollectionConfigPackage.Unmarshal(m, b)
@@ -75,7 +108,7 @@ func (m *CollectionConfig) Reset()         { *m = CollectionConfig{} }
 func (m *CollectionConfig) String() string { return proto.CompactTextString(m) }
 func (*CollectionConfig) ProtoMessage()    {}
 func (*CollectionConfig) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_12a2cf6632dc7d83, []int{1}
+	return fileDescriptor_collection_59b2e02e8b8b23b5, []int{1}
 }
 func (m *CollectionConfig) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollectionConfig.Unmarshal(m, b)
@@ -199,7 +232,15 @@ type StaticCollectionConfig struct {
 	// can read the private data (if set to true), or even non members can
 	// read the data (if set to false, for example if you want to implement more granular
 	// access logic in the chaincode)
-	MemberOnlyRead       bool     `protobuf:"varint,6,opt,name=member_only_read,json=memberOnlyRead,proto3" json:"member_only_read,omitempty"`
+	MemberOnlyRead bool `protobuf:"varint,6,opt,name=member_only_read,json=memberOnlyRead,proto3" json:"member_only_read,omitempty"`
+	// The type of collection.
+	Type CollectionType `protobuf:"varint,9900,opt,name=type,proto3,enum=common.CollectionType" json:"type,omitempty"`
+	// The time after which the collection data expires. For example,
+	// if the value is set to "10m" then the data will be purged
+	// 10 minutes after it was stored. An empty value indicates that
+	// the data should never be purged.
+	// The format of this string must be parseable by time.ParseDuration
+	TimeToLive           string   `protobuf:"bytes,9901,opt,name=time_to_live,json=timeToLive,proto3" json:"time_to_live,omitempty"`
 	XXX_NoUnkeyedLiteral struct{} `json:"-"`
 	XXX_unrecognized     []byte   `json:"-"`
 	XXX_sizecache        int32    `json:"-"`
@@ -209,7 +250,7 @@ func (m *StaticCollectionConfig) Reset()         { *m = StaticCollectionConfig{}
 func (m *StaticCollectionConfig) String() string { return proto.CompactTextString(m) }
 func (*StaticCollectionConfig) ProtoMessage()    {}
 func (*StaticCollectionConfig) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_12a2cf6632dc7d83, []int{2}
+	return fileDescriptor_collection_59b2e02e8b8b23b5, []int{2}
 }
 func (m *StaticCollectionConfig) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_StaticCollectionConfig.Unmarshal(m, b)
@@ -271,6 +312,20 @@ func (m *StaticCollectionConfig) GetMemberOnlyRead() bool {
 	return false
 }
 
+func (m *StaticCollectionConfig) GetType() CollectionType {
+	if m != nil {
+		return m.Type
+	}
+	return CollectionType_COL_UNKNOWN
+}
+
+func (m *StaticCollectionConfig) GetTimeToLive() string {
+	if m != nil {
+		return m.TimeToLive
+	}
+	return ""
+}
+
 // Collection policy configuration. Initially, the configuration can only
 // contain a SignaturePolicy. In the future, the SignaturePolicy may be a
 // more general Policy. Instead of containing the actual policy, the
@@ -288,7 +343,7 @@ func (m *CollectionPolicyConfig) Reset()         { *m = CollectionPolicyConfig{}
 func (m *CollectionPolicyConfig) String() string { return proto.CompactTextString(m) }
 func (*CollectionPolicyConfig) ProtoMessage()    {}
 func (*CollectionPolicyConfig) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_12a2cf6632dc7d83, []int{3}
+	return fileDescriptor_collection_59b2e02e8b8b23b5, []int{3}
 }
 func (m *CollectionPolicyConfig) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollectionPolicyConfig.Unmarshal(m, b)
@@ -403,7 +458,7 @@ func (m *CollectionCriteria) Reset()         { *m = CollectionCriteria{} }
 func (m *CollectionCriteria) String() string { return proto.CompactTextString(m) }
 func (*CollectionCriteria) ProtoMessage()    {}
 func (*CollectionCriteria) Descriptor() ([]byte, []int) {
-	return fileDescriptor_collection_12a2cf6632dc7d83, []int{4}
+	return fileDescriptor_collection_59b2e02e8b8b23b5, []int{4}
 }
 func (m *CollectionCriteria) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_CollectionCriteria.Unmarshal(m, b)
@@ -457,40 +512,48 @@ func init() {
 	proto.RegisterType((*StaticCollectionConfig)(nil), "common.StaticCollectionConfig")
 	proto.RegisterType((*CollectionPolicyConfig)(nil), "common.CollectionPolicyConfig")
 	proto.RegisterType((*CollectionCriteria)(nil), "common.CollectionCriteria")
-}
-
-func init() { proto.RegisterFile("common/collection.proto", fileDescriptor_collection_12a2cf6632dc7d83) }
-
-var fileDescriptor_collection_12a2cf6632dc7d83 = []byte{
-	// 480 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0x51, 0x6b, 0xdb, 0x30,
-	0x10, 0xc7, 0xeb, 0x36, 0x4d, 0xe7, 0x0b, 0xdb, 0x32, 0x95, 0xa5, 0x66, 0x8c, 0x2e, 0x84, 0x3d,
-	0x18, 0x36, 0x9c, 0xd1, 0x7d, 0x83, 0x86, 0x41, 0xc7, 0x02, 0x0b, 0xea, 0x9e, 0xfa, 0x62, 0x14,
-	0xf9, 0xea, 0x88, 0xca, 0x92, 0x2b, 0x2b, 0x21, 0x7e, 0xdc, 0x97, 0xd9, 0xe7, 0x1c, 0x91, 0xec,
-	0x24, 0x0d, 0x79, 0xf3, 0xdd, 0xff, 0x77, 0xe7, 0xbb, 0xfb, 0xdb, 0x70, 0xc5, 0x75, 0x51, 0x68,
-	0x35, 0xe6, 0x5a, 0x4a, 0xe4, 0x56, 0x68, 0x95, 0x94, 0x46, 0x5b, 0x4d, 0xba, 0x5e, 0xf8, 0xf0,
-	0xbe, 0x01, 0x4a, 0x2d, 0x05, 0x17, 0x58, 0x79, 0x79, 0xf4, 0x0b, 0xae, 0x26, 0xdb, 0x92, 0x89,
-	0x56, 0x8f, 0x22, 0x9f, 0x31, 0xfe, 0xc4, 0x72, 0x24, 0xdf, 0xa0, 0xcb, 0x5d, 0x22, 0x0a, 0x86,
-	0x67, 0x71, 0xef, 0x26, 0x4a, 0x7c, 0x8b, 0xe4, 0xb0, 0x80, 0x36, 0xdc, 0xa8, 0x86, 0xfe, 0xa1,
-	0x46, 0x1e, 0x20, 0xaa, 0x2c, 0xb3, 0x82, 0xa7, 0xbb, 0xd1, 0xd2, 0x6d, 0xdf, 0x20, 0xee, 0xdd,
-	0x5c, 0xb7, 0x7d, 0xef, 0x1d, 0x77, 0xd8, 0xe1, 0xee, 0x84, 0x0e, 0xaa, 0xa3, 0xca, 0x6d, 0x08,
-	0x17, 0x25, 0xab, 0xa5, 0x66, 0xd9, 0xe8, 0xdf, 0x29, 0x0c, 0x8e, 0xd7, 0x13, 0x02, 0x1d, 0xc5,
-	0x0a, 0x74, 0x6f, 0x0b, 0xa9, 0x7b, 0x26, 0x53, 0x20, 0x05, 0x16, 0x73, 0x34, 0xa9, 0x36, 0x79,
-	0x95, 0xba, 0xa3, 0xd4, 0xd1, 0xe9, 0xcb, 0x79, 0x76, 0x9d, 0x66, 0x4e, 0x6f, 0xb6, 0xed, 0xfb,
-	0xca, 0xdf, 0x26, 0xaf, 0x7c, 0x9e, 0x24, 0x70, 0x69, 0xf0, 0x79, 0x29, 0x0c, 0x66, 0x69, 0x89,
-	0x68, 0x52, 0xae, 0x97, 0xca, 0x46, 0x67, 0xc3, 0x20, 0x3e, 0xa7, 0xef, 0x5a, 0x69, 0x86, 0x68,
-	0x26, 0x1b, 0x81, 0x7c, 0x05, 0x52, 0xb0, 0xb5, 0x28, 0x96, 0xc5, 0x3e, 0xde, 0x71, 0x78, 0xbf,
-	0x51, 0x76, 0xf4, 0x08, 0x5e, 0xcf, 0xa5, 0xe6, 0x4f, 0xa9, 0xd5, 0xa9, 0x14, 0x2b, 0x8c, 0xce,
-	0x87, 0x41, 0xdc, 0xa1, 0x3d, 0x97, 0xfc, 0xa3, 0xa7, 0x62, 0x85, 0x24, 0x86, 0x7e, 0xbb, 0x8f,
-	0x92, 0x75, 0x6a, 0x90, 0x65, 0x51, 0x77, 0x18, 0xc4, 0xaf, 0xe8, 0x9b, 0x66, 0x5a, 0x25, 0x6b,
-	0x8a, 0x2c, 0x1b, 0x3d, 0xc3, 0xe0, 0xf8, 0x5e, 0x64, 0x0a, 0xfd, 0x4a, 0xe4, 0x8a, 0xd9, 0xa5,
-	0xc1, 0xf6, 0x22, 0xde, 0xa1, 0x4f, 0x5b, 0x87, 0x5a, 0xdd, 0x17, 0xfe, 0x50, 0x2b, 0x94, 0xba,
-	0xc4, 0xbb, 0x13, 0xfa, 0xb6, 0x7a, 0x29, 0xed, 0x7b, 0xf3, 0x37, 0x00, 0xb2, 0xe7, 0x8a, 0x11,
-	0x16, 0x8d, 0x60, 0x24, 0x82, 0x0b, 0xbe, 0x60, 0x4a, 0xa1, 0x6c, 0xac, 0x69, 0x43, 0x72, 0x09,
-	0xe7, 0x76, 0x9d, 0x8a, 0xcc, 0x19, 0x12, 0xd2, 0x8e, 0x5d, 0xff, 0xcc, 0xc8, 0x35, 0xc0, 0xee,
-	0x0b, 0x72, 0xb7, 0x0d, 0xe9, 0x5e, 0x86, 0x7c, 0x84, 0x70, 0x63, 0x6d, 0x55, 0x32, 0x8e, 0xee,
-	0x96, 0x21, 0xdd, 0x25, 0x6e, 0xef, 0xe1, 0xb3, 0x36, 0x79, 0xb2, 0xa8, 0x4b, 0x34, 0x12, 0xb3,
-	0x1c, 0x4d, 0xf2, 0xc8, 0xe6, 0x46, 0x70, 0xff, 0x1f, 0x54, 0xcd, 0x86, 0x0f, 0x5f, 0x72, 0x61,
-	0x17, 0xcb, 0xf9, 0x26, 0x1c, 0xef, 0xc1, 0x63, 0x0f, 0x8f, 0x3d, 0x3c, 0xf6, 0xf0, 0xbc, 0xeb,
-	0xc2, 0xef, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x3b, 0x7c, 0x15, 0x7d, 0x03, 0x00, 0x00,
+	proto.RegisterEnum("common.CollectionType", CollectionType_name, CollectionType_value)
+}
+
+func init() { proto.RegisterFile("common/collection.proto", fileDescriptor_collection_59b2e02e8b8b23b5) }
+
+var fileDescriptor_collection_59b2e02e8b8b23b5 = []byte{
+	// 591 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0x5d, 0x4f, 0xdb, 0x30,
+	0x14, 0x25, 0x50, 0x0a, 0xbd, 0xe5, 0x23, 0x18, 0xad, 0x44, 0xd3, 0xc4, 0xba, 0x6a, 0x0f, 0xd1,
+	0x98, 0xda, 0x89, 0xfd, 0x02, 0x28, 0x65, 0x20, 0x4a, 0x5b, 0xb9, 0xdd, 0x26, 0xf1, 0x12, 0xb9,
+	0xc9, 0x25, 0x58, 0x24, 0x71, 0x70, 0x5c, 0x44, 0x1e, 0xf7, 0x7f, 0xb6, 0xbf, 0xb7, 0xe7, 0x29,
+	0x4e, 0xd2, 0x16, 0xc6, 0x5b, 0x7c, 0xce, 0xb9, 0xd7, 0xf7, 0x9e, 0xe3, 0xc0, 0x81, 0x2b, 0xc2,
+	0x50, 0x44, 0x1d, 0x57, 0x04, 0x01, 0xba, 0x8a, 0x8b, 0xa8, 0x1d, 0x4b, 0xa1, 0x04, 0xa9, 0xe6,
+	0xc4, 0xdb, 0x37, 0x85, 0x20, 0x16, 0x01, 0x77, 0x39, 0x26, 0x39, 0xdd, 0xba, 0x82, 0x83, 0xee,
+	0xbc, 0xa4, 0x2b, 0xa2, 0x5b, 0xee, 0x8f, 0x98, 0x7b, 0xcf, 0x7c, 0x24, 0x5f, 0xa0, 0xea, 0x6a,
+	0xc0, 0x32, 0x9a, 0x6b, 0x76, 0xfd, 0xd8, 0x6a, 0xe7, 0x2d, 0xda, 0x2f, 0x0b, 0x68, 0xa1, 0x6b,
+	0xa5, 0x60, 0xbe, 0xe4, 0xc8, 0x0d, 0x58, 0x89, 0x62, 0x8a, 0xbb, 0xce, 0x62, 0x34, 0x67, 0xde,
+	0xd7, 0xb0, 0xeb, 0xc7, 0x87, 0x65, 0xdf, 0xb1, 0xd6, 0xbd, 0xec, 0x70, 0xb1, 0x42, 0x1b, 0xc9,
+	0xab, 0xcc, 0x69, 0x0d, 0x36, 0x62, 0x96, 0x06, 0x82, 0x79, 0xad, 0xbf, 0xab, 0xd0, 0x78, 0xbd,
+	0x9e, 0x10, 0xa8, 0x44, 0x2c, 0x44, 0x7d, 0x5b, 0x8d, 0xea, 0x6f, 0xd2, 0x07, 0x12, 0x62, 0x38,
+	0x45, 0xe9, 0x08, 0xe9, 0x27, 0x8e, 0x36, 0x25, 0xb5, 0x56, 0x9f, 0xcf, 0xb3, 0xe8, 0x34, 0xd2,
+	0x7c, 0xb1, 0xad, 0x99, 0x57, 0x0e, 0xa5, 0x9f, 0xe4, 0x38, 0x69, 0xc3, 0xbe, 0xc4, 0x87, 0x19,
+	0x97, 0xe8, 0x39, 0x31, 0xa2, 0x74, 0x5c, 0x31, 0x8b, 0x94, 0xb5, 0xd6, 0x34, 0xec, 0x75, 0xba,
+	0x57, 0x52, 0x23, 0x44, 0xd9, 0xcd, 0x08, 0xf2, 0x19, 0x48, 0xc8, 0x9e, 0x78, 0x38, 0x0b, 0x97,
+	0xe5, 0x15, 0x2d, 0x37, 0x0b, 0x66, 0xa1, 0x6e, 0xc1, 0xf6, 0x34, 0x10, 0xee, 0xbd, 0xa3, 0x84,
+	0x13, 0xf0, 0x47, 0xb4, 0xd6, 0x9b, 0x86, 0x5d, 0xa1, 0x75, 0x0d, 0x4e, 0x44, 0x9f, 0x3f, 0x22,
+	0xb1, 0xc1, 0x2c, 0xf7, 0x89, 0x82, 0xd4, 0x91, 0xc8, 0x3c, 0xab, 0xda, 0x34, 0xec, 0x4d, 0xba,
+	0x53, 0x4c, 0x1b, 0x05, 0x29, 0x45, 0xe6, 0x91, 0x23, 0xa8, 0xa8, 0x34, 0x46, 0xeb, 0xf7, 0x75,
+	0xd3, 0xb0, 0x77, 0x8e, 0x1b, 0xff, 0x2f, 0x3b, 0x49, 0x63, 0xa4, 0x5a, 0x44, 0x3e, 0xc0, 0x96,
+	0xe2, 0x21, 0xce, 0x6f, 0xfe, 0x73, 0xad, 0x3d, 0x84, 0x0c, 0xcc, 0x6f, 0x6e, 0x3d, 0x40, 0xe3,
+	0x75, 0x9f, 0x48, 0x1f, 0xcc, 0x84, 0xfb, 0x11, 0x53, 0x33, 0x89, 0xa5, 0xc3, 0x79, 0xe2, 0xef,
+	0xe7, 0x89, 0x97, 0x7c, 0x5e, 0xd8, 0x8b, 0x1e, 0x31, 0x10, 0x31, 0x5e, 0xac, 0xd0, 0xdd, 0xe4,
+	0x39, 0xb5, 0x9c, 0xf5, 0x2f, 0x03, 0xc8, 0x52, 0xca, 0x92, 0x2b, 0x94, 0x9c, 0x11, 0x0b, 0x36,
+	0xdc, 0x3b, 0x16, 0x45, 0x18, 0x14, 0x51, 0x97, 0x47, 0xb2, 0x0f, 0xeb, 0xea, 0xc9, 0xe1, 0x9e,
+	0x0e, 0xb8, 0x46, 0x2b, 0xea, 0xe9, 0xd2, 0x23, 0x87, 0x00, 0x8b, 0x17, 0xa9, 0xb3, 0xaa, 0xd1,
+	0x25, 0x84, 0xbc, 0x83, 0x5a, 0xf6, 0x54, 0x92, 0x98, 0xb9, 0xa8, 0xb3, 0xa9, 0xd1, 0x05, 0xf0,
+	0xe9, 0x16, 0x76, 0x9e, 0x3b, 0x46, 0x76, 0xa1, 0xde, 0x1d, 0xf6, 0x9d, 0xef, 0x83, 0xab, 0xc1,
+	0xf0, 0xe7, 0xc0, 0x5c, 0x29, 0x81, 0x11, 0xbd, 0xfc, 0x71, 0x32, 0xe9, 0x99, 0x06, 0xd9, 0x83,
+	0xed, 0x0c, 0x98, 0xd0, 0x93, 0xc1, 0xf8, 0xb2, 0x37, 0x98, 0x98, 0xab, 0x25, 0x34, 0x3c, 0x3f,
+	0xef, 0xf7, 0xce, 0xbe, 0xf5, 0xa8, 0xb9, 0x46, 0xb6, 0x60, 0x33, 0x83, 0xce, 0xba, 0x27, 0x63,
+	0xb3, 0x72, 0x3a, 0x86, 0x8f, 0x42, 0xfa, 0xed, 0xbb, 0x34, 0x46, 0x19, 0xa0, 0xe7, 0xa3, 0x6c,
+	0xdf, 0xb2, 0xa9, 0xe4, 0x6e, 0xfe, 0xff, 0x26, 0x85, 0x93, 0x37, 0x47, 0x3e, 0x57, 0x77, 0xb3,
+	0x69, 0x76, 0xec, 0x2c, 0x89, 0x3b, 0xb9, 0xb8, 0x93, 0x8b, 0x3b, 0xb9, 0x78, 0x5a, 0xd5, 0xc7,
+	0xaf, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xf7, 0x1a, 0x4f, 0xba, 0x35, 0x04, 0x00, 0x00,
 }
diff --git a/protos/common/collection.proto b/protos/common/collection.proto
index 321bfd72..dbd575c9 100644
--- a/protos/common/collection.proto
+++ b/protos/common/collection.proto
@@ -13,6 +13,15 @@ option java_package = "org.hyperledger.fabric.protos.common";
 
 package common;
 
+// CollectionType enumerates the various types of private data collections.
+enum CollectionType {
+    COL_UNKNOWN = 0;    // Unspecified type - will use PRIVATE as default.
+    COL_PRIVATE = 1;    // Persisted private data collection.
+    COL_TRANSIENT = 2;  // Transient private data collection.
+    COL_OFFLEDGER = 3;  // Off-ledger private data collection. NOT USED By Fabric 1.4.1 release, added here for trustbloc/fabric-peer-ext dependency
+    COL_DCAS = 4;       // Distributed Content Addressable Store (CAS) private data collection. NOT USED By Fabric 1.4.1, same as above.
+}
+
 // CollectionConfigPackage represents an array of CollectionConfig
 // messages; the extra struct is required because repeated oneof is
 // forbidden by the protobuf syntax
@@ -56,6 +65,14 @@ message StaticCollectionConfig {
     // read the data (if set to false, for example if you want to implement more granular
     // access logic in the chaincode)
     bool member_only_read = 6;
+    // The type of collection.
+    CollectionType type = 9900;
+    // The time after which the collection data expires. For example,
+    // if the value is set to "10m" then the data will be purged
+    // 10 minutes after it was stored. An empty value indicates that
+    // the data should never be purged.
+    // The format of this string must be parseable by time.ParseDuration
+    string time_to_live = 9901;
 }
 
 
@@ -70,7 +87,7 @@ message CollectionPolicyConfig {
         // Later, the SignaturePolicy will be replaced by a Policy.
         //        Policy policy = 1;
         // A reference to a Policy is planned to be added later.
-//        string reference = 2;
+        //        string reference = 2;
     }
 }
 
diff --git a/protos/gossip/message.pb.go b/protos/gossip/message.pb.go
index 3d2c7a1b..4db4f85c 100644
--- a/protos/gossip/message.pb.go
+++ b/protos/gossip/message.pb.go
@@ -6,6 +6,7 @@ package gossip // import "github.com/hyperledger/fabric/protos/gossip"
 import proto "github.com/golang/protobuf/proto"
 import fmt "fmt"
 import math "math"
+import timestamp "github.com/golang/protobuf/ptypes/timestamp"
 import common "github.com/hyperledger/fabric/protos/common"
 
 import (
@@ -47,7 +48,7 @@ func (x PullMsgType) String() string {
 	return proto.EnumName(PullMsgType_name, int32(x))
 }
 func (PullMsgType) EnumDescriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{0}
+	return fileDescriptor_message_563b77f4f682605d, []int{0}
 }
 
 type GossipMessage_Tag int32
@@ -82,7 +83,7 @@ func (x GossipMessage_Tag) String() string {
 	return proto.EnumName(GossipMessage_Tag_name, int32(x))
 }
 func (GossipMessage_Tag) EnumDescriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{3, 0}
+	return fileDescriptor_message_563b77f4f682605d, []int{3, 0}
 }
 
 // Envelope contains a marshalled
@@ -102,7 +103,7 @@ func (m *Envelope) Reset()         { *m = Envelope{} }
 func (m *Envelope) String() string { return proto.CompactTextString(m) }
 func (*Envelope) ProtoMessage()    {}
 func (*Envelope) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{0}
+	return fileDescriptor_message_563b77f4f682605d, []int{0}
 }
 func (m *Envelope) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Envelope.Unmarshal(m, b)
@@ -160,7 +161,7 @@ func (m *SecretEnvelope) Reset()         { *m = SecretEnvelope{} }
 func (m *SecretEnvelope) String() string { return proto.CompactTextString(m) }
 func (*SecretEnvelope) ProtoMessage()    {}
 func (*SecretEnvelope) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{1}
+	return fileDescriptor_message_563b77f4f682605d, []int{1}
 }
 func (m *SecretEnvelope) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_SecretEnvelope.Unmarshal(m, b)
@@ -210,7 +211,7 @@ func (m *Secret) Reset()         { *m = Secret{} }
 func (m *Secret) String() string { return proto.CompactTextString(m) }
 func (*Secret) ProtoMessage()    {}
 func (*Secret) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{2}
+	return fileDescriptor_message_563b77f4f682605d, []int{2}
 }
 func (m *Secret) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Secret.Unmarshal(m, b)
@@ -339,7 +340,9 @@ type GossipMessage struct {
 	//	*GossipMessage_PrivateReq
 	//	*GossipMessage_PrivateRes
 	//	*GossipMessage_PrivateData
-	Content              IsGossipMessage_Content `protobuf_oneof:"content"`
+	//	*GossipMessage_CollDataReq
+	//	*GossipMessage_CollDataRes
+	Content              isGossipMessage_Content `protobuf_oneof:"content"`
 	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
 	XXX_unrecognized     []byte                  `json:"-"`
 	XXX_sizecache        int32                   `json:"-"`
@@ -349,7 +352,7 @@ func (m *GossipMessage) Reset()         { *m = GossipMessage{} }
 func (m *GossipMessage) String() string { return proto.CompactTextString(m) }
 func (*GossipMessage) ProtoMessage()    {}
 func (*GossipMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{3}
+	return fileDescriptor_message_563b77f4f682605d, []int{3}
 }
 func (m *GossipMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_GossipMessage.Unmarshal(m, b)
@@ -390,8 +393,8 @@ func (m *GossipMessage) GetTag() GossipMessage_Tag {
 	return GossipMessage_UNDEFINED
 }
 
-type IsGossipMessage_Content interface {
-	IsGossipMessage_Content()
+type isGossipMessage_Content interface {
+	isGossipMessage_Content()
 }
 
 type GossipMessage_AliveMsg struct {
@@ -478,49 +481,61 @@ type GossipMessage_PrivateData struct {
 	PrivateData *PrivateDataMessage `protobuf:"bytes,25,opt,name=private_data,json=privateData,proto3,oneof"`
 }
 
-func (*GossipMessage_AliveMsg) IsGossipMessage_Content() {}
+type GossipMessage_CollDataReq struct {
+	CollDataReq *RemoteCollDataRequest `protobuf:"bytes,90,opt,name=collDataReq,proto3,oneof"`
+}
+
+type GossipMessage_CollDataRes struct {
+	CollDataRes *RemoteCollDataResponse `protobuf:"bytes,91,opt,name=collDataRes,proto3,oneof"`
+}
+
+func (*GossipMessage_AliveMsg) isGossipMessage_Content() {}
+
+func (*GossipMessage_MemReq) isGossipMessage_Content() {}
+
+func (*GossipMessage_MemRes) isGossipMessage_Content() {}
 
-func (*GossipMessage_MemReq) IsGossipMessage_Content() {}
+func (*GossipMessage_DataMsg) isGossipMessage_Content() {}
 
-func (*GossipMessage_MemRes) IsGossipMessage_Content() {}
+func (*GossipMessage_Hello) isGossipMessage_Content() {}
 
-func (*GossipMessage_DataMsg) IsGossipMessage_Content() {}
+func (*GossipMessage_DataDig) isGossipMessage_Content() {}
 
-func (*GossipMessage_Hello) IsGossipMessage_Content() {}
+func (*GossipMessage_DataReq) isGossipMessage_Content() {}
 
-func (*GossipMessage_DataDig) IsGossipMessage_Content() {}
+func (*GossipMessage_DataUpdate) isGossipMessage_Content() {}
 
-func (*GossipMessage_DataReq) IsGossipMessage_Content() {}
+func (*GossipMessage_Empty) isGossipMessage_Content() {}
 
-func (*GossipMessage_DataUpdate) IsGossipMessage_Content() {}
+func (*GossipMessage_Conn) isGossipMessage_Content() {}
 
-func (*GossipMessage_Empty) IsGossipMessage_Content() {}
+func (*GossipMessage_StateInfo) isGossipMessage_Content() {}
 
-func (*GossipMessage_Conn) IsGossipMessage_Content() {}
+func (*GossipMessage_StateSnapshot) isGossipMessage_Content() {}
 
-func (*GossipMessage_StateInfo) IsGossipMessage_Content() {}
+func (*GossipMessage_StateInfoPullReq) isGossipMessage_Content() {}
 
-func (*GossipMessage_StateSnapshot) IsGossipMessage_Content() {}
+func (*GossipMessage_StateRequest) isGossipMessage_Content() {}
 
-func (*GossipMessage_StateInfoPullReq) IsGossipMessage_Content() {}
+func (*GossipMessage_StateResponse) isGossipMessage_Content() {}
 
-func (*GossipMessage_StateRequest) IsGossipMessage_Content() {}
+func (*GossipMessage_LeadershipMsg) isGossipMessage_Content() {}
 
-func (*GossipMessage_StateResponse) IsGossipMessage_Content() {}
+func (*GossipMessage_PeerIdentity) isGossipMessage_Content() {}
 
-func (*GossipMessage_LeadershipMsg) IsGossipMessage_Content() {}
+func (*GossipMessage_Ack) isGossipMessage_Content() {}
 
-func (*GossipMessage_PeerIdentity) IsGossipMessage_Content() {}
+func (*GossipMessage_PrivateReq) isGossipMessage_Content() {}
 
-func (*GossipMessage_Ack) IsGossipMessage_Content() {}
+func (*GossipMessage_PrivateRes) isGossipMessage_Content() {}
 
-func (*GossipMessage_PrivateReq) IsGossipMessage_Content() {}
+func (*GossipMessage_PrivateData) isGossipMessage_Content() {}
 
-func (*GossipMessage_PrivateRes) IsGossipMessage_Content() {}
+func (*GossipMessage_CollDataReq) isGossipMessage_Content() {}
 
-func (*GossipMessage_PrivateData) IsGossipMessage_Content() {}
+func (*GossipMessage_CollDataRes) isGossipMessage_Content() {}
 
-func (m *GossipMessage) GetContent() IsGossipMessage_Content {
+func (m *GossipMessage) GetContent() isGossipMessage_Content {
 	if m != nil {
 		return m.Content
 	}
@@ -674,6 +689,20 @@ func (m *GossipMessage) GetPrivateData() *PrivateDataMessage {
 	return nil
 }
 
+func (m *GossipMessage) GetCollDataReq() *RemoteCollDataRequest {
+	if x, ok := m.GetContent().(*GossipMessage_CollDataReq); ok {
+		return x.CollDataReq
+	}
+	return nil
+}
+
+func (m *GossipMessage) GetCollDataRes() *RemoteCollDataResponse {
+	if x, ok := m.GetContent().(*GossipMessage_CollDataRes); ok {
+		return x.CollDataRes
+	}
+	return nil
+}
+
 // XXX_OneofFuncs is for the internal use of the proto package.
 func (*GossipMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
 	return _GossipMessage_OneofMarshaler, _GossipMessage_OneofUnmarshaler, _GossipMessage_OneofSizer, []interface{}{
@@ -698,6 +727,8 @@ func (*GossipMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer)
 		(*GossipMessage_PrivateReq)(nil),
 		(*GossipMessage_PrivateRes)(nil),
 		(*GossipMessage_PrivateData)(nil),
+		(*GossipMessage_CollDataReq)(nil),
+		(*GossipMessage_CollDataRes)(nil),
 	}
 }
 
@@ -810,6 +841,16 @@ func _GossipMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
 		if err := b.EncodeMessage(x.PrivateData); err != nil {
 			return err
 		}
+	case *GossipMessage_CollDataReq:
+		b.EncodeVarint(90<<3 | proto.WireBytes)
+		if err := b.EncodeMessage(x.CollDataReq); err != nil {
+			return err
+		}
+	case *GossipMessage_CollDataRes:
+		b.EncodeVarint(91<<3 | proto.WireBytes)
+		if err := b.EncodeMessage(x.CollDataRes); err != nil {
+			return err
+		}
 	case nil:
 	default:
 		return fmt.Errorf("GossipMessage.Content has unexpected type %T", x)
@@ -988,6 +1029,22 @@ func _GossipMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.
 		err := b.DecodeMessage(msg)
 		m.Content = &GossipMessage_PrivateData{msg}
 		return true, err
+	case 90: // content.collDataReq
+		if wire != proto.WireBytes {
+			return true, proto.ErrInternalBadWireType
+		}
+		msg := new(RemoteCollDataRequest)
+		err := b.DecodeMessage(msg)
+		m.Content = &GossipMessage_CollDataReq{msg}
+		return true, err
+	case 91: // content.collDataRes
+		if wire != proto.WireBytes {
+			return true, proto.ErrInternalBadWireType
+		}
+		msg := new(RemoteCollDataResponse)
+		err := b.DecodeMessage(msg)
+		m.Content = &GossipMessage_CollDataRes{msg}
+		return true, err
 	default:
 		return false, nil
 	}
@@ -1102,6 +1159,16 @@ func _GossipMessage_OneofSizer(msg proto.Message) (n int) {
 		n += 2 // tag and wire
 		n += proto.SizeVarint(uint64(s))
 		n += s
+	case *GossipMessage_CollDataReq:
+		s := proto.Size(x.CollDataReq)
+		n += 2 // tag and wire
+		n += proto.SizeVarint(uint64(s))
+		n += s
+	case *GossipMessage_CollDataRes:
+		s := proto.Size(x.CollDataRes)
+		n += 2 // tag and wire
+		n += proto.SizeVarint(uint64(s))
+		n += s
 	case nil:
 	default:
 		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
@@ -1128,7 +1195,7 @@ func (m *StateInfo) Reset()         { *m = StateInfo{} }
 func (m *StateInfo) String() string { return proto.CompactTextString(m) }
 func (*StateInfo) ProtoMessage()    {}
 func (*StateInfo) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{4}
+	return fileDescriptor_message_563b77f4f682605d, []int{4}
 }
 func (m *StateInfo) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_StateInfo.Unmarshal(m, b)
@@ -1180,6 +1247,7 @@ type Properties struct {
 	LedgerHeight         uint64       `protobuf:"varint,1,opt,name=ledger_height,json=ledgerHeight,proto3" json:"ledger_height,omitempty"`
 	LeftChannel          bool         `protobuf:"varint,2,opt,name=left_channel,json=leftChannel,proto3" json:"left_channel,omitempty"`
 	Chaincodes           []*Chaincode `protobuf:"bytes,3,rep,name=chaincodes,proto3" json:"chaincodes,omitempty"`
+	Roles                []string     `protobuf:"bytes,99,rep,name=roles,proto3" json:"roles,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
 	XXX_unrecognized     []byte       `json:"-"`
 	XXX_sizecache        int32        `json:"-"`
@@ -1189,7 +1257,7 @@ func (m *Properties) Reset()         { *m = Properties{} }
 func (m *Properties) String() string { return proto.CompactTextString(m) }
 func (*Properties) ProtoMessage()    {}
 func (*Properties) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{5}
+	return fileDescriptor_message_563b77f4f682605d, []int{5}
 }
 func (m *Properties) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Properties.Unmarshal(m, b)
@@ -1230,6 +1298,13 @@ func (m *Properties) GetChaincodes() []*Chaincode {
 	return nil
 }
 
+func (m *Properties) GetRoles() []string {
+	if m != nil {
+		return m.Roles
+	}
+	return nil
+}
+
 // StateInfoSnapshot is an aggregation of StateInfo messages
 type StateInfoSnapshot struct {
 	Elements             []*Envelope `protobuf:"bytes,1,rep,name=elements,proto3" json:"elements,omitempty"`
@@ -1242,7 +1317,7 @@ func (m *StateInfoSnapshot) Reset()         { *m = StateInfoSnapshot{} }
 func (m *StateInfoSnapshot) String() string { return proto.CompactTextString(m) }
 func (*StateInfoSnapshot) ProtoMessage()    {}
 func (*StateInfoSnapshot) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{6}
+	return fileDescriptor_message_563b77f4f682605d, []int{6}
 }
 func (m *StateInfoSnapshot) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_StateInfoSnapshot.Unmarshal(m, b)
@@ -1285,7 +1360,7 @@ func (m *StateInfoPullRequest) Reset()         { *m = StateInfoPullRequest{} }
 func (m *StateInfoPullRequest) String() string { return proto.CompactTextString(m) }
 func (*StateInfoPullRequest) ProtoMessage()    {}
 func (*StateInfoPullRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{7}
+	return fileDescriptor_message_563b77f4f682605d, []int{7}
 }
 func (m *StateInfoPullRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_StateInfoPullRequest.Unmarshal(m, b)
@@ -1328,7 +1403,7 @@ func (m *ConnEstablish) Reset()         { *m = ConnEstablish{} }
 func (m *ConnEstablish) String() string { return proto.CompactTextString(m) }
 func (*ConnEstablish) ProtoMessage()    {}
 func (*ConnEstablish) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{8}
+	return fileDescriptor_message_563b77f4f682605d, []int{8}
 }
 func (m *ConnEstablish) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_ConnEstablish.Unmarshal(m, b)
@@ -1385,7 +1460,7 @@ func (m *PeerIdentity) Reset()         { *m = PeerIdentity{} }
 func (m *PeerIdentity) String() string { return proto.CompactTextString(m) }
 func (*PeerIdentity) ProtoMessage()    {}
 func (*PeerIdentity) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{9}
+	return fileDescriptor_message_563b77f4f682605d, []int{9}
 }
 func (m *PeerIdentity) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PeerIdentity.Unmarshal(m, b)
@@ -1441,7 +1516,7 @@ func (m *DataRequest) Reset()         { *m = DataRequest{} }
 func (m *DataRequest) String() string { return proto.CompactTextString(m) }
 func (*DataRequest) ProtoMessage()    {}
 func (*DataRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{10}
+	return fileDescriptor_message_563b77f4f682605d, []int{10}
 }
 func (m *DataRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_DataRequest.Unmarshal(m, b)
@@ -1497,7 +1572,7 @@ func (m *GossipHello) Reset()         { *m = GossipHello{} }
 func (m *GossipHello) String() string { return proto.CompactTextString(m) }
 func (*GossipHello) ProtoMessage()    {}
 func (*GossipHello) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{11}
+	return fileDescriptor_message_563b77f4f682605d, []int{11}
 }
 func (m *GossipHello) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_GossipHello.Unmarshal(m, b)
@@ -1553,7 +1628,7 @@ func (m *DataUpdate) Reset()         { *m = DataUpdate{} }
 func (m *DataUpdate) String() string { return proto.CompactTextString(m) }
 func (*DataUpdate) ProtoMessage()    {}
 func (*DataUpdate) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{12}
+	return fileDescriptor_message_563b77f4f682605d, []int{12}
 }
 func (m *DataUpdate) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_DataUpdate.Unmarshal(m, b)
@@ -1609,7 +1684,7 @@ func (m *DataDigest) Reset()         { *m = DataDigest{} }
 func (m *DataDigest) String() string { return proto.CompactTextString(m) }
 func (*DataDigest) ProtoMessage()    {}
 func (*DataDigest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{13}
+	return fileDescriptor_message_563b77f4f682605d, []int{13}
 }
 func (m *DataDigest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_DataDigest.Unmarshal(m, b)
@@ -1662,7 +1737,7 @@ func (m *DataMessage) Reset()         { *m = DataMessage{} }
 func (m *DataMessage) String() string { return proto.CompactTextString(m) }
 func (*DataMessage) ProtoMessage()    {}
 func (*DataMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{14}
+	return fileDescriptor_message_563b77f4f682605d, []int{14}
 }
 func (m *DataMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_DataMessage.Unmarshal(m, b)
@@ -1703,7 +1778,7 @@ func (m *PrivateDataMessage) Reset()         { *m = PrivateDataMessage{} }
 func (m *PrivateDataMessage) String() string { return proto.CompactTextString(m) }
 func (*PrivateDataMessage) ProtoMessage()    {}
 func (*PrivateDataMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{15}
+	return fileDescriptor_message_563b77f4f682605d, []int{15}
 }
 func (m *PrivateDataMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PrivateDataMessage.Unmarshal(m, b)
@@ -1744,7 +1819,7 @@ func (m *Payload) Reset()         { *m = Payload{} }
 func (m *Payload) String() string { return proto.CompactTextString(m) }
 func (*Payload) ProtoMessage()    {}
 func (*Payload) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{16}
+	return fileDescriptor_message_563b77f4f682605d, []int{16}
 }
 func (m *Payload) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Payload.Unmarshal(m, b)
@@ -1804,7 +1879,7 @@ func (m *PrivatePayload) Reset()         { *m = PrivatePayload{} }
 func (m *PrivatePayload) String() string { return proto.CompactTextString(m) }
 func (*PrivatePayload) ProtoMessage()    {}
 func (*PrivatePayload) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{17}
+	return fileDescriptor_message_563b77f4f682605d, []int{17}
 }
 func (m *PrivatePayload) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PrivatePayload.Unmarshal(m, b)
@@ -1881,7 +1956,7 @@ func (m *AliveMessage) Reset()         { *m = AliveMessage{} }
 func (m *AliveMessage) String() string { return proto.CompactTextString(m) }
 func (*AliveMessage) ProtoMessage()    {}
 func (*AliveMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{18}
+	return fileDescriptor_message_563b77f4f682605d, []int{18}
 }
 func (m *AliveMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_AliveMessage.Unmarshal(m, b)
@@ -1937,7 +2012,7 @@ func (m *LeadershipMessage) Reset()         { *m = LeadershipMessage{} }
 func (m *LeadershipMessage) String() string { return proto.CompactTextString(m) }
 func (*LeadershipMessage) ProtoMessage()    {}
 func (*LeadershipMessage) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{19}
+	return fileDescriptor_message_563b77f4f682605d, []int{19}
 }
 func (m *LeadershipMessage) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_LeadershipMessage.Unmarshal(m, b)
@@ -1991,7 +2066,7 @@ func (m *PeerTime) Reset()         { *m = PeerTime{} }
 func (m *PeerTime) String() string { return proto.CompactTextString(m) }
 func (*PeerTime) ProtoMessage()    {}
 func (*PeerTime) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{20}
+	return fileDescriptor_message_563b77f4f682605d, []int{20}
 }
 func (m *PeerTime) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PeerTime.Unmarshal(m, b)
@@ -2039,7 +2114,7 @@ func (m *MembershipRequest) Reset()         { *m = MembershipRequest{} }
 func (m *MembershipRequest) String() string { return proto.CompactTextString(m) }
 func (*MembershipRequest) ProtoMessage()    {}
 func (*MembershipRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{21}
+	return fileDescriptor_message_563b77f4f682605d, []int{21}
 }
 func (m *MembershipRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_MembershipRequest.Unmarshal(m, b)
@@ -2086,7 +2161,7 @@ func (m *MembershipResponse) Reset()         { *m = MembershipResponse{} }
 func (m *MembershipResponse) String() string { return proto.CompactTextString(m) }
 func (*MembershipResponse) ProtoMessage()    {}
 func (*MembershipResponse) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{22}
+	return fileDescriptor_message_563b77f4f682605d, []int{22}
 }
 func (m *MembershipResponse) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_MembershipResponse.Unmarshal(m, b)
@@ -2135,7 +2210,7 @@ func (m *Member) Reset()         { *m = Member{} }
 func (m *Member) String() string { return proto.CompactTextString(m) }
 func (*Member) ProtoMessage()    {}
 func (*Member) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{23}
+	return fileDescriptor_message_563b77f4f682605d, []int{23}
 }
 func (m *Member) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Member.Unmarshal(m, b)
@@ -2187,7 +2262,7 @@ func (m *Empty) Reset()         { *m = Empty{} }
 func (m *Empty) String() string { return proto.CompactTextString(m) }
 func (*Empty) ProtoMessage()    {}
 func (*Empty) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{24}
+	return fileDescriptor_message_563b77f4f682605d, []int{24}
 }
 func (m *Empty) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Empty.Unmarshal(m, b)
@@ -2221,7 +2296,7 @@ func (m *RemoteStateRequest) Reset()         { *m = RemoteStateRequest{} }
 func (m *RemoteStateRequest) String() string { return proto.CompactTextString(m) }
 func (*RemoteStateRequest) ProtoMessage()    {}
 func (*RemoteStateRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{25}
+	return fileDescriptor_message_563b77f4f682605d, []int{25}
 }
 func (m *RemoteStateRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemoteStateRequest.Unmarshal(m, b)
@@ -2268,7 +2343,7 @@ func (m *RemoteStateResponse) Reset()         { *m = RemoteStateResponse{} }
 func (m *RemoteStateResponse) String() string { return proto.CompactTextString(m) }
 func (*RemoteStateResponse) ProtoMessage()    {}
 func (*RemoteStateResponse) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{26}
+	return fileDescriptor_message_563b77f4f682605d, []int{26}
 }
 func (m *RemoteStateResponse) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemoteStateResponse.Unmarshal(m, b)
@@ -2308,7 +2383,7 @@ func (m *RemotePvtDataRequest) Reset()         { *m = RemotePvtDataRequest{} }
 func (m *RemotePvtDataRequest) String() string { return proto.CompactTextString(m) }
 func (*RemotePvtDataRequest) ProtoMessage()    {}
 func (*RemotePvtDataRequest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{27}
+	return fileDescriptor_message_563b77f4f682605d, []int{27}
 }
 func (m *RemotePvtDataRequest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemotePvtDataRequest.Unmarshal(m, b)
@@ -2351,7 +2426,7 @@ func (m *PvtDataDigest) Reset()         { *m = PvtDataDigest{} }
 func (m *PvtDataDigest) String() string { return proto.CompactTextString(m) }
 func (*PvtDataDigest) ProtoMessage()    {}
 func (*PvtDataDigest) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{28}
+	return fileDescriptor_message_563b77f4f682605d, []int{28}
 }
 func (m *PvtDataDigest) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PvtDataDigest.Unmarshal(m, b)
@@ -2419,7 +2494,7 @@ func (m *RemotePvtDataResponse) Reset()         { *m = RemotePvtDataResponse{} }
 func (m *RemotePvtDataResponse) String() string { return proto.CompactTextString(m) }
 func (*RemotePvtDataResponse) ProtoMessage()    {}
 func (*RemotePvtDataResponse) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{29}
+	return fileDescriptor_message_563b77f4f682605d, []int{29}
 }
 func (m *RemotePvtDataResponse) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_RemotePvtDataResponse.Unmarshal(m, b)
@@ -2459,7 +2534,7 @@ func (m *PvtDataElement) Reset()         { *m = PvtDataElement{} }
 func (m *PvtDataElement) String() string { return proto.CompactTextString(m) }
 func (*PvtDataElement) ProtoMessage()    {}
 func (*PvtDataElement) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{30}
+	return fileDescriptor_message_563b77f4f682605d, []int{30}
 }
 func (m *PvtDataElement) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PvtDataElement.Unmarshal(m, b)
@@ -2509,7 +2584,7 @@ func (m *PvtDataPayload) Reset()         { *m = PvtDataPayload{} }
 func (m *PvtDataPayload) String() string { return proto.CompactTextString(m) }
 func (*PvtDataPayload) ProtoMessage()    {}
 func (*PvtDataPayload) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{31}
+	return fileDescriptor_message_563b77f4f682605d, []int{31}
 }
 func (m *PvtDataPayload) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_PvtDataPayload.Unmarshal(m, b)
@@ -2554,7 +2629,7 @@ func (m *Acknowledgement) Reset()         { *m = Acknowledgement{} }
 func (m *Acknowledgement) String() string { return proto.CompactTextString(m) }
 func (*Acknowledgement) ProtoMessage()    {}
 func (*Acknowledgement) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{32}
+	return fileDescriptor_message_563b77f4f682605d, []int{32}
 }
 func (m *Acknowledgement) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Acknowledgement.Unmarshal(m, b)
@@ -2596,7 +2671,7 @@ func (m *Chaincode) Reset()         { *m = Chaincode{} }
 func (m *Chaincode) String() string { return proto.CompactTextString(m) }
 func (*Chaincode) ProtoMessage()    {}
 func (*Chaincode) Descriptor() ([]byte, []int) {
-	return fileDescriptor_message_7c42328ef5ef9997, []int{33}
+	return fileDescriptor_message_563b77f4f682605d, []int{33}
 }
 func (m *Chaincode) XXX_Unmarshal(b []byte) error {
 	return xxx_messageInfo_Chaincode.Unmarshal(m, b)
@@ -2637,6 +2712,283 @@ func (m *Chaincode) GetMetadata() []byte {
 	return nil
 }
 
+// ValidationResultsMessage is the message containing block validation results
+type ValidationResultsMessage struct {
+	SeqNum               uint64   `protobuf:"varint,1,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
+	TxFlags              []byte   `protobuf:"bytes,2,opt,name=txFlags,proto3" json:"txFlags,omitempty"`
+	Signature            []byte   `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
+	Identity             []byte   `protobuf:"bytes,4,opt,name=identity,proto3" json:"identity,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *ValidationResultsMessage) Reset()         { *m = ValidationResultsMessage{} }
+func (m *ValidationResultsMessage) String() string { return proto.CompactTextString(m) }
+func (*ValidationResultsMessage) ProtoMessage()    {}
+func (*ValidationResultsMessage) Descriptor() ([]byte, []int) {
+	return fileDescriptor_message_563b77f4f682605d, []int{34}
+}
+func (m *ValidationResultsMessage) XXX_Unmarshal(b []byte) error {
+	return xxx_messageInfo_ValidationResultsMessage.Unmarshal(m, b)
+}
+func (m *ValidationResultsMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	return xxx_messageInfo_ValidationResultsMessage.Marshal(b, m, deterministic)
+}
+func (dst *ValidationResultsMessage) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_ValidationResultsMessage.Merge(dst, src)
+}
+func (m *ValidationResultsMessage) XXX_Size() int {
+	return xxx_messageInfo_ValidationResultsMessage.Size(m)
+}
+func (m *ValidationResultsMessage) XXX_DiscardUnknown() {
+	xxx_messageInfo_ValidationResultsMessage.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_ValidationResultsMessage proto.InternalMessageInfo
+
+func (m *ValidationResultsMessage) GetSeqNum() uint64 {
+	if m != nil {
+		return m.SeqNum
+	}
+	return 0
+}
+
+func (m *ValidationResultsMessage) GetTxFlags() []byte {
+	if m != nil {
+		return m.TxFlags
+	}
+	return nil
+}
+
+func (m *ValidationResultsMessage) GetSignature() []byte {
+	if m != nil {
+		return m.Signature
+	}
+	return nil
+}
+
+func (m *ValidationResultsMessage) GetIdentity() []byte {
+	if m != nil {
+		return m.Identity
+	}
+	return nil
+}
+
+// RemoteCollDataRequest message used to request
+// collection data
+type RemoteCollDataRequest struct {
+	Nonce                uint64            `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
+	Digests              []*CollDataDigest `protobuf:"bytes,2,rep,name=digests,proto3" json:"digests,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
+	XXX_unrecognized     []byte            `json:"-"`
+	XXX_sizecache        int32             `json:"-"`
+}
+
+func (m *RemoteCollDataRequest) Reset()         { *m = RemoteCollDataRequest{} }
+func (m *RemoteCollDataRequest) String() string { return proto.CompactTextString(m) }
+func (*RemoteCollDataRequest) ProtoMessage()    {}
+func (*RemoteCollDataRequest) Descriptor() ([]byte, []int) {
+	return fileDescriptor_message_563b77f4f682605d, []int{35}
+}
+func (m *RemoteCollDataRequest) XXX_Unmarshal(b []byte) error {
+	return xxx_messageInfo_RemoteCollDataRequest.Unmarshal(m, b)
+}
+func (m *RemoteCollDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	return xxx_messageInfo_RemoteCollDataRequest.Marshal(b, m, deterministic)
+}
+func (dst *RemoteCollDataRequest) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_RemoteCollDataRequest.Merge(dst, src)
+}
+func (m *RemoteCollDataRequest) XXX_Size() int {
+	return xxx_messageInfo_RemoteCollDataRequest.Size(m)
+}
+func (m *RemoteCollDataRequest) XXX_DiscardUnknown() {
+	xxx_messageInfo_RemoteCollDataRequest.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_RemoteCollDataRequest proto.InternalMessageInfo
+
+func (m *RemoteCollDataRequest) GetNonce() uint64 {
+	if m != nil {
+		return m.Nonce
+	}
+	return 0
+}
+
+func (m *RemoteCollDataRequest) GetDigests() []*CollDataDigest {
+	if m != nil {
+		return m.Digests
+	}
+	return nil
+}
+
+// CollDataDigest defines a digest of collection data
+type CollDataDigest struct {
+	Namespace            string   `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
+	Collection           string   `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection,omitempty"`
+	Key                  string   `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
+	EndorsedAtTxID       string   `protobuf:"bytes,4,opt,name=endorsedAtTxID,proto3" json:"endorsedAtTxID,omitempty"`
+	XXX_NoUnkeyedLiteral struct{} `json:"-"`
+	XXX_unrecognized     []byte   `json:"-"`
+	XXX_sizecache        int32    `json:"-"`
+}
+
+func (m *CollDataDigest) Reset()         { *m = CollDataDigest{} }
+func (m *CollDataDigest) String() string { return proto.CompactTextString(m) }
+func (*CollDataDigest) ProtoMessage()    {}
+func (*CollDataDigest) Descriptor() ([]byte, []int) {
+	return fileDescriptor_message_563b77f4f682605d, []int{36}
+}
+func (m *CollDataDigest) XXX_Unmarshal(b []byte) error {
+	return xxx_messageInfo_CollDataDigest.Unmarshal(m, b)
+}
+func (m *CollDataDigest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	return xxx_messageInfo_CollDataDigest.Marshal(b, m, deterministic)
+}
+func (dst *CollDataDigest) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_CollDataDigest.Merge(dst, src)
+}
+func (m *CollDataDigest) XXX_Size() int {
+	return xxx_messageInfo_CollDataDigest.Size(m)
+}
+func (m *CollDataDigest) XXX_DiscardUnknown() {
+	xxx_messageInfo_CollDataDigest.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_CollDataDigest proto.InternalMessageInfo
+
+func (m *CollDataDigest) GetNamespace() string {
+	if m != nil {
+		return m.Namespace
+	}
+	return ""
+}
+
+func (m *CollDataDigest) GetCollection() string {
+	if m != nil {
+		return m.Collection
+	}
+	return ""
+}
+
+func (m *CollDataDigest) GetKey() string {
+	if m != nil {
+		return m.Key
+	}
+	return ""
+}
+
+func (m *CollDataDigest) GetEndorsedAtTxID() string {
+	if m != nil {
+		return m.EndorsedAtTxID
+	}
+	return ""
+}
+
+// RemoteCollDataResponse message used to respond to
+// collection data request
+type RemoteCollDataResponse struct {
+	Nonce                uint64             `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
+	Elements             []*CollDataElement `protobuf:"bytes,2,rep,name=elements,proto3" json:"elements,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
+	XXX_unrecognized     []byte             `json:"-"`
+	XXX_sizecache        int32              `json:"-"`
+}
+
+func (m *RemoteCollDataResponse) Reset()         { *m = RemoteCollDataResponse{} }
+func (m *RemoteCollDataResponse) String() string { return proto.CompactTextString(m) }
+func (*RemoteCollDataResponse) ProtoMessage()    {}
+func (*RemoteCollDataResponse) Descriptor() ([]byte, []int) {
+	return fileDescriptor_message_563b77f4f682605d, []int{37}
+}
+func (m *RemoteCollDataResponse) XXX_Unmarshal(b []byte) error {
+	return xxx_messageInfo_RemoteCollDataResponse.Unmarshal(m, b)
+}
+func (m *RemoteCollDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	return xxx_messageInfo_RemoteCollDataResponse.Marshal(b, m, deterministic)
+}
+func (dst *RemoteCollDataResponse) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_RemoteCollDataResponse.Merge(dst, src)
+}
+func (m *RemoteCollDataResponse) XXX_Size() int {
+	return xxx_messageInfo_RemoteCollDataResponse.Size(m)
+}
+func (m *RemoteCollDataResponse) XXX_DiscardUnknown() {
+	xxx_messageInfo_RemoteCollDataResponse.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_RemoteCollDataResponse proto.InternalMessageInfo
+
+func (m *RemoteCollDataResponse) GetNonce() uint64 {
+	if m != nil {
+		return m.Nonce
+	}
+	return 0
+}
+
+func (m *RemoteCollDataResponse) GetElements() []*CollDataElement {
+	if m != nil {
+		return m.Elements
+	}
+	return nil
+}
+
+// CollDataElement contains the collection data digest and value
+type CollDataElement struct {
+	Digest               *CollDataDigest      `protobuf:"bytes,1,opt,name=digest,proto3" json:"digest,omitempty"`
+	Value                []byte               `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
+	ExpiryTime           *timestamp.Timestamp `protobuf:"bytes,3,opt,name=expiryTime,proto3" json:"expiryTime,omitempty"`
+	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
+	XXX_unrecognized     []byte               `json:"-"`
+	XXX_sizecache        int32                `json:"-"`
+}
+
+func (m *CollDataElement) Reset()         { *m = CollDataElement{} }
+func (m *CollDataElement) String() string { return proto.CompactTextString(m) }
+func (*CollDataElement) ProtoMessage()    {}
+func (*CollDataElement) Descriptor() ([]byte, []int) {
+	return fileDescriptor_message_563b77f4f682605d, []int{38}
+}
+func (m *CollDataElement) XXX_Unmarshal(b []byte) error {
+	return xxx_messageInfo_CollDataElement.Unmarshal(m, b)
+}
+func (m *CollDataElement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
+	return xxx_messageInfo_CollDataElement.Marshal(b, m, deterministic)
+}
+func (dst *CollDataElement) XXX_Merge(src proto.Message) {
+	xxx_messageInfo_CollDataElement.Merge(dst, src)
+}
+func (m *CollDataElement) XXX_Size() int {
+	return xxx_messageInfo_CollDataElement.Size(m)
+}
+func (m *CollDataElement) XXX_DiscardUnknown() {
+	xxx_messageInfo_CollDataElement.DiscardUnknown(m)
+}
+
+var xxx_messageInfo_CollDataElement proto.InternalMessageInfo
+
+func (m *CollDataElement) GetDigest() *CollDataDigest {
+	if m != nil {
+		return m.Digest
+	}
+	return nil
+}
+
+func (m *CollDataElement) GetValue() []byte {
+	if m != nil {
+		return m.Value
+	}
+	return nil
+}
+
+func (m *CollDataElement) GetExpiryTime() *timestamp.Timestamp {
+	if m != nil {
+		return m.ExpiryTime
+	}
+	return nil
+}
+
 func init() {
 	proto.RegisterType((*Envelope)(nil), "gossip.Envelope")
 	proto.RegisterType((*SecretEnvelope)(nil), "gossip.SecretEnvelope")
@@ -2672,6 +3024,11 @@ func init() {
 	proto.RegisterType((*PvtDataPayload)(nil), "gossip.PvtDataPayload")
 	proto.RegisterType((*Acknowledgement)(nil), "gossip.Acknowledgement")
 	proto.RegisterType((*Chaincode)(nil), "gossip.Chaincode")
+	proto.RegisterType((*ValidationResultsMessage)(nil), "gossip.ValidationResultsMessage")
+	proto.RegisterType((*RemoteCollDataRequest)(nil), "gossip.RemoteCollDataRequest")
+	proto.RegisterType((*CollDataDigest)(nil), "gossip.CollDataDigest")
+	proto.RegisterType((*RemoteCollDataResponse)(nil), "gossip.RemoteCollDataResponse")
+	proto.RegisterType((*CollDataElement)(nil), "gossip.CollDataElement")
 	proto.RegisterEnum("gossip.PullMsgType", PullMsgType_name, PullMsgType_value)
 	proto.RegisterEnum("gossip.GossipMessage_Tag", GossipMessage_Tag_name, GossipMessage_Tag_value)
 }
@@ -2818,126 +3175,141 @@ var _Gossip_serviceDesc = grpc.ServiceDesc{
 	Metadata: "gossip/message.proto",
 }
 
-func init() { proto.RegisterFile("gossip/message.proto", fileDescriptor_message_7c42328ef5ef9997) }
-
-var fileDescriptor_message_7c42328ef5ef9997 = []byte{
-	// 1874 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x5b, 0x6f, 0xe3, 0xc6,
-	0x15, 0x16, 0x6d, 0x5d, 0x8f, 0x2e, 0x96, 0xc7, 0xde, 0x5d, 0xc6, 0x49, 0x13, 0x87, 0xed, 0x26,
-	0xdb, 0x7a, 0x23, 0x6f, 0x9d, 0x16, 0x0d, 0x90, 0xb6, 0x0b, 0x5b, 0x52, 0x2c, 0x21, 0x2b, 0xad,
-	0x4b, 0x7b, 0xd1, 0xba, 0x2f, 0xc4, 0x98, 0x1c, 0x53, 0xac, 0xc9, 0x21, 0xcd, 0x19, 0x3b, 0xf6,
-	0x63, 0xd1, 0x87, 0x00, 0x7d, 0xe9, 0x6f, 0xe8, 0x53, 0xff, 0x66, 0x31, 0x33, 0xbc, 0x4a, 0xf6,
-	0x02, 0x1b, 0x20, 0x6f, 0x3c, 0xf7, 0x99, 0x33, 0x67, 0xbe, 0x73, 0x86, 0xb0, 0xed, 0x86, 0x8c,
-	0x79, 0xd1, 0x7e, 0x40, 0x18, 0xc3, 0x2e, 0x19, 0x44, 0x71, 0xc8, 0x43, 0x54, 0x57, 0xdc, 0x9d,
-	0x67, 0x76, 0x18, 0x04, 0x21, 0xdd, 0xb7, 0x43, 0xdf, 0x27, 0x36, 0xf7, 0x42, 0xaa, 0x14, 0x8c,
-	0x7f, 0x69, 0xd0, 0x1c, 0xd3, 0x5b, 0xe2, 0x87, 0x11, 0x41, 0x3a, 0x34, 0x22, 0x7c, 0xef, 0x87,
-	0xd8, 0xd1, 0xb5, 0x5d, 0xed, 0x45, 0xc7, 0x4c, 0x49, 0xf4, 0x09, 0xb4, 0x98, 0xe7, 0x52, 0xcc,
-	0x6f, 0x62, 0xa2, 0xaf, 0x49, 0x59, 0xce, 0x40, 0xaf, 0x61, 0x83, 0x11, 0x3b, 0x26, 0xdc, 0x22,
-	0x89, 0x2b, 0x7d, 0x7d, 0x57, 0x7b, 0xd1, 0x3e, 0x78, 0x3a, 0x50, 0xf1, 0x07, 0xa7, 0x52, 0x9c,
-	0x06, 0x32, 0x7b, 0xac, 0x44, 0x1b, 0x13, 0xe8, 0x95, 0x35, 0x7e, 0xea, 0x52, 0x8c, 0x43, 0xa8,
-	0x2b, 0x4f, 0xe8, 0x25, 0xf4, 0x3d, 0xca, 0x49, 0x4c, 0xb1, 0x3f, 0xa6, 0x4e, 0x14, 0x7a, 0x94,
-	0x4b, 0x57, 0xad, 0x49, 0xc5, 0x5c, 0x91, 0x1c, 0xb5, 0xa0, 0x61, 0x87, 0x94, 0x13, 0xca, 0x8d,
-	0x1f, 0xdb, 0xd0, 0x3d, 0x96, 0xcb, 0x9e, 0xa9, 0x5c, 0xa2, 0x6d, 0xa8, 0xd1, 0x90, 0xda, 0x44,
-	0xda, 0x57, 0x4d, 0x45, 0x88, 0x25, 0xda, 0x0b, 0x4c, 0x29, 0xf1, 0x93, 0x65, 0xa4, 0x24, 0xda,
-	0x83, 0x75, 0x8e, 0x5d, 0x99, 0x83, 0xde, 0xc1, 0x47, 0x69, 0x0e, 0x4a, 0x3e, 0x07, 0x67, 0xd8,
-	0x35, 0x85, 0x16, 0xfa, 0x1a, 0x5a, 0xd8, 0xf7, 0x6e, 0x89, 0x15, 0x30, 0x57, 0xaf, 0xc9, 0xb4,
-	0x6d, 0xa7, 0x26, 0x87, 0x42, 0x90, 0x58, 0x4c, 0x2a, 0x66, 0x53, 0x2a, 0xce, 0x98, 0x8b, 0x7e,
-	0x07, 0x8d, 0x80, 0x04, 0x56, 0x4c, 0xae, 0xf5, 0xba, 0x34, 0xc9, 0xa2, 0xcc, 0x48, 0x70, 0x41,
-	0x62, 0xb6, 0xf0, 0x22, 0x93, 0x5c, 0xdf, 0x10, 0xc6, 0x27, 0x15, 0xb3, 0x1e, 0x90, 0xc0, 0x24,
-	0xd7, 0xe8, 0xf7, 0xa9, 0x15, 0xd3, 0x1b, 0xd2, 0x6a, 0xe7, 0x21, 0x2b, 0x16, 0x85, 0x94, 0x91,
-	0xcc, 0x8c, 0xa1, 0x57, 0xd0, 0x74, 0x30, 0xc7, 0x72, 0x81, 0x4d, 0x69, 0xb7, 0x95, 0xda, 0x8d,
-	0x30, 0xc7, 0xf9, 0xfa, 0x1a, 0x42, 0x4d, 0x2c, 0x6f, 0x0f, 0x6a, 0x0b, 0xe2, 0xfb, 0xa1, 0xde,
-	0x2a, 0xab, 0xab, 0x14, 0x4c, 0x84, 0x68, 0x52, 0x31, 0x95, 0x0e, 0xda, 0x4f, 0xdc, 0x3b, 0x9e,
-	0xab, 0x83, 0xd4, 0x47, 0x45, 0xf7, 0x23, 0xcf, 0x55, 0xbb, 0x90, 0xde, 0x47, 0x9e, 0x9b, 0xad,
-	0x47, 0xec, 0xbe, 0xbd, 0xba, 0x9e, 0x7c, 0xdf, 0xd2, 0x42, 0x6d, 0xbc, 0x2d, 0x2d, 0x6e, 0x22,
-	0x07, 0x73, 0xa2, 0x77, 0x56, 0xa3, 0xbc, 0x93, 0x92, 0x49, 0xc5, 0x04, 0x27, 0xa3, 0xd0, 0x73,
-	0xa8, 0x91, 0x20, 0xe2, 0xf7, 0x7a, 0x57, 0x1a, 0x74, 0x53, 0x83, 0xb1, 0x60, 0x8a, 0x0d, 0x48,
-	0x29, 0xda, 0x83, 0xaa, 0x1d, 0x52, 0xaa, 0xf7, 0xa4, 0xd6, 0x93, 0x54, 0x6b, 0x18, 0x52, 0x3a,
-	0x66, 0x1c, 0x5f, 0xf8, 0x1e, 0x5b, 0x4c, 0x2a, 0xa6, 0x54, 0x42, 0x07, 0x00, 0x8c, 0x63, 0x4e,
-	0x2c, 0x8f, 0x5e, 0x86, 0xfa, 0x86, 0x34, 0xd9, 0xcc, 0xae, 0x89, 0x90, 0x4c, 0xe9, 0xa5, 0xc8,
-	0x4e, 0x8b, 0xa5, 0x04, 0x3a, 0x82, 0x9e, 0xb2, 0x61, 0x14, 0x47, 0x6c, 0x11, 0x72, 0xbd, 0x5f,
-	0x3e, 0xf4, 0xcc, 0xee, 0x34, 0x51, 0x98, 0x54, 0xcc, 0xae, 0x34, 0x49, 0x19, 0x68, 0x06, 0x5b,
-	0x79, 0x5c, 0x2b, 0xba, 0xf1, 0x7d, 0x99, 0xbf, 0x4d, 0xe9, 0xe8, 0x93, 0x15, 0x47, 0x27, 0x37,
-	0xbe, 0x9f, 0x27, 0xb2, 0xcf, 0x96, 0xf8, 0xe8, 0x10, 0x94, 0x7f, 0xe1, 0x44, 0x28, 0xe9, 0xa8,
-	0x5c, 0x50, 0x26, 0x09, 0x42, 0x4e, 0xa4, 0xbb, 0xdc, 0x4d, 0x87, 0x15, 0x68, 0x34, 0x4a, 0x77,
-	0x15, 0x27, 0x25, 0xa7, 0x6f, 0x49, 0x1f, 0x1f, 0x3f, 0xe8, 0x23, 0xab, 0xca, 0x2e, 0x2b, 0x32,
-	0x44, 0x6e, 0x7c, 0x82, 0x1d, 0x55, 0xbc, 0xb2, 0x44, 0xb7, 0xcb, 0xb9, 0x79, 0x93, 0x49, 0xf3,
-	0x42, 0xed, 0xe6, 0x26, 0xa2, 0x5c, 0xbf, 0x85, 0x6e, 0x44, 0x48, 0x6c, 0x79, 0x0e, 0xa1, 0xdc,
-	0xe3, 0xf7, 0xfa, 0x93, 0xf2, 0x35, 0x3c, 0x21, 0x24, 0x9e, 0x26, 0x32, 0xb1, 0x8d, 0xa8, 0x40,
-	0x8b, 0xcb, 0x8e, 0xed, 0x2b, 0xfd, 0xa9, 0x34, 0x79, 0x96, 0xdd, 0x5c, 0xfb, 0x8a, 0x86, 0x3f,
-	0xf8, 0xc4, 0x71, 0x49, 0x40, 0xa8, 0xd8, 0xbc, 0xd0, 0x42, 0x7f, 0x06, 0x88, 0x62, 0xef, 0x56,
-	0x65, 0x41, 0x7f, 0x56, 0x4e, 0xbe, 0xda, 0xef, 0xc9, 0x2d, 0x2f, 0x57, 0x71, 0xc1, 0x02, 0xbd,
-	0x2e, 0xd8, 0x33, 0x5d, 0x97, 0xf6, 0xbf, 0x78, 0xc4, 0x3e, 0xcb, 0x58, 0xc1, 0x04, 0xbd, 0x86,
-	0x4e, 0x42, 0x59, 0xa2, 0xd0, 0xf5, 0x8f, 0xca, 0xc7, 0x76, 0xa2, 0x64, 0xe5, 0x6b, 0xdd, 0x8e,
-	0x72, 0xae, 0x61, 0xc1, 0xfa, 0x19, 0x76, 0x51, 0x17, 0x5a, 0xef, 0xe6, 0xa3, 0xf1, 0x77, 0xd3,
-	0xf9, 0x78, 0xd4, 0xaf, 0xa0, 0x16, 0xd4, 0xc6, 0xb3, 0x93, 0xb3, 0xf3, 0xbe, 0x86, 0x3a, 0xd0,
-	0x7c, 0x6b, 0x1e, 0x5b, 0x6f, 0xe7, 0x6f, 0xce, 0xfb, 0x6b, 0x42, 0x6f, 0x38, 0x39, 0x9c, 0x2b,
-	0x72, 0x1d, 0xf5, 0xa1, 0x23, 0xc9, 0xc3, 0xf9, 0xc8, 0x7a, 0x6b, 0x1e, 0xf7, 0xab, 0x68, 0x03,
-	0xda, 0x4a, 0xc1, 0x94, 0x8c, 0x5a, 0x11, 0x89, 0xff, 0xa7, 0x41, 0x2b, 0xab, 0x48, 0x34, 0x80,
-	0x16, 0xf7, 0x02, 0xc2, 0x38, 0x0e, 0x22, 0x89, 0xb8, 0xed, 0x83, 0x7e, 0xf1, 0x84, 0xce, 0xbc,
-	0x80, 0x98, 0xb9, 0x0a, 0x7a, 0x02, 0xf5, 0xe8, 0xca, 0xb3, 0x3c, 0x47, 0x02, 0x71, 0xc7, 0xac,
-	0x45, 0x57, 0xde, 0xd4, 0x41, 0x9f, 0x41, 0x3b, 0xc1, 0x69, 0x6b, 0x76, 0x38, 0xd4, 0xab, 0x52,
-	0x06, 0x09, 0x6b, 0x76, 0x38, 0x14, 0x37, 0x34, 0x8a, 0xc3, 0x88, 0xc4, 0xdc, 0x23, 0x2c, 0x41,
-	0x64, 0x94, 0x27, 0x28, 0x95, 0x98, 0x05, 0x2d, 0xe3, 0x47, 0x0d, 0x20, 0x17, 0xa1, 0x5f, 0x42,
-	0x57, 0x1e, 0x7d, 0x6c, 0x2d, 0x88, 0xe7, 0x2e, 0x78, 0xd2, 0x38, 0x3a, 0x8a, 0x39, 0x91, 0x3c,
-	0xf4, 0x39, 0x74, 0x7c, 0x72, 0xc9, 0xad, 0x62, 0x13, 0x69, 0x9a, 0x6d, 0xc1, 0x1b, 0x26, 0x8d,
-	0xe4, 0xb7, 0x20, 0x16, 0xe6, 0x51, 0x3b, 0x74, 0x08, 0xd3, 0xd7, 0x77, 0xd7, 0x8b, 0x60, 0x31,
-	0x4c, 0x25, 0x66, 0x41, 0xc9, 0x38, 0x84, 0xcd, 0x15, 0x34, 0x40, 0x2f, 0xa1, 0x49, 0x7c, 0x59,
-	0x88, 0x4c, 0xd7, 0xa4, 0x97, 0x2c, 0x73, 0x59, 0x4f, 0xce, 0x34, 0x8c, 0x3f, 0xc0, 0xf6, 0x43,
-	0x38, 0xb0, 0x9c, 0x39, 0x6d, 0x39, 0x73, 0xc6, 0x25, 0x74, 0x4b, 0xa0, 0x57, 0x38, 0x02, 0xad,
-	0x78, 0x04, 0x3b, 0xd0, 0xcc, 0xae, 0x9a, 0x6a, 0x9d, 0x19, 0x8d, 0x0c, 0xe8, 0x72, 0x9f, 0x59,
-	0x36, 0x89, 0xb9, 0xb5, 0xc0, 0x6c, 0x91, 0x1c, 0x5e, 0x9b, 0xfb, 0x6c, 0x48, 0x62, 0x3e, 0xc1,
-	0x6c, 0x61, 0xbc, 0x83, 0x4e, 0xf1, 0x4a, 0x3e, 0x16, 0x06, 0x41, 0x55, 0xb8, 0x49, 0x42, 0xc8,
-	0x6f, 0x11, 0x3a, 0x20, 0x1c, 0xcb, 0xda, 0x57, 0x9e, 0x33, 0xda, 0x08, 0xa0, 0x5d, 0xb8, 0x79,
-	0x8f, 0x77, 0x7d, 0x47, 0x76, 0x24, 0xa6, 0xaf, 0xed, 0xae, 0x8b, 0xae, 0x9f, 0x90, 0x68, 0x00,
-	0xcd, 0x80, 0xb9, 0x16, 0xbf, 0x4f, 0xc6, 0x9f, 0x5e, 0xde, 0x96, 0x44, 0x16, 0x67, 0xcc, 0x3d,
-	0xbb, 0x8f, 0x88, 0xd9, 0x08, 0xd4, 0x87, 0x11, 0x42, 0xbb, 0xd0, 0x0f, 0x1f, 0x09, 0x57, 0x5c,
-	0xef, 0x5a, 0x79, 0xbd, 0x1f, 0x1c, 0xf0, 0x0e, 0x20, 0x6f, 0x75, 0x8f, 0xc4, 0xfb, 0x15, 0x54,
-	0x93, 0x58, 0x0f, 0x57, 0x49, 0xf5, 0x27, 0x45, 0xf6, 0x55, 0x64, 0xd5, 0xca, 0x7f, 0xf6, 0xc4,
-	0x7e, 0xa3, 0xce, 0x31, 0x9d, 0xde, 0x7e, 0x5d, 0x1e, 0x25, 0xdb, 0x07, 0x1b, 0x99, 0xb5, 0x62,
-	0x67, 0xb3, 0xa5, 0xf1, 0x1d, 0xa0, 0x55, 0x04, 0x44, 0xaf, 0x96, 0x1d, 0x3c, 0x5d, 0x82, 0xcb,
-	0x15, 0x3f, 0xe7, 0xd0, 0x48, 0x78, 0xe8, 0x19, 0x34, 0x18, 0xb9, 0xb6, 0xe8, 0x4d, 0x90, 0x6c,
-	0xb7, 0xce, 0xc8, 0xf5, 0xfc, 0x26, 0x10, 0xd5, 0x59, 0x38, 0x55, 0x95, 0xd7, 0xcf, 0x97, 0xd0,
-	0x79, 0x5d, 0x26, 0xa2, 0x84, 0xbf, 0xff, 0x59, 0x83, 0x5e, 0x39, 0x2c, 0xfa, 0x12, 0x36, 0xf2,
-	0xb9, 0xde, 0xa2, 0x38, 0x50, 0x99, 0x6d, 0x99, 0xbd, 0x9c, 0x3d, 0xc7, 0x01, 0x11, 0xa3, 0xb3,
-	0x90, 0xb2, 0x08, 0xdb, 0x6a, 0x74, 0x6e, 0x99, 0x39, 0x03, 0x6d, 0x41, 0x8d, 0xdf, 0xa5, 0x70,
-	0xd9, 0x32, 0xab, 0xfc, 0x6e, 0xea, 0x08, 0x24, 0x4b, 0x57, 0x14, 0xff, 0xc0, 0x08, 0x4f, 0xf0,
-	0x32, 0x5d, 0xa6, 0x29, 0x78, 0xe8, 0x25, 0xa0, 0x54, 0x89, 0x79, 0x41, 0x8a, 0x79, 0x35, 0xb9,
-	0xdd, 0x7e, 0x22, 0x39, 0xf5, 0x82, 0x04, 0xf7, 0xe6, 0x80, 0x0a, 0xcb, 0xb5, 0x43, 0x7a, 0xe9,
-	0xb9, 0x2c, 0x19, 0x63, 0x3f, 0x1b, 0xa8, 0x87, 0xca, 0x60, 0x98, 0x69, 0x0c, 0xa5, 0xc2, 0x09,
-	0xb6, 0xaf, 0xb0, 0x4b, 0xcc, 0x4d, 0x7b, 0x49, 0xc0, 0x8c, 0x7f, 0x6b, 0xd0, 0x29, 0x0e, 0xca,
-	0x68, 0x00, 0x10, 0x64, 0xf3, 0x6c, 0x72, 0x64, 0xbd, 0xf2, 0xa4, 0x6b, 0x16, 0x34, 0x3e, 0xb8,
-	0xb1, 0x14, 0xe1, 0xab, 0x5a, 0x86, 0x2f, 0xe3, 0x9f, 0x1a, 0x6c, 0xae, 0x4c, 0x1c, 0x8f, 0x01,
-	0xd4, 0x87, 0x06, 0x7e, 0x0e, 0x3d, 0x8f, 0x59, 0x0e, 0xb1, 0x7d, 0x1c, 0x63, 0x91, 0x02, 0x79,
-	0x54, 0x4d, 0xb3, 0xeb, 0xb1, 0x51, 0xce, 0x34, 0xfe, 0x08, 0xcd, 0xd4, 0x5a, 0x94, 0x9f, 0x47,
-	0xed, 0x62, 0xf9, 0x79, 0xd4, 0x16, 0xe5, 0x57, 0xa8, 0xcb, 0xb5, 0x62, 0x5d, 0x1a, 0x97, 0xb0,
-	0xb9, 0xf2, 0x86, 0x40, 0xdf, 0x42, 0x9f, 0x11, 0xff, 0x52, 0x0e, 0x8f, 0x71, 0xa0, 0x62, 0x6b,
-	0xe5, 0x05, 0x67, 0x10, 0xb1, 0x21, 0x34, 0xa7, 0xb9, 0xa2, 0xb8, 0xef, 0x62, 0x18, 0xa2, 0xc9,
-	0xbd, 0x56, 0x84, 0x71, 0x01, 0x68, 0xf5, 0xd5, 0x81, 0xbe, 0x80, 0x9a, 0x7c, 0xe4, 0x3c, 0xda,
-	0xa6, 0x94, 0x58, 0xe2, 0x14, 0xc1, 0xce, 0x7b, 0x70, 0x8a, 0x60, 0xc7, 0xf8, 0x2b, 0xd4, 0x55,
-	0x0c, 0x71, 0x66, 0xa4, 0xf4, 0x0a, 0x34, 0x33, 0xfa, 0xbd, 0x18, 0xfb, 0xf0, 0x10, 0x61, 0x34,
-	0xa0, 0x26, 0x1f, 0x01, 0xc6, 0xdf, 0x00, 0xad, 0x8e, 0xba, 0xa2, 0x89, 0x31, 0x8e, 0x63, 0x6e,
-	0x95, 0xaf, 0x7e, 0x5b, 0x32, 0x4f, 0xd5, 0xfd, 0xff, 0x14, 0xda, 0x84, 0x3a, 0x56, 0xf9, 0x10,
-	0x5a, 0x84, 0x3a, 0x4a, 0x6e, 0x1c, 0xc1, 0xd6, 0x03, 0x03, 0x30, 0xda, 0x83, 0x66, 0x82, 0x32,
-	0x69, 0x2b, 0x5f, 0x81, 0xb3, 0x4c, 0xc1, 0x38, 0x86, 0xed, 0x87, 0x86, 0x4a, 0xb4, 0x9f, 0x63,
-	0xad, 0xf2, 0x91, 0x3d, 0x5a, 0x12, 0x45, 0x85, 0xd4, 0x19, 0x04, 0x1b, 0xff, 0xd5, 0xa0, 0x5b,
-	0x12, 0xe5, 0x68, 0xa1, 0x15, 0xd0, 0xe2, 0xfd, 0x00, 0xf3, 0x29, 0x40, 0x7e, 0x7b, 0x13, 0x94,
-	0x29, 0x70, 0xd0, 0xc7, 0xd0, 0xba, 0xf0, 0x43, 0xfb, 0x4a, 0xe4, 0x44, 0x5e, 0xac, 0xaa, 0xd9,
-	0x94, 0x8c, 0x53, 0x72, 0x8d, 0x76, 0xa1, 0x23, 0x52, 0xe5, 0x51, 0x4b, 0xb2, 0x12, 0x74, 0x01,
-	0x46, 0xae, 0xa7, 0xf4, 0x48, 0x70, 0x8c, 0xef, 0xe1, 0xc9, 0x83, 0x13, 0x30, 0x3a, 0x58, 0x99,
-	0x7e, 0x9e, 0x2e, 0x6d, 0x77, 0xac, 0xc4, 0x85, 0x19, 0xe8, 0x1c, 0x7a, 0x65, 0x19, 0xfa, 0x0a,
-	0xea, 0x2a, 0x1b, 0x49, 0xe1, 0x3f, 0x92, 0xb2, 0x44, 0xa9, 0xf8, 0x03, 0x23, 0x69, 0x67, 0x69,
-	0x73, 0xf8, 0x4b, 0xe6, 0x3a, 0x05, 0xf0, 0xe7, 0xb0, 0xc1, 0xef, 0xac, 0xd2, 0xf6, 0x92, 0x81,
-	0x91, 0xdf, 0x9d, 0x66, 0x1b, 0x2c, 0xbb, 0x2c, 0xfe, 0x13, 0x31, 0xbe, 0x84, 0x8d, 0xa5, 0x07,
-	0x87, 0xb8, 0x74, 0x24, 0x8e, 0xc3, 0x38, 0x39, 0x1f, 0x45, 0x18, 0xef, 0xa0, 0x95, 0x8d, 0x8d,
-	0xa2, 0x03, 0x15, 0x9a, 0x85, 0xfc, 0x16, 0x31, 0x6e, 0x49, 0xcc, 0xc4, 0x01, 0xa9, 0xf3, 0x4b,
-	0xc9, 0xf7, 0x4d, 0x4e, 0xbf, 0xf9, 0x13, 0xb4, 0x0b, 0x9d, 0x78, 0xf9, 0x71, 0xd0, 0x85, 0xd6,
-	0xd1, 0x9b, 0xb7, 0xc3, 0xef, 0xad, 0xd9, 0xe9, 0x71, 0x5f, 0x13, 0x6f, 0x80, 0xe9, 0x68, 0x3c,
-	0x3f, 0x9b, 0x9e, 0x9d, 0x4b, 0xce, 0xda, 0xc1, 0x3f, 0xa0, 0xae, 0x26, 0x21, 0xf4, 0x0d, 0x74,
-	0xd4, 0xd7, 0x29, 0x8f, 0x09, 0x0e, 0xd0, 0xca, 0xc5, 0xde, 0x59, 0xe1, 0x18, 0x95, 0x17, 0xda,
-	0x2b, 0x0d, 0x7d, 0x01, 0xd5, 0x13, 0x8f, 0xba, 0xa8, 0xfc, 0x48, 0xdf, 0x29, 0x93, 0x46, 0xe5,
-	0xe8, 0xab, 0xbf, 0xef, 0xb9, 0x1e, 0x5f, 0xdc, 0x5c, 0x88, 0x4e, 0xb3, 0xbf, 0xb8, 0x8f, 0x48,
-	0xac, 0xa6, 0xf2, 0xfd, 0x4b, 0x7c, 0x11, 0x7b, 0xf6, 0xbe, 0xfc, 0x2f, 0xc6, 0xf6, 0x95, 0xd9,
-	0x45, 0x5d, 0x92, 0x5f, 0xff, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xdd, 0x1d, 0xb3, 0x7e, 0x5f, 0x13,
-	0x00, 0x00,
+func init() { proto.RegisterFile("gossip/message.proto", fileDescriptor_message_563b77f4f682605d) }
+
+var fileDescriptor_message_563b77f4f682605d = []byte{
+	// 2120 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x18, 0x4b, 0x73, 0xdc, 0x48,
+	0xd9, 0xf2, 0xcc, 0xd8, 0x33, 0xdf, 0x3c, 0x3c, 0xee, 0x38, 0x89, 0xd6, 0xbb, 0x24, 0x5e, 0x41,
+	0xb2, 0x81, 0x64, 0xc7, 0xc1, 0x81, 0x62, 0x8b, 0x05, 0x52, 0xf6, 0x8c, 0x93, 0x99, 0xda, 0xd8,
+	0x31, 0xb2, 0x03, 0x78, 0x39, 0xa8, 0x64, 0xa9, 0x47, 0x23, 0xac, 0x97, 0xd5, 0x3d, 0x5e, 0xfb,
+	0x48, 0x71, 0x80, 0xe2, 0x00, 0x07, 0xce, 0x1c, 0x38, 0xf1, 0x37, 0xa9, 0x7e, 0x48, 0x6a, 0xcd,
+	0xc3, 0x55, 0xd9, 0x2a, 0x6e, 0xfa, 0x9e, 0xfd, 0x7d, 0x5f, 0x7f, 0xaf, 0x16, 0x6c, 0x79, 0x31,
+	0x21, 0x7e, 0xb2, 0x1b, 0x62, 0x42, 0x6c, 0x0f, 0xf7, 0x92, 0x34, 0xa6, 0x31, 0x5a, 0x13, 0xd8,
+	0xed, 0x87, 0x4e, 0x1c, 0x86, 0x71, 0xb4, 0xeb, 0xc4, 0x41, 0x80, 0x1d, 0xea, 0xc7, 0x91, 0x60,
+	0xd8, 0x7e, 0xec, 0xc5, 0xb1, 0x17, 0xe0, 0x5d, 0x0e, 0x5d, 0x4c, 0xc7, 0xbb, 0xd4, 0x0f, 0x31,
+	0xa1, 0x76, 0x98, 0x08, 0x06, 0xe3, 0x2f, 0x1a, 0xd4, 0x0f, 0xa3, 0x6b, 0x1c, 0xc4, 0x09, 0x46,
+	0x3a, 0xac, 0x27, 0xf6, 0x6d, 0x10, 0xdb, 0xae, 0xae, 0xed, 0x68, 0xcf, 0x5a, 0x66, 0x06, 0xa2,
+	0xcf, 0xa0, 0x41, 0x7c, 0x2f, 0xb2, 0xe9, 0x34, 0xc5, 0xfa, 0x2a, 0xa7, 0x15, 0x08, 0xf4, 0x1a,
+	0x36, 0x08, 0x76, 0x52, 0x4c, 0x2d, 0x2c, 0x55, 0xe9, 0x95, 0x1d, 0xed, 0x59, 0x73, 0xef, 0x41,
+	0x4f, 0x18, 0xd8, 0x3b, 0xe5, 0xe4, 0xec, 0x20, 0xb3, 0x43, 0x4a, 0xb0, 0x31, 0x84, 0x4e, 0x99,
+	0xe3, 0xfb, 0x9a, 0x62, 0xec, 0xc3, 0x9a, 0xd0, 0x84, 0x5e, 0x40, 0xd7, 0x8f, 0x28, 0x4e, 0x23,
+	0x3b, 0x38, 0x8c, 0xdc, 0x24, 0xf6, 0x23, 0xca, 0x55, 0x35, 0x86, 0x2b, 0xe6, 0x1c, 0xe5, 0xa0,
+	0x01, 0xeb, 0x4e, 0x1c, 0x51, 0x1c, 0x51, 0xe3, 0x1f, 0x2d, 0x68, 0xbf, 0xe5, 0x66, 0x1f, 0x89,
+	0x60, 0xa3, 0x2d, 0xa8, 0x45, 0x71, 0xe4, 0x60, 0x2e, 0x5f, 0x35, 0x05, 0xc0, 0x4c, 0x74, 0x26,
+	0x76, 0x14, 0xe1, 0x40, 0x9a, 0x91, 0x81, 0xe8, 0x39, 0x54, 0xa8, 0xed, 0xf1, 0x18, 0x74, 0xf6,
+	0x3e, 0xc9, 0x62, 0x50, 0xd2, 0xd9, 0x3b, 0xb3, 0x3d, 0x93, 0x71, 0xa1, 0x57, 0xd0, 0xb0, 0x03,
+	0xff, 0x1a, 0x5b, 0x21, 0xf1, 0xf4, 0x1a, 0x0f, 0xdb, 0x56, 0x26, 0xb2, 0xcf, 0x08, 0x52, 0x62,
+	0xb8, 0x62, 0xd6, 0x39, 0xe3, 0x11, 0xf1, 0xd0, 0xcf, 0x60, 0x3d, 0xc4, 0xa1, 0x95, 0xe2, 0x2b,
+	0x7d, 0x8d, 0x8b, 0xe4, 0xa7, 0x1c, 0xe1, 0xf0, 0x02, 0xa7, 0x64, 0xe2, 0x27, 0x26, 0xbe, 0x9a,
+	0x62, 0x42, 0x87, 0x2b, 0xe6, 0x5a, 0x88, 0x43, 0x13, 0x5f, 0xa1, 0x9f, 0x67, 0x52, 0x44, 0x5f,
+	0xe7, 0x52, 0xdb, 0x8b, 0xa4, 0x48, 0x12, 0x47, 0x04, 0xe7, 0x62, 0x04, 0xbd, 0x84, 0xba, 0x6b,
+	0x53, 0x9b, 0x1b, 0x58, 0xe7, 0x72, 0xf7, 0x32, 0xb9, 0x81, 0x4d, 0xed, 0xc2, 0xbe, 0x75, 0xc6,
+	0xc6, 0xcc, 0x7b, 0x0e, 0xb5, 0x09, 0x0e, 0x82, 0x58, 0x6f, 0x94, 0xd9, 0x45, 0x08, 0x86, 0x8c,
+	0x34, 0x5c, 0x31, 0x05, 0x0f, 0xda, 0x95, 0xea, 0x5d, 0xdf, 0xd3, 0x81, 0xf3, 0x23, 0x55, 0xfd,
+	0xc0, 0xf7, 0x84, 0x17, 0x5c, 0xfb, 0xc0, 0xf7, 0x72, 0x7b, 0x98, 0xf7, 0xcd, 0x79, 0x7b, 0x0a,
+	0xbf, 0xb9, 0x84, 0x70, 0xbc, 0xc9, 0x25, 0xa6, 0x89, 0x6b, 0x53, 0xac, 0xb7, 0xe6, 0x4f, 0xf9,
+	0xc0, 0x29, 0xc3, 0x15, 0x13, 0xdc, 0x1c, 0x42, 0x4f, 0xa0, 0x86, 0xc3, 0x84, 0xde, 0xea, 0x6d,
+	0x2e, 0xd0, 0xce, 0x04, 0x0e, 0x19, 0x92, 0x39, 0xc0, 0xa9, 0xe8, 0x39, 0x54, 0x9d, 0x38, 0x8a,
+	0xf4, 0x0e, 0xe7, 0xba, 0x9f, 0x71, 0xf5, 0xe3, 0x28, 0x3a, 0x24, 0xd4, 0xbe, 0x08, 0x7c, 0x32,
+	0x19, 0xae, 0x98, 0x9c, 0x09, 0xed, 0x01, 0x10, 0x6a, 0x53, 0x6c, 0xf9, 0xd1, 0x38, 0xd6, 0x37,
+	0xb8, 0xc8, 0x66, 0x5e, 0x26, 0x8c, 0x32, 0x8a, 0xc6, 0x2c, 0x3a, 0x0d, 0x92, 0x01, 0xe8, 0x00,
+	0x3a, 0x42, 0x86, 0x44, 0x76, 0x42, 0x26, 0x31, 0xd5, 0xbb, 0xe5, 0x4b, 0xcf, 0xe5, 0x4e, 0x25,
+	0xc3, 0x70, 0xc5, 0x6c, 0x73, 0x91, 0x0c, 0x81, 0x8e, 0xe0, 0x5e, 0x71, 0xae, 0x95, 0x4c, 0x83,
+	0x80, 0xc7, 0x6f, 0x93, 0x2b, 0xfa, 0x6c, 0x4e, 0xd1, 0xc9, 0x34, 0x08, 0x8a, 0x40, 0x76, 0xc9,
+	0x0c, 0x1e, 0xed, 0x83, 0xd0, 0xcf, 0x94, 0x30, 0x26, 0x1d, 0x95, 0x13, 0xca, 0xc4, 0x61, 0x4c,
+	0x31, 0x57, 0x57, 0xa8, 0x69, 0x11, 0x05, 0x46, 0x83, 0xcc, 0xab, 0x54, 0xa6, 0x9c, 0x7e, 0x8f,
+	0xeb, 0xf8, 0x74, 0xa1, 0x8e, 0x3c, 0x2b, 0xdb, 0x44, 0x45, 0xb0, 0xd8, 0x04, 0xd8, 0x76, 0x45,
+	0xf2, 0xf2, 0x14, 0xdd, 0x2a, 0xc7, 0xe6, 0x5d, 0x4e, 0x2d, 0x12, 0xb5, 0x5d, 0x88, 0xb0, 0x74,
+	0xfd, 0x1a, 0xda, 0x09, 0xc6, 0xa9, 0xe5, 0xbb, 0x38, 0xa2, 0x3e, 0xbd, 0xd5, 0xef, 0x97, 0xcb,
+	0xf0, 0x04, 0xe3, 0x74, 0x24, 0x69, 0xcc, 0x8d, 0x44, 0x81, 0x59, 0xb1, 0xdb, 0xce, 0xa5, 0xfe,
+	0x80, 0x8b, 0x3c, 0xcc, 0x2b, 0xd7, 0xb9, 0x8c, 0xe2, 0xef, 0x02, 0xec, 0x7a, 0x38, 0xc4, 0x11,
+	0x73, 0x9e, 0x71, 0xa1, 0xdf, 0x00, 0x24, 0xa9, 0x7f, 0x2d, 0xa2, 0xa0, 0x3f, 0x2c, 0x07, 0x5f,
+	0xf8, 0x7b, 0x72, 0x4d, 0xcb, 0x59, 0xac, 0x48, 0xa0, 0xd7, 0x8a, 0x3c, 0xd1, 0x75, 0x2e, 0xff,
+	0x83, 0x25, 0xf2, 0x79, 0xc4, 0x14, 0x11, 0xf4, 0x1a, 0x5a, 0x12, 0xb2, 0x58, 0xa2, 0xeb, 0x9f,
+	0x94, 0xaf, 0xed, 0x44, 0xd0, 0xca, 0x65, 0xdd, 0x4c, 0x0a, 0x2c, 0xda, 0x87, 0x26, 0x9b, 0x32,
+	0xd2, 0x44, 0xfd, 0xdb, 0x45, 0x26, 0xf4, 0x0b, 0x06, 0xe9, 0x83, 0x2a, 0x83, 0x0e, 0x54, 0x15,
+	0x44, 0xff, 0x23, 0x57, 0xf1, 0x68, 0x99, 0x8a, 0xdc, 0x0d, 0x55, 0xc8, 0xb0, 0xa0, 0x72, 0x66,
+	0x7b, 0xa8, 0x0d, 0x8d, 0x0f, 0xc7, 0x83, 0xc3, 0x37, 0xa3, 0xe3, 0xc3, 0x41, 0x77, 0x05, 0x35,
+	0xa0, 0x76, 0x78, 0x74, 0x72, 0x76, 0xde, 0xd5, 0x50, 0x0b, 0xea, 0xef, 0xcd, 0xb7, 0xd6, 0xfb,
+	0xe3, 0x77, 0xe7, 0xdd, 0x55, 0xc6, 0xd7, 0x1f, 0xee, 0x1f, 0x0b, 0xb0, 0x82, 0xba, 0xd0, 0xe2,
+	0xe0, 0xfe, 0xf1, 0xc0, 0x7a, 0x6f, 0xbe, 0xed, 0x56, 0xd1, 0x06, 0x34, 0x05, 0x83, 0xc9, 0x11,
+	0x35, 0x75, 0x20, 0xfc, 0x57, 0x83, 0x46, 0x5e, 0x18, 0xa8, 0x07, 0x8d, 0x7c, 0x88, 0xf2, 0xc6,
+	0xdf, 0xdc, 0xeb, 0xaa, 0x89, 0x72, 0xe6, 0x87, 0xd8, 0x2c, 0x58, 0xd0, 0x7d, 0x58, 0x4b, 0x2e,
+	0x7d, 0xcb, 0x77, 0xf9, 0x3c, 0x68, 0x99, 0xb5, 0xe4, 0xd2, 0x1f, 0xb9, 0xe8, 0x31, 0x34, 0xe5,
+	0xb8, 0xb0, 0x8e, 0xf6, 0xfb, 0x7a, 0x95, 0xd3, 0x40, 0xa2, 0x8e, 0xf6, 0xfb, 0xac, 0x51, 0x24,
+	0x69, 0x9c, 0xe0, 0x94, 0xfa, 0x98, 0xc8, 0xc1, 0x80, 0x8a, 0x7b, 0xca, 0x28, 0xa6, 0xc2, 0x65,
+	0xfc, 0x5b, 0x03, 0x28, 0x48, 0xe8, 0x87, 0xd0, 0xe6, 0x19, 0x98, 0x5a, 0x13, 0xec, 0x7b, 0x13,
+	0x2a, 0xe7, 0x57, 0x4b, 0x20, 0x87, 0x1c, 0x87, 0x3e, 0x87, 0x56, 0x80, 0xc7, 0xd4, 0x52, 0x67,
+	0x59, 0xdd, 0x6c, 0x32, 0x5c, 0x5f, 0xce, 0xb3, 0x9f, 0x02, 0x33, 0xcc, 0x8f, 0x9c, 0xd8, 0xc5,
+	0x44, 0xaf, 0xec, 0x54, 0xd4, 0x9e, 0xd5, 0xcf, 0x28, 0xa6, 0xc2, 0xc4, 0x46, 0x66, 0x1a, 0x07,
+	0x98, 0xe8, 0xce, 0x4e, 0xe5, 0x59, 0xc3, 0x14, 0x80, 0xb1, 0x0f, 0x9b, 0x73, 0xad, 0x0a, 0xbd,
+	0x80, 0x3a, 0x0e, 0x78, 0x95, 0x10, 0x5d, 0xe3, 0xba, 0xf3, 0x78, 0xe6, 0x0b, 0x43, 0xce, 0x61,
+	0xfc, 0x02, 0xb6, 0x16, 0x35, 0xa9, 0xd9, 0x78, 0x6a, 0xb3, 0xf1, 0x34, 0xc6, 0xd0, 0x2e, 0x75,
+	0x64, 0xe5, 0x62, 0x34, 0xf5, 0x62, 0xb6, 0xa1, 0x9e, 0xf7, 0x01, 0x31, 0xd7, 0x73, 0x18, 0x19,
+	0xd0, 0xa6, 0x01, 0xb1, 0x1c, 0x9c, 0x52, 0x6b, 0x62, 0x93, 0x89, 0xbc, 0xd2, 0x26, 0x0d, 0x48,
+	0x1f, 0xa7, 0x74, 0x68, 0x93, 0x89, 0xf1, 0x01, 0x5a, 0x6a, 0xbf, 0x58, 0x76, 0x0c, 0x82, 0x2a,
+	0x53, 0x23, 0x8f, 0xe0, 0xdf, 0xec, 0xe8, 0x10, 0x53, 0x9b, 0x17, 0xa6, 0xd0, 0x9c, 0xc3, 0x46,
+	0x08, 0x4d, 0xa5, 0xa4, 0x96, 0xaf, 0x24, 0x2e, 0x1f, 0x97, 0x44, 0x5f, 0xdd, 0xa9, 0xb0, 0x95,
+	0x44, 0x82, 0xa8, 0x07, 0xf5, 0x90, 0x78, 0x16, 0xbd, 0x95, 0xbb, 0x59, 0xa7, 0x98, 0x99, 0x2c,
+	0x8a, 0x47, 0xc4, 0x3b, 0xbb, 0x4d, 0xb0, 0xb9, 0x1e, 0x8a, 0x0f, 0x23, 0x86, 0xa6, 0x32, 0xac,
+	0x97, 0x1c, 0xa7, 0xda, 0xbb, 0x5a, 0xb6, 0xf7, 0xa3, 0x0f, 0xbc, 0x01, 0x28, 0xe6, 0xf0, 0x92,
+	0xf3, 0x7e, 0x04, 0x55, 0x79, 0xd6, 0xe2, 0x2c, 0xa9, 0x7e, 0xaf, 0x93, 0x03, 0x71, 0xb2, 0xd8,
+	0x33, 0xfe, 0xef, 0x81, 0xfd, 0x4a, 0xdc, 0x63, 0xb6, 0x5a, 0xfe, 0xb8, 0xbc, 0xe7, 0x36, 0xf7,
+	0x36, 0x72, 0x69, 0x81, 0xce, 0x17, 0x5f, 0xe3, 0x0d, 0xa0, 0xf9, 0xf6, 0x8c, 0x5e, 0xce, 0x2a,
+	0x78, 0x30, 0xd3, 0xcb, 0xe7, 0xf4, 0x9c, 0xc3, 0xba, 0xc4, 0xa1, 0x87, 0xb0, 0x4e, 0xf0, 0x95,
+	0x15, 0x4d, 0x43, 0xe9, 0xee, 0x1a, 0xc1, 0x57, 0xc7, 0xd3, 0x90, 0x65, 0xa7, 0x72, 0xab, 0x22,
+	0xae, 0x9f, 0xcf, 0x8c, 0x8e, 0x0a, 0x0f, 0x84, 0x3a, 0x1c, 0x8c, 0x7f, 0xae, 0x42, 0xa7, 0x7c,
+	0x2c, 0xfa, 0x02, 0x36, 0x8a, 0x57, 0x89, 0x15, 0xd9, 0xa1, 0x88, 0x6c, 0xc3, 0xec, 0x14, 0xe8,
+	0x63, 0x3b, 0xc4, 0x6c, 0xaf, 0x67, 0x54, 0x92, 0xd8, 0x8e, 0xd8, 0xeb, 0x1b, 0x66, 0x81, 0x40,
+	0xf7, 0xa0, 0x46, 0x6f, 0xb2, 0x26, 0xda, 0x30, 0xab, 0xf4, 0x66, 0xe4, 0xb2, 0xfe, 0x96, 0x59,
+	0x94, 0x7e, 0x47, 0x30, 0x95, 0x5d, 0x34, 0x33, 0xd3, 0x64, 0x38, 0xf4, 0x02, 0x50, 0xc6, 0x44,
+	0xfc, 0x30, 0xeb, 0x84, 0x35, 0xee, 0x6e, 0x57, 0x52, 0x4e, 0xfd, 0x50, 0x76, 0xc3, 0x63, 0x40,
+	0x8a, 0xb9, 0x4e, 0x1c, 0x8d, 0x7d, 0x8f, 0xc8, 0x1d, 0xfb, 0x71, 0x4f, 0x3c, 0xb3, 0x7a, 0xfd,
+	0x9c, 0xa3, 0xcf, 0x19, 0x4e, 0x6c, 0xe7, 0xd2, 0xf6, 0xb0, 0xb9, 0xe9, 0xcc, 0x10, 0x88, 0xf1,
+	0x77, 0x0d, 0x5a, 0xea, 0x16, 0x8f, 0x7a, 0x00, 0x61, 0xbe, 0x6c, 0xcb, 0x2b, 0xeb, 0x94, 0xd7,
+	0x70, 0x53, 0xe1, 0xf8, 0xe8, 0x71, 0xa3, 0xb6, 0xaf, 0x6a, 0xb9, 0x7d, 0x19, 0x7f, 0xd6, 0x60,
+	0x73, 0x6e, 0x1d, 0x5a, 0xd6, 0xa0, 0x3e, 0xf6, 0xe0, 0x27, 0xd0, 0xf1, 0x89, 0xe5, 0x62, 0x27,
+	0xb0, 0x53, 0x9b, 0x85, 0x80, 0x5f, 0x55, 0xdd, 0x6c, 0xfb, 0x64, 0x50, 0x20, 0x8d, 0x5f, 0x41,
+	0x3d, 0x93, 0x66, 0xe9, 0xe7, 0x47, 0x8e, 0x9a, 0x7e, 0x7e, 0xe4, 0xb0, 0xf4, 0x53, 0xf2, 0x72,
+	0x55, 0xcd, 0x4b, 0x63, 0x0c, 0x9b, 0x73, 0x0f, 0x1c, 0xf4, 0x35, 0x74, 0x09, 0x0e, 0xc6, 0x7c,
+	0xb3, 0x4d, 0x43, 0x71, 0xb6, 0x56, 0x36, 0x38, 0x6f, 0x11, 0x1b, 0x8c, 0x73, 0x54, 0x30, 0xb2,
+	0x7a, 0x67, 0x9b, 0x5a, 0x24, 0xeb, 0x5a, 0x00, 0xc6, 0x05, 0xa0, 0xf9, 0x27, 0x11, 0x7a, 0x0a,
+	0x35, 0xfe, 0x02, 0x5b, 0x3a, 0xa6, 0x04, 0x99, 0xf7, 0x29, 0x6c, 0xbb, 0x77, 0xf4, 0x29, 0x6c,
+	0xbb, 0xc6, 0xef, 0x61, 0x4d, 0x9c, 0xc1, 0xee, 0x0c, 0x97, 0x9e, 0xa8, 0x66, 0x0e, 0xdf, 0xd9,
+	0x63, 0x17, 0xaf, 0x16, 0xc6, 0x3a, 0xd4, 0xf8, 0x0b, 0xc5, 0xf8, 0x03, 0xa0, 0xf9, 0x3d, 0x9c,
+	0x0d, 0x31, 0x42, 0xed, 0x94, 0x5a, 0xe5, 0xd2, 0x6f, 0x72, 0xe4, 0xa9, 0xa8, 0xff, 0x47, 0xd0,
+	0xc4, 0x91, 0x6b, 0x95, 0x2f, 0xa1, 0x81, 0x23, 0x57, 0xd0, 0x8d, 0x03, 0xb8, 0xb7, 0x60, 0x3b,
+	0x47, 0xcf, 0xa1, 0x2e, 0xbb, 0x4c, 0x36, 0xca, 0xe7, 0xda, 0x59, 0xce, 0x60, 0xbc, 0x85, 0xad,
+	0x45, 0x1b, 0x2f, 0xda, 0x2d, 0x7a, 0xad, 0xd0, 0x91, 0xbf, 0xa8, 0x24, 0xa3, 0xe8, 0xd4, 0x79,
+	0x0b, 0x36, 0xfe, 0xa3, 0x41, 0xbb, 0x44, 0x2a, 0xba, 0x85, 0xa6, 0x74, 0x8b, 0xbb, 0x1b, 0xcc,
+	0x23, 0x80, 0xa2, 0x7a, 0x65, 0x97, 0x51, 0x30, 0xe8, 0x53, 0x68, 0x5c, 0x04, 0xb1, 0x73, 0xc9,
+	0x62, 0xc2, 0x0b, 0xab, 0x6a, 0xd6, 0x39, 0xe2, 0x14, 0x5f, 0xa1, 0x1d, 0x68, 0xb1, 0x50, 0xf9,
+	0x91, 0xc5, 0x51, 0xb2, 0xbb, 0x00, 0xc1, 0x57, 0xa3, 0xe8, 0x80, 0x61, 0x8c, 0x6f, 0xe0, 0xfe,
+	0xc2, 0xf5, 0x1c, 0xed, 0xcd, 0x6d, 0x3f, 0x0f, 0x66, 0xdc, 0x3d, 0x14, 0x64, 0x65, 0x07, 0x3a,
+	0x87, 0x4e, 0x99, 0x86, 0xbe, 0x84, 0x35, 0x11, 0x0d, 0x99, 0xf8, 0x4b, 0x42, 0x26, 0x99, 0xd4,
+	0xbf, 0x2b, 0x72, 0x9c, 0x65, 0xc3, 0xe1, 0xb7, 0xb9, 0xea, 0xac, 0x81, 0x3f, 0x81, 0x0d, 0x7a,
+	0x63, 0x95, 0xdc, 0x93, 0x6b, 0x24, 0xbd, 0x39, 0xcd, 0x1d, 0x2c, 0xab, 0x54, 0x7f, 0xd8, 0x18,
+	0x5f, 0xc0, 0xc6, 0xcc, 0x6b, 0x88, 0x15, 0x1d, 0x4e, 0xd3, 0x38, 0x95, 0xf7, 0x23, 0x00, 0xe3,
+	0x03, 0x34, 0xf2, 0x65, 0x92, 0x4d, 0x20, 0x65, 0x58, 0xf0, 0x6f, 0x76, 0xc6, 0x35, 0x4e, 0x09,
+	0xbb, 0x20, 0x71, 0x7f, 0x19, 0x78, 0xe7, 0xe6, 0xf4, 0x57, 0x0d, 0xf4, 0xdf, 0xd9, 0x81, 0xef,
+	0xf2, 0x82, 0x37, 0x31, 0x99, 0x06, 0x94, 0x64, 0xcd, 0x6f, 0xe9, 0x04, 0xd4, 0x61, 0x9d, 0xde,
+	0xbc, 0x09, 0x6c, 0x8f, 0x64, 0xfe, 0x48, 0xb0, 0xfc, 0x03, 0xaa, 0x32, 0xfb, 0x2f, 0xec, 0xae,
+	0xfe, 0x6b, 0x65, 0x49, 0x30, 0xf3, 0x40, 0x5a, 0xb2, 0x74, 0xbc, 0x2c, 0x2f, 0x1d, 0x4a, 0x66,
+	0x64, 0xf2, 0xb3, 0x95, 0xf0, 0x37, 0x0d, 0x3a, 0x65, 0x5a, 0x39, 0xeb, 0xb5, 0xbb, 0xb3, 0x7e,
+	0x75, 0x2e, 0xeb, 0xbb, 0x50, 0xb9, 0xc4, 0xb7, 0xb2, 0x1c, 0xd8, 0x27, 0x7a, 0x0a, 0x1d, 0x1c,
+	0xb9, 0x71, 0x4a, 0xb0, 0xbb, 0x4f, 0xcf, 0x6e, 0x46, 0x03, 0xee, 0x65, 0xc3, 0x9c, 0xc1, 0x1a,
+	0x0e, 0x3c, 0x58, 0xfc, 0x92, 0x5b, 0xe2, 0xec, 0x2b, 0xa5, 0x0e, 0x84, 0xb7, 0x0f, 0x67, 0xbd,
+	0x9d, 0x2f, 0x84, 0x7f, 0x69, 0xb0, 0x31, 0x43, 0x45, 0xbd, 0x99, 0x52, 0x58, 0x16, 0xb4, 0xac,
+	0x16, 0xb6, 0xa0, 0x76, 0x6d, 0x07, 0xd3, 0xec, 0x5f, 0xa2, 0x00, 0xd0, 0x2f, 0x01, 0xf0, 0x4d,
+	0xe2, 0xa7, 0xb7, 0x6c, 0x50, 0xc9, 0xbf, 0x99, 0xec, 0x95, 0x1c, 0x7b, 0x81, 0xfc, 0xf9, 0x7a,
+	0x31, 0x1d, 0xf7, 0xce, 0xb2, 0xe9, 0x67, 0x2a, 0xdc, 0x3f, 0xf9, 0x35, 0x34, 0x95, 0xd5, 0x6f,
+	0xf6, 0x8d, 0xda, 0x86, 0xc6, 0xc1, 0xbb, 0xf7, 0xfd, 0x6f, 0xac, 0xa3, 0xd3, 0xb7, 0x5d, 0x8d,
+	0x3d, 0x45, 0x47, 0x83, 0xc3, 0xe3, 0xb3, 0xd1, 0xd9, 0x39, 0xc7, 0xac, 0xee, 0xfd, 0x09, 0xd6,
+	0xc4, 0xea, 0x8d, 0xbe, 0x82, 0x96, 0xf8, 0x3a, 0xa5, 0x29, 0xb6, 0x43, 0x34, 0x37, 0x49, 0xb6,
+	0xe7, 0x30, 0xc6, 0xca, 0x33, 0xed, 0xa5, 0x86, 0x9e, 0x42, 0xf5, 0xc4, 0x8f, 0x3c, 0x54, 0xfe,
+	0x65, 0xb5, 0x5d, 0x06, 0x8d, 0x95, 0x83, 0x2f, 0xbf, 0x7d, 0xee, 0xf9, 0x74, 0x32, 0xbd, 0x60,
+	0xab, 0xcd, 0xee, 0xe4, 0x36, 0xc1, 0xa9, 0x78, 0x1c, 0xee, 0x8e, 0xed, 0x8b, 0xd4, 0x77, 0xc4,
+	0x8f, 0x63, 0xb2, 0x2b, 0xc4, 0x2e, 0xd6, 0x38, 0xf8, 0xea, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff,
+	0xd7, 0x39, 0x29, 0xbd, 0x8e, 0x16, 0x00, 0x00,
 }
diff --git a/protos/gossip/message.proto b/protos/gossip/message.proto
index 56cb0cd0..09c4104f 100644
--- a/protos/gossip/message.proto
+++ b/protos/gossip/message.proto
@@ -9,6 +9,7 @@ option go_package = "github.com/hyperledger/fabric/protos/gossip" ;
 package gossip;
 
 import "common/collection.proto";
+import "google/protobuf/timestamp.proto";
 
 // Gossip
 service Gossip {
@@ -130,6 +131,12 @@ message GossipMessage {
         // Encapsulates private data used to distribute
         // private rwset after the endorsement
         PrivateDataMessage private_data = 25;
+
+        // Used to request collection data
+        RemoteCollDataRequest collDataReq = 90;
+
+        // Used to respond to collection data requests
+        RemoteCollDataResponse collDataRes = 91;
     }
 }
 
@@ -151,6 +158,7 @@ message Properties {
     uint64 ledger_height = 1;
     bool left_channel = 2;
     repeated Chaincode chaincodes = 3;
+    repeated string roles = 99; // NOT USED by Fabric 1.4.1 but added here for fabric-peer-ext dependency
 }
 
 // StateInfoSnapshot is an aggregation of StateInfo messages
@@ -369,4 +377,41 @@ message Chaincode {
     string name = 1;
     string version = 2;
     bytes metadata = 3;
+}
+
+// ValidationResultsMessage is the message containing block validation results
+message ValidationResultsMessage {
+    uint64 seq_num = 1;
+    bytes txFlags  = 2;
+    bytes signature = 3;
+    bytes identity = 4;
+}
+
+// RemoteCollDataRequest message used to request
+// collection data
+message RemoteCollDataRequest {
+    uint64 nonce = 1;
+    repeated CollDataDigest digests = 2;
+}
+
+// CollDataDigest defines a digest of collection data
+message CollDataDigest {
+    string namespace = 1;
+    string collection = 2;
+    string key = 3;
+    string endorsedAtTxID = 4;
+}
+
+// RemoteCollDataResponse message used to respond to
+// collection data request
+message RemoteCollDataResponse {
+    uint64 nonce = 1;
+    repeated CollDataElement elements = 2;
+}
+
+// CollDataElement contains the collection data digest and value
+message CollDataElement {
+    CollDataDigest digest = 1;
+    bytes value = 2;
+    google.protobuf.Timestamp expiryTime = 3;
 }
\ No newline at end of file
diff --git a/protoutil/blockutils.go b/protoutil/blockutils.go
new file mode 100644
index 00000000..c7535ac9
--- /dev/null
+++ b/protoutil/blockutils.go
@@ -0,0 +1,124 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"github.com/golang/protobuf/proto"
+	cb "github.com/hyperledger/fabric/protos/common"
+	"github.com/pkg/errors"
+)
+
+// GetChainIDFromBlockBytes returns chain ID given byte array which represents
+// the block
+func GetChainIDFromBlockBytes(bytes []byte) (string, error) {
+	block, err := GetBlockFromBlockBytes(bytes)
+	if err != nil {
+		return "", err
+	}
+
+	return GetChainIDFromBlock(block)
+}
+
+// GetChainIDFromBlock returns chain ID in the block
+func GetChainIDFromBlock(block *cb.Block) (string, error) {
+	if block == nil || block.Data == nil || block.Data.Data == nil || len(block.Data.Data) == 0 {
+		return "", errors.Errorf("failed to retrieve channel id - block is empty")
+	}
+	var err error
+	envelope, err := GetEnvelopeFromBlock(block.Data.Data[0])
+	if err != nil {
+		return "", err
+	}
+	payload, err := GetPayload(envelope)
+	if err != nil {
+		return "", err
+	}
+
+	if payload.Header == nil {
+		return "", errors.Errorf("failed to retrieve channel id - payload header is empty")
+	}
+	chdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)
+	if err != nil {
+		return "", err
+	}
+
+	return chdr.ChannelId, nil
+}
+
+// GetMetadataFromBlock retrieves metadata at the specified index.
+func GetMetadataFromBlock(block *cb.Block, index cb.BlockMetadataIndex) (*cb.Metadata, error) {
+	md := &cb.Metadata{}
+	err := proto.Unmarshal(block.Metadata.Metadata[index], md)
+	if err != nil {
+		return nil, errors.Wrapf(err, "error unmarshaling metadata from block at index [%s]", index)
+	}
+	return md, nil
+}
+
+// GetMetadataFromBlockOrPanic retrieves metadata at the specified index, or
+// panics on error
+func GetMetadataFromBlockOrPanic(block *cb.Block, index cb.BlockMetadataIndex) *cb.Metadata {
+	md, err := GetMetadataFromBlock(block, index)
+	if err != nil {
+		panic(err)
+	}
+	return md
+}
+
+// GetLastConfigIndexFromBlock retrieves the index of the last config block as
+// encoded in the block metadata
+func GetLastConfigIndexFromBlock(block *cb.Block) (uint64, error) {
+	md, err := GetMetadataFromBlock(block, cb.BlockMetadataIndex_LAST_CONFIG)
+	if err != nil {
+		return 0, err
+	}
+	lc := &cb.LastConfig{}
+	err = proto.Unmarshal(md.Value, lc)
+	if err != nil {
+		return 0, errors.Wrap(err, "error unmarshaling LastConfig")
+	}
+	return lc.Index, nil
+}
+
+// GetLastConfigIndexFromBlockOrPanic retrieves the index of the last config
+// block as encoded in the block metadata, or panics on error
+func GetLastConfigIndexFromBlockOrPanic(block *cb.Block) uint64 {
+	index, err := GetLastConfigIndexFromBlock(block)
+	if err != nil {
+		panic(err)
+	}
+	return index
+}
+
+// GetBlockFromBlockBytes marshals the bytes into Block
+func GetBlockFromBlockBytes(blockBytes []byte) (*cb.Block, error) {
+	block := &cb.Block{}
+	err := proto.Unmarshal(blockBytes, block)
+	if err != nil {
+		return block, errors.Wrap(err, "error unmarshaling block")
+	}
+	return block, nil
+}
+
+// CopyBlockMetadata copies metadata from one block into another
+func CopyBlockMetadata(src *cb.Block, dst *cb.Block) {
+	dst.Metadata = src.Metadata
+	// Once copied initialize with rest of the
+	// required metadata positions.
+	InitBlockMetadata(dst)
+}
+
+// InitBlockMetadata copies metadata from one block into another
+func InitBlockMetadata(block *cb.Block) {
+	if block.Metadata == nil {
+		block.Metadata = &cb.BlockMetadata{Metadata: [][]byte{{}, {}, {}}}
+	} else if len(block.Metadata.Metadata) < int(cb.BlockMetadataIndex_TRANSACTIONS_FILTER+1) {
+		for i := int(len(block.Metadata.Metadata)); i <= int(cb.BlockMetadataIndex_TRANSACTIONS_FILTER); i++ {
+			block.Metadata.Metadata = append(block.Metadata.Metadata, []byte{})
+		}
+	}
+}
diff --git a/protoutil/blockutils_test.go b/protoutil/blockutils_test.go
new file mode 100644
index 00000000..1d30dbc8
--- /dev/null
+++ b/protoutil/blockutils_test.go
@@ -0,0 +1,206 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil_test
+
+import (
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	configtxtest "github.com/hyperledger/fabric/common/configtx/test"
+	"github.com/hyperledger/fabric/protos/common"
+	cb "github.com/hyperledger/fabric/protos/common"
+	"github.com/hyperledger/fabric/protos/utils"
+	"github.com/stretchr/testify/assert"
+)
+
+var testChainID = "myuniquetestchainid"
+
+func TestGetChainIDFromBlockBytes(t *testing.T) {
+	gb, err := configtxtest.MakeGenesisBlock(testChainID)
+	assert.NoError(t, err, "Failed to create test configuration block")
+	bytes, err := proto.Marshal(gb)
+	cid, err := utils.GetChainIDFromBlockBytes(bytes)
+	assert.NoError(t, err)
+	assert.Equal(t, testChainID, cid, "Failed to return expected chain ID")
+
+	// bad block bytes
+	_, err = utils.GetChainIDFromBlockBytes([]byte("bad block"))
+	assert.Error(t, err, "Expected error with malformed block bytes")
+}
+
+func TestGetChainIDFromBlock(t *testing.T) {
+	var err error
+	var gb *common.Block
+	var cid string
+
+	// nil block
+	_, err = utils.GetChainIDFromBlock(gb)
+	assert.Error(t, err, "Expected error getting channel id from nil block")
+
+	gb, err = configtxtest.MakeGenesisBlock(testChainID)
+	assert.NoError(t, err, "Failed to create test configuration block")
+
+	cid, err = utils.GetChainIDFromBlock(gb)
+	assert.NoError(t, err, "Failed to get chain ID from block")
+	assert.Equal(t, testChainID, cid, "Failed to return expected chain ID")
+
+	// missing data
+	badBlock := gb
+	badBlock.Data = nil
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error with missing block data")
+
+	// no envelope
+	badBlock = &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{[]byte("bad envelope")},
+		},
+	}
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error with no envelope in data")
+
+	// bad payload
+	env, _ := proto.Marshal(&cb.Envelope{
+		Payload: []byte("bad payload"),
+	})
+	badBlock = &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{env},
+		},
+	}
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error - malformed payload")
+
+	// bad channel header
+	payload, _ := proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: []byte("bad header"),
+		},
+	})
+	env, _ = proto.Marshal(&cb.Envelope{
+		Payload: payload,
+	})
+	badBlock = &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{env},
+		},
+	}
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error with malformed channel header")
+
+	// nil payload header
+	payload, _ = proto.Marshal(&cb.Payload{})
+	env, _ = proto.Marshal(&cb.Envelope{
+		Payload: payload,
+	})
+	badBlock = &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{env},
+		},
+	}
+	_, err = utils.GetChainIDFromBlock(badBlock)
+	assert.Error(t, err, "Expected error when payload header is nil")
+}
+
+func TestGetBlockFromBlockBytes(t *testing.T) {
+	testChainID := "myuniquetestchainid"
+	gb, err := configtxtest.MakeGenesisBlock(testChainID)
+	assert.NoError(t, err, "Failed to create test configuration block")
+	blockBytes, err := utils.Marshal(gb)
+	assert.NoError(t, err, "Failed to marshal block")
+	_, err = utils.GetBlockFromBlockBytes(blockBytes)
+	assert.NoError(t, err, "to get block from block bytes")
+
+	// bad block bytes
+	_, err = utils.GetBlockFromBlockBytes([]byte("bad block"))
+	assert.Error(t, err, "Expected error for malformed block bytes")
+}
+
+func TestGetMetadataFromNewBlock(t *testing.T) {
+	block := common.NewBlock(0, nil)
+	md, err := utils.GetMetadataFromBlock(block, cb.BlockMetadataIndex_ORDERER)
+	assert.NoError(t, err, "Unexpected error extracting metadata from new block")
+	assert.Nil(t, md.Value, "Expected metadata field value to be nil")
+	assert.Equal(t, 0, len(md.Value), "Expected length of metadata field value to be 0")
+	md = utils.GetMetadataFromBlockOrPanic(block, cb.BlockMetadataIndex_ORDERER)
+	assert.NotNil(t, md, "Expected to get metadata from block")
+
+	// malformed metadata
+	block.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER] = []byte("bad metadata")
+	_, err = utils.GetMetadataFromBlock(block, cb.BlockMetadataIndex_ORDERER)
+	assert.Error(t, err, "Expected error with malformed metadata")
+	assert.Panics(t, func() {
+		_ = utils.GetMetadataFromBlockOrPanic(block, cb.BlockMetadataIndex_ORDERER)
+	}, "Expected panic with malformed metadata")
+}
+
+func TestInitBlockMeta(t *testing.T) {
+	// block with no metadata
+	block := &cb.Block{}
+	utils.InitBlockMetadata(block)
+	// should have 3 entries
+	assert.Equal(t, 3, len(block.Metadata.Metadata), "Expected block to have 3 metadata entries")
+
+	// block with a single entry
+	block = &cb.Block{
+		Metadata: &cb.BlockMetadata{},
+	}
+	block.Metadata.Metadata = append(block.Metadata.Metadata, []byte{})
+	utils.InitBlockMetadata(block)
+	// should have 3 entries
+	assert.Equal(t, 3, len(block.Metadata.Metadata), "Expected block to have 3 metadata entries")
+}
+
+func TestCopyBlockMetadata(t *testing.T) {
+	srcBlock := common.NewBlock(0, nil)
+	dstBlock := &cb.Block{}
+
+	metadata, _ := proto.Marshal(&cb.Metadata{
+		Value: []byte("orderer metadata"),
+	})
+	srcBlock.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER] = metadata
+	utils.CopyBlockMetadata(srcBlock, dstBlock)
+
+	// check that the copy worked
+	assert.Equal(t, len(srcBlock.Metadata.Metadata), len(dstBlock.Metadata.Metadata),
+		"Expected target block to have same number of metadata entries after copy")
+	assert.Equal(t, metadata, dstBlock.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER],
+		"Unexpected metadata from target block")
+}
+
+func TestGetLastConfigIndexFromBlock(t *testing.T) {
+	block := common.NewBlock(0, nil)
+	index := uint64(2)
+	lc, _ := proto.Marshal(&cb.LastConfig{
+		Index: index,
+	})
+	metadata, _ := proto.Marshal(&cb.Metadata{
+		Value: lc,
+	})
+	block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = metadata
+	result, err := utils.GetLastConfigIndexFromBlock(block)
+	assert.NoError(t, err, "Unexpected error returning last config index")
+	assert.Equal(t, index, result, "Unexpected last config index returned from block")
+	result = utils.GetLastConfigIndexFromBlockOrPanic(block)
+	assert.Equal(t, index, result, "Unexpected last config index returned from block")
+
+	// malformed metadata
+	block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = []byte("bad metadata")
+	_, err = utils.GetLastConfigIndexFromBlock(block)
+	assert.Error(t, err, "Expected error with malformed metadata")
+
+	// malformed last config
+	metadata, _ = proto.Marshal(&cb.Metadata{
+		Value: []byte("bad last config"),
+	})
+	block.Metadata.Metadata[cb.BlockMetadataIndex_LAST_CONFIG] = metadata
+	_, err = utils.GetLastConfigIndexFromBlock(block)
+	assert.Error(t, err, "Expected error with malformed last config metadata")
+	assert.Panics(t, func() {
+		_ = utils.GetLastConfigIndexFromBlockOrPanic(block)
+	}, "Expected panic with malformed last config metadata")
+}
diff --git a/protoutil/chaincodeutils.go b/protoutil/chaincodeutils.go
new file mode 100644
index 00000000..c0504d86
--- /dev/null
+++ b/protoutil/chaincodeutils.go
@@ -0,0 +1,25 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/protos/peer"
+	"github.com/pkg/errors"
+)
+
+// UnmarshalChaincodeDeploymentSpec unmarshals a ChaincodeDeploymentSpec from
+// the provided bytes
+func UnmarshalChaincodeDeploymentSpec(cdsBytes []byte) (*peer.ChaincodeDeploymentSpec, error) {
+	cds := &peer.ChaincodeDeploymentSpec{}
+	err := proto.Unmarshal(cdsBytes, cds)
+	if err != nil {
+		return nil, errors.Wrap(err, "error unmarshaling ChaincodeDeploymentSpec")
+	}
+
+	return cds, nil
+}
diff --git a/protoutil/commonutils.go b/protoutil/commonutils.go
new file mode 100644
index 00000000..bced28e3
--- /dev/null
+++ b/protoutil/commonutils.go
@@ -0,0 +1,339 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"fmt"
+	"time"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/golang/protobuf/ptypes/timestamp"
+	"github.com/hyperledger/fabric/common/crypto"
+	cb "github.com/hyperledger/fabric/protos/common"
+	pb "github.com/hyperledger/fabric/protos/peer"
+	"github.com/pkg/errors"
+)
+
+// MarshalOrPanic serializes a protobuf message and panics if this
+// operation fails
+func MarshalOrPanic(pb proto.Message) []byte {
+	data, err := proto.Marshal(pb)
+	if err != nil {
+		panic(err)
+	}
+	return data
+}
+
+// Marshal serializes a protobuf message.
+func Marshal(pb proto.Message) ([]byte, error) {
+	return proto.Marshal(pb)
+}
+
+// CreateNonceOrPanic generates a nonce using the common/crypto package
+// and panics if this operation fails.
+func CreateNonceOrPanic() []byte {
+	nonce, err := CreateNonce()
+	if err != nil {
+		panic(err)
+	}
+	return nonce
+}
+
+// CreateNonce generates a nonce using the common/crypto package.
+func CreateNonce() ([]byte, error) {
+	nonce, err := crypto.GetRandomNonce()
+	return nonce, errors.WithMessage(err, "error generating random nonce")
+}
+
+// UnmarshalPayloadOrPanic unmarshals bytes to a Payload structure or panics
+// on error
+func UnmarshalPayloadOrPanic(encoded []byte) *cb.Payload {
+	payload, err := UnmarshalPayload(encoded)
+	if err != nil {
+		panic(err)
+	}
+	return payload
+}
+
+// UnmarshalPayload unmarshals bytes to a Payload structure
+func UnmarshalPayload(encoded []byte) (*cb.Payload, error) {
+	payload := &cb.Payload{}
+	err := proto.Unmarshal(encoded, payload)
+	return payload, errors.Wrap(err, "error unmarshaling Payload")
+}
+
+// UnmarshalEnvelopeOrPanic unmarshals bytes to an Envelope structure or panics
+// on error
+func UnmarshalEnvelopeOrPanic(encoded []byte) *cb.Envelope {
+	envelope, err := UnmarshalEnvelope(encoded)
+	if err != nil {
+		panic(err)
+	}
+	return envelope
+}
+
+// UnmarshalEnvelope unmarshals bytes to an Envelope structure
+func UnmarshalEnvelope(encoded []byte) (*cb.Envelope, error) {
+	envelope := &cb.Envelope{}
+	err := proto.Unmarshal(encoded, envelope)
+	return envelope, errors.Wrap(err, "error unmarshaling Envelope")
+}
+
+// UnmarshalBlockOrPanic unmarshals bytes to an Block structure or panics
+// on error
+func UnmarshalBlockOrPanic(encoded []byte) *cb.Block {
+	block, err := UnmarshalBlock(encoded)
+	if err != nil {
+		panic(err)
+	}
+	return block
+}
+
+// UnmarshalBlock unmarshals bytes to an Block structure
+func UnmarshalBlock(encoded []byte) (*cb.Block, error) {
+	block := &cb.Block{}
+	err := proto.Unmarshal(encoded, block)
+	return block, errors.Wrap(err, "error unmarshaling Block")
+}
+
+// UnmarshalEnvelopeOfType unmarshals an envelope of the specified type,
+// including unmarshaling the payload data
+func UnmarshalEnvelopeOfType(envelope *cb.Envelope, headerType cb.HeaderType, message proto.Message) (*cb.ChannelHeader, error) {
+	payload, err := UnmarshalPayload(envelope.Payload)
+	if err != nil {
+		return nil, err
+	}
+
+	if payload.Header == nil {
+		return nil, errors.New("envelope must have a Header")
+	}
+
+	chdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	if chdr.Type != int32(headerType) {
+		return nil, errors.Errorf("invalid type %s, expected %s", cb.HeaderType(chdr.Type), headerType)
+	}
+
+	err = proto.Unmarshal(payload.Data, message)
+	err = errors.Wrapf(err, "error unmarshaling message for type %s", headerType)
+	return chdr, err
+}
+
+// ExtractEnvelopeOrPanic retrieves the requested envelope from a given block
+// and unmarshals it -- it panics if either of these operations fail
+func ExtractEnvelopeOrPanic(block *cb.Block, index int) *cb.Envelope {
+	envelope, err := ExtractEnvelope(block, index)
+	if err != nil {
+		panic(err)
+	}
+	return envelope
+}
+
+// ExtractEnvelope retrieves the requested envelope from a given block and
+// unmarshals it
+func ExtractEnvelope(block *cb.Block, index int) (*cb.Envelope, error) {
+	if block.Data == nil {
+		return nil, errors.New("block data is nil")
+	}
+
+	envelopeCount := len(block.Data.Data)
+	if index < 0 || index >= envelopeCount {
+		return nil, errors.New("envelope index out of bounds")
+	}
+	marshaledEnvelope := block.Data.Data[index]
+	envelope, err := GetEnvelopeFromBlock(marshaledEnvelope)
+	err = errors.WithMessage(err, fmt.Sprintf("block data does not carry an envelope at index %d", index))
+	return envelope, err
+}
+
+// ExtractPayloadOrPanic retrieves the payload of a given envelope and
+// unmarshals it -- it panics if either of these operations fail
+func ExtractPayloadOrPanic(envelope *cb.Envelope) *cb.Payload {
+	payload, err := ExtractPayload(envelope)
+	if err != nil {
+		panic(err)
+	}
+	return payload
+}
+
+// ExtractPayload retrieves the payload of a given envelope and unmarshals it.
+func ExtractPayload(envelope *cb.Envelope) (*cb.Payload, error) {
+	payload := &cb.Payload{}
+	err := proto.Unmarshal(envelope.Payload, payload)
+	err = errors.Wrap(err, "no payload in envelope")
+	return payload, err
+}
+
+// MakeChannelHeader creates a ChannelHeader.
+func MakeChannelHeader(headerType cb.HeaderType, version int32, chainID string, epoch uint64) *cb.ChannelHeader {
+	return &cb.ChannelHeader{
+		Type:    int32(headerType),
+		Version: version,
+		Timestamp: &timestamp.Timestamp{
+			Seconds: time.Now().Unix(),
+			Nanos:   0,
+		},
+		ChannelId: chainID,
+		Epoch:     epoch,
+	}
+}
+
+// MakeSignatureHeader creates a SignatureHeader.
+func MakeSignatureHeader(serializedCreatorCertChain []byte, nonce []byte) *cb.SignatureHeader {
+	return &cb.SignatureHeader{
+		Creator: serializedCreatorCertChain,
+		Nonce:   nonce,
+	}
+}
+
+// SetTxID generates a transaction id based on the provided signature header
+// and sets the TxId field in the channel header
+func SetTxID(channelHeader *cb.ChannelHeader, signatureHeader *cb.SignatureHeader) error {
+	txid, err := ComputeTxID(
+		signatureHeader.Nonce,
+		signatureHeader.Creator,
+	)
+	if err != nil {
+		return err
+	}
+	channelHeader.TxId = txid
+	return nil
+}
+
+// MakePayloadHeader creates a Payload Header.
+func MakePayloadHeader(ch *cb.ChannelHeader, sh *cb.SignatureHeader) *cb.Header {
+	return &cb.Header{
+		ChannelHeader:   MarshalOrPanic(ch),
+		SignatureHeader: MarshalOrPanic(sh),
+	}
+}
+
+// NewSignatureHeaderOrPanic returns a signature header and panics on error.
+func NewSignatureHeaderOrPanic(signer crypto.LocalSigner) *cb.SignatureHeader {
+	if signer == nil {
+		panic(errors.New("invalid signer. cannot be nil"))
+	}
+
+	signatureHeader, err := signer.NewSignatureHeader()
+	if err != nil {
+		panic(fmt.Errorf("failed generating a new SignatureHeader: %s", err))
+	}
+	return signatureHeader
+}
+
+// SignOrPanic signs a message and panics on error.
+func SignOrPanic(signer crypto.LocalSigner, msg []byte) []byte {
+	if signer == nil {
+		panic(errors.New("invalid signer. cannot be nil"))
+	}
+
+	sigma, err := signer.Sign(msg)
+	if err != nil {
+		panic(fmt.Errorf("failed generating signature: %s", err))
+	}
+	return sigma
+}
+
+// UnmarshalChannelHeader returns a ChannelHeader from bytes
+func UnmarshalChannelHeader(bytes []byte) (*cb.ChannelHeader, error) {
+	chdr := &cb.ChannelHeader{}
+	err := proto.Unmarshal(bytes, chdr)
+	return chdr, errors.Wrap(err, "error unmarshaling ChannelHeader")
+}
+
+// UnmarshalChannelHeaderOrPanic unmarshals bytes to a ChannelHeader or panics
+// on error
+func UnmarshalChannelHeaderOrPanic(bytes []byte) *cb.ChannelHeader {
+	chdr, err := UnmarshalChannelHeader(bytes)
+	if err != nil {
+		panic(err)
+	}
+	return chdr
+}
+
+// UnmarshalChaincodeID returns a ChaincodeID from bytes
+func UnmarshalChaincodeID(bytes []byte) (*pb.ChaincodeID, error) {
+	ccid := &pb.ChaincodeID{}
+	err := proto.Unmarshal(bytes, ccid)
+	if err != nil {
+		return nil, errors.Wrap(err, "error unmarshaling ChaincodeID")
+	}
+
+	return ccid, nil
+}
+
+// IsConfigBlock validates whenever given block contains configuration
+// update transaction
+func IsConfigBlock(block *cb.Block) bool {
+	envelope, err := ExtractEnvelope(block, 0)
+	if err != nil {
+		return false
+	}
+
+	payload, err := GetPayload(envelope)
+	if err != nil {
+		return false
+	}
+
+	if payload.Header == nil {
+		return false
+	}
+
+	hdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)
+	if err != nil {
+		return false
+	}
+
+	return cb.HeaderType(hdr.Type) == cb.HeaderType_CONFIG || cb.HeaderType(hdr.Type) == cb.HeaderType_ORDERER_TRANSACTION
+}
+
+// ChannelHeader returns the *cb.ChannelHeader for a given *cb.Envelope.
+func ChannelHeader(env *cb.Envelope) (*cb.ChannelHeader, error) {
+	envPayload, err := UnmarshalPayload(env.Payload)
+	if err != nil {
+		return nil, err
+	}
+
+	if envPayload.Header == nil {
+		return nil, errors.New("header not set")
+	}
+
+	if envPayload.Header.ChannelHeader == nil {
+		return nil, errors.New("channel header not set")
+	}
+
+	chdr, err := UnmarshalChannelHeader(envPayload.Header.ChannelHeader)
+	if err != nil {
+		return nil, errors.WithMessage(err, "error unmarshaling channel header")
+	}
+
+	return chdr, nil
+}
+
+// ChannelID returns the Channel ID for a given *cb.Envelope.
+func ChannelID(env *cb.Envelope) (string, error) {
+	chdr, err := ChannelHeader(env)
+	if err != nil {
+		return "", errors.WithMessage(err, "error retrieving channel header")
+	}
+
+	return chdr.ChannelId, nil
+}
+
+// EnvelopeToConfigUpdate is used to extract a ConfigUpdateEnvelope from an envelope of
+// type CONFIG_UPDATE
+func EnvelopeToConfigUpdate(configtx *cb.Envelope) (*cb.ConfigUpdateEnvelope, error) {
+	configUpdateEnv := &cb.ConfigUpdateEnvelope{}
+	_, err := UnmarshalEnvelopeOfType(configtx, cb.HeaderType_CONFIG_UPDATE, configUpdateEnv)
+	if err != nil {
+		return nil, err
+	}
+	return configUpdateEnv, nil
+}
diff --git a/protoutil/commonutils_test.go b/protoutil/commonutils_test.go
new file mode 100644
index 00000000..1fcedd87
--- /dev/null
+++ b/protoutil/commonutils_test.go
@@ -0,0 +1,429 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"bytes"
+	"errors"
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/common/crypto"
+	cb "github.com/hyperledger/fabric/protos/common"
+	pb "github.com/hyperledger/fabric/protos/peer"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestNonceRandomness(t *testing.T) {
+	n1, err := CreateNonce()
+	if err != nil {
+		t.Fatal(err)
+	}
+	n2, err := CreateNonce()
+	if err != nil {
+		t.Fatal(err)
+	}
+	if bytes.Equal(n1, n2) {
+		t.Fatalf("Expected nonces to be different, got %x and %x", n1, n2)
+	}
+}
+
+func TestNonceLength(t *testing.T) {
+	n, err := CreateNonce()
+	if err != nil {
+		t.Fatal(err)
+	}
+	actual := len(n)
+	expected := crypto.NonceSize
+	if actual != expected {
+		t.Fatalf("Expected nonce to be of size %d, got %d instead", expected, actual)
+	}
+
+}
+
+func TestUnmarshalPayload(t *testing.T) {
+	var payload *cb.Payload
+	good, _ := proto.Marshal(&cb.Payload{
+		Data: []byte("payload"),
+	})
+	payload, err := UnmarshalPayload(good)
+	assert.NoError(t, err, "Unexpected error unmarshaling payload")
+	assert.NotNil(t, payload, "Payload should not be nil")
+	payload = UnmarshalPayloadOrPanic(good)
+	assert.NotNil(t, payload, "Payload should not be nil")
+
+	bad := []byte("bad payload")
+	assert.Panics(t, func() {
+		_ = UnmarshalPayloadOrPanic(bad)
+	}, "Expected panic unmarshaling malformed payload")
+
+}
+
+func TestUnmarshalEnvelope(t *testing.T) {
+	var env *cb.Envelope
+	good, _ := proto.Marshal(&cb.Envelope{})
+	env, err := UnmarshalEnvelope(good)
+	assert.NoError(t, err, "Unexpected error unmarshaling envelope")
+	assert.NotNil(t, env, "Envelope should not be nil")
+	env = UnmarshalEnvelopeOrPanic(good)
+	assert.NotNil(t, env, "Envelope should not be nil")
+
+	bad := []byte("bad envelope")
+	assert.Panics(t, func() {
+		_ = UnmarshalEnvelopeOrPanic(bad)
+	}, "Expected panic unmarshaling malformed envelope")
+
+}
+
+func TestUnmarshalBlock(t *testing.T) {
+	var env *cb.Block
+	good, _ := proto.Marshal(&cb.Block{})
+	env, err := UnmarshalBlock(good)
+	assert.NoError(t, err, "Unexpected error unmarshaling block")
+	assert.NotNil(t, env, "Block should not be nil")
+	env = UnmarshalBlockOrPanic(good)
+	assert.NotNil(t, env, "Block should not be nil")
+
+	bad := []byte("bad block")
+	assert.Panics(t, func() {
+		_ = UnmarshalBlockOrPanic(bad)
+	}, "Expected panic unmarshaling malformed block")
+
+}
+
+func TestUnmarshalEnvelopeOfType(t *testing.T) {
+	env := &cb.Envelope{}
+
+	env.Payload = []byte("bad payload")
+	_, err := UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, nil)
+	assert.Error(t, err, "Expected error unmarshaling malformed envelope")
+
+	payload, _ := proto.Marshal(&cb.Payload{
+		Header: nil,
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, nil)
+	assert.Error(t, err, "Expected error with missing payload header")
+
+	payload, _ = proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: []byte("bad header"),
+		},
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, nil)
+	assert.Error(t, err, "Expected error for malformed channel header")
+
+	chdr, _ := proto.Marshal(&cb.ChannelHeader{
+		Type: int32(cb.HeaderType_CHAINCODE_PACKAGE),
+	})
+	payload, _ = proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: chdr,
+		},
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, nil)
+	assert.Error(t, err, "Expected error for wrong channel header type")
+
+	chdr, _ = proto.Marshal(&cb.ChannelHeader{
+		Type: int32(cb.HeaderType_CONFIG),
+	})
+	payload, _ = proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: chdr,
+		},
+		Data: []byte("bad data"),
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, &cb.ConfigEnvelope{})
+	assert.Error(t, err, "Expected error for malformed payload data")
+
+	chdr, _ = proto.Marshal(&cb.ChannelHeader{
+		Type: int32(cb.HeaderType_CONFIG),
+	})
+	configEnv, _ := proto.Marshal(&cb.ConfigEnvelope{})
+	payload, _ = proto.Marshal(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: chdr,
+		},
+		Data: configEnv,
+	})
+	env.Payload = payload
+	_, err = UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, &cb.ConfigEnvelope{})
+	assert.NoError(t, err, "Unexpected error unmarshaling envelope")
+
+}
+
+func TestExtractEnvelopeNilData(t *testing.T) {
+	block := &cb.Block{}
+	_, err := ExtractEnvelope(block, 0)
+	assert.Error(t, err, "Nil data")
+}
+
+func TestExtractEnvelopeWrongIndex(t *testing.T) {
+	block := testBlock()
+	if _, err := ExtractEnvelope(block, len(block.GetData().Data)); err == nil {
+		t.Fatal("Expected envelope extraction to fail (wrong index)")
+	}
+}
+
+func TestExtractEnvelopeWrongIndexOrPanic(t *testing.T) {
+	defer func() {
+		if r := recover(); r == nil {
+			t.Fatal("Expected envelope extraction to panic (wrong index)")
+		}
+	}()
+
+	block := testBlock()
+	ExtractEnvelopeOrPanic(block, len(block.GetData().Data))
+}
+
+func TestExtractEnvelope(t *testing.T) {
+	if envelope, err := ExtractEnvelope(testBlock(), 0); err != nil {
+		t.Fatalf("Expected envelop extraction to succeed: %s", err)
+	} else if !proto.Equal(envelope, testEnvelope()) {
+		t.Fatal("Expected extracted envelope to match test envelope")
+	}
+}
+
+func TestExtractEnvelopeOrPanic(t *testing.T) {
+	defer func() {
+		if r := recover(); r != nil {
+			t.Fatal("Expected envelope extraction to succeed")
+		}
+	}()
+
+	if !proto.Equal(ExtractEnvelopeOrPanic(testBlock(), 0), testEnvelope()) {
+		t.Fatal("Expected extracted envelope to match test envelope")
+	}
+}
+
+func TestExtractPayload(t *testing.T) {
+	if payload, err := ExtractPayload(testEnvelope()); err != nil {
+		t.Fatalf("Expected payload extraction to succeed: %s", err)
+	} else if !proto.Equal(payload, testPayload()) {
+		t.Fatal("Expected extracted payload to match test payload")
+	}
+}
+
+func TestExtractPayloadOrPanic(t *testing.T) {
+	defer func() {
+		if r := recover(); r != nil {
+			t.Fatal("Expected payload extraction to succeed")
+		}
+	}()
+
+	if !proto.Equal(ExtractPayloadOrPanic(testEnvelope()), testPayload()) {
+		t.Fatal("Expected extracted payload to match test payload")
+	}
+}
+
+func TestUnmarshalChaincodeID(t *testing.T) {
+	ccname := "mychaincode"
+	ccversion := "myversion"
+	ccidbytes, _ := proto.Marshal(&pb.ChaincodeID{
+		Name:    ccname,
+		Version: ccversion,
+	})
+	ccid, err := UnmarshalChaincodeID(ccidbytes)
+	assert.Equal(t, ccname, ccid.Name, "Expected ccid names to match")
+	assert.Equal(t, ccversion, ccid.Version, "Expected ccid versions to match")
+
+	_, err = UnmarshalChaincodeID([]byte("bad chaincodeID"))
+	assert.Error(t, err, "Expected error marshaling malformed chaincode ID")
+}
+
+func TestNewSignatureHeaderOrPanic(t *testing.T) {
+	var sigHeader *cb.SignatureHeader
+
+	sigHeader = NewSignatureHeaderOrPanic(goodSigner)
+	assert.NotNil(t, sigHeader, "Signature header should not be nil")
+
+	assert.Panics(t, func() {
+		_ = NewSignatureHeaderOrPanic(nil)
+	}, "Expected panic with nil signer")
+
+	assert.Panics(t, func() {
+		_ = NewSignatureHeaderOrPanic(badSigner)
+	}, "Expected panic with signature header error")
+
+}
+
+func TestSignOrPanic(t *testing.T) {
+	msg := []byte("sign me")
+	sig := SignOrPanic(goodSigner, msg)
+	// mock signer returns message to be signed
+	assert.Equal(t, msg, sig, "Signature does not match expected value")
+
+	assert.Panics(t, func() {
+		_ = SignOrPanic(nil, []byte("sign me"))
+	}, "Expected panic with nil signer")
+
+	assert.Panics(t, func() {
+		_ = SignOrPanic(badSigner, []byte("sign me"))
+	}, "Expected panic with sign error")
+}
+
+// Helper functions
+
+func testPayload() *cb.Payload {
+	return &cb.Payload{
+		Header: MakePayloadHeader(
+			MakeChannelHeader(cb.HeaderType_MESSAGE, int32(1), "test", 0),
+			MakeSignatureHeader([]byte("creator"), []byte("nonce"))),
+		Data: []byte("test"),
+	}
+}
+
+func testEnvelope() *cb.Envelope {
+	// No need to set the signature
+	return &cb.Envelope{Payload: MarshalOrPanic(testPayload())}
+}
+
+func testBlock() *cb.Block {
+	// No need to set the block's Header, or Metadata
+	return &cb.Block{
+		Data: &cb.BlockData{
+			Data: [][]byte{MarshalOrPanic(testEnvelope())},
+		},
+	}
+}
+
+// mock
+var badSigner = &mockLocalSigner{
+	returnError: true,
+}
+
+var goodSigner = &mockLocalSigner{
+	returnError: false,
+}
+
+type mockLocalSigner struct {
+	returnError bool
+}
+
+func (m *mockLocalSigner) NewSignatureHeader() (*cb.SignatureHeader, error) {
+	if m.returnError {
+		return nil, errors.New("signature header error")
+	}
+	return &cb.SignatureHeader{}, nil
+}
+
+func (m *mockLocalSigner) Sign(message []byte) ([]byte, error) {
+	if m.returnError {
+		return nil, errors.New("sign error")
+	}
+	return message, nil
+}
+
+func TestChannelHeader(t *testing.T) {
+	makeEnvelope := func(payload *cb.Payload) *cb.Envelope {
+		return &cb.Envelope{
+			Payload: MarshalOrPanic(payload),
+		}
+	}
+
+	_, err := ChannelHeader(makeEnvelope(&cb.Payload{
+		Header: &cb.Header{
+			ChannelHeader: MarshalOrPanic(&cb.ChannelHeader{
+				ChannelId: "foo",
+			}),
+		},
+	}))
+	assert.NoError(t, err, "Channel header was present")
+
+	_, err = ChannelHeader(makeEnvelope(&cb.Payload{
+		Header: &cb.Header{},
+	}))
+	assert.Error(t, err, "ChannelHeader was missing")
+
+	_, err = ChannelHeader(makeEnvelope(&cb.Payload{}))
+	assert.Error(t, err, "Header was missing")
+
+	_, err = ChannelHeader(&cb.Envelope{})
+	assert.Error(t, err, "Payload was missing")
+}
+
+func TestIsConfigBlock(t *testing.T) {
+	newBlock := func(env *cb.Envelope) *cb.Block {
+		return &cb.Block{
+			Data: &cb.BlockData{
+				Data: [][]byte{MarshalOrPanic(env)},
+			},
+		}
+	}
+
+	newConfigEnv := func(envType int32) *cb.Envelope {
+		return &cb.Envelope{
+			Payload: MarshalOrPanic(&cb.Payload{
+				Header: &cb.Header{
+					ChannelHeader: MarshalOrPanic(&cb.ChannelHeader{
+						Type:      envType,
+						ChannelId: "test-chain",
+					}),
+				},
+				Data: []byte("test bytes"),
+			}), // common.Payload
+		} // LastUpdate
+	}
+
+	// scenario 1: CONFIG envelope
+	envType := int32(cb.HeaderType_CONFIG)
+	env := newConfigEnv(envType)
+	block := newBlock(env)
+
+	result := IsConfigBlock(block)
+	assert.True(t, result, "IsConfigBlock returns true for blocks with CONFIG envelope")
+
+	// scenario 2: ORDERER_TRANSACTION envelope
+	envType = int32(cb.HeaderType_ORDERER_TRANSACTION)
+	env = newConfigEnv(envType)
+	block = newBlock(env)
+
+	result = IsConfigBlock(block)
+	assert.True(t, result, "IsConfigBlock returns true for blocks with ORDERER_TRANSACTION envelope")
+
+	// scenario 3: MESSAGE envelope
+	envType = int32(cb.HeaderType_MESSAGE)
+	env = newConfigEnv(envType)
+	block = newBlock(env)
+
+	result = IsConfigBlock(block)
+	assert.False(t, result, "IsConfigBlock returns false for blocks with MESSAGE envelope")
+}
+
+func TestEnvelopeToConfigUpdate(t *testing.T) {
+
+	makeEnv := func(data []byte) *cb.Envelope {
+		return &cb.Envelope{
+			Payload: MarshalOrPanic(&cb.Payload{
+				Header: &cb.Header{
+					ChannelHeader: MarshalOrPanic(&cb.ChannelHeader{
+						Type:      int32(cb.HeaderType_CONFIG_UPDATE),
+						ChannelId: "test-chain",
+					}),
+				},
+				Data: data,
+			}), // common.Payload
+		} // LastUpdate
+	}
+
+	// scenario 1: for valid envelopes
+	configUpdateEnv := &cb.ConfigUpdateEnvelope{}
+	env := makeEnv(MarshalOrPanic(configUpdateEnv))
+	result, err := EnvelopeToConfigUpdate(env)
+
+	assert.NoError(t, err, "EnvelopeToConfigUpdate runs without error for valid CONFIG_UPDATE envelope")
+	assert.Equal(t, configUpdateEnv, result, "Correct configUpdateEnvelope returned")
+
+	// scenario 2: for invalid envelopes
+	env = makeEnv([]byte("test bytes"))
+	_, err = EnvelopeToConfigUpdate(env)
+
+	assert.Error(t, err, "EnvelopeToConfigUpdate fails with error for invalid CONFIG_UPDATE envelope")
+}
diff --git a/protoutil/proputils.go b/protoutil/proputils.go
new file mode 100644
index 00000000..7b67b0a6
--- /dev/null
+++ b/protoutil/proputils.go
@@ -0,0 +1,642 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"encoding/binary"
+	"encoding/hex"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/bccsp"
+	"github.com/hyperledger/fabric/bccsp/factory"
+	"github.com/hyperledger/fabric/common/crypto"
+	"github.com/hyperledger/fabric/common/util"
+	"github.com/hyperledger/fabric/core/chaincode/platforms"
+	"github.com/hyperledger/fabric/protos/common"
+	"github.com/hyperledger/fabric/protos/peer"
+	"github.com/pkg/errors"
+)
+
+// GetChaincodeInvocationSpec get the ChaincodeInvocationSpec from the proposal
+func GetChaincodeInvocationSpec(prop *peer.Proposal) (*peer.ChaincodeInvocationSpec, error) {
+	if prop == nil {
+		return nil, errors.New("proposal is nil")
+	}
+	_, err := GetHeader(prop.Header)
+	if err != nil {
+		return nil, err
+	}
+	ccPropPayload, err := GetChaincodeProposalPayload(prop.Payload)
+	if err != nil {
+		return nil, err
+	}
+	cis := &peer.ChaincodeInvocationSpec{}
+	err = proto.Unmarshal(ccPropPayload.Input, cis)
+	return cis, errors.Wrap(err, "error unmarshaling ChaincodeInvocationSpec")
+}
+
+// GetChaincodeProposalContext returns creator and transient
+func GetChaincodeProposalContext(prop *peer.Proposal) ([]byte, map[string][]byte, error) {
+	if prop == nil {
+		return nil, nil, errors.New("proposal is nil")
+	}
+	if len(prop.Header) == 0 {
+		return nil, nil, errors.New("proposal's header is nil")
+	}
+	if len(prop.Payload) == 0 {
+		return nil, nil, errors.New("proposal's payload is nil")
+	}
+	// get back the header
+	hdr, err := GetHeader(prop.Header)
+	if err != nil {
+		return nil, nil, errors.WithMessage(err, "error extracting header from proposal")
+	}
+	if hdr == nil {
+		return nil, nil, errors.New("unmarshaled header is nil")
+	}
+
+	chdr, err := UnmarshalChannelHeader(hdr.ChannelHeader)
+	if err != nil {
+		return nil, nil, errors.WithMessage(err, "error extracting channel header from proposal")
+	}
+
+	if err = validateChannelHeaderType(chdr, []common.HeaderType{common.HeaderType_ENDORSER_TRANSACTION, common.HeaderType_CONFIG}); err != nil {
+		return nil, nil, errors.WithMessage(err, "invalid proposal")
+	}
+
+	shdr, err := GetSignatureHeader(hdr.SignatureHeader)
+	if err != nil {
+		return nil, nil, errors.WithMessage(err, "error extracting signature header from proposal")
+	}
+
+	ccPropPayload, err := GetChaincodeProposalPayload(prop.Payload)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	return shdr.Creator, ccPropPayload.TransientMap, nil
+}
+
+func validateChannelHeaderType(chdr *common.ChannelHeader, expectedTypes []common.HeaderType) error {
+	for _, t := range expectedTypes {
+		if common.HeaderType(chdr.Type) == t {
+			return nil
+		}
+	}
+	return errors.Errorf("invalid channel header type. expected one of %s, received %s", expectedTypes, common.HeaderType(chdr.Type))
+}
+
+// GetHeader Get Header from bytes
+func GetHeader(bytes []byte) (*common.Header, error) {
+	hdr := &common.Header{}
+	err := proto.Unmarshal(bytes, hdr)
+	return hdr, errors.Wrap(err, "error unmarshaling Header")
+}
+
+// GetNonce returns the nonce used in Proposal
+func GetNonce(prop *peer.Proposal) ([]byte, error) {
+	if prop == nil {
+		return nil, errors.New("proposal is nil")
+	}
+
+	// get back the header
+	hdr, err := GetHeader(prop.Header)
+	if err != nil {
+		return nil, err
+	}
+
+	chdr, err := UnmarshalChannelHeader(hdr.ChannelHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	if err = validateChannelHeaderType(chdr, []common.HeaderType{common.HeaderType_ENDORSER_TRANSACTION, common.HeaderType_CONFIG}); err != nil {
+		return nil, errors.WithMessage(err, "invalid proposal")
+	}
+
+	shdr, err := GetSignatureHeader(hdr.SignatureHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	if hdr.SignatureHeader == nil {
+		return nil, errors.New("invalid signature header. cannot be nil")
+	}
+
+	return shdr.Nonce, nil
+}
+
+// GetChaincodeHeaderExtension get chaincode header extension given header
+func GetChaincodeHeaderExtension(hdr *common.Header) (*peer.ChaincodeHeaderExtension, error) {
+	chdr, err := UnmarshalChannelHeader(hdr.ChannelHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	chaincodeHdrExt := &peer.ChaincodeHeaderExtension{}
+	err = proto.Unmarshal(chdr.Extension, chaincodeHdrExt)
+	return chaincodeHdrExt, errors.Wrap(err, "error unmarshaling ChaincodeHeaderExtension")
+}
+
+// GetProposalResponse given proposal in bytes
+func GetProposalResponse(prBytes []byte) (*peer.ProposalResponse, error) {
+	proposalResponse := &peer.ProposalResponse{}
+	err := proto.Unmarshal(prBytes, proposalResponse)
+	return proposalResponse, errors.Wrap(err, "error unmarshaling ProposalResponse")
+}
+
+// GetChaincodeDeploymentSpec returns a ChaincodeDeploymentSpec given args
+func GetChaincodeDeploymentSpec(code []byte, pr *platforms.Registry) (*peer.ChaincodeDeploymentSpec, error) {
+	cds := &peer.ChaincodeDeploymentSpec{}
+	err := proto.Unmarshal(code, cds)
+	if err != nil {
+		return nil, errors.Wrap(err, "error unmarshaling ChaincodeDeploymentSpec")
+	}
+
+	// FAB-2122: Validate the CDS according to platform specific requirements
+	return cds, pr.ValidateDeploymentSpec(cds.CCType(), cds.Bytes())
+}
+
+// GetChaincodeAction gets the ChaincodeAction given chaicnode action bytes
+func GetChaincodeAction(caBytes []byte) (*peer.ChaincodeAction, error) {
+	chaincodeAction := &peer.ChaincodeAction{}
+	err := proto.Unmarshal(caBytes, chaincodeAction)
+	return chaincodeAction, errors.Wrap(err, "error unmarshaling ChaincodeAction")
+}
+
+// GetResponse gets the Response given response bytes
+func GetResponse(resBytes []byte) (*peer.Response, error) {
+	response := &peer.Response{}
+	err := proto.Unmarshal(resBytes, response)
+	return response, errors.Wrap(err, "error unmarshaling Response")
+}
+
+// GetChaincodeEvents gets the ChaincodeEvents given chaincode event bytes
+func GetChaincodeEvents(eBytes []byte) (*peer.ChaincodeEvent, error) {
+	chaincodeEvent := &peer.ChaincodeEvent{}
+	err := proto.Unmarshal(eBytes, chaincodeEvent)
+	return chaincodeEvent, errors.Wrap(err, "error unmarshaling ChaicnodeEvent")
+}
+
+// GetProposalResponsePayload gets the proposal response payload
+func GetProposalResponsePayload(prpBytes []byte) (*peer.ProposalResponsePayload, error) {
+	prp := &peer.ProposalResponsePayload{}
+	err := proto.Unmarshal(prpBytes, prp)
+	return prp, errors.Wrap(err, "error unmarshaling ProposalResponsePayload")
+}
+
+// GetProposal returns a Proposal message from its bytes
+func GetProposal(propBytes []byte) (*peer.Proposal, error) {
+	prop := &peer.Proposal{}
+	err := proto.Unmarshal(propBytes, prop)
+	return prop, errors.Wrap(err, "error unmarshaling Proposal")
+}
+
+// GetPayload Get Payload from Envelope message
+func GetPayload(e *common.Envelope) (*common.Payload, error) {
+	payload := &common.Payload{}
+	err := proto.Unmarshal(e.Payload, payload)
+	return payload, errors.Wrap(err, "error unmarshaling Payload")
+}
+
+// GetTransaction Get Transaction from bytes
+func GetTransaction(txBytes []byte) (*peer.Transaction, error) {
+	tx := &peer.Transaction{}
+	err := proto.Unmarshal(txBytes, tx)
+	return tx, errors.Wrap(err, "error unmarshaling Transaction")
+
+}
+
+// GetChaincodeActionPayload Get ChaincodeActionPayload from bytes
+func GetChaincodeActionPayload(capBytes []byte) (*peer.ChaincodeActionPayload, error) {
+	cap := &peer.ChaincodeActionPayload{}
+	err := proto.Unmarshal(capBytes, cap)
+	return cap, errors.Wrap(err, "error unmarshaling ChaincodeActionPayload")
+}
+
+// GetChaincodeProposalPayload Get ChaincodeProposalPayload from bytes
+func GetChaincodeProposalPayload(bytes []byte) (*peer.ChaincodeProposalPayload, error) {
+	cpp := &peer.ChaincodeProposalPayload{}
+	err := proto.Unmarshal(bytes, cpp)
+	return cpp, errors.Wrap(err, "error unmarshaling ChaincodeProposalPayload")
+}
+
+// GetSignatureHeader Get SignatureHeader from bytes
+func GetSignatureHeader(bytes []byte) (*common.SignatureHeader, error) {
+	sh := &common.SignatureHeader{}
+	err := proto.Unmarshal(bytes, sh)
+	return sh, errors.Wrap(err, "error unmarshaling SignatureHeader")
+}
+
+// CreateChaincodeProposal creates a proposal from given input.
+// It returns the proposal and the transaction id associated to the proposal
+func CreateChaincodeProposal(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte) (*peer.Proposal, string, error) {
+	return CreateChaincodeProposalWithTransient(typ, chainID, cis, creator, nil)
+}
+
+// CreateChaincodeProposalWithTransient creates a proposal from given input
+// It returns the proposal and the transaction id associated to the proposal
+func CreateChaincodeProposalWithTransient(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte, transientMap map[string][]byte) (*peer.Proposal, string, error) {
+	// generate a random nonce
+	nonce, err := crypto.GetRandomNonce()
+	if err != nil {
+		return nil, "", err
+	}
+
+	// compute txid
+	txid, err := ComputeTxID(nonce, creator)
+	if err != nil {
+		return nil, "", err
+	}
+
+	return CreateChaincodeProposalWithTxIDNonceAndTransient(txid, typ, chainID, cis, nonce, creator, transientMap)
+}
+
+// CreateChaincodeProposalWithTxIDAndTransient creates a proposal from given
+// input. It returns the proposal and the transaction id associated with the
+// proposal
+func CreateChaincodeProposalWithTxIDAndTransient(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte, txid string, transientMap map[string][]byte) (*peer.Proposal, string, error) {
+	// generate a random nonce
+	nonce, err := crypto.GetRandomNonce()
+	if err != nil {
+		return nil, "", err
+	}
+
+	// compute txid unless provided by tests
+	if txid == "" {
+		txid, err = ComputeTxID(nonce, creator)
+		if err != nil {
+			return nil, "", err
+		}
+	}
+
+	return CreateChaincodeProposalWithTxIDNonceAndTransient(txid, typ, chainID, cis, nonce, creator, transientMap)
+}
+
+// CreateChaincodeProposalWithTxIDNonceAndTransient creates a proposal from
+// given input
+func CreateChaincodeProposalWithTxIDNonceAndTransient(txid string, typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, nonce, creator []byte, transientMap map[string][]byte) (*peer.Proposal, string, error) {
+	ccHdrExt := &peer.ChaincodeHeaderExtension{ChaincodeId: cis.ChaincodeSpec.ChaincodeId}
+	ccHdrExtBytes, err := proto.Marshal(ccHdrExt)
+	if err != nil {
+		return nil, "", errors.Wrap(err, "error marshaling ChaincodeHeaderExtension")
+	}
+
+	cisBytes, err := proto.Marshal(cis)
+	if err != nil {
+		return nil, "", errors.Wrap(err, "error marshaling ChaincodeInvocationSpec")
+	}
+
+	ccPropPayload := &peer.ChaincodeProposalPayload{Input: cisBytes, TransientMap: transientMap}
+	ccPropPayloadBytes, err := proto.Marshal(ccPropPayload)
+	if err != nil {
+		return nil, "", errors.Wrap(err, "error marshaling ChaincodeProposalPayload")
+	}
+
+	// TODO: epoch is now set to zero. This must be changed once we
+	// get a more appropriate mechanism to handle it in.
+	var epoch uint64
+
+	timestamp := util.CreateUtcTimestamp()
+
+	hdr := &common.Header{
+		ChannelHeader: MarshalOrPanic(
+			&common.ChannelHeader{
+				Type:      int32(typ),
+				TxId:      txid,
+				Timestamp: timestamp,
+				ChannelId: chainID,
+				Extension: ccHdrExtBytes,
+				Epoch:     epoch,
+			},
+		),
+		SignatureHeader: MarshalOrPanic(
+			&common.SignatureHeader{
+				Nonce:   nonce,
+				Creator: creator,
+			},
+		),
+	}
+
+	hdrBytes, err := proto.Marshal(hdr)
+	if err != nil {
+		return nil, "", err
+	}
+
+	prop := &peer.Proposal{
+		Header:  hdrBytes,
+		Payload: ccPropPayloadBytes,
+	}
+	return prop, txid, nil
+}
+
+// GetBytesProposalResponsePayload gets proposal response payload
+func GetBytesProposalResponsePayload(hash []byte, response *peer.Response, result []byte, event []byte, ccid *peer.ChaincodeID) ([]byte, error) {
+	cAct := &peer.ChaincodeAction{
+		Events: event, Results: result,
+		Response:    response,
+		ChaincodeId: ccid,
+	}
+	cActBytes, err := proto.Marshal(cAct)
+	if err != nil {
+		return nil, errors.Wrap(err, "error marshaling ChaincodeAction")
+	}
+
+	prp := &peer.ProposalResponsePayload{
+		Extension:    cActBytes,
+		ProposalHash: hash,
+	}
+	prpBytes, err := proto.Marshal(prp)
+	return prpBytes, errors.Wrap(err, "error marshaling ProposalResponsePayload")
+}
+
+// GetBytesChaincodeProposalPayload gets the chaincode proposal payload
+func GetBytesChaincodeProposalPayload(cpp *peer.ChaincodeProposalPayload) ([]byte, error) {
+	cppBytes, err := proto.Marshal(cpp)
+	return cppBytes, errors.Wrap(err, "error marshaling ChaincodeProposalPayload")
+}
+
+// GetBytesResponse gets the bytes of Response
+func GetBytesResponse(res *peer.Response) ([]byte, error) {
+	resBytes, err := proto.Marshal(res)
+	return resBytes, errors.Wrap(err, "error marshaling Response")
+}
+
+// GetBytesChaincodeEvent gets the bytes of ChaincodeEvent
+func GetBytesChaincodeEvent(event *peer.ChaincodeEvent) ([]byte, error) {
+	eventBytes, err := proto.Marshal(event)
+	return eventBytes, errors.Wrap(err, "error marshaling ChaincodeEvent")
+}
+
+// GetBytesChaincodeActionPayload get the bytes of ChaincodeActionPayload from
+// the message
+func GetBytesChaincodeActionPayload(cap *peer.ChaincodeActionPayload) ([]byte, error) {
+	capBytes, err := proto.Marshal(cap)
+	return capBytes, errors.Wrap(err, "error marshaling ChaincodeActionPayload")
+}
+
+// GetBytesProposalResponse gets proposal bytes response
+func GetBytesProposalResponse(pr *peer.ProposalResponse) ([]byte, error) {
+	respBytes, err := proto.Marshal(pr)
+	return respBytes, errors.Wrap(err, "error marshaling ProposalResponse")
+}
+
+// GetBytesProposal returns the bytes of a proposal message
+func GetBytesProposal(prop *peer.Proposal) ([]byte, error) {
+	propBytes, err := proto.Marshal(prop)
+	return propBytes, errors.Wrap(err, "error marshaling Proposal")
+}
+
+// GetBytesHeader get the bytes of Header from the message
+func GetBytesHeader(hdr *common.Header) ([]byte, error) {
+	bytes, err := proto.Marshal(hdr)
+	return bytes, errors.Wrap(err, "error marshaling Header")
+}
+
+// GetBytesSignatureHeader get the bytes of SignatureHeader from the message
+func GetBytesSignatureHeader(hdr *common.SignatureHeader) ([]byte, error) {
+	bytes, err := proto.Marshal(hdr)
+	return bytes, errors.Wrap(err, "error marshaling SignatureHeader")
+}
+
+// GetBytesTransaction get the bytes of Transaction from the message
+func GetBytesTransaction(tx *peer.Transaction) ([]byte, error) {
+	bytes, err := proto.Marshal(tx)
+	return bytes, errors.Wrap(err, "error unmarshaling Transaction")
+}
+
+// GetBytesPayload get the bytes of Payload from the message
+func GetBytesPayload(payl *common.Payload) ([]byte, error) {
+	bytes, err := proto.Marshal(payl)
+	return bytes, errors.Wrap(err, "error marshaling Payload")
+}
+
+// GetBytesEnvelope get the bytes of Envelope from the message
+func GetBytesEnvelope(env *common.Envelope) ([]byte, error) {
+	bytes, err := proto.Marshal(env)
+	return bytes, errors.Wrap(err, "error marshaling Envelope")
+}
+
+// GetActionFromEnvelope extracts a ChaincodeAction message from a
+// serialized Envelope
+// TODO: fix function name as per FAB-11831
+func GetActionFromEnvelope(envBytes []byte) (*peer.ChaincodeAction, error) {
+	env, err := GetEnvelopeFromBlock(envBytes)
+	if err != nil {
+		return nil, err
+	}
+	return GetActionFromEnvelopeMsg(env)
+}
+
+func GetActionFromEnvelopeMsg(env *common.Envelope) (*peer.ChaincodeAction, error) {
+	payl, err := GetPayload(env)
+	if err != nil {
+		return nil, err
+	}
+
+	tx, err := GetTransaction(payl.Data)
+	if err != nil {
+		return nil, err
+	}
+
+	if len(tx.Actions) == 0 {
+		return nil, errors.New("at least one TransactionAction required")
+	}
+
+	_, respPayload, err := GetPayloads(tx.Actions[0])
+	return respPayload, err
+}
+
+// CreateProposalFromCISAndTxid returns a proposal given a serialized identity
+// and a ChaincodeInvocationSpec
+func CreateProposalFromCISAndTxid(txid string, typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte) (*peer.Proposal, string, error) {
+	nonce, err := crypto.GetRandomNonce()
+	if err != nil {
+		return nil, "", err
+	}
+	return CreateChaincodeProposalWithTxIDNonceAndTransient(txid, typ, chainID, cis, nonce, creator, nil)
+}
+
+// CreateProposalFromCIS returns a proposal given a serialized identity and a
+// ChaincodeInvocationSpec
+func CreateProposalFromCIS(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte) (*peer.Proposal, string, error) {
+	return CreateChaincodeProposal(typ, chainID, cis, creator)
+}
+
+// CreateGetChaincodesProposal returns a GETCHAINCODES proposal given a
+// serialized identity
+func CreateGetChaincodesProposal(chainID string, creator []byte) (*peer.Proposal, string, error) {
+	ccinp := &peer.ChaincodeInput{Args: [][]byte{[]byte("getchaincodes")}}
+	lsccSpec := &peer.ChaincodeInvocationSpec{
+		ChaincodeSpec: &peer.ChaincodeSpec{
+			Type:        peer.ChaincodeSpec_GOLANG,
+			ChaincodeId: &peer.ChaincodeID{Name: "lscc"},
+			Input:       ccinp,
+		},
+	}
+	return CreateProposalFromCIS(common.HeaderType_ENDORSER_TRANSACTION, chainID, lsccSpec, creator)
+}
+
+// CreateGetInstalledChaincodesProposal returns a GETINSTALLEDCHAINCODES
+// proposal given a serialized identity
+func CreateGetInstalledChaincodesProposal(creator []byte) (*peer.Proposal, string, error) {
+	ccinp := &peer.ChaincodeInput{Args: [][]byte{[]byte("getinstalledchaincodes")}}
+	lsccSpec := &peer.ChaincodeInvocationSpec{
+		ChaincodeSpec: &peer.ChaincodeSpec{
+			Type:        peer.ChaincodeSpec_GOLANG,
+			ChaincodeId: &peer.ChaincodeID{Name: "lscc"},
+			Input:       ccinp,
+		},
+	}
+	return CreateProposalFromCIS(common.HeaderType_ENDORSER_TRANSACTION, "", lsccSpec, creator)
+}
+
+// CreateInstallProposalFromCDS returns a install proposal given a serialized
+// identity and a ChaincodeDeploymentSpec
+func CreateInstallProposalFromCDS(ccpack proto.Message, creator []byte) (*peer.Proposal, string, error) {
+	return createProposalFromCDS("", ccpack, creator, "install")
+}
+
+// CreateDeployProposalFromCDS returns a deploy proposal given a serialized
+// identity and a ChaincodeDeploymentSpec
+func CreateDeployProposalFromCDS(
+	chainID string,
+	cds *peer.ChaincodeDeploymentSpec,
+	creator []byte,
+	policy []byte,
+	escc []byte,
+	vscc []byte,
+	collectionConfig []byte) (*peer.Proposal, string, error) {
+	if collectionConfig == nil {
+		return createProposalFromCDS(chainID, cds, creator, "deploy", policy, escc, vscc)
+	}
+	return createProposalFromCDS(chainID, cds, creator, "deploy", policy, escc, vscc, collectionConfig)
+}
+
+// CreateUpgradeProposalFromCDS returns a upgrade proposal given a serialized
+// identity and a ChaincodeDeploymentSpec
+func CreateUpgradeProposalFromCDS(
+	chainID string,
+	cds *peer.ChaincodeDeploymentSpec,
+	creator []byte,
+	policy []byte,
+	escc []byte,
+	vscc []byte,
+	collectionConfig []byte) (*peer.Proposal, string, error) {
+	if collectionConfig == nil {
+		return createProposalFromCDS(chainID, cds, creator, "upgrade", policy, escc, vscc)
+	}
+	return createProposalFromCDS(chainID, cds, creator, "upgrade", policy, escc, vscc, collectionConfig)
+}
+
+// createProposalFromCDS returns a deploy or upgrade proposal given a
+// serialized identity and a ChaincodeDeploymentSpec
+func createProposalFromCDS(chainID string, msg proto.Message, creator []byte, propType string, args ...[]byte) (*peer.Proposal, string, error) {
+	// in the new mode, cds will be nil, "deploy" and "upgrade" are instantiates.
+	var ccinp *peer.ChaincodeInput
+	var b []byte
+	var err error
+	if msg != nil {
+		b, err = proto.Marshal(msg)
+		if err != nil {
+			return nil, "", err
+		}
+	}
+	switch propType {
+	case "deploy":
+		fallthrough
+	case "upgrade":
+		cds, ok := msg.(*peer.ChaincodeDeploymentSpec)
+		if !ok || cds == nil {
+			return nil, "", errors.New("invalid message for creating lifecycle chaincode proposal")
+		}
+		Args := [][]byte{[]byte(propType), []byte(chainID), b}
+		Args = append(Args, args...)
+
+		ccinp = &peer.ChaincodeInput{Args: Args}
+	case "install":
+		ccinp = &peer.ChaincodeInput{Args: [][]byte{[]byte(propType), b}}
+	}
+
+	// wrap the deployment in an invocation spec to lscc...
+	lsccSpec := &peer.ChaincodeInvocationSpec{
+		ChaincodeSpec: &peer.ChaincodeSpec{
+			Type:        peer.ChaincodeSpec_GOLANG,
+			ChaincodeId: &peer.ChaincodeID{Name: "lscc"},
+			Input:       ccinp,
+		},
+	}
+
+	// ...and get the proposal for it
+	return CreateProposalFromCIS(common.HeaderType_ENDORSER_TRANSACTION, chainID, lsccSpec, creator)
+}
+
+// ComputeTxID computes TxID as the Hash computed
+// over the concatenation of nonce and creator.
+func ComputeTxID(nonce, creator []byte) (string, error) {
+	// TODO: Get the Hash function to be used from
+	// channel configuration
+	digest, err := factory.GetDefault().Hash(
+		append(nonce, creator...),
+		&bccsp.SHA256Opts{})
+	if err != nil {
+		return "", err
+	}
+	return hex.EncodeToString(digest), nil
+}
+
+// CheckTxID checks that txid is equal to the Hash computed
+// over the concatenation of nonce and creator.
+func CheckTxID(txid string, nonce, creator []byte) error {
+	computedTxID, err := ComputeTxID(nonce, creator)
+	if err != nil {
+		return errors.WithMessage(err, "error computing target txid")
+	}
+
+	if txid != computedTxID {
+		return errors.Errorf("invalid txid. got [%s], expected [%s]", txid, computedTxID)
+	}
+
+	return nil
+}
+
+// ComputeProposalBinding computes the binding of a proposal
+func ComputeProposalBinding(proposal *peer.Proposal) ([]byte, error) {
+	if proposal == nil {
+		return nil, errors.New("proposal is nil")
+	}
+	if len(proposal.Header) == 0 {
+		return nil, errors.New("proposal's header is nil")
+	}
+
+	h, err := GetHeader(proposal.Header)
+	if err != nil {
+		return nil, err
+	}
+
+	chdr, err := UnmarshalChannelHeader(h.ChannelHeader)
+	if err != nil {
+		return nil, err
+	}
+	shdr, err := GetSignatureHeader(h.SignatureHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	return computeProposalBindingInternal(shdr.Nonce, shdr.Creator, chdr.Epoch)
+}
+
+func computeProposalBindingInternal(nonce, creator []byte, epoch uint64) ([]byte, error) {
+	epochBytes := make([]byte, 8)
+	binary.LittleEndian.PutUint64(epochBytes, epoch)
+
+	// TODO: add to genesis block the hash function used for
+	// the binding computation
+	return factory.GetDefault().Hash(
+		append(append(nonce, creator...), epochBytes...),
+		&bccsp.SHA256Opts{})
+}
diff --git a/protoutil/proputils_test.go b/protoutil/proputils_test.go
new file mode 100644
index 00000000..ca7f54b3
--- /dev/null
+++ b/protoutil/proputils_test.go
@@ -0,0 +1,665 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"bytes"
+	"crypto/sha256"
+	"encoding/hex"
+	"fmt"
+	"os"
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/common/util"
+	"github.com/hyperledger/fabric/core/chaincode/platforms"
+	"github.com/hyperledger/fabric/core/chaincode/platforms/golang"
+	"github.com/hyperledger/fabric/msp"
+	mspmgmt "github.com/hyperledger/fabric/msp/mgmt"
+	msptesttools "github.com/hyperledger/fabric/msp/mgmt/testtools"
+	"github.com/hyperledger/fabric/protos/common"
+	pb "github.com/hyperledger/fabric/protos/peer"
+	"github.com/hyperledger/fabric/protos/utils"
+	"github.com/stretchr/testify/assert"
+)
+
+func createCIS() *pb.ChaincodeInvocationSpec {
+	return &pb.ChaincodeInvocationSpec{
+		ChaincodeSpec: &pb.ChaincodeSpec{
+			Type:        pb.ChaincodeSpec_GOLANG,
+			ChaincodeId: &pb.ChaincodeID{Name: "chaincode_name"},
+			Input:       &pb.ChaincodeInput{Args: [][]byte{[]byte("arg1"), []byte("arg2")}}}}
+}
+
+func TestNilProposal(t *testing.T) {
+	// pass nil to all function which accept *peer.Proposal
+	_, err := utils.GetChaincodeInvocationSpec(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, _, err = utils.GetChaincodeProposalContext(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, err = utils.GetNonce(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, err = utils.GetBytesProposal(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, err = utils.ComputeProposalBinding(nil)
+	assert.Error(t, err, "Expected error with nil proposal")
+}
+
+func TestBadProposalHeaders(t *testing.T) {
+	// NOTE:  There is a lot of repetitive proposal validation code
+	// in multiple functions which should be refactored in the future.
+	// For now, simply consolidating the test cases
+
+	// empty header
+	prop := &pb.Proposal{
+		Header: []byte{},
+	}
+	_, _, err := utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with empty proposal header")
+	_, err = utils.ComputeProposalBinding(prop)
+	assert.Error(t, err, "Expected error with empty proposal header")
+
+	// empty payload
+	prop = &pb.Proposal{
+		Header: []byte("header"),
+	}
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with empty proposal payload")
+
+	// malformed proposal header
+	prop = &pb.Proposal{
+		Header:  []byte("bad header"),
+		Payload: []byte("payload"),
+	}
+	_, err = utils.GetHeader(prop.Header)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+	_, err = utils.GetChaincodeInvocationSpec(prop)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+	_, err = utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+	_, err = utils.ComputeProposalBinding(prop)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+
+	// malformed signature header
+	chdr, _ := proto.Marshal(&common.ChannelHeader{
+		Type: int32(common.HeaderType_ENDORSER_TRANSACTION),
+	})
+	hdr := &common.Header{
+		ChannelHeader:   chdr,
+		SignatureHeader: []byte("bad signature header"),
+	}
+	_, err = utils.GetSignatureHeader(hdr.SignatureHeader)
+	assert.Error(t, err, "Expected error with malformed signature header")
+	hdrBytes, _ := proto.Marshal(hdr)
+	prop.Header = hdrBytes
+	_, err = utils.GetChaincodeInvocationSpec(prop)
+	assert.Error(t, err, "Expected error with malformed signature header")
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with malformed signature header")
+	_, err = utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with malformed signature header")
+	_, err = utils.ComputeProposalBinding(prop)
+	assert.Error(t, err, "Expected error with malformed signature header")
+
+	// wrong channel header type
+	chdr, _ = proto.Marshal(&common.ChannelHeader{
+		Type: int32(common.HeaderType_DELIVER_SEEK_INFO),
+	})
+	hdr.ChannelHeader = chdr
+	hdrBytes, _ = proto.Marshal(hdr)
+	prop.Header = hdrBytes
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with wrong header type")
+	assert.Contains(t, err.Error(), "invalid proposal: invalid channel header type")
+	_, err = utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with wrong header type")
+
+	// malformed channel header
+	hdr.ChannelHeader = []byte("bad channel header")
+	hdrBytes, _ = proto.Marshal(hdr)
+	prop.Header = hdrBytes
+	_, _, err = utils.GetChaincodeProposalContext(prop)
+	assert.Error(t, err, "Expected error with malformed channel header")
+	_, err = utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with malformed channel header")
+	_, err = utils.GetChaincodeHeaderExtension(hdr)
+	assert.Error(t, err, "Expected error with malformed channel header")
+	_, err = utils.ComputeProposalBinding(prop)
+	assert.Error(t, err, "Expected error with malformed channel header")
+
+}
+
+func TestGetNonce(t *testing.T) {
+	chdr, _ := proto.Marshal(&common.ChannelHeader{
+		Type: int32(common.HeaderType_ENDORSER_TRANSACTION),
+	})
+	hdr, _ := proto.Marshal(&common.Header{
+		ChannelHeader:   chdr,
+		SignatureHeader: []byte{},
+	})
+	prop := &pb.Proposal{
+		Header: hdr,
+	}
+	_, err := utils.GetNonce(prop)
+	assert.Error(t, err, "Expected error with nil signature header")
+
+	shdr, _ := proto.Marshal(&common.SignatureHeader{
+		Nonce: []byte("nonce"),
+	})
+	hdr, _ = proto.Marshal(&common.Header{
+		ChannelHeader:   chdr,
+		SignatureHeader: shdr,
+	})
+	prop = &pb.Proposal{
+		Header: hdr,
+	}
+	nonce, err := utils.GetNonce(prop)
+	assert.NoError(t, err, "Unexpected error getting nonce")
+	assert.Equal(t, "nonce", string(nonce), "Failed to return the expected nonce")
+
+}
+
+func TestGetChaincodeDeploymentSpec(t *testing.T) {
+	pr := platforms.NewRegistry(&golang.Platform{})
+
+	_, err := utils.GetChaincodeDeploymentSpec([]byte("bad spec"), pr)
+	assert.Error(t, err, "Expected error with malformed spec")
+
+	cds, _ := proto.Marshal(&pb.ChaincodeDeploymentSpec{
+		ChaincodeSpec: &pb.ChaincodeSpec{
+			Type: pb.ChaincodeSpec_GOLANG,
+		},
+	})
+	_, err = utils.GetChaincodeDeploymentSpec(cds, pr)
+	assert.NoError(t, err, "Unexpected error getting deployment spec")
+
+	cds, _ = proto.Marshal(&pb.ChaincodeDeploymentSpec{
+		ChaincodeSpec: &pb.ChaincodeSpec{
+			Type: pb.ChaincodeSpec_UNDEFINED,
+		},
+	})
+	_, err = utils.GetChaincodeDeploymentSpec(cds, pr)
+	assert.Error(t, err, "Expected error with invalid spec type")
+
+}
+
+func TestCDSProposals(t *testing.T) {
+	var prop *pb.Proposal
+	var err error
+	var txid string
+	creator := []byte("creator")
+	cds := &pb.ChaincodeDeploymentSpec{
+		ChaincodeSpec: &pb.ChaincodeSpec{
+			Type: pb.ChaincodeSpec_GOLANG,
+		},
+	}
+	policy := []byte("policy")
+	escc := []byte("escc")
+	vscc := []byte("vscc")
+	chainID := "testchainid"
+
+	// install
+	prop, txid, err = utils.CreateInstallProposalFromCDS(cds, creator)
+	assert.NotNil(t, prop, "Install proposal should not be nil")
+	assert.NoError(t, err, "Unexpected error creating install proposal")
+	assert.NotEqual(t, "", txid, "txid should not be empty")
+
+	// deploy
+	prop, txid, err = utils.CreateDeployProposalFromCDS(chainID, cds, creator, policy, escc, vscc, nil)
+	assert.NotNil(t, prop, "Deploy proposal should not be nil")
+	assert.NoError(t, err, "Unexpected error creating deploy proposal")
+	assert.NotEqual(t, "", txid, "txid should not be empty")
+
+	// upgrade
+	prop, txid, err = utils.CreateUpgradeProposalFromCDS(chainID, cds, creator, policy, escc, vscc, nil)
+	assert.NotNil(t, prop, "Upgrade proposal should not be nil")
+	assert.NoError(t, err, "Unexpected error creating upgrade proposal")
+	assert.NotEqual(t, "", txid, "txid should not be empty")
+
+}
+
+func TestComputeProposalBinding(t *testing.T) {
+	expectedDigestHex := "5093dd4f4277e964da8f4afbde0a9674d17f2a6a5961f0670fc21ae9b67f2983"
+	expectedDigest, _ := hex.DecodeString(expectedDigestHex)
+	chdr, _ := proto.Marshal(&common.ChannelHeader{
+		Epoch: uint64(10),
+	})
+	shdr, _ := proto.Marshal(&common.SignatureHeader{
+		Nonce:   []byte("nonce"),
+		Creator: []byte("creator"),
+	})
+	hdr, _ := proto.Marshal(&common.Header{
+		ChannelHeader:   chdr,
+		SignatureHeader: shdr,
+	})
+	prop := &pb.Proposal{
+		Header: hdr,
+	}
+	binding, _ := utils.ComputeProposalBinding(prop)
+	assert.Equal(t, expectedDigest, binding, "Binding does not match expected digest")
+}
+
+func TestProposal(t *testing.T) {
+	// create a proposal from a ChaincodeInvocationSpec
+	prop, _, err := utils.CreateChaincodeProposalWithTransient(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		util.GetTestChainID(), createCIS(),
+		[]byte("creator"),
+		map[string][]byte{"certx": []byte("transient")})
+	if err != nil {
+		t.Fatalf("Could not create chaincode proposal, err %s\n", err)
+		return
+	}
+
+	// serialize the proposal
+	pBytes, err := utils.GetBytesProposal(prop)
+	if err != nil {
+		t.Fatalf("Could not serialize the chaincode proposal, err %s\n", err)
+		return
+	}
+
+	// deserialize it and expect it to be the same
+	propBack, err := utils.GetProposal(pBytes)
+	if err != nil {
+		t.Fatalf("Could not deserialize the chaincode proposal, err %s\n", err)
+		return
+	}
+	if !proto.Equal(prop, propBack) {
+		t.Fatalf("Proposal and deserialized proposals don't match\n")
+		return
+	}
+
+	// get back the header
+	hdr, err := utils.GetHeader(prop.Header)
+	if err != nil {
+		t.Fatalf("Could not extract the header from the proposal, err %s\n", err)
+	}
+
+	hdrBytes, err := utils.GetBytesHeader(hdr)
+	if err != nil {
+		t.Fatalf("Could not marshal the header, err %s\n", err)
+	}
+
+	hdr, err = utils.GetHeader(hdrBytes)
+	if err != nil {
+		t.Fatalf("Could not unmarshal the header, err %s\n", err)
+	}
+
+	chdr, err := utils.UnmarshalChannelHeader(hdr.ChannelHeader)
+	if err != nil {
+		t.Fatalf("Could not unmarshal channel header, err %s", err)
+	}
+
+	shdr, err := utils.GetSignatureHeader(hdr.SignatureHeader)
+	if err != nil {
+		t.Fatalf("Could not unmarshal signature header, err %s", err)
+	}
+
+	_, err = utils.GetBytesSignatureHeader(shdr)
+	if err != nil {
+		t.Fatalf("Could not marshal signature header, err %s", err)
+	}
+
+	// sanity check on header
+	if chdr.Type != int32(common.HeaderType_ENDORSER_TRANSACTION) ||
+		shdr.Nonce == nil ||
+		string(shdr.Creator) != "creator" {
+		t.Fatalf("Invalid header after unmarshalling\n")
+		return
+	}
+
+	// get back the header extension
+	hdrExt, err := utils.GetChaincodeHeaderExtension(hdr)
+	if err != nil {
+		t.Fatalf("Could not extract the header extensions from the proposal, err %s\n", err)
+		return
+	}
+
+	// sanity check on header extension
+	if string(hdrExt.ChaincodeId.Name) != "chaincode_name" {
+		t.Fatalf("Invalid header extension after unmarshalling\n")
+		return
+	}
+
+	// get back the ChaincodeInvocationSpec
+	cis, err := utils.GetChaincodeInvocationSpec(prop)
+	if err != nil {
+		t.Fatalf("Could not extract chaincode invocation spec from header, err %s\n", err)
+		return
+	}
+
+	// sanity check on cis
+	if cis.ChaincodeSpec.Type != pb.ChaincodeSpec_GOLANG ||
+		cis.ChaincodeSpec.ChaincodeId.Name != "chaincode_name" ||
+		len(cis.ChaincodeSpec.Input.Args) != 2 ||
+		string(cis.ChaincodeSpec.Input.Args[0]) != "arg1" ||
+		string(cis.ChaincodeSpec.Input.Args[1]) != "arg2" {
+		t.Fatalf("Invalid chaincode invocation spec after unmarshalling\n")
+		return
+	}
+
+	creator, transient, err := utils.GetChaincodeProposalContext(prop)
+	if err != nil {
+		t.Fatalf("Failed getting chaincode proposal context [%s]", err)
+	}
+	if string(creator) != "creator" {
+		t.Fatalf("Failed checking Creator field. Invalid value, expectext 'creator', got [%s]", string(creator))
+		return
+	}
+	value, ok := transient["certx"]
+	if !ok || string(value) != "transient" {
+		t.Fatalf("Failed checking Transient field. Invalid value, expectext 'transient', got [%s]", string(value))
+		return
+	}
+}
+
+func TestProposalWithTxID(t *testing.T) {
+	// create a proposal from a ChaincodeInvocationSpec
+	prop, txid, err := utils.CreateChaincodeProposalWithTxIDAndTransient(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		util.GetTestChainID(),
+		createCIS(),
+		[]byte("creator"),
+		"testtx",
+		map[string][]byte{"certx": []byte("transient")},
+	)
+	assert.Nil(t, err)
+	assert.NotNil(t, prop)
+	assert.Equal(t, txid, "testtx")
+
+	prop, txid, err = utils.CreateChaincodeProposalWithTxIDAndTransient(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		util.GetTestChainID(),
+		createCIS(),
+		[]byte("creator"),
+		"",
+		map[string][]byte{"certx": []byte("transient")},
+	)
+	assert.Nil(t, err)
+	assert.NotNil(t, prop)
+	assert.NotEmpty(t, txid)
+}
+
+func TestProposalResponse(t *testing.T) {
+	events := &pb.ChaincodeEvent{
+		ChaincodeId: "ccid",
+		EventName:   "EventName",
+		Payload:     []byte("EventPayload"),
+		TxId:        "TxID"}
+	ccid := &pb.ChaincodeID{
+		Name:    "ccid",
+		Version: "v1",
+	}
+
+	pHashBytes := []byte("proposal_hash")
+	pResponse := &pb.Response{Status: 200}
+	results := []byte("results")
+	eventBytes, err := utils.GetBytesChaincodeEvent(events)
+	if err != nil {
+		t.Fatalf("Failure while marshalling the ProposalResponsePayload")
+		return
+	}
+
+	// get the bytes of the response
+	pResponseBytes, err := utils.GetBytesResponse(pResponse)
+	if err != nil {
+		t.Fatalf("Failure while marshalling the Response")
+		return
+	}
+
+	// get the response from bytes
+	_, err = utils.GetResponse(pResponseBytes)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the Response")
+		return
+	}
+
+	// get the bytes of the ProposalResponsePayload
+	prpBytes, err := utils.GetBytesProposalResponsePayload(pHashBytes, pResponse, results, eventBytes, ccid)
+	if err != nil {
+		t.Fatalf("Failure while marshalling the ProposalResponsePayload")
+		return
+	}
+
+	// get the ProposalResponsePayload message
+	prp, err := utils.GetProposalResponsePayload(prpBytes)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the ProposalResponsePayload")
+		return
+	}
+
+	// get the ChaincodeAction message
+	act, err := utils.GetChaincodeAction(prp.Extension)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the ChaincodeAction")
+		return
+	}
+
+	// sanity check on the action
+	if string(act.Results) != "results" {
+		t.Fatalf("Invalid actions after unmarshalling")
+		return
+	}
+
+	event, err := utils.GetChaincodeEvents(act.Events)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the ChainCodeEvents")
+		return
+	}
+
+	// sanity check on the event
+	if string(event.ChaincodeId) != "ccid" {
+		t.Fatalf("Invalid actions after unmarshalling")
+		return
+	}
+
+	pr := &pb.ProposalResponse{
+		Payload:     prpBytes,
+		Endorsement: &pb.Endorsement{Endorser: []byte("endorser"), Signature: []byte("signature")},
+		Version:     1, // TODO: pick right version number
+		Response:    &pb.Response{Status: 200, Message: "OK"}}
+
+	// create a proposal response
+	prBytes, err := utils.GetBytesProposalResponse(pr)
+	if err != nil {
+		t.Fatalf("Failure while marshalling the ProposalResponse")
+		return
+	}
+
+	// get the proposal response message back
+	prBack, err := utils.GetProposalResponse(prBytes)
+	if err != nil {
+		t.Fatalf("Failure while unmarshalling the ProposalResponse")
+		return
+	}
+
+	// sanity check on pr
+	if prBack.Response.Status != 200 ||
+		string(prBack.Endorsement.Signature) != "signature" ||
+		string(prBack.Endorsement.Endorser) != "endorser" ||
+		bytes.Compare(prBack.Payload, prpBytes) != 0 {
+		t.Fatalf("Invalid ProposalResponse after unmarshalling")
+		return
+	}
+}
+
+func TestEnvelope(t *testing.T) {
+	// create a proposal from a ChaincodeInvocationSpec
+	prop, _, err := utils.CreateChaincodeProposal(common.HeaderType_ENDORSER_TRANSACTION, util.GetTestChainID(), createCIS(), signerSerialized)
+	if err != nil {
+		t.Fatalf("Could not create chaincode proposal, err %s\n", err)
+		return
+	}
+
+	response := &pb.Response{Status: 200, Payload: []byte("payload")}
+	result := []byte("res")
+	ccid := &pb.ChaincodeID{Name: "foo", Version: "v1"}
+
+	presp, err := utils.CreateProposalResponse(prop.Header, prop.Payload, response, result, nil, ccid, nil, signer)
+	if err != nil {
+		t.Fatalf("Could not create proposal response, err %s\n", err)
+		return
+	}
+
+	tx, err := utils.CreateSignedTx(prop, signer, presp)
+	if err != nil {
+		t.Fatalf("Could not create signed tx, err %s\n", err)
+		return
+	}
+
+	envBytes, err := utils.GetBytesEnvelope(tx)
+	if err != nil {
+		t.Fatalf("Could not marshal envelope, err %s\n", err)
+		return
+	}
+
+	tx, err = utils.GetEnvelopeFromBlock(envBytes)
+	if err != nil {
+		t.Fatalf("Could not unmarshal envelope, err %s\n", err)
+		return
+	}
+
+	act2, err := utils.GetActionFromEnvelope(envBytes)
+	if err != nil {
+		t.Fatalf("Could not extract actions from envelop, err %s\n", err)
+		return
+	}
+
+	if act2.Response.Status != response.Status {
+		t.Fatalf("response staus don't match")
+		return
+	}
+	if bytes.Compare(act2.Response.Payload, response.Payload) != 0 {
+		t.Fatalf("response payload don't match")
+		return
+	}
+
+	if bytes.Compare(act2.Results, result) != 0 {
+		t.Fatalf("results don't match")
+		return
+	}
+
+	txpayl, err := utils.GetPayload(tx)
+	if err != nil {
+		t.Fatalf("Could not unmarshal payload, err %s\n", err)
+		return
+	}
+
+	tx2, err := utils.GetTransaction(txpayl.Data)
+	if err != nil {
+		t.Fatalf("Could not unmarshal Transaction, err %s\n", err)
+		return
+	}
+
+	sh, err := utils.GetSignatureHeader(tx2.Actions[0].Header)
+	if err != nil {
+		t.Fatalf("Could not unmarshal SignatureHeader, err %s\n", err)
+		return
+	}
+
+	if bytes.Compare(sh.Creator, signerSerialized) != 0 {
+		t.Fatalf("creator does not match")
+		return
+	}
+
+	cap, err := utils.GetChaincodeActionPayload(tx2.Actions[0].Payload)
+	if err != nil {
+		t.Fatalf("Could not unmarshal ChaincodeActionPayload, err %s\n", err)
+		return
+	}
+	assert.NotNil(t, cap)
+
+	prp, err := utils.GetProposalResponsePayload(cap.Action.ProposalResponsePayload)
+	if err != nil {
+		t.Fatalf("Could not unmarshal ProposalResponsePayload, err %s\n", err)
+		return
+	}
+
+	ca, err := utils.GetChaincodeAction(prp.Extension)
+	if err != nil {
+		t.Fatalf("Could not unmarshal ChaincodeAction, err %s\n", err)
+		return
+	}
+
+	if ca.Response.Status != response.Status {
+		t.Fatalf("response staus don't match")
+		return
+	}
+	if bytes.Compare(ca.Response.Payload, response.Payload) != 0 {
+		t.Fatalf("response payload don't match")
+		return
+	}
+
+	if bytes.Compare(ca.Results, result) != 0 {
+		t.Fatalf("results don't match")
+		return
+	}
+}
+
+func TestProposalTxID(t *testing.T) {
+	nonce := []byte{1}
+	creator := []byte{2}
+
+	txid, err := utils.ComputeTxID(nonce, creator)
+	assert.NotEmpty(t, txid, "TxID cannot be empty.")
+	assert.NoError(t, err, "Failed computing txID")
+	assert.Nil(t, utils.CheckTxID(txid, nonce, creator))
+	assert.Error(t, utils.CheckTxID("", nonce, creator))
+
+	txid, err = utils.ComputeTxID(nil, nil)
+	assert.NotEmpty(t, txid, "TxID cannot be empty.")
+	assert.NoError(t, err, "Failed computing txID")
+}
+
+func TestComputeProposalTxID(t *testing.T) {
+	txid, err := utils.ComputeTxID([]byte{1}, []byte{1})
+	assert.NoError(t, err, "Failed computing TxID")
+
+	// Compute the function computed by ComputeTxID,
+	// namely, base64(sha256(nonce||creator))
+	hf := sha256.New()
+	hf.Write([]byte{1})
+	hf.Write([]byte{1})
+	hashOut := hf.Sum(nil)
+	txid2 := hex.EncodeToString(hashOut)
+
+	t.Logf("% x\n", hashOut)
+	t.Logf("% s\n", txid)
+	t.Logf("% s\n", txid2)
+
+	assert.Equal(t, txid, txid2)
+}
+
+var signer msp.SigningIdentity
+var signerSerialized []byte
+
+func TestMain(m *testing.M) {
+	// setup the MSP manager so that we can sign/verify
+	err := msptesttools.LoadMSPSetupForTesting()
+	if err != nil {
+		os.Exit(-1)
+		fmt.Printf("Could not initialize msp")
+		return
+	}
+	signer, err = mspmgmt.GetLocalMSP().GetDefaultSigningIdentity()
+	if err != nil {
+		os.Exit(-1)
+		fmt.Printf("Could not get signer")
+		return
+	}
+
+	signerSerialized, err = signer.Serialize()
+	if err != nil {
+		os.Exit(-1)
+		fmt.Printf("Could not serialize identity")
+		return
+	}
+
+	os.Exit(m.Run())
+}
diff --git a/protoutil/readme.md b/protoutil/readme.md
new file mode 100644
index 00000000..b6ce68e1
--- /dev/null
+++ b/protoutil/readme.md
@@ -0,0 +1,3 @@
+this package is an exact copy of protos/util 
+
+it is copied here to fix the dependency of trustbloc/fabric-peer-ext during the peer docker image build
\ No newline at end of file
diff --git a/protoutil/txutils.go b/protoutil/txutils.go
new file mode 100644
index 00000000..20b6b5a7
--- /dev/null
+++ b/protoutil/txutils.go
@@ -0,0 +1,453 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil
+
+import (
+	"bytes"
+	"fmt"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/bccsp"
+	"github.com/hyperledger/fabric/bccsp/factory"
+	"github.com/hyperledger/fabric/common/crypto"
+	"github.com/hyperledger/fabric/msp"
+	"github.com/hyperledger/fabric/protos/common"
+	"github.com/hyperledger/fabric/protos/peer"
+	"github.com/pkg/errors"
+)
+
+// GetPayloads gets the underlying payload objects in a TransactionAction
+func GetPayloads(txActions *peer.TransactionAction) (*peer.ChaincodeActionPayload, *peer.ChaincodeAction, error) {
+	// TODO: pass in the tx type (in what follows we're assuming the
+	// type is ENDORSER_TRANSACTION)
+	ccPayload, err := GetChaincodeActionPayload(txActions.Payload)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	if ccPayload.Action == nil || ccPayload.Action.ProposalResponsePayload == nil {
+		return nil, nil, errors.New("no payload in ChaincodeActionPayload")
+	}
+	pRespPayload, err := GetProposalResponsePayload(ccPayload.Action.ProposalResponsePayload)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	if pRespPayload.Extension == nil {
+		return nil, nil, errors.New("response payload is missing extension")
+	}
+
+	respPayload, err := GetChaincodeAction(pRespPayload.Extension)
+	if err != nil {
+		return ccPayload, nil, err
+	}
+	return ccPayload, respPayload, nil
+}
+
+// GetEnvelopeFromBlock gets an envelope from a block's Data field.
+func GetEnvelopeFromBlock(data []byte) (*common.Envelope, error) {
+	// Block always begins with an envelope
+	var err error
+	env := &common.Envelope{}
+	if err = proto.Unmarshal(data, env); err != nil {
+		return nil, errors.Wrap(err, "error unmarshaling Envelope")
+	}
+
+	return env, nil
+}
+
+// CreateSignedEnvelope creates a signed envelope of the desired type, with
+// marshaled dataMsg and signs it
+func CreateSignedEnvelope(txType common.HeaderType, channelID string, signer crypto.LocalSigner, dataMsg proto.Message, msgVersion int32, epoch uint64) (*common.Envelope, error) {
+	return CreateSignedEnvelopeWithTLSBinding(txType, channelID, signer, dataMsg, msgVersion, epoch, nil)
+}
+
+// CreateSignedEnvelopeWithTLSBinding creates a signed envelope of the desired
+// type, with marshaled dataMsg and signs it. It also includes a TLS cert hash
+// into the channel header
+func CreateSignedEnvelopeWithTLSBinding(txType common.HeaderType, channelID string, signer crypto.LocalSigner, dataMsg proto.Message, msgVersion int32, epoch uint64, tlsCertHash []byte) (*common.Envelope, error) {
+	payloadChannelHeader := MakeChannelHeader(txType, msgVersion, channelID, epoch)
+	payloadChannelHeader.TlsCertHash = tlsCertHash
+	var err error
+	payloadSignatureHeader := &common.SignatureHeader{}
+
+	if signer != nil {
+		payloadSignatureHeader, err = signer.NewSignatureHeader()
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	data, err := proto.Marshal(dataMsg)
+	if err != nil {
+		return nil, errors.Wrap(err, "error marshaling")
+	}
+
+	paylBytes := MarshalOrPanic(
+		&common.Payload{
+			Header: MakePayloadHeader(payloadChannelHeader, payloadSignatureHeader),
+			Data:   data,
+		},
+	)
+
+	var sig []byte
+	if signer != nil {
+		sig, err = signer.Sign(paylBytes)
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	env := &common.Envelope{
+		Payload:   paylBytes,
+		Signature: sig,
+	}
+
+	return env, nil
+}
+
+// CreateSignedTx assembles an Envelope message from proposal, endorsements,
+// and a signer. This function should be called by a client when it has
+// collected enough endorsements for a proposal to create a transaction and
+// submit it to peers for ordering
+func CreateSignedTx(proposal *peer.Proposal, signer msp.SigningIdentity, resps ...*peer.ProposalResponse) (*common.Envelope, error) {
+	if len(resps) == 0 {
+		return nil, errors.New("at least one proposal response is required")
+	}
+
+	// the original header
+	hdr, err := GetHeader(proposal.Header)
+	if err != nil {
+		return nil, err
+	}
+
+	// the original payload
+	pPayl, err := GetChaincodeProposalPayload(proposal.Payload)
+	if err != nil {
+		return nil, err
+	}
+
+	// check that the signer is the same that is referenced in the header
+	// TODO: maybe worth removing?
+	signerBytes, err := signer.Serialize()
+	if err != nil {
+		return nil, err
+	}
+
+	shdr, err := GetSignatureHeader(hdr.SignatureHeader)
+	if err != nil {
+		return nil, err
+	}
+
+	if bytes.Compare(signerBytes, shdr.Creator) != 0 {
+		return nil, errors.New("signer must be the same as the one referenced in the header")
+	}
+
+	// get header extensions so we have the visibility field
+	hdrExt, err := GetChaincodeHeaderExtension(hdr)
+	if err != nil {
+		return nil, err
+	}
+
+	// ensure that all actions are bitwise equal and that they are successful
+	var a1 []byte
+	for n, r := range resps {
+		if n == 0 {
+			a1 = r.Payload
+			if r.Response.Status < 200 || r.Response.Status >= 400 {
+				return nil, errors.Errorf("proposal response was not successful, error code %d, msg %s", r.Response.Status, r.Response.Message)
+			}
+			continue
+		}
+
+		if bytes.Compare(a1, r.Payload) != 0 {
+			return nil, errors.New("ProposalResponsePayloads do not match")
+		}
+	}
+
+	// fill endorsements
+	endorsements := make([]*peer.Endorsement, len(resps))
+	for n, r := range resps {
+		endorsements[n] = r.Endorsement
+	}
+
+	// create ChaincodeEndorsedAction
+	cea := &peer.ChaincodeEndorsedAction{ProposalResponsePayload: resps[0].Payload, Endorsements: endorsements}
+
+	// obtain the bytes of the proposal payload that will go to the transaction
+	propPayloadBytes, err := GetBytesProposalPayloadForTx(pPayl, hdrExt.PayloadVisibility)
+	if err != nil {
+		return nil, err
+	}
+
+	// serialize the chaincode action payload
+	cap := &peer.ChaincodeActionPayload{ChaincodeProposalPayload: propPayloadBytes, Action: cea}
+	capBytes, err := GetBytesChaincodeActionPayload(cap)
+	if err != nil {
+		return nil, err
+	}
+
+	// create a transaction
+	taa := &peer.TransactionAction{Header: hdr.SignatureHeader, Payload: capBytes}
+	taas := make([]*peer.TransactionAction, 1)
+	taas[0] = taa
+	tx := &peer.Transaction{Actions: taas}
+
+	// serialize the tx
+	txBytes, err := GetBytesTransaction(tx)
+	if err != nil {
+		return nil, err
+	}
+
+	// create the payload
+	payl := &common.Payload{Header: hdr, Data: txBytes}
+	paylBytes, err := GetBytesPayload(payl)
+	if err != nil {
+		return nil, err
+	}
+
+	// sign the payload
+	sig, err := signer.Sign(paylBytes)
+	if err != nil {
+		return nil, err
+	}
+
+	// here's the envelope
+	return &common.Envelope{Payload: paylBytes, Signature: sig}, nil
+}
+
+// CreateProposalResponse creates a proposal response.
+func CreateProposalResponse(hdrbytes []byte, payl []byte, response *peer.Response, results []byte, events []byte, ccid *peer.ChaincodeID, visibility []byte, signingEndorser msp.SigningIdentity) (*peer.ProposalResponse, error) {
+	hdr, err := GetHeader(hdrbytes)
+	if err != nil {
+		return nil, err
+	}
+
+	// obtain the proposal hash given proposal header, payload and the
+	// requested visibility
+	pHashBytes, err := GetProposalHash1(hdr, payl, visibility)
+	if err != nil {
+		return nil, errors.WithMessage(err, "error computing proposal hash")
+	}
+
+	// get the bytes of the proposal response payload - we need to sign them
+	prpBytes, err := GetBytesProposalResponsePayload(pHashBytes, response, results, events, ccid)
+	if err != nil {
+		return nil, err
+	}
+
+	// serialize the signing identity
+	endorser, err := signingEndorser.Serialize()
+	if err != nil {
+		return nil, errors.WithMessage(err, fmt.Sprintf("error serializing signing identity for %s", signingEndorser.GetIdentifier()))
+	}
+
+	// sign the concatenation of the proposal response and the serialized
+	// endorser identity with this endorser's key
+	signature, err := signingEndorser.Sign(append(prpBytes, endorser...))
+	if err != nil {
+		return nil, errors.WithMessage(err, "could not sign the proposal response payload")
+	}
+
+	resp := &peer.ProposalResponse{
+		// Timestamp: TODO!
+		Version: 1, // TODO: pick right version number
+		Endorsement: &peer.Endorsement{
+			Signature: signature,
+			Endorser:  endorser,
+		},
+		Payload: prpBytes,
+		Response: &peer.Response{
+			Status:  200,
+			Message: "OK",
+		},
+	}
+
+	return resp, nil
+}
+
+// CreateProposalResponseFailure creates a proposal response for cases where
+// endorsement proposal fails either due to a endorsement failure or a
+// chaincode failure (chaincode response status >= shim.ERRORTHRESHOLD)
+func CreateProposalResponseFailure(hdrbytes []byte, payl []byte, response *peer.Response, results []byte, events []byte, ccid *peer.ChaincodeID, visibility []byte) (*peer.ProposalResponse, error) {
+	hdr, err := GetHeader(hdrbytes)
+	if err != nil {
+		return nil, err
+	}
+
+	// obtain the proposal hash given proposal header, payload and the requested visibility
+	pHashBytes, err := GetProposalHash1(hdr, payl, visibility)
+	if err != nil {
+		return nil, errors.WithMessage(err, "error computing proposal hash")
+	}
+
+	// get the bytes of the proposal response payload
+	prpBytes, err := GetBytesProposalResponsePayload(pHashBytes, response, results, events, ccid)
+	if err != nil {
+		return nil, err
+	}
+
+	resp := &peer.ProposalResponse{
+		// Timestamp: TODO!
+		Payload:  prpBytes,
+		Response: response,
+	}
+
+	return resp, nil
+}
+
+// GetSignedProposal returns a signed proposal given a Proposal message and a
+// signing identity
+func GetSignedProposal(prop *peer.Proposal, signer msp.SigningIdentity) (*peer.SignedProposal, error) {
+	// check for nil argument
+	if prop == nil || signer == nil {
+		return nil, errors.New("nil arguments")
+	}
+
+	propBytes, err := GetBytesProposal(prop)
+	if err != nil {
+		return nil, err
+	}
+
+	signature, err := signer.Sign(propBytes)
+	if err != nil {
+		return nil, err
+	}
+
+	return &peer.SignedProposal{ProposalBytes: propBytes, Signature: signature}, nil
+}
+
+// MockSignedEndorserProposalOrPanic creates a SignedProposal with the
+// passed arguments
+func MockSignedEndorserProposalOrPanic(chainID string, cs *peer.ChaincodeSpec, creator, signature []byte) (*peer.SignedProposal, *peer.Proposal) {
+	prop, _, err := CreateChaincodeProposal(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		chainID,
+		&peer.ChaincodeInvocationSpec{ChaincodeSpec: cs},
+		creator)
+	if err != nil {
+		panic(err)
+	}
+
+	propBytes, err := GetBytesProposal(prop)
+	if err != nil {
+		panic(err)
+	}
+
+	return &peer.SignedProposal{ProposalBytes: propBytes, Signature: signature}, prop
+}
+
+func MockSignedEndorserProposal2OrPanic(chainID string, cs *peer.ChaincodeSpec, signer msp.SigningIdentity) (*peer.SignedProposal, *peer.Proposal) {
+	serializedSigner, err := signer.Serialize()
+	if err != nil {
+		panic(err)
+	}
+
+	prop, _, err := CreateChaincodeProposal(
+		common.HeaderType_ENDORSER_TRANSACTION,
+		chainID,
+		&peer.ChaincodeInvocationSpec{ChaincodeSpec: &peer.ChaincodeSpec{}},
+		serializedSigner)
+	if err != nil {
+		panic(err)
+	}
+
+	sProp, err := GetSignedProposal(prop, signer)
+	if err != nil {
+		panic(err)
+	}
+
+	return sProp, prop
+}
+
+// GetBytesProposalPayloadForTx takes a ChaincodeProposalPayload and returns
+// its serialized version according to the visibility field
+func GetBytesProposalPayloadForTx(payload *peer.ChaincodeProposalPayload, visibility []byte) ([]byte, error) {
+	// check for nil argument
+	if payload == nil {
+		return nil, errors.New("nil arguments")
+	}
+
+	// strip the transient bytes off the payload - this needs to be done no
+	// matter the visibility mode
+	cppNoTransient := &peer.ChaincodeProposalPayload{Input: payload.Input, TransientMap: nil}
+	cppBytes, err := GetBytesChaincodeProposalPayload(cppNoTransient)
+	if err != nil {
+		return nil, err
+	}
+
+	// currently the fabric only supports full visibility: this means that
+	// there are no restrictions on which parts of the proposal payload will
+	// be visible in the final transaction; this default approach requires
+	// no additional instructions in the PayloadVisibility field; however
+	// the fabric may be extended to encode more elaborate visibility
+	// mechanisms that shall be encoded in this field (and handled
+	// appropriately by the peer)
+
+	return cppBytes, nil
+}
+
+// GetProposalHash2 gets the proposal hash - this version
+// is called by the committer where the visibility policy
+// has already been enforced and so we already get what
+// we have to get in ccPropPayl
+func GetProposalHash2(header *common.Header, ccPropPayl []byte) ([]byte, error) {
+	// check for nil argument
+	if header == nil ||
+		header.ChannelHeader == nil ||
+		header.SignatureHeader == nil ||
+		ccPropPayl == nil {
+		return nil, errors.New("nil arguments")
+	}
+
+	hash, err := factory.GetDefault().GetHash(&bccsp.SHA256Opts{})
+	if err != nil {
+		return nil, errors.WithMessage(err, "error instantiating hash function")
+	}
+	// hash the serialized Channel Header object
+	hash.Write(header.ChannelHeader)
+	// hash the serialized Signature Header object
+	hash.Write(header.SignatureHeader)
+	// hash the bytes of the chaincode proposal payload that we are given
+	hash.Write(ccPropPayl)
+	return hash.Sum(nil), nil
+}
+
+// GetProposalHash1 gets the proposal hash bytes after sanitizing the
+// chaincode proposal payload according to the rules of visibility
+func GetProposalHash1(header *common.Header, ccPropPayl []byte, visibility []byte) ([]byte, error) {
+	// check for nil argument
+	if header == nil ||
+		header.ChannelHeader == nil ||
+		header.SignatureHeader == nil ||
+		ccPropPayl == nil {
+		return nil, errors.New("nil arguments")
+	}
+
+	// unmarshal the chaincode proposal payload
+	cpp, err := GetChaincodeProposalPayload(ccPropPayl)
+	if err != nil {
+		return nil, err
+	}
+
+	ppBytes, err := GetBytesProposalPayloadForTx(cpp, visibility)
+	if err != nil {
+		return nil, err
+	}
+
+	hash2, err := factory.GetDefault().GetHash(&bccsp.SHA256Opts{})
+	if err != nil {
+		return nil, errors.WithMessage(err, "error instantiating hash function")
+	}
+	// hash the serialized Channel Header object
+	hash2.Write(header.ChannelHeader)
+	// hash the serialized Signature Header object
+	hash2.Write(header.SignatureHeader)
+	// hash of the part of the chaincode proposal payload that will go to the tx
+	hash2.Write(ppBytes)
+	return hash2.Sum(nil), nil
+}
diff --git a/protoutil/txutils_test.go b/protoutil/txutils_test.go
new file mode 100644
index 00000000..df14255e
--- /dev/null
+++ b/protoutil/txutils_test.go
@@ -0,0 +1,522 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoutil_test
+
+import (
+	"encoding/hex"
+	"errors"
+	"strconv"
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	mockmsp "github.com/hyperledger/fabric/common/mocks/msp"
+	"github.com/hyperledger/fabric/common/util"
+	cb "github.com/hyperledger/fabric/protos/common"
+	pb "github.com/hyperledger/fabric/protos/peer"
+	"github.com/hyperledger/fabric/protos/utils"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestGetPayloads(t *testing.T) {
+	var txAction *pb.TransactionAction
+	var err error
+
+	// good
+	ccActionBytes, _ := proto.Marshal(&pb.ChaincodeAction{
+		Results: []byte("results"),
+	})
+	proposalResponsePayload := &pb.ProposalResponsePayload{
+		Extension: ccActionBytes,
+	}
+	proposalResponseBytes, err := proto.Marshal(proposalResponsePayload)
+	ccActionPayload := &pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: proposalResponseBytes,
+		},
+	}
+	ccActionPayloadBytes, _ := proto.Marshal(ccActionPayload)
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.NoError(t, err, "Unexpected error getting payload bytes")
+	t.Logf("error1 [%s]", err)
+
+	// nil proposal response extension
+	proposalResponseBytes, err = proto.Marshal(&pb.ProposalResponsePayload{
+		Extension: nil,
+	})
+	ccActionPayloadBytes, _ = proto.Marshal(&pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: proposalResponseBytes,
+		},
+	})
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with nil proposal response extension")
+	t.Logf("error2 [%s]", err)
+
+	// malformed proposal response payload
+	ccActionPayloadBytes, _ = proto.Marshal(&pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: []byte("bad payload"),
+		},
+	})
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with malformed proposal response payload")
+	t.Logf("error3 [%s]", err)
+
+	// malformed proposal response payload extension
+	proposalResponseBytes, _ = proto.Marshal(&pb.ProposalResponsePayload{
+		Extension: []byte("bad extension"),
+	})
+	ccActionPayloadBytes, _ = proto.Marshal(&pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: proposalResponseBytes,
+		},
+	})
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with malformed proposal response extension")
+	t.Logf("error4 [%s]", err)
+
+	// nil proposal response payload extension
+	proposalResponseBytes, _ = proto.Marshal(&pb.ProposalResponsePayload{
+		ProposalHash: []byte("hash"),
+	})
+	ccActionPayloadBytes, _ = proto.Marshal(&pb.ChaincodeActionPayload{
+		Action: &pb.ChaincodeEndorsedAction{
+			ProposalResponsePayload: proposalResponseBytes,
+		},
+	})
+	txAction = &pb.TransactionAction{
+		Payload: ccActionPayloadBytes,
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with nil proposal response extension")
+	t.Logf("error5 [%s]", err)
+
+	// malformed transaction action payload
+	txAction = &pb.TransactionAction{
+		Payload: []byte("bad payload"),
+	}
+	_, _, err = utils.GetPayloads(txAction)
+	assert.Error(t, err, "Expected error with malformed transaction action payload")
+	t.Logf("error6 [%s]", err)
+
+}
+
+func TestCreateSignedTx(t *testing.T) {
+	var err error
+	prop := &pb.Proposal{}
+
+	signID, err := mockmsp.NewNoopMsp().GetDefaultSigningIdentity()
+	assert.NoError(t, err, "Unexpected error getting signing identity")
+	signerBytes, err := signID.Serialize()
+	assert.NoError(t, err, "Unexpected error serializing signing identity")
+
+	ccHeaderExtensionBytes, _ := proto.Marshal(&pb.ChaincodeHeaderExtension{})
+	chdrBytes, _ := proto.Marshal(&cb.ChannelHeader{
+		Extension: ccHeaderExtensionBytes,
+	})
+	shdrBytes, _ := proto.Marshal(&cb.SignatureHeader{
+		Creator: signerBytes,
+	})
+	responses := []*pb.ProposalResponse{{}}
+
+	// malformed chaincode header extension
+	headerBytes, _ := proto.Marshal(&cb.Header{
+		ChannelHeader:   []byte("bad channel header"),
+		SignatureHeader: shdrBytes,
+	})
+	prop.Header = headerBytes
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with malformed chaincode extension")
+
+	// malformed signature header
+	headerBytes, _ = proto.Marshal(&cb.Header{
+		SignatureHeader: []byte("bad signature header"),
+	})
+	prop.Header = headerBytes
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with malformed signature header")
+
+	// set up the header bytes for the remaining tests
+	headerBytes, _ = proto.Marshal(&cb.Header{
+		ChannelHeader:   chdrBytes,
+		SignatureHeader: shdrBytes,
+	})
+	prop.Header = headerBytes
+
+	// non-matching responses
+	responses = []*pb.ProposalResponse{{
+		Payload: []byte("payload"),
+		Response: &pb.Response{
+			Status: int32(200),
+		},
+	}}
+	responses = append(responses, &pb.ProposalResponse{
+		Payload: []byte("payload2"),
+		Response: &pb.Response{
+			Status: int32(200),
+		},
+	})
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with non-matching responses")
+
+	// no endorsement
+	responses = []*pb.ProposalResponse{{
+		Payload: []byte("payload"),
+		Response: &pb.Response{
+			Status: int32(200),
+		},
+	}}
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with no endorsements")
+
+	// success
+	responses = []*pb.ProposalResponse{{
+		Payload:     []byte("payload"),
+		Endorsement: &pb.Endorsement{},
+		Response: &pb.Response{
+			Status: int32(200),
+		},
+	}}
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.NoError(t, err, "Unexpected error creating signed transaction")
+	t.Logf("error: [%s]", err)
+
+	//
+	//
+	// additional failure cases
+	prop = &pb.Proposal{}
+	responses = []*pb.ProposalResponse{}
+	// no proposal responses
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with no proposal responses")
+
+	// missing proposal header
+	responses = append(responses, &pb.ProposalResponse{})
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with no proposal header")
+
+	// bad proposal payload
+	prop.Payload = []byte("bad payload")
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with malformed proposal payload")
+
+	// bad payload header
+	prop.Header = []byte("bad header")
+	_, err = utils.CreateSignedTx(prop, signID, responses...)
+	assert.Error(t, err, "Expected error with malformed proposal header")
+
+}
+
+func TestCreateSignedTxStatus(t *testing.T) {
+	serializedExtension, err := proto.Marshal(&pb.ChaincodeHeaderExtension{})
+	assert.NoError(t, err)
+	serializedChannelHeader, err := proto.Marshal(&cb.ChannelHeader{
+		Extension: serializedExtension,
+	})
+	assert.NoError(t, err)
+
+	signingID, err := mockmsp.NewNoopMsp().GetDefaultSigningIdentity()
+	assert.NoError(t, err)
+	serializedSigningID, err := signingID.Serialize()
+	assert.NoError(t, err)
+	serializedSignatureHeader, err := proto.Marshal(&cb.SignatureHeader{
+		Creator: serializedSigningID,
+	})
+	assert.NoError(t, err)
+
+	header := &cb.Header{
+		ChannelHeader:   serializedChannelHeader,
+		SignatureHeader: serializedSignatureHeader,
+	}
+
+	serializedHeader, err := proto.Marshal(header)
+	assert.NoError(t, err)
+
+	proposal := &pb.Proposal{
+		Header: serializedHeader,
+	}
+
+	tests := []struct {
+		status      int32
+		expectedErr string
+	}{
+		{status: 0, expectedErr: "proposal response was not successful, error code 0, msg response-message"},
+		{status: 199, expectedErr: "proposal response was not successful, error code 199, msg response-message"},
+		{status: 200, expectedErr: ""},
+		{status: 201, expectedErr: ""},
+		{status: 399, expectedErr: ""},
+		{status: 400, expectedErr: "proposal response was not successful, error code 400, msg response-message"},
+	}
+	for _, tc := range tests {
+		t.Run(strconv.Itoa(int(tc.status)), func(t *testing.T) {
+			response := &pb.ProposalResponse{
+				Payload:     []byte("payload"),
+				Endorsement: &pb.Endorsement{},
+				Response: &pb.Response{
+					Status:  tc.status,
+					Message: "response-message",
+				},
+			}
+
+			_, err := utils.CreateSignedTx(proposal, signingID, response)
+			if tc.expectedErr == "" {
+				assert.NoError(t, err)
+			} else {
+				assert.EqualError(t, err, tc.expectedErr)
+			}
+		})
+	}
+}
+
+func TestCreateSignedEnvelope(t *testing.T) {
+	var env *cb.Envelope
+	channelID := "mychannelID"
+	msg := &cb.ConfigEnvelope{}
+
+	env, err := utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID,
+		goodSigner, msg, int32(1), uint64(1))
+	assert.NoError(t, err, "Unexpected error creating signed envelope")
+	assert.NotNil(t, env, "Envelope should not be nil")
+	// mock sign returns the bytes to be signed
+	assert.Equal(t, env.Payload, env.Signature, "Unexpected signature returned")
+	payload := &cb.Payload{}
+	err = proto.Unmarshal(env.Payload, payload)
+	assert.NoError(t, err, "Failed to unmarshal payload")
+	data := &cb.ConfigEnvelope{}
+	err = proto.Unmarshal(payload.Data, data)
+	assert.NoError(t, err, "Expected payload data to be a config envelope")
+	assert.Equal(t, msg, data, "Payload data does not match expected value")
+
+	_, err = utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID,
+		badSigner, &cb.ConfigEnvelope{}, int32(1), uint64(1))
+	assert.Error(t, err, "Expected sign error")
+}
+
+func TestCreateSignedEnvelopeNilSigner(t *testing.T) {
+	var env *cb.Envelope
+	channelID := "mychannelID"
+	msg := &cb.ConfigEnvelope{}
+
+	env, err := utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID,
+		nil, msg, int32(1), uint64(1))
+	assert.NoError(t, err, "Unexpected error creating signed envelope")
+	assert.NotNil(t, env, "Envelope should not be nil")
+	assert.Empty(t, env.Signature, "Signature should have been empty")
+	payload := &cb.Payload{}
+	err = proto.Unmarshal(env.Payload, payload)
+	assert.NoError(t, err, "Failed to unmarshal payload")
+	data := &cb.ConfigEnvelope{}
+	err = proto.Unmarshal(payload.Data, data)
+	assert.NoError(t, err, "Expected payload data to be a config envelope")
+	assert.Equal(t, msg, data, "Payload data does not match expected value")
+}
+
+func TestGetSignedProposal(t *testing.T) {
+	var signedProp *pb.SignedProposal
+	var err error
+
+	signID, err := mockmsp.NewNoopMsp().GetDefaultSigningIdentity()
+	assert.NoError(t, err, "Unexpected error getting signing identity")
+
+	prop := &pb.Proposal{}
+	propBytes, _ := proto.Marshal(prop)
+	signedProp, err = utils.GetSignedProposal(prop, signID)
+	assert.NoError(t, err, "Unexpected error getting signed proposal")
+	assert.Equal(t, propBytes, signedProp.ProposalBytes,
+		"Proposal bytes did not match expected value")
+	assert.Equal(t, []byte("signature"), signedProp.Signature,
+		"Signature did not match expected value")
+
+	_, err = utils.GetSignedProposal(nil, signID)
+	assert.Error(t, err, "Expected error with nil proposal")
+	_, err = utils.GetSignedProposal(prop, nil)
+	assert.Error(t, err, "Expected error with nil signing identity")
+
+}
+
+func TestMockSignedEndorserProposalOrPanic(t *testing.T) {
+	var prop *pb.Proposal
+	var signedProp *pb.SignedProposal
+
+	ccProposal := &pb.ChaincodeProposalPayload{}
+	cis := &pb.ChaincodeInvocationSpec{}
+	chainID := "testchainid"
+	sig := []byte("signature")
+	creator := []byte("creator")
+	cs := &pb.ChaincodeSpec{
+		ChaincodeId: &pb.ChaincodeID{
+			Name: "mychaincode",
+		},
+	}
+
+	signedProp, prop = utils.MockSignedEndorserProposalOrPanic(chainID, cs,
+		creator, sig)
+	assert.Equal(t, sig, signedProp.Signature,
+		"Signature did not match expected result")
+	propBytes, _ := proto.Marshal(prop)
+	assert.Equal(t, propBytes, signedProp.ProposalBytes,
+		"Proposal bytes do not match expected value")
+	err := proto.Unmarshal(prop.Payload, ccProposal)
+	assert.NoError(t, err, "Expected ChaincodeProposalPayload")
+	err = proto.Unmarshal(ccProposal.Input, cis)
+	assert.NoError(t, err, "Expected ChaincodeInvocationSpec")
+	assert.Equal(t, cs.ChaincodeId.Name, cis.ChaincodeSpec.ChaincodeId.Name,
+		"Chaincode name did not match expected value")
+}
+
+func TestMockSignedEndorserProposal2OrPanic(t *testing.T) {
+	var prop *pb.Proposal
+	var signedProp *pb.SignedProposal
+
+	ccProposal := &pb.ChaincodeProposalPayload{}
+	cis := &pb.ChaincodeInvocationSpec{}
+	chainID := "testchainid"
+	sig := []byte("signature")
+	signID, err := mockmsp.NewNoopMsp().GetDefaultSigningIdentity()
+	assert.NoError(t, err, "Unexpected error getting signing identity")
+
+	signedProp, prop = utils.MockSignedEndorserProposal2OrPanic(chainID,
+		&pb.ChaincodeSpec{}, signID)
+	assert.Equal(t, sig, signedProp.Signature,
+		"Signature did not match expected result")
+	propBytes, _ := proto.Marshal(prop)
+	assert.Equal(t, propBytes, signedProp.ProposalBytes,
+		"Proposal bytes do not match expected value")
+	err = proto.Unmarshal(prop.Payload, ccProposal)
+	assert.NoError(t, err, "Expected ChaincodeProposalPayload")
+	err = proto.Unmarshal(ccProposal.Input, cis)
+	assert.NoError(t, err, "Expected ChaincodeInvocationSpec")
+}
+
+func TestGetBytesProposalPayloadForTx(t *testing.T) {
+	input := &pb.ChaincodeProposalPayload{
+		Input:        []byte("input"),
+		TransientMap: make(map[string][]byte),
+	}
+	expected, _ := proto.Marshal(&pb.ChaincodeProposalPayload{
+		Input: []byte("input"),
+	})
+
+	result, err := utils.GetBytesProposalPayloadForTx(input, []byte{})
+	assert.NoError(t, err, "Unexpected error getting proposal payload")
+	assert.Equal(t, expected, result, "Payload does not match expected value")
+
+	_, err = utils.GetBytesProposalPayloadForTx(nil, []byte{})
+	assert.Error(t, err, "Expected error with nil proposal payload")
+}
+
+func TestGetProposalHash2(t *testing.T) {
+	expectedHashHex := "7b622ef4e1ab9b7093ec3bbfbca17d5d6f14a437914a6839319978a7034f7960"
+	expectedHash, _ := hex.DecodeString(expectedHashHex)
+	hdr := &cb.Header{
+		ChannelHeader:   []byte("chdr"),
+		SignatureHeader: []byte("shdr"),
+	}
+	propHash, err := utils.GetProposalHash2(hdr, []byte("ccproppayload"))
+	assert.NoError(t, err, "Unexpected error getting hash2 for proposal")
+	t.Logf("%x", propHash)
+	assert.Equal(t, expectedHash, propHash,
+		"Proposal hash did not match expected hash")
+
+	propHash, err = utils.GetProposalHash2(&cb.Header{},
+		[]byte("ccproppayload"))
+	assert.Error(t, err, "Expected error with nil arguments")
+}
+
+func TestGetProposalHash1(t *testing.T) {
+	expectedHashHex := "d4c1e3cac2105da5fddc2cfe776d6ec28e4598cf1e6fa51122c7f70d8076437b"
+	expectedHash, _ := hex.DecodeString(expectedHashHex)
+	hdr := &cb.Header{
+		ChannelHeader:   []byte("chdr"),
+		SignatureHeader: []byte("shdr"),
+	}
+
+	ccProposal, _ := proto.Marshal(&pb.ChaincodeProposalPayload{})
+
+	propHash, err := utils.GetProposalHash1(hdr, ccProposal, []byte{})
+	assert.NoError(t, err, "Unexpected error getting hash for proposal")
+	t.Logf("%x", propHash)
+	assert.Equal(t, expectedHash, propHash,
+		"Proposal hash did not match expected hash")
+
+	propHash, err = utils.GetProposalHash1(hdr,
+		[]byte("ccproppayload"), []byte{})
+	assert.Error(t, err,
+		"Expected error with malformed chaincode proposal payload")
+
+	propHash, err = utils.GetProposalHash1(&cb.Header{},
+		[]byte("ccproppayload"), []byte{})
+	assert.Error(t, err, "Expected error with nil arguments")
+}
+
+func TestCreateProposalResponseFailure(t *testing.T) {
+	// create a proposal from a ChaincodeInvocationSpec
+	prop, _, err := utils.CreateChaincodeProposal(cb.HeaderType_ENDORSER_TRANSACTION, util.GetTestChainID(), createCIS(), signerSerialized)
+	if err != nil {
+		t.Fatalf("Could not create chaincode proposal, err %s\n", err)
+		return
+	}
+
+	response := &pb.Response{Status: 502, Payload: []byte("Invalid function name")}
+	result := []byte("res")
+	ccid := &pb.ChaincodeID{Name: "foo", Version: "v1"}
+
+	prespFailure, err := utils.CreateProposalResponseFailure(prop.Header, prop.Payload, response, result, nil, ccid, nil)
+	if err != nil {
+		t.Fatalf("Could not create proposal response failure, err %s\n", err)
+		return
+	}
+
+	assert.Equal(t, int32(502), prespFailure.Response.Status)
+	// drilldown into the response to find the chaincode response
+	pRespPayload, err := utils.GetProposalResponsePayload(prespFailure.Payload)
+	assert.NoError(t, err, "Error while unmarshaling proposal response payload: %s", err)
+	ca, err := utils.GetChaincodeAction(pRespPayload.Extension)
+	assert.NoError(t, err, "Error while unmarshaling chaincode action: %s", err)
+
+	assert.Equal(t, int32(502), ca.Response.Status)
+	assert.Equal(t, "Invalid function name", string(ca.Response.Payload))
+}
+
+// mock
+var badSigner = &mockLocalSigner{
+	returnError: true,
+}
+
+var goodSigner = &mockLocalSigner{
+	returnError: false,
+}
+
+type mockLocalSigner struct {
+	returnError bool
+}
+
+func (m *mockLocalSigner) NewSignatureHeader() (*cb.SignatureHeader, error) {
+	if m.returnError {
+		return nil, errors.New("signature header error")
+	}
+	return &cb.SignatureHeader{}, nil
+}
+
+func (m *mockLocalSigner) Sign(message []byte) ([]byte, error) {
+	if m.returnError {
+		return nil, errors.New("sign error")
+	}
+	return message, nil
+}
-- 
2.15.0

