From b2c0c583f04a20f1f25754ed2b724b5f47914207 Mon Sep 17 00:00:00 2001
From: Firas Qutishat <firas.qutishat@securekey.com>
Date: Wed, 17 Jul 2019 19:54:29 -0400
Subject: [PATCH] gossip protos extensions refactoring

Signed-off-by: Firas Qutishat <firas.qutishat@securekey.com>
Change-Id: Id664c7a5fd7fb654af6f328d69a6df871a6a5b44
---
 discovery/client/api.go                       |   6 +-
 discovery/client/client.go                    |  16 +-
 discovery/client/client_test.go               |   7 +-
 discovery/client/selection.go                 |   4 +-
 discovery/client/selection_test.go            |  13 +-
 discovery/cmd/endorsers.go                    |  11 +-
 discovery/cmd/peers_test.go                   |  11 +-
 discovery/service_test.go                     |   5 +-
 discovery/support/gossip/support_test.go      |   3 +-
 discovery/support/mocks/gossip.go             |  47 +-
 discovery/test/integration_test.go            |   9 +-
 gossip/comm/ack.go                            |  12 +-
 gossip/comm/ack_test.go                       |  15 +-
 gossip/comm/comm.go                           |   8 +-
 gossip/comm/comm_impl.go                      |  47 +-
 gossip/comm/comm_test.go                      |  47 +-
 gossip/comm/conn.go                           |  17 +-
 gossip/comm/mock/mock_comm.go                 |  19 +-
 gossip/comm/mock/mock_comm_test.go            |  13 +-
 gossip/comm/msg.go                            |  11 +-
 gossip/discovery/discovery.go                 |  15 +-
 gossip/discovery/discovery_impl.go            |  93 +-
 gossip/discovery/discovery_test.go            | 143 +--
 gossip/election/adapter.go                    |   5 +-
 gossip/election/adapter_test.go               |   7 +-
 gossip/gossip/anchor_test.go                  |  39 +-
 gossip/gossip/certstore.go                    |  15 +-
 gossip/gossip/certstore_test.go               |  61 +-
 gossip/gossip/channel/channel.go              |  99 +-
 gossip/gossip/channel/channel_test.go         | 183 ++--
 gossip/gossip/chanstate.go                    |  21 +-
 gossip/gossip/gossip.go                       |   9 +-
 gossip/gossip/gossip_impl.go                  | 131 ++-
 gossip/gossip/gossip_test.go                  |  35 +-
 gossip/gossip/orgs_test.go                    |  35 +-
 gossip/gossip/pull/pullstore.go               |  58 +-
 gossip/gossip/pull/pullstore_test.go          |  49 +-
 gossip/privdata/distributor.go                |  13 +-
 gossip/privdata/distributor_test.go           |   5 +-
 gossip/privdata/pull.go                       |  19 +-
 gossip/privdata/pull_test.go                  |  23 +-
 .../protoext}/compatibility_test.go           |  21 +-
 .../gossip => gossip/protoext}/extensions.go  | 213 +++--
 gossip/protoext/extensions_test.go            | 864 ++++++++++++++++++
 gossip/protoext/stringers.go                  | 124 +++
 gossip/protoext/stringers_test.go             | 210 +++++
 gossip/service/join_test.go                   |   7 +-
 gossip/state/metrics_test.go                  |   3 +-
 gossip/state/mocks/gossip.go                  |   9 +-
 gossip/state/state.go                         |  31 +-
 gossip/state/state_test.go                    |  67 +-
 gossip/util/msgs.go                           |  14 +-
 gossip/util/msgs_test.go                      |  21 +-
 protos/gossip/extensions_test.go              | 863 -----------------
 protos/gossip/message.pb.go                   |  50 +-
 protos/gossip/message_ext.go                  |  25 +
 protos/gossip/message_test.go                 |   4 +-
 57 files changed, 2155 insertions(+), 1750 deletions(-)
 rename {protos/gossip => gossip/protoext}/compatibility_test.go (73%)
 rename {protos/gossip => gossip/protoext}/extensions.go (67%)
 create mode 100644 gossip/protoext/extensions_test.go
 create mode 100644 gossip/protoext/stringers.go
 create mode 100644 gossip/protoext/stringers_test.go
 delete mode 100644 protos/gossip/extensions_test.go
 create mode 100644 protos/gossip/message_ext.go

diff --git a/discovery/client/api.go b/discovery/client/api.go
index 88139b8d4..595ab8027 100644
--- a/discovery/client/api.go
+++ b/discovery/client/api.go
@@ -7,8 +7,8 @@ SPDX-License-Identifier: Apache-2.0
 package discovery
 
 import (
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/discovery"
-	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
 	"google.golang.org/grpc"
 )
@@ -67,7 +67,7 @@ type Endorsers []*Peer
 // of a certain peer.
 type Peer struct {
 	MSPID            string
-	AliveMessage     *gossip.SignedGossipMessage
-	StateInfoMessage *gossip.SignedGossipMessage
+	AliveMessage     *protoext.SignedGossipMessage
+	StateInfoMessage *protoext.SignedGossipMessage
 	Identity         []byte
 }
diff --git a/discovery/client/client.go b/discovery/client/client.go
index 12a9711c4..abfc9b92e 100644
--- a/discovery/client/client.go
+++ b/discovery/client/client.go
@@ -14,8 +14,8 @@ import (
 	"time"
 
 	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/discovery"
-	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/msp"
 	"github.com/pkg/errors"
 )
@@ -407,13 +407,13 @@ func peersForChannel(membersRes *discovery.PeerMembershipResult, qt discovery.Qu
 	var peers []*Peer
 	for org, peersOfCurrentOrg := range membersRes.PeersByOrg {
 		for _, peer := range peersOfCurrentOrg.Peers {
-			aliveMsg, err := peer.MembershipInfo.ToGossipMessage()
+			aliveMsg, err := protoext.EnvelopeToGossipMessage(peer.MembershipInfo)
 			if err != nil {
 				return nil, errors.Wrap(err, "failed unmarshaling alive message")
 			}
-			var stateInfoMsg *gossip.SignedGossipMessage
+			var stateInfoMsg *protoext.SignedGossipMessage
 			if isStateInfoExpected(qt) {
-				stateInfoMsg, err = peer.StateInfo.ToGossipMessage()
+				stateInfoMsg, err = protoext.EnvelopeToGossipMessage(peer.StateInfo)
 				if err != nil {
 					return nil, errors.Wrap(err, "failed unmarshaling stateInfo message")
 				}
@@ -525,11 +525,11 @@ func endorser(peer *discovery.Peer, chaincode, channel string) (*Peer, error) {
 	if peer.MembershipInfo == nil || peer.StateInfo == nil {
 		return nil, errors.Errorf("received empty envelope(s) for endorsers for chaincode %s, channel %s", chaincode, channel)
 	}
-	aliveMsg, err := peer.MembershipInfo.ToGossipMessage()
+	aliveMsg, err := protoext.EnvelopeToGossipMessage(peer.MembershipInfo)
 	if err != nil {
 		return nil, errors.Wrap(err, "failed unmarshaling gossip envelope to alive message")
 	}
-	stateInfMsg, err := peer.StateInfo.ToGossipMessage()
+	stateInfMsg, err := protoext.EnvelopeToGossipMessage(peer.StateInfo)
 	if err != nil {
 		return nil, errors.Wrap(err, "failed unmarshaling gossip envelope to state info message")
 	}
@@ -564,7 +564,7 @@ func NewClient(createConnection Dialer, s Signer, signerCacheSize uint) *Client
 	}
 }
 
-func validateAliveMessage(message *gossip.SignedGossipMessage) error {
+func validateAliveMessage(message *protoext.SignedGossipMessage) error {
 	am := message.GetAliveMsg()
 	if am == nil {
 		return errors.New("message isn't an alive message")
@@ -579,7 +579,7 @@ func validateAliveMessage(message *gossip.SignedGossipMessage) error {
 	return nil
 }
 
-func validateStateInfoMessage(message *gossip.SignedGossipMessage) error {
+func validateStateInfoMessage(message *protoext.SignedGossipMessage) error {
 	si := message.GetStateInfo()
 	if si == nil {
 		return errors.New("message isn't a stateInfo message")
diff --git a/discovery/client/client_test.go b/discovery/client/client_test.go
index 6a641e84f..2e10a0363 100644
--- a/discovery/client/client_test.go
+++ b/discovery/client/client_test.go
@@ -29,6 +29,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/api"
 	gossipcommon "github.com/hyperledger/fabric/gossip/common"
 	gdisc "github.com/hyperledger/fabric/gossip/discovery"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/discovery"
 	"github.com/hyperledger/fabric/protos/gossip"
@@ -712,7 +713,7 @@ func TestAddEndorsersQueryInvalidInput(t *testing.T) {
 
 func TestValidateAliveMessage(t *testing.T) {
 	am := aliveMessage(1)
-	msg, _ := am.ToGossipMessage()
+	msg, _ := protoext.EnvelopeToGossipMessage(am)
 
 	// Scenario I: Valid alive message
 	assert.NoError(t, validateAliveMessage(msg))
@@ -885,7 +886,7 @@ func aliveMessage(id int) *gossip.Envelope {
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg.Envelope
 }
 
@@ -908,7 +909,7 @@ func stateInfoMessageWithHeight(ledgerHeight uint64, chaincodes ...*gossip.Chain
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg.Envelope
 }
 
diff --git a/discovery/client/selection.go b/discovery/client/selection.go
index 0d25eabc6..dedc5c996 100644
--- a/discovery/client/selection.go
+++ b/discovery/client/selection.go
@@ -10,6 +10,8 @@ import (
 	"math/rand"
 	"sort"
 	"time"
+
+	"github.com/hyperledger/fabric/gossip/protoext"
 )
 
 // Filter filters and sorts the given endorsers
@@ -98,7 +100,7 @@ func ExcludeByHost(reject func(host string) bool) ExclusionFilter {
 		var internalEndpoint string
 		se := p.AliveMessage.GetSecretEnvelope()
 		if se != nil {
-			internalEndpoint = se.InternalEndpoint()
+			internalEndpoint = protoext.InternalEndpoint(se)
 		}
 		return reject(endpoint) || reject(internalEndpoint)
 	})
diff --git a/discovery/client/selection_test.go b/discovery/client/selection_test.go
index b07edaba4..4aa951ac0 100644
--- a/discovery/client/selection_test.go
+++ b/discovery/client/selection_test.go
@@ -10,6 +10,7 @@ import (
 	"testing"
 
 	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
@@ -40,7 +41,7 @@ func TestShuffle(t *testing.T) {
 func TestExclusionAndPriority(t *testing.T) {
 	newPeer := func(i int) *Peer {
 		si := stateInfoWithHeight(uint64(i))
-		am, _ := aliveMessage(i).ToGossipMessage()
+		am, _ := protoext.EnvelopeToGossipMessage(aliveMessage(i))
 		return &Peer{
 			StateInfoMessage: si,
 			AliveMessage:     am,
@@ -68,9 +69,9 @@ func TestExcludeEndpoints(t *testing.T) {
 		Payload: secret,
 	}
 	am3 := aliveMessage(3)
-	g1, _ := am1.ToGossipMessage()
-	g2, _ := am2.ToGossipMessage()
-	g3, _ := am3.ToGossipMessage()
+	g1, _ := protoext.EnvelopeToGossipMessage(am1)
+	g2, _ := protoext.EnvelopeToGossipMessage(am2)
+	g3, _ := protoext.EnvelopeToGossipMessage(am3)
 	p1 := Peer{
 		AliveMessage: g1,
 	}
@@ -149,7 +150,7 @@ func TestPrioritiesByHeight(t *testing.T) {
 
 }
 
-func stateInfoWithHeight(h uint64) *gossip.SignedGossipMessage {
+func stateInfoWithHeight(h uint64) *protoext.SignedGossipMessage {
 	g := &gossip.GossipMessage{
 		Content: &gossip.GossipMessage_StateInfo{
 			StateInfo: &gossip.StateInfo{
@@ -160,7 +161,7 @@ func stateInfoWithHeight(h uint64) *gossip.SignedGossipMessage {
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg
 }
 
diff --git a/discovery/cmd/endorsers.go b/discovery/cmd/endorsers.go
index cbb073710..2734f2369 100644
--- a/discovery/cmd/endorsers.go
+++ b/discovery/cmd/endorsers.go
@@ -15,7 +15,8 @@ import (
 
 	"github.com/golang/protobuf/proto"
 	"github.com/hyperledger/fabric/cmd/common"
-	"github.com/hyperledger/fabric/discovery/client"
+	discovery "github.com/hyperledger/fabric/discovery/client"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	. "github.com/hyperledger/fabric/protos/discovery"
 	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/msp"
@@ -215,11 +216,11 @@ func endpointFromEnvelope(env *gossip.Envelope) string {
 	if env == nil {
 		return ""
 	}
-	aliveMsg, _ := env.ToGossipMessage()
+	aliveMsg, _ := protoext.EnvelopeToGossipMessage(env)
 	if aliveMsg == nil {
 		return ""
 	}
-	if !aliveMsg.IsAliveMsg() {
+	if !protoext.IsAliveMsg(aliveMsg.GossipMessage) {
 		return ""
 	}
 	if aliveMsg.GetAliveMsg().Membership == nil {
@@ -232,11 +233,11 @@ func ledgerHeightFromEnvelope(env *gossip.Envelope) uint64 {
 	if env == nil {
 		return 0
 	}
-	stateInfoMsg, _ := env.ToGossipMessage()
+	stateInfoMsg, _ := protoext.EnvelopeToGossipMessage(env)
 	if stateInfoMsg == nil {
 		return 0
 	}
-	if !stateInfoMsg.IsStateInfoMsg() {
+	if !protoext.IsStateInfoMsg(stateInfoMsg.GossipMessage) {
 		return 0
 	}
 	if stateInfoMsg.GetStateInfo().Properties == nil {
diff --git a/discovery/cmd/peers_test.go b/discovery/cmd/peers_test.go
index 6da3a12d5..917676724 100644
--- a/discovery/cmd/peers_test.go
+++ b/discovery/cmd/peers_test.go
@@ -14,8 +14,9 @@ import (
 
 	"github.com/hyperledger/fabric/cmd/common"
 	. "github.com/hyperledger/fabric/discovery/client"
-	"github.com/hyperledger/fabric/discovery/cmd"
+	discovery "github.com/hyperledger/fabric/discovery/cmd"
 	"github.com/hyperledger/fabric/discovery/cmd/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/msp"
 	"github.com/hyperledger/fabric/protos/utils"
@@ -104,7 +105,7 @@ func TestParsePeers(t *testing.T) {
 	}
 }
 
-func aliveMessage(id int) *gossip.SignedGossipMessage {
+func aliveMessage(id int) *protoext.SignedGossipMessage {
 	g := &gossip.GossipMessage{
 		Content: &gossip.GossipMessage_AliveMsg{
 			AliveMsg: &gossip.AliveMessage{
@@ -118,11 +119,11 @@ func aliveMessage(id int) *gossip.SignedGossipMessage {
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg
 }
 
-func stateInfoMessage(height uint64) *gossip.SignedGossipMessage {
+func stateInfoMessage(height uint64) *protoext.SignedGossipMessage {
 	g := &gossip.GossipMessage{
 		Content: &gossip.GossipMessage_StateInfo{
 			StateInfo: &gossip.StateInfo{
@@ -140,6 +141,6 @@ func stateInfoMessage(height uint64) *gossip.SignedGossipMessage {
 			},
 		},
 	}
-	sMsg, _ := g.NoopSign()
+	sMsg, _ := protoext.NoopSign(g)
 	return sMsg
 }
diff --git a/discovery/service_test.go b/discovery/service_test.go
index 325ec6831..49026e61e 100644
--- a/discovery/service_test.go
+++ b/discovery/service_test.go
@@ -17,6 +17,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/api"
 	gcommon "github.com/hyperledger/fabric/gossip/common"
 	gdisc "github.com/hyperledger/fabric/gossip/discovery"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/common"
 	"github.com/hyperledger/fabric/protos/discovery"
 	"github.com/hyperledger/fabric/protos/gossip"
@@ -551,7 +552,7 @@ func stateInfoMsg(id int) gdisc.NetworkMember {
 			StateInfo: si,
 		},
 	}
-	sm, _ := gm.NoopSign()
+	sm, _ := protoext.NoopSign(gm)
 	return gdisc.NetworkMember{
 		PKIid:    pkiID,
 		Envelope: sm.Envelope,
@@ -572,7 +573,7 @@ func aliveMsg(id int) gdisc.NetworkMember {
 			AliveMsg: am,
 		},
 	}
-	sm, _ := gm.NoopSign()
+	sm, _ := protoext.NoopSign(gm)
 	return gdisc.NetworkMember{
 		PKIid:    pkiID,
 		Endpoint: endpoint,
diff --git a/discovery/support/gossip/support_test.go b/discovery/support/gossip/support_test.go
index 9f60b1eb6..cda261246 100644
--- a/discovery/support/gossip/support_test.go
+++ b/discovery/support/gossip/support_test.go
@@ -13,6 +13,7 @@ import (
 	"github.com/hyperledger/fabric/discovery/support/mocks"
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
@@ -54,7 +55,7 @@ func TestPeersOfChannel(t *testing.T) {
 			},
 		},
 	}
-	sMsg, _ := stateInfo.NoopSign()
+	sMsg, _ := protoext.NoopSign(stateInfo)
 	g := &mocks.Gossip{}
 	g.SelfChannelInfoReturnsOnCall(0, nil)
 	g.SelfChannelInfoReturnsOnCall(1, sMsg)
diff --git a/discovery/support/mocks/gossip.go b/discovery/support/mocks/gossip.go
index 22535cec2..5ae2fb2cb 100644
--- a/discovery/support/mocks/gossip.go
+++ b/discovery/support/mocks/gossip.go
@@ -10,6 +10,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/filter"
 	"github.com/hyperledger/fabric/gossip/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
@@ -23,16 +24,16 @@ type Gossip struct {
 	selfMembershipInfoReturnsOnCall map[int]struct {
 		result1 discovery.NetworkMember
 	}
-	SelfChannelInfoStub        func(common.ChainID) *proto.SignedGossipMessage
+	SelfChannelInfoStub        func(common.ChainID) *protoext.SignedGossipMessage
 	selfChannelInfoMutex       sync.RWMutex
 	selfChannelInfoArgsForCall []struct {
 		arg1 common.ChainID
 	}
 	selfChannelInfoReturns struct {
-		result1 *proto.SignedGossipMessage
+		result1 *protoext.SignedGossipMessage
 	}
 	selfChannelInfoReturnsOnCall map[int]struct {
-		result1 *proto.SignedGossipMessage
+		result1 *protoext.SignedGossipMessage
 	}
 	SendStub        func(msg *proto.GossipMessage, peers ...*comm.RemotePeer)
 	sendMutex       sync.RWMutex
@@ -40,10 +41,10 @@ type Gossip struct {
 		msg   *proto.GossipMessage
 		peers []*comm.RemotePeer
 	}
-	SendByCriteriaStub        func(*proto.SignedGossipMessage, gossip.SendCriteria) error
+	SendByCriteriaStub        func(*protoext.SignedGossipMessage, gossip.SendCriteria) error
 	sendByCriteriaMutex       sync.RWMutex
 	sendByCriteriaArgsForCall []struct {
-		arg1 *proto.SignedGossipMessage
+		arg1 *protoext.SignedGossipMessage
 		arg2 gossip.SendCriteria
 	}
 	sendByCriteriaReturns struct {
@@ -108,7 +109,7 @@ type Gossip struct {
 		result1 filter.RoutingFilter
 		result2 error
 	}
-	AcceptStub        func(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	AcceptStub        func(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 	acceptMutex       sync.RWMutex
 	acceptArgsForCall []struct {
 		acceptor    common.MessageAcceptor
@@ -116,11 +117,11 @@ type Gossip struct {
 	}
 	acceptReturns struct {
 		result1 <-chan *proto.GossipMessage
-		result2 <-chan proto.ReceivedMessage
+		result2 <-chan protoext.ReceivedMessage
 	}
 	acceptReturnsOnCall map[int]struct {
 		result1 <-chan *proto.GossipMessage
-		result2 <-chan proto.ReceivedMessage
+		result2 <-chan protoext.ReceivedMessage
 	}
 	JoinChanStub        func(joinMsg api.JoinChannelMessage, chainID common.ChainID)
 	joinChanMutex       sync.RWMutex
@@ -194,7 +195,7 @@ func (fake *Gossip) SelfMembershipInfoReturnsOnCall(i int, result1 discovery.Net
 	}{result1}
 }
 
-func (fake *Gossip) SelfChannelInfo(arg1 common.ChainID) *proto.SignedGossipMessage {
+func (fake *Gossip) SelfChannelInfo(arg1 common.ChainID) *protoext.SignedGossipMessage {
 	fake.selfChannelInfoMutex.Lock()
 	ret, specificReturn := fake.selfChannelInfoReturnsOnCall[len(fake.selfChannelInfoArgsForCall)]
 	fake.selfChannelInfoArgsForCall = append(fake.selfChannelInfoArgsForCall, struct {
@@ -223,22 +224,22 @@ func (fake *Gossip) SelfChannelInfoArgsForCall(i int) common.ChainID {
 	return fake.selfChannelInfoArgsForCall[i].arg1
 }
 
-func (fake *Gossip) SelfChannelInfoReturns(result1 *proto.SignedGossipMessage) {
+func (fake *Gossip) SelfChannelInfoReturns(result1 *protoext.SignedGossipMessage) {
 	fake.SelfChannelInfoStub = nil
 	fake.selfChannelInfoReturns = struct {
-		result1 *proto.SignedGossipMessage
+		result1 *protoext.SignedGossipMessage
 	}{result1}
 }
 
-func (fake *Gossip) SelfChannelInfoReturnsOnCall(i int, result1 *proto.SignedGossipMessage) {
+func (fake *Gossip) SelfChannelInfoReturnsOnCall(i int, result1 *protoext.SignedGossipMessage) {
 	fake.SelfChannelInfoStub = nil
 	if fake.selfChannelInfoReturnsOnCall == nil {
 		fake.selfChannelInfoReturnsOnCall = make(map[int]struct {
-			result1 *proto.SignedGossipMessage
+			result1 *protoext.SignedGossipMessage
 		})
 	}
 	fake.selfChannelInfoReturnsOnCall[i] = struct {
-		result1 *proto.SignedGossipMessage
+		result1 *protoext.SignedGossipMessage
 	}{result1}
 }
 
@@ -267,11 +268,11 @@ func (fake *Gossip) SendArgsForCall(i int) (*proto.GossipMessage, []*comm.Remote
 	return fake.sendArgsForCall[i].msg, fake.sendArgsForCall[i].peers
 }
 
-func (fake *Gossip) SendByCriteria(arg1 *proto.SignedGossipMessage, arg2 gossip.SendCriteria) error {
+func (fake *Gossip) SendByCriteria(arg1 *protoext.SignedGossipMessage, arg2 gossip.SendCriteria) error {
 	fake.sendByCriteriaMutex.Lock()
 	ret, specificReturn := fake.sendByCriteriaReturnsOnCall[len(fake.sendByCriteriaArgsForCall)]
 	fake.sendByCriteriaArgsForCall = append(fake.sendByCriteriaArgsForCall, struct {
-		arg1 *proto.SignedGossipMessage
+		arg1 *protoext.SignedGossipMessage
 		arg2 gossip.SendCriteria
 	}{arg1, arg2})
 	fake.recordInvocation("SendByCriteria", []interface{}{arg1, arg2})
@@ -291,7 +292,7 @@ func (fake *Gossip) SendByCriteriaCallCount() int {
 	return len(fake.sendByCriteriaArgsForCall)
 }
 
-func (fake *Gossip) SendByCriteriaArgsForCall(i int) (*proto.SignedGossipMessage, gossip.SendCriteria) {
+func (fake *Gossip) SendByCriteriaArgsForCall(i int) (*protoext.SignedGossipMessage, gossip.SendCriteria) {
 	fake.sendByCriteriaMutex.RLock()
 	defer fake.sendByCriteriaMutex.RUnlock()
 	return fake.sendByCriteriaArgsForCall[i].arg1, fake.sendByCriteriaArgsForCall[i].arg2
@@ -564,7 +565,7 @@ func (fake *Gossip) PeerFilterReturnsOnCall(i int, result1 filter.RoutingFilter,
 	}{result1, result2}
 }
 
-func (fake *Gossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (fake *Gossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	fake.acceptMutex.Lock()
 	ret, specificReturn := fake.acceptReturnsOnCall[len(fake.acceptArgsForCall)]
 	fake.acceptArgsForCall = append(fake.acceptArgsForCall, struct {
@@ -594,25 +595,25 @@ func (fake *Gossip) AcceptArgsForCall(i int) (common.MessageAcceptor, bool) {
 	return fake.acceptArgsForCall[i].acceptor, fake.acceptArgsForCall[i].passThrough
 }
 
-func (fake *Gossip) AcceptReturns(result1 <-chan *proto.GossipMessage, result2 <-chan proto.ReceivedMessage) {
+func (fake *Gossip) AcceptReturns(result1 <-chan *proto.GossipMessage, result2 <-chan protoext.ReceivedMessage) {
 	fake.AcceptStub = nil
 	fake.acceptReturns = struct {
 		result1 <-chan *proto.GossipMessage
-		result2 <-chan proto.ReceivedMessage
+		result2 <-chan protoext.ReceivedMessage
 	}{result1, result2}
 }
 
-func (fake *Gossip) AcceptReturnsOnCall(i int, result1 <-chan *proto.GossipMessage, result2 <-chan proto.ReceivedMessage) {
+func (fake *Gossip) AcceptReturnsOnCall(i int, result1 <-chan *proto.GossipMessage, result2 <-chan protoext.ReceivedMessage) {
 	fake.AcceptStub = nil
 	if fake.acceptReturnsOnCall == nil {
 		fake.acceptReturnsOnCall = make(map[int]struct {
 			result1 <-chan *proto.GossipMessage
-			result2 <-chan proto.ReceivedMessage
+			result2 <-chan protoext.ReceivedMessage
 		})
 	}
 	fake.acceptReturnsOnCall[i] = struct {
 		result1 <-chan *proto.GossipMessage
-		result2 <-chan proto.ReceivedMessage
+		result2 <-chan protoext.ReceivedMessage
 	}{result1, result2}
 }
 
diff --git a/discovery/test/integration_test.go b/discovery/test/integration_test.go
index bff876c26..3ec075d71 100644
--- a/discovery/test/integration_test.go
+++ b/discovery/test/integration_test.go
@@ -33,7 +33,7 @@ import (
 	"github.com/hyperledger/fabric/common/tools/configtxgen/encoder"
 	genesisconfig "github.com/hyperledger/fabric/common/tools/configtxgen/localconfig"
 	"github.com/hyperledger/fabric/common/util"
-	"github.com/hyperledger/fabric/core/cclifecycle"
+	cc "github.com/hyperledger/fabric/core/cclifecycle"
 	lifecyclemocks "github.com/hyperledger/fabric/core/cclifecycle/mocks"
 	"github.com/hyperledger/fabric/core/comm"
 	"github.com/hyperledger/fabric/core/common/ccprovider"
@@ -48,6 +48,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/api"
 	gcommon "github.com/hyperledger/fabric/gossip/common"
 	gdisc "github.com/hyperledger/fabric/gossip/discovery"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/msp"
 	"github.com/hyperledger/fabric/protos/common"
 	. "github.com/hyperledger/fabric/protos/discovery"
@@ -745,7 +746,7 @@ func peersToTestPeers(peers []*disc.Peer) testPeerSet {
 		pkiID := gcommon.PKIidType(hex.EncodeToString(util.ComputeSHA256(p.Identity)))
 		var stateInfoMember gdisc.NetworkMember
 		if p.StateInfoMessage != nil {
-			stateInfo, _ := p.StateInfoMessage.ToGossipMessage()
+			stateInfo, _ := protoext.EnvelopeToGossipMessage(p.StateInfoMessage.Envelope)
 			stateInfoMember = gdisc.NetworkMember{
 				PKIid:      pkiID,
 				Envelope:   p.StateInfoMessage.Envelope,
@@ -815,7 +816,7 @@ func stateInfoMsg(pkiID gcommon.PKIidType) gdisc.NetworkMember {
 			StateInfo: si,
 		},
 	}
-	sm, _ := gm.NoopSign()
+	sm, _ := protoext.NoopSign(gm)
 	return gdisc.NetworkMember{
 		Properties: si.Properties,
 		PKIid:      pkiID,
@@ -836,7 +837,7 @@ func aliveMsg(pkiID gcommon.PKIidType) gdisc.NetworkMember {
 			AliveMsg: am,
 		},
 	}
-	sm, _ := gm.NoopSign()
+	sm, _ := protoext.NoopSign(gm)
 	return gdisc.NetworkMember{
 		PKIid:    pkiID,
 		Endpoint: string(pkiID),
diff --git a/gossip/comm/ack.go b/gossip/comm/ack.go
index 62c1febf5..7d871b637 100644
--- a/gossip/comm/ack.go
+++ b/gossip/comm/ack.go
@@ -8,11 +8,11 @@ package comm
 
 import (
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
-	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
-type sendFunc func(peer *RemotePeer, msg *proto.SignedGossipMessage)
+type sendFunc func(peer *RemotePeer, msg *protoext.SignedGossipMessage)
 type waitFunc func(*RemotePeer) error
 
 type ackSendOperation struct {
@@ -27,7 +27,7 @@ func newAckSendOperation(snd sendFunc, waitForAck waitFunc) *ackSendOperation {
 	}
 }
 
-func (aso *ackSendOperation) send(msg *proto.SignedGossipMessage, minAckNum int, peers ...*RemotePeer) []SendResult {
+func (aso *ackSendOperation) send(msg *protoext.SignedGossipMessage, minAckNum int, peers ...*RemotePeer) []SendResult {
 	successAcks := 0
 	results := []SendResult{}
 
@@ -61,9 +61,9 @@ func (aso *ackSendOperation) send(msg *proto.SignedGossipMessage, minAckNum int,
 	return results
 }
 
-func interceptAcks(nextHandler handler, remotePeerID common.PKIidType, pubSub *util.PubSub) func(*proto.SignedGossipMessage) {
-	return func(m *proto.SignedGossipMessage) {
-		if m.IsAck() {
+func interceptAcks(nextHandler handler, remotePeerID common.PKIidType, pubSub *util.PubSub) func(*protoext.SignedGossipMessage) {
+	return func(m *protoext.SignedGossipMessage) {
+		if protoext.IsAck(m.GossipMessage) {
 			topic := topicForAck(m.Nonce, remotePeerID)
 			pubSub.Publish(topic, m.GetAck())
 			return
diff --git a/gossip/comm/ack_test.go b/gossip/comm/ack_test.go
index 55a9b28e3..665ecf92a 100644
--- a/gossip/comm/ack_test.go
+++ b/gossip/comm/ack_test.go
@@ -12,6 +12,7 @@ import (
 	"time"
 
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -20,12 +21,12 @@ import (
 func TestInterceptAcks(t *testing.T) {
 	pubsub := util.NewPubSub()
 	pkiID := common.PKIidType("pkiID")
-	msgs := make(chan *proto.SignedGossipMessage, 1)
-	handlerFunc := func(message *proto.SignedGossipMessage) {
+	msgs := make(chan *protoext.SignedGossipMessage, 1)
+	handlerFunc := func(message *protoext.SignedGossipMessage) {
 		msgs <- message
 	}
 	wrappedHandler := interceptAcks(handlerFunc, pkiID, pubsub)
-	ack := &proto.SignedGossipMessage{
+	ack := &protoext.SignedGossipMessage{
 		GossipMessage: &proto.GossipMessage{
 			Nonce: 1,
 			Content: &proto.GossipMessage_Ack{
@@ -42,7 +43,7 @@ func TestInterceptAcks(t *testing.T) {
 	assert.NoError(t, err)
 
 	// Test none acks are just forwarded
-	notAck := &proto.SignedGossipMessage{
+	notAck := &protoext.SignedGossipMessage{
 		GossipMessage: &proto.GossipMessage{
 			Nonce: 2,
 			Content: &proto.GossipMessage_DataMsg{
@@ -71,15 +72,15 @@ func TestAck(t *testing.T) {
 	defer comm4.Stop()
 
 	acceptData := func(o interface{}) bool {
-		return o.(proto.ReceivedMessage).GetGossipMessage().IsDataMsg()
+		return protoext.IsDataMsg(o.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}
 
-	ack := func(c <-chan proto.ReceivedMessage) {
+	ack := func(c <-chan protoext.ReceivedMessage) {
 		msg := <-c
 		msg.Ack(nil)
 	}
 
-	nack := func(c <-chan proto.ReceivedMessage) {
+	nack := func(c <-chan protoext.ReceivedMessage) {
 		msg := <-c
 		msg.Ack(errors.New("Failed processing message because reasons"))
 	}
diff --git a/gossip/comm/comm.go b/gossip/comm/comm.go
index f231622be..e5c75d254 100644
--- a/gossip/comm/comm.go
+++ b/gossip/comm/comm.go
@@ -13,7 +13,7 @@ import (
 
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/common"
-	proto "github.com/hyperledger/fabric/protos/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 )
 
 // Comm is an object that enables to communicate with other peers
@@ -24,10 +24,10 @@ type Comm interface {
 	GetPKIid() common.PKIidType
 
 	// Send sends a message to remote peers
-	Send(msg *proto.SignedGossipMessage, peers ...*RemotePeer)
+	Send(msg *protoext.SignedGossipMessage, peers ...*RemotePeer)
 
 	// SendWithAck sends a message to remote peers, waiting for acknowledgement from minAck of them, or until a certain timeout expires
-	SendWithAck(msg *proto.SignedGossipMessage, timeout time.Duration, minAck int, peers ...*RemotePeer) AggregatedSendResult
+	SendWithAck(msg *protoext.SignedGossipMessage, timeout time.Duration, minAck int, peers ...*RemotePeer) AggregatedSendResult
 
 	// Probe probes a remote node and returns nil if its responsive,
 	// and an error if it's not.
@@ -39,7 +39,7 @@ type Comm interface {
 
 	// Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.
 	// Each message from the channel can be used to send a reply back to the sender
-	Accept(common.MessageAcceptor) <-chan proto.ReceivedMessage
+	Accept(common.MessageAcceptor) <-chan protoext.ReceivedMessage
 
 	// PresumedDead returns a read-only channel for node endpoints that are suspected to be offline
 	PresumedDead() <-chan common.PKIidType
diff --git a/gossip/comm/comm_impl.go b/gossip/comm/comm_impl.go
index fdfe721e9..cdcf44282 100644
--- a/gossip/comm/comm_impl.go
+++ b/gossip/comm/comm_impl.go
@@ -21,6 +21,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/identity"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -70,7 +71,7 @@ func NewCommInstance(s *grpc.Server, certs *common.TLSCertificates, idStore iden
 		deadEndpoints:  make(chan common.PKIidType, 100),
 		stopping:       int32(0),
 		exitChan:       make(chan struct{}),
-		subscriptions:  make([]chan proto.ReceivedMessage, 0),
+		subscriptions:  make([]chan protoext.ReceivedMessage, 0),
 		tlsCerts:       certs,
 		metrics:        commMetrics,
 		dialTimeout:    config.DialTimeout,
@@ -115,7 +116,7 @@ type commImpl struct {
 	lock           *sync.Mutex
 	exitChan       chan struct{}
 	stopWG         sync.WaitGroup
-	subscriptions  []chan proto.ReceivedMessage
+	subscriptions  []chan protoext.ReceivedMessage
 	stopping       int32
 	metrics        *metrics.CommMetrics
 	dialTimeout    time.Duration
@@ -129,7 +130,7 @@ func (c *commImpl) createConnection(endpoint string, expectedPKIID common.PKIidT
 	var cc *grpc.ClientConn
 	var stream proto.Gossip_GossipStreamClient
 	var pkiID common.PKIidType
-	var connInfo *proto.ConnectionInfo
+	var connInfo *protoext.ConnectionInfo
 	var dialOpts []grpc.DialOption
 
 	c.logger.Debug("Entering", endpoint, expectedPKIID)
@@ -187,7 +188,7 @@ func (c *commImpl) createConnection(endpoint string, expectedPKIID common.PKIidT
 			conn.logger = c.logger
 			conn.cancel = cancel
 
-			h := func(m *proto.SignedGossipMessage) {
+			h := func(m *protoext.SignedGossipMessage) {
 				c.logger.Debug("Got message:", m)
 				c.msgPublisher.DeMultiplex(&ReceivedMessageImpl{
 					conn:                conn,
@@ -206,20 +207,20 @@ func (c *commImpl) createConnection(endpoint string, expectedPKIID common.PKIidT
 	return nil, errors.WithStack(err)
 }
 
-func (c *commImpl) Send(msg *proto.SignedGossipMessage, peers ...*RemotePeer) {
+func (c *commImpl) Send(msg *protoext.SignedGossipMessage, peers ...*RemotePeer) {
 	if c.isStopping() || len(peers) == 0 {
 		return
 	}
 	c.logger.Debug("Entering, sending", msg, "to ", len(peers), "peers")
 
 	for _, peer := range peers {
-		go func(peer *RemotePeer, msg *proto.SignedGossipMessage) {
+		go func(peer *RemotePeer, msg *protoext.SignedGossipMessage) {
 			c.sendToEndpoint(peer, msg, nonBlockingSend)
 		}(peer, msg)
 	}
 }
 
-func (c *commImpl) sendToEndpoint(peer *RemotePeer, msg *proto.SignedGossipMessage, shouldBlock blockingBehavior) {
+func (c *commImpl) sendToEndpoint(peer *RemotePeer, msg *protoext.SignedGossipMessage, shouldBlock blockingBehavior) {
 	if c.isStopping() {
 		return
 	}
@@ -310,9 +311,9 @@ func (c *commImpl) Handshake(remotePeer *RemotePeer) (api.PeerIdentityType, erro
 	return connInfo.Identity, nil
 }
 
-func (c *commImpl) Accept(acceptor common.MessageAcceptor) <-chan proto.ReceivedMessage {
+func (c *commImpl) Accept(acceptor common.MessageAcceptor) <-chan protoext.ReceivedMessage {
 	genericChan := c.msgPublisher.AddChannel(acceptor)
-	specificChan := make(chan proto.ReceivedMessage, 10)
+	specificChan := make(chan protoext.ReceivedMessage, 10)
 
 	if c.isStopping() {
 		c.logger.Warning("Accept() called but comm module is stopping, returning empty channel")
@@ -394,12 +395,12 @@ func extractRemoteAddress(stream stream) string {
 	return remoteAddress
 }
 
-func (c *commImpl) authenticateRemotePeer(stream stream, initiator bool) (*proto.ConnectionInfo, error) {
+func (c *commImpl) authenticateRemotePeer(stream stream, initiator bool) (*protoext.ConnectionInfo, error) {
 	ctx := stream.Context()
 	remoteAddress := extractRemoteAddress(stream)
 	remoteCertHash := extractCertificateHashFromContext(ctx)
 	var err error
-	var cMsg *proto.SignedGossipMessage
+	var cMsg *protoext.SignedGossipMessage
 	useTLS := c.tlsCerts != nil
 	var selfCertHash []byte
 
@@ -451,11 +452,11 @@ func (c *commImpl) authenticateRemotePeer(stream stream, initiator bool) (*proto
 		return nil, err
 	}
 
-	connInfo := &proto.ConnectionInfo{
+	connInfo := &protoext.ConnectionInfo{
 		ID:       receivedMsg.PkiId,
 		Identity: receivedMsg.Identity,
 		Endpoint: remoteAddress,
-		Auth: &proto.AuthInfo{
+		Auth: &protoext.AuthInfo{
 			Signature:  m.Signature,
 			SignedData: m.Payload,
 		},
@@ -486,7 +487,7 @@ func (c *commImpl) authenticateRemotePeer(stream stream, initiator bool) (*proto
 }
 
 // SendWithAck sends a message to remote peers, waiting for acknowledgement from minAck of them, or until a certain timeout expires
-func (c *commImpl) SendWithAck(msg *proto.SignedGossipMessage, timeout time.Duration, minAck int, peers ...*RemotePeer) AggregatedSendResult {
+func (c *commImpl) SendWithAck(msg *protoext.SignedGossipMessage, timeout time.Duration, minAck int, peers ...*RemotePeer) AggregatedSendResult {
 	if len(peers) == 0 {
 		return nil
 	}
@@ -496,7 +497,7 @@ func (c *commImpl) SendWithAck(msg *proto.SignedGossipMessage, timeout time.Dura
 	// between different invocations
 	msg.Nonce = util.RandomUInt64()
 	// Replace the envelope in the message to update the NONCE
-	msg, err = msg.NoopSign()
+	msg, err = protoext.NoopSign(msg.GossipMessage)
 
 	if c.isStopping() || err != nil {
 		if err == nil {
@@ -512,7 +513,7 @@ func (c *commImpl) SendWithAck(msg *proto.SignedGossipMessage, timeout time.Dura
 		return results
 	}
 	c.logger.Debug("Entering, sending", msg, "to ", len(peers), "peers")
-	sndFunc := func(peer *RemotePeer, msg *proto.SignedGossipMessage) {
+	sndFunc := func(peer *RemotePeer, msg *protoext.SignedGossipMessage) {
 		c.sendToEndpoint(peer, msg, blockingSend)
 	}
 	// Subscribe to acks
@@ -555,7 +556,7 @@ func (c *commImpl) GossipStream(stream proto.Gossip_GossipStreamServer) error {
 
 	conn := c.connStore.onConnected(stream, connInfo, c.metrics)
 
-	h := func(m *proto.SignedGossipMessage) {
+	h := func(m *protoext.SignedGossipMessage) {
 		c.msgPublisher.DeMultiplex(&ReceivedMessageImpl{
 			conn:                conn,
 			lock:                conn,
@@ -587,13 +588,13 @@ func (c *commImpl) disconnect(pkiID common.PKIidType) {
 	c.connStore.closeByPKIid(pkiID)
 }
 
-func readWithTimeout(stream interface{}, timeout time.Duration, address string) (*proto.SignedGossipMessage, error) {
-	incChan := make(chan *proto.SignedGossipMessage, 1)
+func readWithTimeout(stream interface{}, timeout time.Duration, address string) (*protoext.SignedGossipMessage, error) {
+	incChan := make(chan *protoext.SignedGossipMessage, 1)
 	errChan := make(chan error, 1)
 	go func() {
 		if srvStr, isServerStr := stream.(proto.Gossip_GossipStreamServer); isServerStr {
 			if m, err := srvStr.Recv(); err == nil {
-				msg, err := m.ToGossipMessage()
+				msg, err := protoext.EnvelopeToGossipMessage(m)
 				if err != nil {
 					errChan <- err
 					return
@@ -602,7 +603,7 @@ func readWithTimeout(stream interface{}, timeout time.Duration, address string)
 			}
 		} else if clStr, isClientStr := stream.(proto.Gossip_GossipStreamClient); isClientStr {
 			if m, err := clStr.Recv(); err == nil {
-				msg, err := m.ToGossipMessage()
+				msg, err := protoext.EnvelopeToGossipMessage(m)
 				if err != nil {
 					errChan <- err
 					return
@@ -623,7 +624,7 @@ func readWithTimeout(stream interface{}, timeout time.Duration, address string)
 	}
 }
 
-func (c *commImpl) createConnectionMsg(pkiID common.PKIidType, certHash []byte, cert api.PeerIdentityType, signer proto.Signer) (*proto.SignedGossipMessage, error) {
+func (c *commImpl) createConnectionMsg(pkiID common.PKIidType, certHash []byte, cert api.PeerIdentityType, signer protoext.Signer) (*protoext.SignedGossipMessage, error) {
 	m := &proto.GossipMessage{
 		Tag:   proto.GossipMessage_EMPTY,
 		Nonce: 0,
@@ -635,7 +636,7 @@ func (c *commImpl) createConnectionMsg(pkiID common.PKIidType, certHash []byte,
 			},
 		},
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	_, err := sMsg.Sign(signer)
diff --git a/gossip/comm/comm_test.go b/gossip/comm/comm_test.go
index 812dc75e2..505682b8b 100644
--- a/gossip/comm/comm_test.go
+++ b/gossip/comm/comm_test.go
@@ -29,6 +29,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/identity"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -164,7 +165,7 @@ func newCommInstance(t *testing.T, sec *naiveSecProvider) (c Comm, port int) {
 	return comm, port
 }
 
-type msgMutator func(*proto.SignedGossipMessage) *proto.SignedGossipMessage
+type msgMutator func(*protoext.SignedGossipMessage) *protoext.SignedGossipMessage
 
 type tlsType int
 
@@ -174,7 +175,7 @@ const (
 	mutualTLS
 )
 
-func handshaker(port int, endpoint string, comm Comm, t *testing.T, connMutator msgMutator, connType tlsType) <-chan proto.ReceivedMessage {
+func handshaker(port int, endpoint string, comm Comm, t *testing.T, connMutator msgMutator, connType tlsType) <-chan protoext.ReceivedMessage {
 	c := &commImpl{}
 	cert := GenerateCertificatesOrPanic()
 	tlsCfg := &tls.Config{
@@ -226,7 +227,7 @@ func handshaker(port int, endpoint string, comm Comm, t *testing.T, connMutator
 		return acceptChan
 	}
 	assert.NoError(t, err, "%v", err)
-	msg, err = envelope.ToGossipMessage()
+	msg, err = protoext.EnvelopeToGossipMessage(envelope)
 	assert.NoError(t, err, "%v", err)
 	assert.Equal(t, []byte(target), msg.GetConn().PkiId)
 	assert.Equal(t, extractCertificateHashFromContext(stream.Context()), msg.GetConn().TlsCertHash)
@@ -251,7 +252,7 @@ func TestMutualParallelSendWithAck(t *testing.T) {
 	defer comm2.Stop()
 
 	acceptData := func(o interface{}) bool {
-		return o.(proto.ReceivedMessage).GetGossipMessage().IsDataMsg()
+		return protoext.IsDataMsg(o.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}
 
 	inc1 := comm1.Accept(acceptData)
@@ -299,10 +300,10 @@ func TestHandshake(t *testing.T) {
 		mac.Write(msg)
 		return mac.Sum(nil), nil
 	}
-	mutator := func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator := func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		return msg
 	}
-	assertPositivePath := func(msg proto.ReceivedMessage, endpoint string) {
+	assertPositivePath := func(msg protoext.ReceivedMessage, endpoint string) {
 		expectedPKIID := common.PKIidType(endpoint)
 		assert.Equal(t, expectedPKIID, msg.GetConnectionInfo().ID)
 		assert.Equal(t, api.PeerIdentityType(endpoint), msg.GetConnectionInfo().Identity)
@@ -321,7 +322,7 @@ func TestHandshake(t *testing.T) {
 	}, naiveSec, disabledMetrics, testCommConfig)
 	go s.Serve(ll)
 	assert.NoError(t, err)
-	var msg proto.ReceivedMessage
+	var msg protoext.ReceivedMessage
 
 	_, tempEndpoint, tempL := getAvailablePort(t)
 	acceptChan := handshaker(port, tempEndpoint, inst, t, mutator, none)
@@ -364,7 +365,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, signature is wrong
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.Signature = append(msg.Signature, 0)
 		return msg
 	}
@@ -375,7 +376,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, the PKIid doesn't match the identity
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.GetConn().PkiId = []byte(tempEndpoint)
 		// Sign the message again
 		msg.Sign(signer)
@@ -390,7 +391,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, the cert hash isn't what is expected
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.GetConn().TlsCertHash = append(msg.GetConn().TlsCertHash, 0)
 		msg.Sign(signer)
 		return msg
@@ -402,7 +403,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, no PKI-ID was sent
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.GetConn().PkiId = nil
 		msg.Sign(signer)
 		return msg
@@ -414,7 +415,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, connection message is of a different type
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		msg.Content = &proto.GossipMessage_Empty{
 			Empty: &proto.Empty{},
 		}
@@ -428,7 +429,7 @@ func TestHandshake(t *testing.T) {
 
 	// Negative path, the peer didn't respond to the handshake in due time
 	_, tempEndpoint, tempL = getAvailablePort(t)
-	mutator = func(msg *proto.SignedGossipMessage) *proto.SignedGossipMessage {
+	mutator = func(msg *protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 		time.Sleep(time.Second * 5)
 		return msg
 	}
@@ -447,7 +448,7 @@ func TestBasic(t *testing.T) {
 	m1 := comm1.Accept(acceptAll)
 	m2 := comm2.Accept(acceptAll)
 	out := make(chan uint64, 2)
-	reader := func(ch <-chan proto.ReceivedMessage) {
+	reader := func(ch <-chan protoext.ReceivedMessage) {
 		m := <-ch
 		out <- m.GetGossipMessage().Nonce
 	}
@@ -537,7 +538,7 @@ func TestProdConstructor(t *testing.T) {
 	m1 := comm1.Accept(acceptAll)
 	m2 := comm2.Accept(acceptAll)
 	out := make(chan uint64, 2)
-	reader := func(ch <-chan proto.ReceivedMessage) {
+	reader := func(ch <-chan protoext.ReceivedMessage) {
 		m := <-ch
 		out <- m.GetGossipMessage().Nonce
 	}
@@ -608,7 +609,7 @@ func TestCloseConn(t *testing.T) {
 	msg2Send.GetDataMsg().Payload = &proto.Payload{
 		Data: make([]byte, 1024*1024),
 	}
-	msg2Send.NoopSign()
+	protoext.NoopSign(msg2Send.GossipMessage)
 	for i := 0; i < DefRecvBuffSize; i++ {
 		err := stream.Send(msg2Send.Envelope)
 		if err != nil {
@@ -753,11 +754,11 @@ func TestAccept(t *testing.T) {
 	comm2, _ := newCommInstance(t, naiveSec)
 
 	evenNONCESelector := func(m interface{}) bool {
-		return m.(proto.ReceivedMessage).GetGossipMessage().Nonce%2 == 0
+		return m.(protoext.ReceivedMessage).GetGossipMessage().Nonce%2 == 0
 	}
 
 	oddNONCESelector := func(m interface{}) bool {
-		return m.(proto.ReceivedMessage).GetGossipMessage().Nonce%2 != 0
+		return m.(protoext.ReceivedMessage).GetGossipMessage().Nonce%2 != 0
 	}
 
 	evenNONCES := comm1.Accept(evenNONCESelector)
@@ -769,7 +770,7 @@ func TestAccept(t *testing.T) {
 	out := make(chan uint64, DefRecvBuffSize)
 	sem := make(chan struct{}, 0)
 
-	readIntoSlice := func(a *[]uint64, ch <-chan proto.ReceivedMessage) {
+	readIntoSlice := func(a *[]uint64, ch <-chan protoext.ReceivedMessage) {
 		for m := range ch {
 			*a = append(*a, m.GetGossipMessage().Nonce)
 			out <- m.GetGossipMessage().Nonce
@@ -810,7 +811,7 @@ func TestReConnections(t *testing.T) {
 	comm1, port1 := newCommInstance(t, naiveSec)
 	comm2, port2 := newCommInstance(t, naiveSec)
 
-	reader := func(out chan uint64, in <-chan proto.ReceivedMessage) {
+	reader := func(out chan uint64, in <-chan protoext.ReceivedMessage) {
 		for {
 			msg := <-in
 			if msg == nil {
@@ -928,14 +929,14 @@ func TestPresumedDead(t *testing.T) {
 	}
 }
 
-func createGossipMsg() *proto.SignedGossipMessage {
-	msg, _ := (&proto.GossipMessage{
+func createGossipMsg() *protoext.SignedGossipMessage {
+	msg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Tag:   proto.GossipMessage_EMPTY,
 		Nonce: uint64(rand.Int()),
 		Content: &proto.GossipMessage_DataMsg{
 			DataMsg: &proto.DataMessage{},
 		},
-	}).NoopSign()
+	})
 	return msg
 }
 
diff --git a/gossip/comm/conn.go b/gossip/comm/conn.go
index a1b7364bf..a296d89a1 100644
--- a/gossip/comm/conn.go
+++ b/gossip/comm/conn.go
@@ -14,13 +14,14 @@ import (
 
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
 	"google.golang.org/grpc"
 )
 
-type handler func(message *proto.SignedGossipMessage)
+type handler func(message *protoext.SignedGossipMessage)
 
 type blockingBehavior bool
 
@@ -164,7 +165,7 @@ func (cs *connectionStore) shutdown() {
 }
 
 func (cs *connectionStore) onConnected(serverStream proto.Gossip_GossipStreamServer,
-	connInfo *proto.ConnectionInfo, metrics *metrics.CommMetrics) *connection {
+	connInfo *protoext.ConnectionInfo, metrics *metrics.CommMetrics) *connection {
 	cs.Lock()
 	defer cs.Unlock()
 
@@ -175,7 +176,7 @@ func (cs *connectionStore) onConnected(serverStream proto.Gossip_GossipStreamSer
 	return cs.registerConn(connInfo, serverStream, metrics)
 }
 
-func (cs *connectionStore) registerConn(connInfo *proto.ConnectionInfo,
+func (cs *connectionStore) registerConn(connInfo *protoext.ConnectionInfo,
 	serverStream proto.Gossip_GossipStreamServer, metrics *metrics.CommMetrics) *connection {
 	conn := newConnection(nil, nil, nil, serverStream, metrics, cs.config)
 	conn.pkiID = connInfo.ID
@@ -220,7 +221,7 @@ type connection struct {
 	recvBuffSize int
 	metrics      *metrics.CommMetrics
 	cancel       context.CancelFunc
-	info         *proto.ConnectionInfo
+	info         *protoext.ConnectionInfo
 	outBuff      chan *msgSending
 	logger       util.Logger                     // logger
 	pkiID        common.PKIidType                // pkiID of the remote endpoint
@@ -266,7 +267,7 @@ func (conn *connection) toDie() bool {
 	return atomic.LoadInt32(&(conn.stopFlag)) == int32(1)
 }
 
-func (conn *connection) send(msg *proto.SignedGossipMessage, onErr func(error), shouldBlock blockingBehavior) {
+func (conn *connection) send(msg *protoext.SignedGossipMessage, onErr func(error), shouldBlock blockingBehavior) {
 	if conn.toDie() {
 		conn.logger.Debugf("Aborting send() to %s because connection is closing", conn.info.Endpoint)
 		return
@@ -292,7 +293,7 @@ func (conn *connection) send(msg *proto.SignedGossipMessage, onErr func(error),
 
 func (conn *connection) serviceConnection() error {
 	errChan := make(chan error, 1)
-	msgChan := make(chan *proto.SignedGossipMessage, conn.recvBuffSize)
+	msgChan := make(chan *protoext.SignedGossipMessage, conn.recvBuffSize)
 	quit := make(chan struct{})
 	// Call stream.Recv() asynchronously in readFromStream(),
 	// and wait for either the Recv() call to end,
@@ -353,7 +354,7 @@ func (conn *connection) drainOutputBuffer() {
 	}
 }
 
-func (conn *connection) readFromStream(errChan chan error, quit chan struct{}, msgChan chan *proto.SignedGossipMessage) {
+func (conn *connection) readFromStream(errChan chan error, quit chan struct{}, msgChan chan *protoext.SignedGossipMessage) {
 	for !conn.toDie() {
 		stream := conn.getStream()
 		if stream == nil {
@@ -372,7 +373,7 @@ func (conn *connection) readFromStream(errChan chan error, quit chan struct{}, m
 			return
 		}
 		conn.metrics.ReceivedMessages.Add(1)
-		msg, err := envelope.ToGossipMessage()
+		msg, err := protoext.EnvelopeToGossipMessage(envelope)
 		if err != nil {
 			errChan <- err
 			conn.logger.Warningf("Got error, aborting: %v", err)
diff --git a/gossip/comm/mock/mock_comm.go b/gossip/comm/mock/mock_comm.go
index 27eda29a8..a64a65bd7 100644
--- a/gossip/comm/mock/mock_comm.go
+++ b/gossip/comm/mock/mock_comm.go
@@ -12,6 +12,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/comm"
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
@@ -39,7 +40,7 @@ type packetMock struct {
 type channelMock struct {
 	accept common.MessageAcceptor
 
-	channel chan proto.ReceivedMessage
+	channel chan protoext.ReceivedMessage
 }
 
 type commMock struct {
@@ -77,7 +78,7 @@ func NewCommMock(id string, members map[string]*socketMock) comm.Comm {
 
 // Respond sends a GossipMessage to the origin from which this ReceivedMessage was sent from
 func (packet *packetMock) Respond(msg *proto.GossipMessage) {
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	packet.src.socket <- &packetMock{
 		src: packet.dst,
 		dst: packet.src,
@@ -97,13 +98,13 @@ func (packet *packetMock) GetSourceEnvelope() *proto.Envelope {
 }
 
 // GetGossipMessage returns the underlying GossipMessage
-func (packet *packetMock) GetGossipMessage() *proto.SignedGossipMessage {
-	return packet.msg.(*proto.SignedGossipMessage)
+func (packet *packetMock) GetGossipMessage() *protoext.SignedGossipMessage {
+	return packet.msg.(*protoext.SignedGossipMessage)
 }
 
 // GetConnectionInfo returns information about the remote peer
 // that sent the message
-func (packet *packetMock) GetConnectionInfo() *proto.ConnectionInfo {
+func (packet *packetMock) GetConnectionInfo() *protoext.ConnectionInfo {
 	return nil
 }
 
@@ -140,7 +141,7 @@ func (mock *commMock) GetPKIid() common.PKIidType {
 }
 
 // Send sends a message to remote peers
-func (mock *commMock) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (mock *commMock) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	for _, peer := range peers {
 		logger.Debug("Sending message to peer ", peer.Endpoint, "from ", mock.id)
 		mock.members[peer.Endpoint].socket <- &packetMock{
@@ -151,7 +152,7 @@ func (mock *commMock) Send(msg *proto.SignedGossipMessage, peers ...*comm.Remote
 	}
 }
 
-func (mock *commMock) SendWithAck(_ *proto.SignedGossipMessage, _ time.Duration, _ int, _ ...*comm.RemotePeer) comm.AggregatedSendResult {
+func (mock *commMock) SendWithAck(_ *protoext.SignedGossipMessage, _ time.Duration, _ int, _ ...*comm.RemotePeer) comm.AggregatedSendResult {
 	panic("not implemented")
 }
 
@@ -169,8 +170,8 @@ func (mock *commMock) Handshake(peer *comm.RemotePeer) (api.PeerIdentityType, er
 
 // Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.
 // Each message from the channel can be used to send a reply back to the sender
-func (mock *commMock) Accept(accept common.MessageAcceptor) <-chan proto.ReceivedMessage {
-	ch := make(chan proto.ReceivedMessage)
+func (mock *commMock) Accept(accept common.MessageAcceptor) <-chan protoext.ReceivedMessage {
+	ch := make(chan protoext.ReceivedMessage)
 	mock.acceptors = append(mock.acceptors, &channelMock{accept, ch})
 	return ch
 }
diff --git a/gossip/comm/mock/mock_comm_test.go b/gossip/comm/mock/mock_comm_test.go
index 8f5218729..843b5e122 100644
--- a/gossip/comm/mock/mock_comm_test.go
+++ b/gossip/comm/mock/mock_comm_test.go
@@ -11,6 +11,7 @@ import (
 
 	"github.com/hyperledger/fabric/gossip/comm"
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
@@ -27,19 +28,19 @@ func TestMockComm(t *testing.T) {
 	defer comm1.Stop()
 
 	msgCh := comm1.Accept(func(message interface{}) bool {
-		return message.(proto.ReceivedMessage).GetGossipMessage().GetStateRequest() != nil ||
-			message.(proto.ReceivedMessage).GetGossipMessage().GetStateResponse() != nil
+		return message.(protoext.ReceivedMessage).GetGossipMessage().GetStateRequest() != nil ||
+			message.(protoext.ReceivedMessage).GetGossipMessage().GetStateResponse() != nil
 	})
 
 	comm2 := NewCommMock(second.endpoint, members)
 	defer comm2.Stop()
 
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Content: &proto.GossipMessage_StateRequest{StateRequest: &proto.RemoteStateRequest{
 			StartSeqNum: 1,
 			EndSeqNum:   3,
 		}},
-	}).NoopSign()
+	})
 	comm2.Send(sMsg, &comm.RemotePeer{Endpoint: "first", PKIID: common.PKIidType("first")})
 
 	msg := <-msgCh
@@ -64,7 +65,7 @@ func TestMockComm_PingPong(t *testing.T) {
 	rcvChA := peerA.Accept(all)
 	rcvChB := peerB.Accept(all)
 
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Content: &proto.GossipMessage_DataMsg{
 			DataMsg: &proto.DataMessage{
 				Payload: &proto.Payload{
@@ -72,7 +73,7 @@ func TestMockComm_PingPong(t *testing.T) {
 					Data:   []byte("Ping"),
 				},
 			}},
-	}).NoopSign()
+	})
 	peerA.Send(sMsg, &comm.RemotePeer{Endpoint: "peerB", PKIID: common.PKIidType("peerB")})
 
 	msg := <-rcvChB
diff --git a/gossip/comm/msg.go b/gossip/comm/msg.go
index 283a528b1..2f29a5b31 100644
--- a/gossip/comm/msg.go
+++ b/gossip/comm/msg.go
@@ -9,16 +9,17 @@ package comm
 import (
 	"sync"
 
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
 )
 
 // ReceivedMessageImpl is an implementation of ReceivedMessage
 type ReceivedMessageImpl struct {
-	*proto.SignedGossipMessage
+	*protoext.SignedGossipMessage
 	lock     sync.Locker
 	conn     *connection
-	connInfo *proto.ConnectionInfo
+	connInfo *protoext.ConnectionInfo
 }
 
 // GetSourceEnvelope Returns the Envelope the ReceivedMessage was
@@ -29,7 +30,7 @@ func (m *ReceivedMessageImpl) GetSourceEnvelope() *proto.Envelope {
 
 // Respond sends a msg to the source that sent the ReceivedMessageImpl
 func (m *ReceivedMessageImpl) Respond(msg *proto.GossipMessage) {
-	sMsg, err := msg.NoopSign()
+	sMsg, err := protoext.NoopSign(msg)
 	if err != nil {
 		err = errors.WithStack(err)
 		m.conn.logger.Errorf("Failed creating SignedGossipMessage: %+v", err)
@@ -39,13 +40,13 @@ func (m *ReceivedMessageImpl) Respond(msg *proto.GossipMessage) {
 }
 
 // GetGossipMessage returns the inner GossipMessage
-func (m *ReceivedMessageImpl) GetGossipMessage() *proto.SignedGossipMessage {
+func (m *ReceivedMessageImpl) GetGossipMessage() *protoext.SignedGossipMessage {
 	return m.SignedGossipMessage
 }
 
 // GetConnectionInfo returns information about the remote peer
 // that send the message
-func (m *ReceivedMessageImpl) GetConnectionInfo() *proto.ConnectionInfo {
+func (m *ReceivedMessageImpl) GetConnectionInfo() *protoext.ConnectionInfo {
 	return m.connInfo
 }
 
diff --git a/gossip/discovery/discovery.go b/gossip/discovery/discovery.go
index 675eb96f8..08ab8fea5 100644
--- a/gossip/discovery/discovery.go
+++ b/gossip/discovery/discovery.go
@@ -10,13 +10,14 @@ import (
 	"fmt"
 
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
 // CryptoService is an interface that the discovery expects to be implemented and passed on creation
 type CryptoService interface {
 	// ValidateAliveMsg validates that an Alive message is authentic
-	ValidateAliveMsg(message *proto.SignedGossipMessage) bool
+	ValidateAliveMsg(message *protoext.SignedGossipMessage) bool
 
 	// SignMessage signs a message
 	SignMessage(m *proto.GossipMessage, internalEndpoint string) *proto.Envelope
@@ -24,12 +25,12 @@ type CryptoService interface {
 
 // EnvelopeFilter may or may not remove part of the Envelope
 // that the given SignedGossipMessage originates from.
-type EnvelopeFilter func(message *proto.SignedGossipMessage) *proto.Envelope
+type EnvelopeFilter func(message *protoext.SignedGossipMessage) *proto.Envelope
 
 // Sieve defines the messages that are allowed to be sent to some remote peer,
 // based on some criteria.
 // Returns whether the sieve permits sending a given message.
-type Sieve func(message *proto.SignedGossipMessage) bool
+type Sieve func(message *protoext.SignedGossipMessage) bool
 
 // DisclosurePolicy defines which messages a given remote peer
 // is eligible of knowing about, and also what is it eligible
@@ -45,17 +46,17 @@ type DisclosurePolicy func(remotePeer *NetworkMember) (Sieve, EnvelopeFilter)
 // CommService is an interface that the discovery expects to be implemented and passed on creation
 type CommService interface {
 	// Gossip gossips a message
-	Gossip(msg *proto.SignedGossipMessage)
+	Gossip(msg *protoext.SignedGossipMessage)
 
 	// SendToPeer sends to a given peer a message.
 	// The nonce can be anything since the communication module handles the nonce itself
-	SendToPeer(peer *NetworkMember, msg *proto.SignedGossipMessage)
+	SendToPeer(peer *NetworkMember, msg *protoext.SignedGossipMessage)
 
 	// Ping probes a remote peer and returns if it's responsive or not
 	Ping(peer *NetworkMember) bool
 
 	// Accept returns a read-only channel for membership messages sent from remote peers
-	Accept() <-chan proto.ReceivedMessage
+	Accept() <-chan protoext.ReceivedMessage
 
 	// PresumedDead returns a read-only channel for peers that are presumed to be dead
 	PresumedDead() <-chan common.PKIidType
@@ -65,7 +66,7 @@ type CommService interface {
 
 	// Forward sends message to the next hop, excluding the hop
 	// from which message was initially received
-	Forward(msg proto.ReceivedMessage)
+	Forward(msg protoext.ReceivedMessage)
 }
 
 // NetworkMember is a peer's representation
diff --git a/gossip/discovery/discovery_impl.go b/gossip/discovery/discovery_impl.go
index c184f752a..49c08054a 100644
--- a/gossip/discovery/discovery_impl.go
+++ b/gossip/discovery/discovery_impl.go
@@ -18,6 +18,7 @@ import (
 
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/gossip/msgstore"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -56,7 +57,7 @@ type gossipDiscoveryImpl struct {
 	id2Member        map[string]*NetworkMember // all known members
 	aliveMembership  *util.MembershipStore
 	deadMembership   *util.MembershipStore
-	selfAliveMessage *proto.SignedGossipMessage
+	selfAliveMessage *protoext.SignedGossipMessage
 
 	msgStore *aliveMsgStore
 
@@ -169,13 +170,13 @@ func (d *gossipDiscoveryImpl) Connect(member NetworkMember, id identifier) {
 				d.logger.Warningf("Failed creating membership request: %+v", errors.WithStack(err))
 				continue
 			}
-			req, err := m.NoopSign()
+			req, err := protoext.NoopSign(m)
 			if err != nil {
 				d.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 				continue
 			}
 			req.Nonce = util.RandomUInt64()
-			req, err = req.NoopSign()
+			req, err = protoext.NoopSign(req.GossipMessage)
 			if err != nil {
 				d.logger.Warningf("Failed adding NONCE to SignedGossipMessage %+v", errors.WithStack(err))
 				continue
@@ -214,7 +215,7 @@ func (d *gossipDiscoveryImpl) validateSelfConfig() {
 	d.port = int(myPort)
 }
 
-func (d *gossipDiscoveryImpl) sendUntilAcked(peer *NetworkMember, message *proto.SignedGossipMessage) {
+func (d *gossipDiscoveryImpl) sendUntilAcked(peer *NetworkMember, message *protoext.SignedGossipMessage) {
 	nonce := message.Nonce
 	for i := 0; i < maxConnectionAttempts && !d.toDie(); i++ {
 		sub := d.pubsub.Subscribe(fmt.Sprintf("%d", nonce), time.Second*5)
@@ -236,7 +237,7 @@ func (d *gossipDiscoveryImpl) InitiateSync(peerNum int) {
 		d.logger.Warningf("Failed creating membership request: %+v", errors.WithStack(err))
 		return
 	}
-	memReq, err := m.NoopSign()
+	memReq, err := protoext.NoopSign(m)
 	if err != nil {
 		d.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -254,7 +255,7 @@ func (d *gossipDiscoveryImpl) InitiateSync(peerNum int) {
 		pulledPeer := aliveMembersAsSlice[i].GetAliveMsg().Membership
 		var internalEndpoint string
 		if aliveMembersAsSlice[i].Envelope.SecretEnvelope != nil {
-			internalEndpoint = aliveMembersAsSlice[i].Envelope.SecretEnvelope.InternalEndpoint()
+			internalEndpoint = protoext.InternalEndpoint(aliveMembersAsSlice[i].Envelope.SecretEnvelope)
 		}
 		netMember := &NetworkMember{
 			Endpoint:         pulledPeer.Endpoint,
@@ -310,7 +311,7 @@ func (d *gossipDiscoveryImpl) handleMessages() {
 	}
 }
 
-func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
+func (d *gossipDiscoveryImpl) handleMsgFromComm(msg protoext.ReceivedMessage) {
 	if msg == nil {
 		return
 	}
@@ -324,7 +325,7 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 	defer d.logger.Debug("Exiting")
 
 	if memReq := m.GetMemReq(); memReq != nil {
-		selfInfoGossipMsg, err := memReq.SelfInformation.ToGossipMessage()
+		selfInfoGossipMsg, err := protoext.EnvelopeToGossipMessage(memReq.SelfInformation)
 		if err != nil {
 			d.logger.Warningf("Failed deserializing GossipMessage from envelope: %+v", errors.WithStack(err))
 			return
@@ -340,7 +341,7 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 
 		var internalEndpoint string
 		if m.Envelope.SecretEnvelope != nil {
-			internalEndpoint = m.Envelope.SecretEnvelope.InternalEndpoint()
+			internalEndpoint = protoext.InternalEndpoint(m.Envelope.SecretEnvelope)
 		}
 
 		// Sending a membership response to a peer may block this routine
@@ -350,7 +351,7 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 		return
 	}
 
-	if m.IsAliveMsg() {
+	if protoext.IsAliveMsg(m.GossipMessage) {
 		if !d.msgStore.CheckValid(m) || !d.crypt.ValidateAliveMsg(m) {
 			return
 		}
@@ -368,12 +369,12 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 	if memResp := m.GetMemRes(); memResp != nil {
 		d.pubsub.Publish(fmt.Sprintf("%d", m.Nonce), m.Nonce)
 		for _, env := range memResp.Alive {
-			am, err := env.ToGossipMessage()
+			am, err := protoext.EnvelopeToGossipMessage(env)
 			if err != nil {
 				d.logger.Warningf("Membership response contains an invalid message from an online peer:%+v", errors.WithStack(err))
 				return
 			}
-			if !am.IsAliveMsg() {
+			if !protoext.IsAliveMsg(am.GossipMessage) {
 				d.logger.Warning("Expected alive message, got", am, "instead")
 				return
 			}
@@ -384,7 +385,7 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 		}
 
 		for _, env := range memResp.Dead {
-			dm, err := env.ToGossipMessage()
+			dm, err := protoext.EnvelopeToGossipMessage(env)
 			if err != nil {
 				d.logger.Warningf("Membership response contains an invalid message from an offline peer %+v", errors.WithStack(err))
 				return
@@ -395,13 +396,13 @@ func (d *gossipDiscoveryImpl) handleMsgFromComm(msg proto.ReceivedMessage) {
 				continue
 			}
 
-			newDeadMembers := []*proto.SignedGossipMessage{}
+			newDeadMembers := []*protoext.SignedGossipMessage{}
 			d.lock.RLock()
 			if _, known := d.id2Member[string(dm.GetAliveMsg().Membership.PkiId)]; !known {
 				newDeadMembers = append(newDeadMembers, dm)
 			}
 			d.lock.RUnlock()
-			d.learnNewMembers([]*proto.SignedGossipMessage{}, newDeadMembers)
+			d.learnNewMembers([]*protoext.SignedGossipMessage{}, newDeadMembers)
 		}
 	}
 }
@@ -416,7 +417,7 @@ func (d *gossipDiscoveryImpl) sendMemResponse(targetMember *proto.Member, intern
 		InternalEndpoint: internalEndpoint,
 	}
 
-	var aliveMsg *proto.SignedGossipMessage
+	var aliveMsg *protoext.SignedGossipMessage
 	var err error
 	d.lock.RLock()
 	aliveMsg = d.selfAliveMessage
@@ -438,13 +439,13 @@ func (d *gossipDiscoveryImpl) sendMemResponse(targetMember *proto.Member, intern
 
 	defer d.logger.Debug("Exiting, replying with", memResp)
 
-	msg, err := (&proto.GossipMessage{
+	msg, err := protoext.NoopSign(&proto.GossipMessage{
 		Tag:   proto.GossipMessage_EMPTY,
 		Nonce: nonce,
 		Content: &proto.GossipMessage_MemRes{
 			MemRes: memResp,
 		},
-	}).NoopSign()
+	})
 	if err != nil {
 		err = errors.WithStack(err)
 		d.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
@@ -453,7 +454,7 @@ func (d *gossipDiscoveryImpl) sendMemResponse(targetMember *proto.Member, intern
 	d.comm.SendToPeer(targetPeer, msg)
 }
 
-func (d *gossipDiscoveryImpl) createMembershipResponse(aliveMsg *proto.SignedGossipMessage, targetMember *NetworkMember) *proto.MembershipResponse {
+func (d *gossipDiscoveryImpl) createMembershipResponse(aliveMsg *protoext.SignedGossipMessage, targetMember *NetworkMember) *proto.MembershipResponse {
 	shouldBeDisclosed, omitConcealedFields := d.disclosurePolicy(targetMember)
 
 	if !shouldBeDisclosed(aliveMsg) {
@@ -487,7 +488,7 @@ func (d *gossipDiscoveryImpl) createMembershipResponse(aliveMsg *proto.SignedGos
 	}
 }
 
-func (d *gossipDiscoveryImpl) handleAliveMessage(m *proto.SignedGossipMessage) {
+func (d *gossipDiscoveryImpl) handleAliveMessage(m *protoext.SignedGossipMessage) {
 	d.logger.Debug("Entering", m)
 	defer d.logger.Debug("Exiting")
 
@@ -504,7 +505,7 @@ func (d *gossipDiscoveryImpl) handleAliveMessage(m *proto.SignedGossipMessage) {
 	d.lock.RUnlock()
 
 	if !known {
-		d.learnNewMembers([]*proto.SignedGossipMessage{m}, []*proto.SignedGossipMessage{})
+		d.learnNewMembers([]*protoext.SignedGossipMessage{m}, []*protoext.SignedGossipMessage{})
 		return
 	}
 
@@ -539,7 +540,7 @@ func (d *gossipDiscoveryImpl) handleAliveMessage(m *proto.SignedGossipMessage) {
 
 	if isAlive {
 		if before(lastAliveTS, ts) {
-			d.learnExistingMembers([]*proto.SignedGossipMessage{m})
+			d.learnExistingMembers([]*protoext.SignedGossipMessage{m})
 		} else if !same(lastAliveTS, ts) {
 			d.logger.Debug(m.GetAliveMsg().Membership, "lastAliveTS:", lastAliveTS, "but got ts:", ts)
 		}
@@ -548,7 +549,7 @@ func (d *gossipDiscoveryImpl) handleAliveMessage(m *proto.SignedGossipMessage) {
 	// else, ignore the message because it is too old
 }
 
-func (d *gossipDiscoveryImpl) isSentByMe(m *proto.SignedGossipMessage) bool {
+func (d *gossipDiscoveryImpl) isSentByMe(m *protoext.SignedGossipMessage) bool {
 	pkiID := m.GetAliveMsg().Membership.PkiId
 	if !equalPKIid(pkiID, d.self.PKIid) {
 		return false
@@ -557,8 +558,8 @@ func (d *gossipDiscoveryImpl) isSentByMe(m *proto.SignedGossipMessage) bool {
 	diffExternalEndpoint := d.self.Endpoint != m.GetAliveMsg().Membership.Endpoint
 	var diffInternalEndpoint bool
 	secretEnvelope := m.GetSecretEnvelope()
-	if secretEnvelope != nil && secretEnvelope.InternalEndpoint() != "" {
-		diffInternalEndpoint = secretEnvelope.InternalEndpoint() != d.self.InternalEndpoint
+	if secretEnvelope != nil && protoext.InternalEndpoint(secretEnvelope) != "" {
+		diffInternalEndpoint = protoext.InternalEndpoint(secretEnvelope) != d.self.InternalEndpoint
 	}
 	if diffInternalEndpoint || diffExternalEndpoint {
 		d.logger.Error("Bad configuration detected: Received AliveMessage from a peer with the same PKI-ID as myself:", m.GossipMessage)
@@ -566,7 +567,7 @@ func (d *gossipDiscoveryImpl) isSentByMe(m *proto.SignedGossipMessage) bool {
 	return true
 }
 
-func (d *gossipDiscoveryImpl) resurrectMember(am *proto.SignedGossipMessage, t proto.PeerTime) {
+func (d *gossipDiscoveryImpl) resurrectMember(am *protoext.SignedGossipMessage, t proto.PeerTime) {
 	d.logger.Debug("Entering, AliveMessage:", am, "t:", t)
 	defer d.logger.Debug("Exiting")
 	d.lock.Lock()
@@ -585,7 +586,7 @@ func (d *gossipDiscoveryImpl) resurrectMember(am *proto.SignedGossipMessage, t p
 		internalEndpoint = prevNetMem.InternalEndpoint
 	}
 	if am.Envelope.SecretEnvelope != nil {
-		internalEndpoint = am.Envelope.SecretEnvelope.InternalEndpoint()
+		internalEndpoint = protoext.InternalEndpoint(am.Envelope.SecretEnvelope)
 	}
 
 	d.id2Member[string(pkiID)] = &NetworkMember{
@@ -597,7 +598,7 @@ func (d *gossipDiscoveryImpl) resurrectMember(am *proto.SignedGossipMessage, t p
 
 	delete(d.deadLastTS, string(pkiID))
 	d.deadMembership.Remove(common.PKIidType(pkiID))
-	d.aliveMembership.Put(common.PKIidType(pkiID), &proto.SignedGossipMessage{GossipMessage: am.GossipMessage, Envelope: am.Envelope})
+	d.aliveMembership.Put(common.PKIidType(pkiID), &protoext.SignedGossipMessage{GossipMessage: am.GossipMessage, Envelope: am.Envelope})
 }
 
 func (d *gossipDiscoveryImpl) periodicalReconnectToDead() {
@@ -631,7 +632,7 @@ func (d *gossipDiscoveryImpl) sendMembershipRequest(member *NetworkMember, inclu
 		d.logger.Warningf("Failed creating membership request: %+v", errors.WithStack(err))
 		return
 	}
-	req, err := m.NoopSign()
+	req, err := protoext.NoopSign(m)
 	if err != nil {
 		d.logger.Errorf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -779,13 +780,13 @@ func (d *gossipDiscoveryImpl) aliveMsgAndInternalEndpoint() (*proto.GossipMessag
 	return msg, internalEndpoint
 }
 
-func (d *gossipDiscoveryImpl) createSignedAliveMessage(includeInternalEndpoint bool) (*proto.SignedGossipMessage, error) {
+func (d *gossipDiscoveryImpl) createSignedAliveMessage(includeInternalEndpoint bool) (*protoext.SignedGossipMessage, error) {
 	msg, internalEndpoint := d.aliveMsgAndInternalEndpoint()
 	envp := d.crypt.SignMessage(msg, internalEndpoint)
 	if envp == nil {
 		return nil, errors.New("Failed signing message")
 	}
-	signedMsg := &proto.SignedGossipMessage{
+	signedMsg := &protoext.SignedGossipMessage{
 		GossipMessage: msg,
 		Envelope:      envp,
 	}
@@ -797,7 +798,7 @@ func (d *gossipDiscoveryImpl) createSignedAliveMessage(includeInternalEndpoint b
 	return signedMsg, nil
 }
 
-func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*proto.SignedGossipMessage) {
+func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*protoext.SignedGossipMessage) {
 	d.logger.Debugf("Entering: learnedMembers={%v}", aliveArr)
 	defer d.logger.Debug("Exiting")
 
@@ -817,7 +818,7 @@ func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*proto.SignedGossi
 			internalEndpoint = prevNetMem.InternalEndpoint
 		}
 		if m.Envelope.SecretEnvelope != nil {
-			internalEndpoint = m.Envelope.SecretEnvelope.InternalEndpoint()
+			internalEndpoint = protoext.InternalEndpoint(m.Envelope.SecretEnvelope)
 		}
 
 		// update member's data
@@ -844,7 +845,7 @@ func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*proto.SignedGossi
 
 			if am := d.aliveMembership.MsgByID(m.GetAliveMsg().Membership.PkiId); am == nil {
 				d.logger.Debug("Adding", am, "to aliveMembership")
-				msg := &proto.SignedGossipMessage{GossipMessage: m.GossipMessage, Envelope: am.Envelope}
+				msg := &protoext.SignedGossipMessage{GossipMessage: m.GossipMessage, Envelope: am.Envelope}
 				d.aliveMembership.Put(m.GetAliveMsg().Membership.PkiId, msg)
 			} else {
 				d.logger.Debug("Replacing", am, "in aliveMembership")
@@ -855,7 +856,7 @@ func (d *gossipDiscoveryImpl) learnExistingMembers(aliveArr []*proto.SignedGossi
 	}
 }
 
-func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*proto.SignedGossipMessage, deadMembers []*proto.SignedGossipMessage) {
+func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*protoext.SignedGossipMessage, deadMembers []*protoext.SignedGossipMessage) {
 	d.logger.Debugf("Entering: learnedMembers={%v}, deadMembers={%v}", aliveMembers, deadMembers)
 	defer d.logger.Debugf("Exiting")
 
@@ -872,7 +873,7 @@ func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*proto.SignedGossip
 			seqNum:   am.GetAliveMsg().Timestamp.SeqNum,
 		}
 
-		d.aliveMembership.Put(am.GetAliveMsg().Membership.PkiId, &proto.SignedGossipMessage{GossipMessage: am.GossipMessage, Envelope: am.Envelope})
+		d.aliveMembership.Put(am.GetAliveMsg().Membership.PkiId, &protoext.SignedGossipMessage{GossipMessage: am.GossipMessage, Envelope: am.Envelope})
 		d.logger.Debugf("Learned about a new alive member: %v", am)
 	}
 
@@ -886,12 +887,12 @@ func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*proto.SignedGossip
 			seqNum:   dm.GetAliveMsg().Timestamp.SeqNum,
 		}
 
-		d.deadMembership.Put(dm.GetAliveMsg().Membership.PkiId, &proto.SignedGossipMessage{GossipMessage: dm.GossipMessage, Envelope: dm.Envelope})
+		d.deadMembership.Put(dm.GetAliveMsg().Membership.PkiId, &protoext.SignedGossipMessage{GossipMessage: dm.GossipMessage, Envelope: dm.Envelope})
 		d.logger.Debugf("Learned about a new dead member: %v", dm)
 	}
 
 	// update the member in any case
-	for _, a := range [][]*proto.SignedGossipMessage{aliveMembers, deadMembers} {
+	for _, a := range [][]*protoext.SignedGossipMessage{aliveMembers, deadMembers} {
 		for _, m := range a {
 			member := m.GetAliveMsg()
 			if member == nil {
@@ -901,7 +902,7 @@ func (d *gossipDiscoveryImpl) learnNewMembers(aliveMembers []*proto.SignedGossip
 
 			var internalEndpoint string
 			if m.Envelope.SecretEnvelope != nil {
-				internalEndpoint = m.Envelope.SecretEnvelope.InternalEndpoint()
+				internalEndpoint = protoext.InternalEndpoint(m.Envelope.SecretEnvelope)
 			}
 
 			if prevNetMem := d.id2Member[string(member.Membership.PkiId)]; prevNetMem != nil {
@@ -960,7 +961,7 @@ func (d *gossipDiscoveryImpl) UpdateEndpoint(endpoint string) {
 func (d *gossipDiscoveryImpl) Self() NetworkMember {
 	var env *proto.Envelope
 	msg, _ := d.aliveMsgAndInternalEndpoint()
-	sMsg, err := msg.NoopSign()
+	sMsg, err := protoext.NoopSign(msg)
 	if err != nil {
 		d.logger.Warning("Failed creating SignedGossipMessage:", err)
 	} else {
@@ -1016,20 +1017,20 @@ type aliveMsgStore struct {
 }
 
 func newAliveMsgStore(d *gossipDiscoveryImpl) *aliveMsgStore {
-	policy := proto.NewGossipMessageComparator(0)
+	policy := protoext.NewGossipMessageComparator(0)
 	trigger := func(m interface{}) {}
 	aliveMsgTTL := d.aliveExpirationTimeout * msgExpirationFactor
 	externalLock := func() { d.lock.Lock() }
 	externalUnlock := func() { d.lock.Unlock() }
 	callback := func(m interface{}) {
-		msg := m.(*proto.SignedGossipMessage)
-		if !msg.IsAliveMsg() {
+		msg := m.(*protoext.SignedGossipMessage)
+		if !protoext.IsAliveMsg(msg.GossipMessage) {
 			return
 		}
 		membership := msg.GetAliveMsg().Membership
 		id := membership.PkiId
 		endpoint := membership.Endpoint
-		internalEndpoint := msg.SecretEnvelope.InternalEndpoint()
+		internalEndpoint := protoext.InternalEndpoint(msg.SecretEnvelope)
 		if util.Contains(endpoint, d.bootstrapPeers) || util.Contains(internalEndpoint, d.bootstrapPeers) {
 			// Never remove a bootstrap peer
 			return
@@ -1049,14 +1050,14 @@ func newAliveMsgStore(d *gossipDiscoveryImpl) *aliveMsgStore {
 }
 
 func (s *aliveMsgStore) Add(msg interface{}) bool {
-	if !msg.(*proto.SignedGossipMessage).IsAliveMsg() {
+	if !protoext.IsAliveMsg(msg.(*protoext.SignedGossipMessage).GossipMessage) {
 		panic(fmt.Sprint("Msg ", msg, " is not AliveMsg"))
 	}
 	return s.MessageStore.Add(msg)
 }
 
 func (s *aliveMsgStore) CheckValid(msg interface{}) bool {
-	if !msg.(*proto.SignedGossipMessage).IsAliveMsg() {
+	if !protoext.IsAliveMsg(msg.(*protoext.SignedGossipMessage).GossipMessage) {
 		panic(fmt.Sprint("Msg ", msg, " is not AliveMsg"))
 	}
 	return s.MessageStore.CheckValid(msg)
diff --git a/gossip/discovery/discovery_test.go b/gossip/discovery/discovery_test.go
index a21c7f6a8..939c5e126 100644
--- a/gossip/discovery/discovery_test.go
+++ b/gossip/discovery/discovery_test.go
@@ -25,6 +25,7 @@ import (
 	"github.com/hyperledger/fabric/common/flogging"
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/gossip/msgstore"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -51,15 +52,15 @@ func init() {
 }
 
 type dummyReceivedMessage struct {
-	msg  *proto.SignedGossipMessage
-	info *proto.ConnectionInfo
+	msg  *protoext.SignedGossipMessage
+	info *protoext.ConnectionInfo
 }
 
 func (*dummyReceivedMessage) Respond(msg *proto.GossipMessage) {
 	panic("implement me")
 }
 
-func (rm *dummyReceivedMessage) GetGossipMessage() *proto.SignedGossipMessage {
+func (rm *dummyReceivedMessage) GetGossipMessage() *protoext.SignedGossipMessage {
 	return rm.msg
 }
 
@@ -67,7 +68,7 @@ func (*dummyReceivedMessage) GetSourceEnvelope() *proto.Envelope {
 	panic("implement me")
 }
 
-func (rm *dummyReceivedMessage) GetConnectionInfo() *proto.ConnectionInfo {
+func (rm *dummyReceivedMessage) GetConnectionInfo() *protoext.ConnectionInfo {
 	return rm.info
 }
 
@@ -76,7 +77,7 @@ func (*dummyReceivedMessage) Ack(err error) {
 }
 
 type dummyCommModule struct {
-	validatedMessages chan *proto.SignedGossipMessage
+	validatedMessages chan *protoext.SignedGossipMessage
 	msgsReceived      uint32
 	msgsSent          uint32
 	id                string
@@ -85,7 +86,7 @@ type dummyCommModule struct {
 	streams           map[string]proto.Gossip_GossipStreamClient
 	conns             map[string]*grpc.ClientConn
 	lock              *sync.RWMutex
-	incMsgs           chan proto.ReceivedMessage
+	incMsgs           chan protoext.ReceivedMessage
 	lastSeqs          map[string]uint64
 	shouldGossip      bool
 	disableComm       bool
@@ -93,7 +94,7 @@ type dummyCommModule struct {
 }
 
 type gossipInstance struct {
-	msgInterceptor func(*proto.SignedGossipMessage)
+	msgInterceptor func(*protoext.SignedGossipMessage)
 	comm           *dummyCommModule
 	Discovery
 	gRGCserv      *grpc.Server
@@ -104,7 +105,7 @@ type gossipInstance struct {
 	port          int
 }
 
-func (comm *dummyCommModule) ValidateAliveMsg(am *proto.SignedGossipMessage) bool {
+func (comm *dummyCommModule) ValidateAliveMsg(am *protoext.SignedGossipMessage) bool {
 	comm.lock.RLock()
 	c := comm.validatedMessages
 	comm.lock.RUnlock()
@@ -115,14 +116,14 @@ func (comm *dummyCommModule) ValidateAliveMsg(am *proto.SignedGossipMessage) boo
 	return true
 }
 
-func (comm *dummyCommModule) recordValidation(validatedMessages chan *proto.SignedGossipMessage) {
+func (comm *dummyCommModule) recordValidation(validatedMessages chan *protoext.SignedGossipMessage) {
 	comm.lock.Lock()
 	defer comm.lock.Unlock()
 	comm.validatedMessages = validatedMessages
 }
 
 func (comm *dummyCommModule) SignMessage(am *proto.GossipMessage, internalEndpoint string) *proto.Envelope {
-	am.NoopSign()
+	protoext.NoopSign(am)
 
 	secret := &proto.Secret{
 		Content: &proto.Secret_InternalEndpoint{
@@ -132,13 +133,13 @@ func (comm *dummyCommModule) SignMessage(am *proto.GossipMessage, internalEndpoi
 	signer := func(msg []byte) ([]byte, error) {
 		return nil, nil
 	}
-	s, _ := am.NoopSign()
+	s, _ := protoext.NoopSign(am)
 	env := s.Envelope
-	env.SignSecret(signer, secret)
+	protoext.SignSecret(env, signer, secret)
 	return env
 }
 
-func (comm *dummyCommModule) Gossip(msg *proto.SignedGossipMessage) {
+func (comm *dummyCommModule) Gossip(msg *protoext.SignedGossipMessage) {
 	if !comm.shouldGossip || comm.disableComm {
 		return
 	}
@@ -160,7 +161,7 @@ func (comm *dummyCommModule) Forward(msg proto.ReceivedMessage) {
 	}
 }
 
-func (comm *dummyCommModule) SendToPeer(peer *NetworkMember, msg *proto.SignedGossipMessage) {
+func (comm *dummyCommModule) SendToPeer(peer *NetworkMember, msg *protoext.SignedGossipMessage) {
 	if comm.disableComm {
 		return
 	}
@@ -180,7 +181,7 @@ func (comm *dummyCommModule) SendToPeer(peer *NetworkMember, msg *proto.SignedGo
 		}
 	}
 	comm.lock.Lock()
-	s, _ := msg.NoopSign()
+	s, _ := protoext.NoopSign(msg.GossipMessage)
 	comm.streams[peer.Endpoint].Send(s.Envelope)
 	comm.lock.Unlock()
 	atomic.AddUint32(&comm.msgsSent, 1)
@@ -217,7 +218,7 @@ func (comm *dummyCommModule) Ping(peer *NetworkMember) bool {
 	return true
 }
 
-func (comm *dummyCommModule) Accept() <-chan proto.ReceivedMessage {
+func (comm *dummyCommModule) Accept() <-chan protoext.ReceivedMessage {
 	return comm.incMsgs
 }
 
@@ -275,7 +276,7 @@ func (g *gossipInstance) GossipStream(stream proto.Gossip_GossipStreamServer) er
 			return err
 		}
 		lgr := g.Discovery.(*gossipDiscoveryImpl).logger
-		gMsg, err := envelope.ToGossipMessage()
+		gMsg, err := protoext.EnvelopeToGossipMessage(envelope)
 		if err != nil {
 			lgr.Warning("Failed deserializing GossipMessage from envelope:", err)
 			continue
@@ -285,7 +286,7 @@ func (g *gossipInstance) GossipStream(stream proto.Gossip_GossipStreamServer) er
 		lgr.Debug(g.Discovery.Self().Endpoint, "Got message:", gMsg)
 		g.comm.incMsgs <- &dummyReceivedMessage{
 			msg: gMsg,
-			info: &proto.ConnectionInfo{
+			info: &protoext.ConnectionInfo{
 				ID: common.PKIidType("testID"),
 			},
 		}
@@ -297,7 +298,7 @@ func (g *gossipInstance) GossipStream(stream proto.Gossip_GossipStreamServer) er
 	}
 }
 
-func (g *gossipInstance) tryForwardMessage(msg *proto.SignedGossipMessage) {
+func (g *gossipInstance) tryForwardMessage(msg *protoext.SignedGossipMessage) {
 	g.comm.lock.Lock()
 
 	aliveMsg := msg.GetAliveMsg()
@@ -344,9 +345,9 @@ func (g *gossipInstance) Ping(context.Context, *proto.Empty) (*proto.Empty, erro
 }
 
 var noopPolicy = func(remotePeer *NetworkMember) (Sieve, EnvelopeFilter) {
-	return func(msg *proto.SignedGossipMessage) bool {
+	return func(msg *protoext.SignedGossipMessage) bool {
 			return true
-		}, func(message *proto.SignedGossipMessage) *proto.Envelope {
+		}, func(message *protoext.SignedGossipMessage) *proto.Envelope {
 			return message.Envelope
 		}
 }
@@ -368,14 +369,14 @@ func createDiscoveryInstanceWithNoGossipWithDisclosurePolicy(port int, id string
 }
 
 func createDiscoveryInstanceThatGossips(port int, id string, bootstrapPeers []string, shouldGossip bool, pol DisclosurePolicy, config DiscoveryConfig) *gossipInstance {
-	return createDiscoveryInstanceThatGossipsWithInterceptors(port, id, bootstrapPeers, shouldGossip, pol, func(_ *proto.SignedGossipMessage) {}, config)
+	return createDiscoveryInstanceThatGossipsWithInterceptors(port, id, bootstrapPeers, shouldGossip, pol, func(_ *protoext.SignedGossipMessage) {}, config)
 }
 
-func createDiscoveryInstanceThatGossipsWithInterceptors(port int, id string, bootstrapPeers []string, shouldGossip bool, pol DisclosurePolicy, f func(*proto.SignedGossipMessage), config DiscoveryConfig) *gossipInstance {
+func createDiscoveryInstanceThatGossipsWithInterceptors(port int, id string, bootstrapPeers []string, shouldGossip bool, pol DisclosurePolicy, f func(*protoext.SignedGossipMessage), config DiscoveryConfig) *gossipInstance {
 	comm := &dummyCommModule{
 		conns:        make(map[string]*grpc.ClientConn),
 		streams:      make(map[string]proto.Gossip_GossipStreamClient),
-		incMsgs:      make(chan proto.ReceivedMessage, 1000),
+		incMsgs:      make(chan protoext.ReceivedMessage, 1000),
 		presumeDead:  make(chan common.PKIidType, 10000),
 		id:           id,
 		detectedDead: make(chan string, 10000),
@@ -470,14 +471,14 @@ func TestNetworkMemberString(t *testing.T) {
 func TestBadInput(t *testing.T) {
 	inst := createDiscoveryInstance(2048, fmt.Sprintf("d%d", 0), []string{})
 	inst.Discovery.(*gossipDiscoveryImpl).handleMsgFromComm(nil)
-	s, _ := (&proto.GossipMessage{
+	s, _ := protoext.NoopSign(&proto.GossipMessage{
 		Content: &proto.GossipMessage_DataMsg{
 			DataMsg: &proto.DataMessage{},
 		},
-	}).NoopSign()
+	})
 	inst.Discovery.(*gossipDiscoveryImpl).handleMsgFromComm(&dummyReceivedMessage{
 		msg: s,
-		info: &proto.ConnectionInfo{
+		info: &protoext.ConnectionInfo{
 			ID: common.PKIidType("testID"),
 		},
 	})
@@ -487,7 +488,7 @@ func TestConnect(t *testing.T) {
 	t.Parallel()
 	nodeNum := 10
 	instances := []*gossipInstance{}
-	firstSentMemReqMsgs := make(chan *proto.SignedGossipMessage, nodeNum)
+	firstSentMemReqMsgs := make(chan *protoext.SignedGossipMessage, nodeNum)
 	for i := 0; i < nodeNum; i++ {
 		inst := createDiscoveryInstance(7611+i, fmt.Sprintf("d%d", i), []string{})
 
@@ -495,9 +496,9 @@ func TestConnect(t *testing.T) {
 		inst.comm.mock = &mock.Mock{}
 		inst.comm.mock.On("SendToPeer", mock.Anything, mock.Anything).Run(func(arguments mock.Arguments) {
 			inst := inst
-			msg := arguments.Get(1).(*proto.SignedGossipMessage)
+			msg := arguments.Get(1).(*protoext.SignedGossipMessage)
 			if req := msg.GetMemReq(); req != nil {
-				selfMsg, _ := req.SelfInformation.ToGossipMessage()
+				selfMsg, _ := protoext.EnvelopeToGossipMessage(req.SelfInformation)
 				firstSentMemReqMsgs <- selfMsg
 				inst.comm.lock.Lock()
 				inst.comm.mock = nil
@@ -523,10 +524,10 @@ func TestConnect(t *testing.T) {
 
 	discInst := instances[rand.Intn(len(instances))].Discovery.(*gossipDiscoveryImpl)
 	mr, _ := discInst.createMembershipRequest(true)
-	am, _ := mr.GetMemReq().SelfInformation.ToGossipMessage()
+	am, _ := protoext.EnvelopeToGossipMessage(mr.GetMemReq().SelfInformation)
 	assert.NotNil(t, am.SecretEnvelope)
 	mr2, _ := discInst.createMembershipRequest(false)
-	am, _ = mr2.GetMemReq().SelfInformation.ToGossipMessage()
+	am, _ = protoext.EnvelopeToGossipMessage(mr2.GetMemReq().SelfInformation)
 	assert.Nil(t, am.SecretEnvelope)
 	stopInstances(t, instances)
 	assert.Len(t, firstSentMemReqMsgs, 10)
@@ -546,30 +547,30 @@ func TestValidation(t *testing.T) {
 	//   2.2) once alive messages enter the message store, reception of them via membership responses
 	//        doesn't trigger validation, but via membership requests - do.
 
-	wrapReceivedMessage := func(msg *proto.SignedGossipMessage) proto.ReceivedMessage {
+	wrapReceivedMessage := func(msg *protoext.SignedGossipMessage) protoext.ReceivedMessage {
 		return &dummyReceivedMessage{
 			msg: msg,
-			info: &proto.ConnectionInfo{
+			info: &protoext.ConnectionInfo{
 				ID: common.PKIidType("testID"),
 			},
 		}
 	}
 
-	requestMessagesReceived := make(chan *proto.SignedGossipMessage, 100)
-	responseMessagesReceived := make(chan *proto.SignedGossipMessage, 100)
-	aliveMessagesReceived := make(chan *proto.SignedGossipMessage, 5000)
+	requestMessagesReceived := make(chan *protoext.SignedGossipMessage, 100)
+	responseMessagesReceived := make(chan *protoext.SignedGossipMessage, 100)
+	aliveMessagesReceived := make(chan *protoext.SignedGossipMessage, 5000)
 
 	var membershipRequest atomic.Value
 	var membershipResponseWithAlivePeers atomic.Value
 	var membershipResponseWithDeadPeers atomic.Value
 
-	recordMembershipRequest := func(req *proto.SignedGossipMessage) {
-		msg, _ := req.GetMemReq().SelfInformation.ToGossipMessage()
+	recordMembershipRequest := func(req *protoext.SignedGossipMessage) {
+		msg, _ := protoext.EnvelopeToGossipMessage(req.GetMemReq().SelfInformation)
 		membershipRequest.Store(req)
 		requestMessagesReceived <- msg
 	}
 
-	recordMembershipResponse := func(res *proto.SignedGossipMessage) {
+	recordMembershipResponse := func(res *protoext.SignedGossipMessage) {
 		memRes := res.GetMemRes()
 		if len(memRes.GetAlive()) > 0 {
 			membershipResponseWithAlivePeers.Store(res)
@@ -580,7 +581,7 @@ func TestValidation(t *testing.T) {
 		responseMessagesReceived <- res
 	}
 
-	interceptor := func(msg *proto.SignedGossipMessage) {
+	interceptor := func(msg *protoext.SignedGossipMessage) {
 		if memReq := msg.GetMemReq(); memReq != nil {
 			recordMembershipRequest(msg)
 			return
@@ -636,9 +637,9 @@ func TestValidation(t *testing.T) {
 		p4 := createDiscoveryInstance(4678, "p1", nil)
 		defer p4.Stop()
 		// Record messages validated
-		validatedMessages := make(chan *proto.SignedGossipMessage, 5000)
+		validatedMessages := make(chan *protoext.SignedGossipMessage, 5000)
 		p4.comm.recordValidation(validatedMessages)
-		tmpMsgs := make(chan *proto.SignedGossipMessage, 5000)
+		tmpMsgs := make(chan *protoext.SignedGossipMessage, 5000)
 		// Replay the messages sent to p1 into p4, and also save them into a temporary channel
 		for msg := range aliveMessagesReceived {
 			p4.comm.incMsgs <- wrapReceivedMessage(msg)
@@ -646,7 +647,7 @@ func TestValidation(t *testing.T) {
 		}
 
 		// Simulate the messages received by p4 into the message store
-		policy := proto.NewGossipMessageComparator(0)
+		policy := protoext.NewGossipMessageComparator(0)
 		msgStore := msgstore.NewMessageStore(policy, func(_ interface{}) {})
 		close(tmpMsgs)
 		for msg := range tmpMsgs {
@@ -660,8 +661,8 @@ func TestValidation(t *testing.T) {
 		assert.Empty(t, validatedMessages)
 	})
 
-	req := membershipRequest.Load().(*proto.SignedGossipMessage)
-	res := membershipResponseWithDeadPeers.Load().(*proto.SignedGossipMessage)
+	req := membershipRequest.Load().(*protoext.SignedGossipMessage)
+	res := membershipResponseWithDeadPeers.Load().(*protoext.SignedGossipMessage)
 	// Ensure the membership response contains both alive and dead peers
 	assert.Len(t, res.GetMemRes().GetAlive(), 2)
 	assert.Len(t, res.GetMemRes().GetDead(), 1)
@@ -670,7 +671,7 @@ func TestValidation(t *testing.T) {
 		name                  string
 		expectedAliveMessages int
 		port                  int
-		message               *proto.SignedGossipMessage
+		message               *protoext.SignedGossipMessage
 		shouldBeReValidated   bool
 	}{
 		{
@@ -693,7 +694,7 @@ func TestValidation(t *testing.T) {
 			p := createDiscoveryInstance(testCase.port, "p", nil)
 			defer p.Stop()
 			// Record messages validated
-			validatedMessages := make(chan *proto.SignedGossipMessage, testCase.expectedAliveMessages)
+			validatedMessages := make(chan *protoext.SignedGossipMessage, testCase.expectedAliveMessages)
 			p.comm.recordValidation(validatedMessages)
 
 			p.comm.incMsgs <- wrapReceivedMessage(testCase.message)
@@ -808,7 +809,7 @@ func TestSelf(t *testing.T) {
 	inst := createDiscoveryInstance(13463, "d1", []string{})
 	defer inst.Stop()
 	env := inst.Self().Envelope
-	sMsg, err := env.ToGossipMessage()
+	sMsg, err := protoext.EnvelopeToGossipMessage(env)
 	assert.NoError(t, err)
 	member := sMsg.GetAliveMsg().Membership
 	assert.Equal(t, "localhost:13463", member.Endpoint)
@@ -1073,7 +1074,7 @@ func discPolForPeer(selfPort int) DisclosurePolicy {
 	return func(remotePeer *NetworkMember) (Sieve, EnvelopeFilter) {
 		targetPortStr := strings.Split(remotePeer.Endpoint, ":")[1]
 		targetPort, _ := strconv.ParseInt(targetPortStr, 10, 64)
-		return func(msg *proto.SignedGossipMessage) bool {
+		return func(msg *protoext.SignedGossipMessage) bool {
 				portOfAliveMsgStr := strings.Split(msg.GetAliveMsg().Membership.Endpoint, ":")[1]
 				portOfAliveMsg, _ := strconv.ParseInt(portOfAliveMsgStr, 10, 64)
 
@@ -1086,7 +1087,7 @@ func discPolForPeer(selfPort int) DisclosurePolicy {
 
 				// Else, expose peers with even ids to other peers with even ids
 				return portOfAliveMsg%2 == 0 && targetPort%2 == 0
-			}, func(msg *proto.SignedGossipMessage) *proto.Envelope {
+			}, func(msg *protoext.SignedGossipMessage) *proto.Envelope {
 				envelope := protoG.Clone(msg.Envelope).(*proto.Envelope)
 				if selfPort < 8615 && targetPort >= 8615 {
 					envelope.SecretEnvelope = nil
@@ -1196,7 +1197,7 @@ func TestMsgStoreExpiration(t *testing.T) {
 					return false
 				}
 				for _, am := range downCastInst.msgStore.Get() {
-					m := am.(*proto.SignedGossipMessage).GetAliveMsg()
+					m := am.(*protoext.SignedGossipMessage).GetAliveMsg()
 					if bytes.Equal(m.Membership.PkiId, downInst.discoveryImpl().self.PKIid) {
 						downCastInst.lock.RUnlock()
 						return false
@@ -1232,9 +1233,9 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 	bootPeers := []string{}
 	peersNum := 3
 	instances := []*gossipInstance{}
-	aliveMsgs := []*proto.SignedGossipMessage{}
-	newAliveMsgs := []*proto.SignedGossipMessage{}
-	memReqMsgs := []*proto.SignedGossipMessage{}
+	aliveMsgs := []*protoext.SignedGossipMessage{}
+	newAliveMsgs := []*protoext.SignedGossipMessage{}
+	memReqMsgs := []*protoext.SignedGossipMessage{}
 	memRespMsgs := make(map[int][]*proto.MembershipResponse)
 
 	for i := 0; i < peersNum; i++ {
@@ -1247,7 +1248,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 	// Creating MembershipRequest messages
 	for i := 0; i < peersNum; i++ {
 		memReqMsg, _ := instances[i].discoveryImpl().createMembershipRequest(true)
-		sMsg, _ := memReqMsg.NoopSign()
+		sMsg, _ := protoext.NoopSign(memReqMsg)
 		memReqMsgs = append(memReqMsgs, sMsg)
 	}
 	// Creating Alive messages
@@ -1270,14 +1271,14 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		for k := 0; k < peersNum; k++ {
 			instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 				msg: aliveMsgs[k],
-				info: &proto.ConnectionInfo{
+				info: &protoext.ConnectionInfo{
 					ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 				},
 			})
 		}
 	}
 
-	checkExistence := func(instances []*gossipInstance, msgs []*proto.SignedGossipMessage, index int, i int, step string) {
+	checkExistence := func(instances []*gossipInstance, msgs []*protoext.SignedGossipMessage, index int, i int, step string) {
 		_, exist := instances[index].discoveryImpl().aliveLastTS[string(instances[i].discoveryImpl().self.PKIid)]
 		assert.True(t, exist, fmt.Sprint(step, " Data from alive msg ", i, " doesn't exist in aliveLastTS of discovery inst ", index))
 
@@ -1289,7 +1290,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		assert.Contains(t, instances[index].discoveryImpl().msgStore.Get(), msgs[i], fmt.Sprint(step, " Alive msg ", i, "not stored in store of discovery inst ", index))
 	}
 
-	checkAliveMsgExist := func(instances []*gossipInstance, msgs []*proto.SignedGossipMessage, index int, step string) {
+	checkAliveMsgExist := func(instances []*gossipInstance, msgs []*protoext.SignedGossipMessage, index int, step string) {
 		instances[index].discoveryImpl().lock.RLock()
 		defer instances[index].discoveryImpl().lock.RUnlock()
 		repeatForFiltered(peersNum,
@@ -1337,7 +1338,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		for k := 0; k < peersNum; k++ {
 			instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 				msg: newAliveMsgs[k],
-				info: &proto.ConnectionInfo{
+				info: &protoext.ConnectionInfo{
 					ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 				},
 			})
@@ -1349,7 +1350,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		checkAliveMsgExist(instances, newAliveMsgs, i, "[Step 2 - proccesing aliveMsg]")
 	}
 
-	checkAliveMsgNotExist := func(instances []*gossipInstance, msgs []*proto.SignedGossipMessage, index int, step string) {
+	checkAliveMsgNotExist := func(instances []*gossipInstance, msgs []*protoext.SignedGossipMessage, index int, step string) {
 		instances[index].discoveryImpl().lock.RLock()
 		defer instances[index].discoveryImpl().lock.RUnlock()
 		assert.Empty(t, instances[index].discoveryImpl().aliveLastTS, fmt.Sprint(step, " Data from alive msg still exists in aliveLastTS of discovery inst ", index))
@@ -1377,7 +1378,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 			func(k int) {
 				instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 					msg: memReqMsgs[k],
-					info: &proto.ConnectionInfo{
+					info: &protoext.ConnectionInfo{
 						ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 					},
 				})
@@ -1394,7 +1395,7 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 		for k := 0; k < peersNum; k++ {
 			instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 				msg: aliveMsgs[k],
-				info: &proto.ConnectionInfo{
+				info: &protoext.ConnectionInfo{
 					ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 				},
 			})
@@ -1411,16 +1412,16 @@ func TestMsgStoreExpirationWithMembershipMessages(t *testing.T) {
 	for i := 0; i < peersNum; i++ {
 		respForPeer := memRespMsgs[i]
 		for _, msg := range respForPeer {
-			sMsg, _ := (&proto.GossipMessage{
+			sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 				Tag:   proto.GossipMessage_EMPTY,
 				Nonce: uint64(0),
 				Content: &proto.GossipMessage_MemRes{
 					MemRes: msg,
 				},
-			}).NoopSign()
+			})
 			instances[i].discoveryImpl().handleMsgFromComm(&dummyReceivedMessage{
 				msg: sMsg,
-				info: &proto.ConnectionInfo{
+				info: &protoext.ConnectionInfo{
 					ID: common.PKIidType(fmt.Sprintf("d%d", i)),
 				},
 			})
@@ -1444,8 +1445,8 @@ func TestAliveMsgStore(t *testing.T) {
 	bootPeers := []string{}
 	peersNum := 2
 	instances := []*gossipInstance{}
-	aliveMsgs := []*proto.SignedGossipMessage{}
-	memReqMsgs := []*proto.SignedGossipMessage{}
+	aliveMsgs := []*protoext.SignedGossipMessage{}
+	memReqMsgs := []*protoext.SignedGossipMessage{}
 
 	for i := 0; i < peersNum; i++ {
 		id := fmt.Sprintf("d%d", i)
@@ -1456,7 +1457,7 @@ func TestAliveMsgStore(t *testing.T) {
 	// Creating MembershipRequest messages
 	for i := 0; i < peersNum; i++ {
 		memReqMsg, _ := instances[i].discoveryImpl().createMembershipRequest(true)
-		sMsg, _ := memReqMsg.NoopSign()
+		sMsg, _ := protoext.NoopSign(memReqMsg)
 		memReqMsgs = append(memReqMsgs, sMsg)
 	}
 	// Creating Alive messages
@@ -1490,9 +1491,9 @@ func TestAliveMsgStore(t *testing.T) {
 func TestMemRespDisclosurePol(t *testing.T) {
 	t.Parallel()
 	pol := func(remotePeer *NetworkMember) (Sieve, EnvelopeFilter) {
-		return func(_ *proto.SignedGossipMessage) bool {
+		return func(_ *protoext.SignedGossipMessage) bool {
 				return remotePeer.Endpoint == "localhost:7880"
-			}, func(m *proto.SignedGossipMessage) *proto.Envelope {
+			}, func(m *protoext.SignedGossipMessage) *proto.Envelope {
 				return m.Envelope
 			}
 	}
diff --git a/gossip/election/adapter.go b/gossip/election/adapter.go
index 8a2c3f803..3c725a124 100644
--- a/gossip/election/adapter.go
+++ b/gossip/election/adapter.go
@@ -14,6 +14,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
@@ -50,7 +51,7 @@ type gossip interface {
 	// If passThrough is false, the messages are processed by the gossip layer beforehand.
 	// If passThrough is true, the gossip layer doesn't intervene and the messages
 	// can be used to send a reply back to the sender
-	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 
 	// Gossip sends a message to other peers to the network
 	Gossip(msg *proto.GossipMessage)
@@ -100,7 +101,7 @@ func (ai *adapterImpl) Accept() <-chan Msg {
 	adapterCh, _ := ai.gossip.Accept(func(message interface{}) bool {
 		// Get only leadership org and channel messages
 		return message.(*proto.GossipMessage).Tag == proto.GossipMessage_CHAN_AND_ORG &&
-			message.(*proto.GossipMessage).IsLeadershipMsg() &&
+			protoext.IsLeadershipMsg(message.(*proto.GossipMessage)) &&
 			bytes.Equal(message.(*proto.GossipMessage).Channel, ai.channel)
 	}, false)
 
diff --git a/gossip/election/adapter_test.go b/gossip/election/adapter_test.go
index 9d3d4dc40..41a97ff5e 100644
--- a/gossip/election/adapter_test.go
+++ b/gossip/election/adapter_test.go
@@ -19,6 +19,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -55,7 +56,7 @@ func TestAdapterImpl_CreateMessage(t *testing.T) {
 		metrics.NewGossipMetrics(&disabled.Provider{}).ElectionMetrics)
 	msg := adapter.CreateMessage(true)
 
-	if !msg.(*msgImpl).msg.IsLeadershipMsg() {
+	if !protoext.IsLeadershipMsg(msg.(*msgImpl).msg) {
 		t.Error("Newly created message should be LeadershipMsg")
 	}
 
@@ -65,7 +66,7 @@ func TestAdapterImpl_CreateMessage(t *testing.T) {
 
 	msg = adapter.CreateMessage(false)
 
-	if !msg.(*msgImpl).msg.IsLeadershipMsg() {
+	if !protoext.IsLeadershipMsg(msg.(*msgImpl).msg) {
 		t.Error("Newly created message should be LeadershipMsg")
 	}
 
@@ -195,7 +196,7 @@ func (g *peerMockGossip) Peers() []discovery.NetworkMember {
 	return res
 }
 
-func (g *peerMockGossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (g *peerMockGossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	ch := make(chan *proto.GossipMessage, 100)
 	g.acceptorLock.Lock()
 	g.acceptors = append(g.acceptors, &mockAcceptor{
diff --git a/gossip/gossip/anchor_test.go b/gossip/gossip/anchor_test.go
index 1484a0e73..0df8227a8 100644
--- a/gossip/gossip/anchor_test.go
+++ b/gossip/gossip/anchor_test.go
@@ -20,6 +20,7 @@ import (
 	"github.com/hyperledger/fabric/core/comm"
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	utilgossip "github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -47,7 +48,7 @@ func (p *peerMock) GossipStream(stream proto.Gossip_GossipStreamServer) error {
 		if err != nil {
 			return err
 		}
-		gMsg, err := envelope.ToGossipMessage()
+		gMsg, err := protoext.EnvelopeToGossipMessage(envelope)
 		if err != nil {
 			panic(err)
 		}
@@ -89,7 +90,7 @@ func newPeerMockWithGRPC(port int, gRPCServer *comm.GRPCServer, certs *common.TL
 	return p
 }
 
-func (p *peerMock) connEstablishMsg(pkiID common.PKIidType, hash []byte, cert api.PeerIdentityType) *proto.SignedGossipMessage {
+func (p *peerMock) connEstablishMsg(pkiID common.PKIidType, hash []byte, cert api.PeerIdentityType) *protoext.SignedGossipMessage {
 	m := &proto.GossipMessage{
 		Tag:   proto.GossipMessage_EMPTY,
 		Nonce: 0,
@@ -101,7 +102,7 @@ func (p *peerMock) connEstablishMsg(pkiID common.PKIidType, hash []byte, cert ap
 			},
 		},
 	}
-	gMsg := &proto.SignedGossipMessage{
+	gMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	gMsg.Sign((&configurableCryptoService{}).Sign)
@@ -113,16 +114,16 @@ func (p *peerMock) stop() {
 }
 
 type receivedMsg struct {
-	*proto.SignedGossipMessage
+	*protoext.SignedGossipMessage
 	stream proto.Gossip_GossipStreamServer
 }
 
-func (msg *receivedMsg) respond(message *proto.SignedGossipMessage) {
+func (msg *receivedMsg) respond(message *protoext.SignedGossipMessage) {
 	msg.stream.Send(message.Envelope)
 }
 
-func memResp(nonce uint64, endpoint string) *proto.SignedGossipMessage {
-	fakePeerAliveMsg := &proto.SignedGossipMessage{
+func memResp(nonce uint64, endpoint string) *protoext.SignedGossipMessage {
+	fakePeerAliveMsg := &protoext.SignedGossipMessage{
 		GossipMessage: &proto.GossipMessage{
 			Tag: proto.GossipMessage_EMPTY,
 			Content: &proto.GossipMessage_AliveMsg{
@@ -142,18 +143,16 @@ func memResp(nonce uint64, endpoint string) *proto.SignedGossipMessage {
 	}
 
 	m, _ := fakePeerAliveMsg.Sign((&configurableCryptoService{}).Sign)
-	sMsg, _ := (&proto.SignedGossipMessage{
-		GossipMessage: &proto.GossipMessage{
-			Tag:   proto.GossipMessage_EMPTY,
-			Nonce: nonce,
-			Content: &proto.GossipMessage_MemRes{
-				MemRes: &proto.MembershipResponse{
-					Alive: []*proto.Envelope{m},
-					Dead:  []*proto.Envelope{},
-				},
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
+		Tag:   proto.GossipMessage_EMPTY,
+		Nonce: nonce,
+		Content: &proto.GossipMessage_MemRes{
+			MemRes: &proto.MembershipResponse{
+				Alive: []*proto.Envelope{m},
+				Dead:  []*proto.Envelope{},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
@@ -212,9 +211,9 @@ func TestAnchorPeer(t *testing.T) {
 		}
 		assert.True(t, index > 0)
 		req := m.GetMemReq()
-		am, err := req.SelfInformation.ToGossipMessage()
+		am, err := protoext.EnvelopeToGossipMessage(req.SelfInformation)
 		assert.NoError(t, err)
-		assert.NotEmpty(t, am.GetSecretEnvelope().InternalEndpoint())
+		assert.NotEmpty(t, protoext.InternalEndpoint(am.GetSecretEnvelope()))
 		m.respond(memResp(m.Nonce, fmt.Sprintf("127.0.0.1:%d", port3)))
 	}
 
@@ -224,7 +223,7 @@ func TestAnchorPeer(t *testing.T) {
 		}
 		assert.True(t, index > 0)
 		req := m.GetMemReq()
-		am, err := req.SelfInformation.ToGossipMessage()
+		am, err := protoext.EnvelopeToGossipMessage(req.SelfInformation)
 		assert.NoError(t, err)
 		assert.Nil(t, am.GetSecretEnvelope())
 		m.respond(memResp(m.Nonce, fmt.Sprintf("127.0.0.1:%d", port4)))
diff --git a/gossip/gossip/certstore.go b/gossip/gossip/certstore.go
index 520d4023b..73a1274e8 100644
--- a/gossip/gossip/certstore.go
+++ b/gossip/gossip/certstore.go
@@ -14,6 +14,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/gossip/pull"
 	"github.com/hyperledger/fabric/gossip/identity"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -49,7 +50,7 @@ func newCertStore(puller pull.Mediator, idMapper identity.Mapper, selfIdentity a
 		certStore.logger.Panicf("Failed creating self identity message: %+v", errors.WithStack(err))
 	}
 	puller.Add(selfIDMsg)
-	puller.RegisterMsgHook(pull.RequestMsgType, func(_ []string, msgs []*proto.SignedGossipMessage, _ proto.ReceivedMessage) {
+	puller.RegisterMsgHook(pull.RequestMsgType, func(_ []string, msgs []*protoext.SignedGossipMessage, _ protoext.ReceivedMessage) {
 		for _, msg := range msgs {
 			pkiID := common.PKIidType(msg.GetPeerIdentity().PkiId)
 			cert := api.PeerIdentityType(msg.GetPeerIdentity().Cert)
@@ -61,15 +62,15 @@ func newCertStore(puller pull.Mediator, idMapper identity.Mapper, selfIdentity a
 	return certStore
 }
 
-func (cs *certStore) handleMessage(msg proto.ReceivedMessage) {
+func (cs *certStore) handleMessage(msg protoext.ReceivedMessage) {
 	if update := msg.GetGossipMessage().GetDataUpdate(); update != nil {
 		for _, env := range update.Data {
-			m, err := env.ToGossipMessage()
+			m, err := protoext.EnvelopeToGossipMessage(env)
 			if err != nil {
 				cs.logger.Warningf("Data update contains an invalid message: %+v", errors.WithStack(err))
 				return
 			}
-			if !m.IsIdentityMsg() {
+			if !protoext.IsIdentityMsg(m.GossipMessage) {
 				cs.logger.Warning("Got a non-identity message:", m, "aborting")
 				return
 			}
@@ -82,7 +83,7 @@ func (cs *certStore) handleMessage(msg proto.ReceivedMessage) {
 	cs.pull.HandleMessage(msg)
 }
 
-func (cs *certStore) validateIdentityMsg(msg *proto.SignedGossipMessage) error {
+func (cs *certStore) validateIdentityMsg(msg *protoext.SignedGossipMessage) error {
 	idMsg := msg.GetPeerIdentity()
 	if idMsg == nil {
 		return errors.Errorf("Identity empty: %+v", msg)
@@ -107,7 +108,7 @@ func (cs *certStore) validateIdentityMsg(msg *proto.SignedGossipMessage) error {
 	return cs.mcs.ValidateIdentity(api.PeerIdentityType(idMsg.Cert))
 }
 
-func (cs *certStore) createIdentityMessage() (*proto.SignedGossipMessage, error) {
+func (cs *certStore) createIdentityMessage() (*protoext.SignedGossipMessage, error) {
 	pi := &proto.PeerIdentity{
 		Cert:     cs.selfIdentity,
 		Metadata: nil,
@@ -124,7 +125,7 @@ func (cs *certStore) createIdentityMessage() (*proto.SignedGossipMessage, error)
 	signer := func(msg []byte) ([]byte, error) {
 		return cs.idMapper.Sign(msg)
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	_, err := sMsg.Sign(signer)
diff --git a/gossip/gossip/certstore_test.go b/gossip/gossip/certstore_test.go
index af3a2aaad..162d076ba 100644
--- a/gossip/gossip/certstore_test.go
+++ b/gossip/gossip/certstore_test.go
@@ -20,6 +20,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/algo"
 	"github.com/hyperledger/fabric/gossip/gossip/pull"
 	"github.com/hyperledger/fabric/gossip/identity"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -42,7 +43,7 @@ type pullerMock struct {
 }
 
 type sentMsg struct {
-	msg *proto.SignedGossipMessage
+	msg *protoext.SignedGossipMessage
 	mock.Mock
 }
 
@@ -61,11 +62,11 @@ func (s *sentMsg) Respond(msg *proto.GossipMessage) {
 	s.Called(msg)
 }
 
-func (s *sentMsg) GetGossipMessage() *proto.SignedGossipMessage {
+func (s *sentMsg) GetGossipMessage() *protoext.SignedGossipMessage {
 	return s.msg
 }
 
-func (s *sentMsg) GetConnectionInfo() *proto.ConnectionInfo {
+func (s *sentMsg) GetConnectionInfo() *protoext.ConnectionInfo {
 	return nil
 }
 
@@ -73,7 +74,7 @@ type senderMock struct {
 	mock.Mock
 }
 
-func (s *senderMock) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (s *senderMock) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	s.Called(msg, peers)
 }
 
@@ -87,7 +88,7 @@ func (m *membershipSvcMock) GetMembership() []discovery.NetworkMember {
 }
 
 func TestCertStoreBadSignature(t *testing.T) {
-	badSignature := func(nonce uint64) proto.ReceivedMessage {
+	badSignature := func(nonce uint64) protoext.ReceivedMessage {
 		return createUpdateMessage(nonce, createBadlySignedUpdateMessage())
 	}
 	pm, cs, _ := createObjects(badSignature, nil)
@@ -97,7 +98,7 @@ func TestCertStoreBadSignature(t *testing.T) {
 }
 
 func TestCertStoreMismatchedIdentity(t *testing.T) {
-	mismatchedIdentity := func(nonce uint64) proto.ReceivedMessage {
+	mismatchedIdentity := func(nonce uint64) protoext.ReceivedMessage {
 		return createUpdateMessage(nonce, createMismatchedUpdateMessage())
 	}
 
@@ -108,7 +109,7 @@ func TestCertStoreMismatchedIdentity(t *testing.T) {
 }
 
 func TestCertStoreShouldSucceed(t *testing.T) {
-	totallyFineIdentity := func(nonce uint64) proto.ReceivedMessage {
+	totallyFineIdentity := func(nonce uint64) protoext.ReceivedMessage {
 		return createUpdateMessage(nonce, createValidUpdateMessage())
 	}
 
@@ -123,13 +124,13 @@ func TestCertRevocation(t *testing.T) {
 		cs.revokedPkiIDS = map[string]struct{}{}
 	}()
 
-	totallyFineIdentity := func(nonce uint64) proto.ReceivedMessage {
+	totallyFineIdentity := func(nonce uint64) protoext.ReceivedMessage {
 		return createUpdateMessage(nonce, createValidUpdateMessage())
 	}
 
 	askedForIdentity := make(chan struct{}, 1)
 
-	pm, cStore, sender := createObjects(totallyFineIdentity, func(message *proto.SignedGossipMessage) {
+	pm, cStore, sender := createObjects(totallyFineIdentity, func(message *protoext.SignedGossipMessage) {
 		askedForIdentity <- struct{}{}
 	})
 	defer cStore.stop()
@@ -146,7 +147,7 @@ func TestCertRevocation(t *testing.T) {
 	l := sync.Mutex{}
 	sender.Mock = mock.Mock{}
 	sender.On("Send", mock.Anything, mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
 		l.Lock()
 		defer l.Unlock()
 
@@ -162,7 +163,7 @@ func TestCertRevocation(t *testing.T) {
 					},
 				},
 			}
-			sMsg, _ := dig.NoopSign()
+			sMsg, _ := protoext.NoopSign(dig)
 			go cStore.handleMessage(&sentMsg{msg: sMsg})
 		}
 
@@ -229,8 +230,8 @@ func TestCertExpiration(t *testing.T) {
 	// Make the channel bigger than needed so goroutines won't get stuck
 	identitiesGotViaPull := make(chan struct{}, identities2Detect+100)
 	acceptIdentityPullMsgs := func(o interface{}) bool {
-		m := o.(proto.ReceivedMessage).GetGossipMessage()
-		if m.IsPullMsg() && m.IsDigestMsg() {
+		m := o.(protoext.ReceivedMessage).GetGossipMessage()
+		if protoext.IsPullMsg(m.GossipMessage) && protoext.IsDigestMsg(m.GossipMessage) {
 			for _, dig := range m.GetDataDig().Digests {
 				if bytes.Equal(dig, []byte(fmt.Sprintf("127.0.0.1:%d", port0))) {
 					identitiesGotViaPull <- struct{}{}
@@ -251,7 +252,7 @@ func TestCertExpiration(t *testing.T) {
 }
 
 func testCertificateUpdate(t *testing.T, shouldSucceed bool, certStore *certStore) {
-	msg, _ := (&proto.GossipMessage{
+	msg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Channel: []byte(""),
 		Tag:     proto.GossipMessage_EMPTY,
 		Content: &proto.GossipMessage_Hello{
@@ -261,7 +262,7 @@ func testCertificateUpdate(t *testing.T, shouldSucceed bool, certStore *certStor
 				MsgType:  proto.PullMsgType_IDENTITY_MSG,
 			},
 		},
-	}).NoopSign()
+	})
 	hello := &sentMsg{
 		msg: msg,
 	}
@@ -284,7 +285,7 @@ func testCertificateUpdate(t *testing.T, shouldSucceed bool, certStore *certStor
 	}
 }
 
-func createMismatchedUpdateMessage() *proto.SignedGossipMessage {
+func createMismatchedUpdateMessage() *protoext.SignedGossipMessage {
 	peeridentity := &proto.PeerIdentity{
 		// This PKI-ID is different than the cert, and the mapping between
 		// certificate to PKI-ID in this test is simply the identity function.
@@ -303,14 +304,14 @@ func createMismatchedUpdateMessage() *proto.SignedGossipMessage {
 			PeerIdentity: peeridentity,
 		},
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	sMsg.Sign(signer)
 	return sMsg
 }
 
-func createBadlySignedUpdateMessage() *proto.SignedGossipMessage {
+func createBadlySignedUpdateMessage() *protoext.SignedGossipMessage {
 	peeridentity := &proto.PeerIdentity{
 		PkiId: []byte("C"),
 		Cert:  []byte("C"),
@@ -328,7 +329,7 @@ func createBadlySignedUpdateMessage() *proto.SignedGossipMessage {
 			PeerIdentity: peeridentity,
 		},
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	sMsg.Sign(signer)
@@ -341,7 +342,7 @@ func createBadlySignedUpdateMessage() *proto.SignedGossipMessage {
 	return sMsg
 }
 
-func createValidUpdateMessage() *proto.SignedGossipMessage {
+func createValidUpdateMessage() *protoext.SignedGossipMessage {
 	peeridentity := &proto.PeerIdentity{
 		PkiId: []byte("B"),
 		Cert:  []byte("B"),
@@ -358,14 +359,14 @@ func createValidUpdateMessage() *proto.SignedGossipMessage {
 			PeerIdentity: peeridentity,
 		},
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	sMsg.Sign(signer)
 	return sMsg
 }
 
-func createUpdateMessage(nonce uint64, idMsg *proto.SignedGossipMessage) proto.ReceivedMessage {
+func createUpdateMessage(nonce uint64, idMsg *protoext.SignedGossipMessage) protoext.ReceivedMessage {
 	update := &proto.GossipMessage{
 		Tag: proto.GossipMessage_EMPTY,
 		Content: &proto.GossipMessage_DataUpdate{
@@ -376,11 +377,11 @@ func createUpdateMessage(nonce uint64, idMsg *proto.SignedGossipMessage) proto.R
 			},
 		},
 	}
-	sMsg, _ := update.NoopSign()
+	sMsg, _ := protoext.NoopSign(update)
 	return &sentMsg{msg: sMsg}
 }
 
-func createDigest(nonce uint64) proto.ReceivedMessage {
+func createDigest(nonce uint64) protoext.ReceivedMessage {
 	digest := &proto.GossipMessage{
 		Tag: proto.GossipMessage_EMPTY,
 		Content: &proto.GossipMessage_DataDig{
@@ -391,13 +392,13 @@ func createDigest(nonce uint64) proto.ReceivedMessage {
 			},
 		},
 	}
-	sMsg, _ := digest.NoopSign()
+	sMsg, _ := protoext.NoopSign(digest)
 	return &sentMsg{msg: sMsg}
 }
 
-func createObjects(updateFactory func(uint64) proto.ReceivedMessage, msgCons proto.MsgConsumer) (pull.Mediator, *certStore, *senderMock) {
+func createObjects(updateFactory func(uint64) protoext.ReceivedMessage, msgCons protoext.MsgConsumer) (pull.Mediator, *certStore, *senderMock) {
 	if msgCons == nil {
-		msgCons = func(_ *proto.SignedGossipMessage) {}
+		msgCons = func(_ *protoext.SignedGossipMessage) {}
 	}
 	shortenedWaitTime := time.Millisecond * 300
 	config := pull.Config{
@@ -420,11 +421,11 @@ func createObjects(updateFactory func(uint64) proto.ReceivedMessage, msgCons pro
 	var certStore *certStore
 	adapter := &pull.PullAdapter{
 		Sndr: sender,
-		MsgCons: func(msg *proto.SignedGossipMessage) {
+		MsgCons: func(msg *protoext.SignedGossipMessage) {
 			certStore.idMapper.Put(msg.GetPeerIdentity().PkiId, msg.GetPeerIdentity().Cert)
 			msgCons(msg)
 		},
-		IdExtractor: func(msg *proto.SignedGossipMessage) string {
+		IdExtractor: func(msg *protoext.SignedGossipMessage) string {
 			return string(msg.GetPeerIdentity().PkiId)
 		},
 		MemSvc: memberSvc,
@@ -443,7 +444,7 @@ func createObjects(updateFactory func(uint64) proto.ReceivedMessage, msgCons pro
 	sentDataReq := false
 	l := sync.Mutex{}
 	sender.On("Send", mock.Anything, mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
 		l.Lock()
 		defer l.Unlock()
 
diff --git a/gossip/gossip/channel/channel.go b/gossip/gossip/channel/channel.go
index 7f93260c1..21dd4d0e2 100644
--- a/gossip/gossip/channel/channel.go
+++ b/gossip/gossip/channel/channel.go
@@ -26,6 +26,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/msgstore"
 	"github.com/hyperledger/fabric/gossip/gossip/pull"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -54,7 +55,7 @@ type Config struct {
 // GossipChannel defines an object that deals with all channel-related messages
 type GossipChannel interface {
 	// Self returns a StateInfoMessage about the peer
-	Self() *proto.SignedGossipMessage
+	Self() *protoext.SignedGossipMessage
 
 	// GetPeers returns a list of peers with metadata as published by them
 	GetPeers() []discovery.NetworkMember
@@ -82,10 +83,10 @@ type GossipChannel interface {
 	EligibleForChannel(member discovery.NetworkMember) bool
 
 	// HandleMessage processes a message sent by a remote peer
-	HandleMessage(proto.ReceivedMessage)
+	HandleMessage(protoext.ReceivedMessage)
 
 	// AddToMsgStore adds a given GossipMessage to the message store
-	AddToMsgStore(msg *proto.SignedGossipMessage)
+	AddToMsgStore(msg *protoext.SignedGossipMessage)
 
 	// ConfigureChannel (re)configures the list of organizations
 	// that are eligible to be in the channel
@@ -101,16 +102,16 @@ type GossipChannel interface {
 // Adapter enables the gossipChannel
 // to communicate with gossipServiceImpl.
 type Adapter interface {
-	Sign(msg *proto.GossipMessage) (*proto.SignedGossipMessage, error)
+	Sign(msg *proto.GossipMessage) (*protoext.SignedGossipMessage, error)
 
 	// GetConf returns the configuration that this GossipChannel will posses
 	GetConf() Config
 
 	// Gossip gossips a message in the channel
-	Gossip(message *proto.SignedGossipMessage)
+	Gossip(message *protoext.SignedGossipMessage)
 
 	// Forward sends a message to the next hops
-	Forward(message proto.ReceivedMessage)
+	Forward(message protoext.ReceivedMessage)
 
 	// DeMultiplex de-multiplexes an item to subscribers
 	DeMultiplex(interface{})
@@ -122,11 +123,11 @@ type Adapter interface {
 	Lookup(PKIID common.PKIidType) *discovery.NetworkMember
 
 	// Send sends a message to a list of peers
-	Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer)
+	Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer)
 
 	// ValidateStateInfoMessage returns an error if a message
 	// hasn't been signed correctly, nil otherwise.
-	ValidateStateInfoMessage(message *proto.SignedGossipMessage) error
+	ValidateStateInfoMessage(message *protoext.SignedGossipMessage) error
 
 	// GetOrgOfPeer returns the organization ID of a given peer PKI-ID
 	GetOrgOfPeer(pkiID common.PKIidType) api.OrgIdentityType
@@ -144,7 +145,7 @@ type gossipChannel struct {
 	pkiID                     common.PKIidType
 	selfOrg                   api.OrgIdentityType
 	stopChan                  chan struct{}
-	stateInfoMsg              *proto.SignedGossipMessage
+	stateInfoMsg              *protoext.SignedGossipMessage
 	orgs                      []api.OrgIdentityType
 	joinMsg                   api.JoinChannelMessage
 	blockMsgStore             msgstore.MessageStore
@@ -203,12 +204,12 @@ func NewGossipChannel(pkiID common.PKIidType, org api.OrgIdentityType, mcs api.M
 
 	gc.memFilter = &membershipFilter{adapter: gc.Adapter, gossipChannel: gc}
 
-	comparator := proto.NewGossipMessageComparator(adapter.GetConf().MaxBlockCountToStore)
+	comparator := protoext.NewGossipMessageComparator(adapter.GetConf().MaxBlockCountToStore)
 
 	gc.blocksPuller = gc.createBlockPuller()
 
 	seqNumFromMsg := func(m interface{}) string {
-		return fmt.Sprintf("%d", m.(*proto.SignedGossipMessage).GetDataMsg().Payload.SeqNum)
+		return fmt.Sprintf("%d", m.(*protoext.SignedGossipMessage).GetDataMsg().Payload.SeqNum)
 	}
 	gc.blockMsgStore = msgstore.NewMessageStoreExpirable(comparator, func(m interface{}) {
 		gc.logger.Debugf("Removing %s from the message store", seqNumFromMsg(m))
@@ -219,10 +220,10 @@ func NewGossipChannel(pkiID common.PKIidType, org api.OrgIdentityType, mcs api.M
 	})
 
 	hashPeerExpiredInMembership := func(o interface{}) bool {
-		pkiID := o.(*proto.SignedGossipMessage).GetStateInfo().PkiId
+		pkiID := o.(*protoext.SignedGossipMessage).GetStateInfo().PkiId
 		return gc.Lookup(pkiID) == nil
 	}
-	verifyStateInfoMsg := func(msg *proto.SignedGossipMessage, orgs ...api.OrgIdentityType) bool {
+	verifyStateInfoMsg := func(msg *protoext.SignedGossipMessage, orgs ...api.OrgIdentityType) bool {
 		si := msg.GetStateInfo()
 		// No point in verifying ourselves
 		if bytes.Equal(gc.pkiID, si.PkiId) {
@@ -267,7 +268,7 @@ func NewGossipChannel(pkiID common.PKIidType, org api.OrgIdentityType, mcs api.M
 	gc.stateInfoMsgStore = newStateInfoCache(gc.GetConf().StateInfoCacheSweepInterval, hashPeerExpiredInMembership, verifyStateInfoMsg)
 
 	ttl := adapter.GetConf().MsgExpirationTimeout
-	pol := proto.NewGossipMessageComparator(0)
+	pol := protoext.NewGossipMessageComparator(0)
 
 	gc.leaderMsgStore = msgstore.NewMessageStoreExpirable(pol, msgstore.Noop, ttl, nil, nil, nil)
 
@@ -321,7 +322,7 @@ func (gc *gossipChannel) periodicalInvocation(fn func(), c <-chan time.Time) {
 }
 
 // Self returns a StateInfoMessage about the peer
-func (gc *gossipChannel) Self() *proto.SignedGossipMessage {
+func (gc *gossipChannel) Self() *protoext.SignedGossipMessage {
 	gc.RLock()
 	defer gc.RUnlock()
 	return gc.stateInfoMsg
@@ -417,7 +418,7 @@ func (gc *gossipChannel) createBlockPuller() pull.Mediator {
 			ResponseWaitTime: gc.GetConf().ResponseWaitTime,
 		},
 	}
-	seqNumFromMsg := func(msg *proto.SignedGossipMessage) string {
+	seqNumFromMsg := func(msg *protoext.SignedGossipMessage) string {
 		dataMsg := msg.GetDataMsg()
 		if dataMsg == nil || dataMsg.Payload == nil {
 			gc.logger.Warning("Non-data block or with no payload")
@@ -429,7 +430,7 @@ func (gc *gossipChannel) createBlockPuller() pull.Mediator {
 		Sndr:        gc,
 		MemSvc:      gc.memFilter,
 		IdExtractor: seqNumFromMsg,
-		MsgCons: func(msg *proto.SignedGossipMessage) {
+		MsgCons: func(msg *protoext.SignedGossipMessage) {
 			gc.DeMultiplex(msg)
 		},
 	}
@@ -516,8 +517,8 @@ func (gc *gossipChannel) EligibleForChannel(member discovery.NetworkMember) bool
 }
 
 // AddToMsgStore adds a given GossipMessage to the message store
-func (gc *gossipChannel) AddToMsgStore(msg *proto.SignedGossipMessage) {
-	if msg.IsDataMsg() {
+func (gc *gossipChannel) AddToMsgStore(msg *protoext.SignedGossipMessage) {
+	if protoext.IsDataMsg(msg.GossipMessage) {
 		gc.Lock()
 		defer gc.Unlock()
 		added := gc.blockMsgStore.Add(msg)
@@ -527,7 +528,7 @@ func (gc *gossipChannel) AddToMsgStore(msg *proto.SignedGossipMessage) {
 		}
 	}
 
-	if msg.IsStateInfoMsg() {
+	if protoext.IsStateInfoMsg(msg.GossipMessage) {
 		gc.stateInfoMsgStore.Add(msg)
 	}
 }
@@ -558,13 +559,13 @@ func (gc *gossipChannel) ConfigureChannel(joinMsg api.JoinChannelMessage) {
 }
 
 // HandleMessage processes a message sent by a remote peer
-func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
+func (gc *gossipChannel) HandleMessage(msg protoext.ReceivedMessage) {
 	if !gc.verifyMsg(msg) {
 		gc.logger.Warning("Failed verifying message:", msg.GetGossipMessage().GossipMessage)
 		return
 	}
 	m := msg.GetGossipMessage()
-	if !m.IsChannelRestricted() {
+	if !protoext.IsChannelRestricted(m.GossipMessage) {
 		gc.logger.Warning("Got message", msg.GetGossipMessage(), "but it's not a per-channel message, discarding it")
 		return
 	}
@@ -579,20 +580,20 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 		return
 	}
 
-	if m.IsStateInfoPullRequestMsg() {
+	if protoext.IsStateInfoPullRequestMsg(m.GossipMessage) {
 		msg.Respond(gc.createStateInfoSnapshot(orgID))
 		return
 	}
 
-	if m.IsStateInfoSnapshot() {
+	if protoext.IsStateInfoSnapshot(m.GossipMessage) {
 		gc.handleStateInfSnapshot(m.GossipMessage, msg.GetConnectionInfo().ID)
 		return
 	}
 
-	if m.IsDataMsg() || m.IsStateInfoMsg() {
+	if protoext.IsDataMsg(m.GossipMessage) || protoext.IsStateInfoMsg(m.GossipMessage) {
 		added := false
 
-		if m.IsDataMsg() {
+		if protoext.IsDataMsg(m.GossipMessage) {
 			if m.GetDataMsg().Payload == nil {
 				gc.logger.Warning("Payload is empty, got it from", msg.GetConnectionInfo().ID)
 				return
@@ -626,7 +627,7 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 		return
 	}
 
-	if m.IsPullMsg() && m.GetPullMsgType() == proto.PullMsgType_BLOCK_MSG {
+	if protoext.IsPullMsg(m.GossipMessage) && protoext.GetPullMsgType(m.GossipMessage) == proto.PullMsgType_BLOCK_MSG {
 		if gc.hasLeftChannel() {
 			gc.logger.Info("Received Pull message from", msg.GetConnectionInfo().Endpoint, "but left the channel", string(gc.chainID))
 			return
@@ -641,15 +642,15 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 			gc.logger.Warning(msg.GetConnectionInfo(), "isn't eligible for pulling blocks of", string(gc.chainID))
 			return
 		}
-		if m.IsDataUpdate() {
+		if protoext.IsDataUpdate(m.GossipMessage) {
 			// Iterate over the envelopes, and filter out blocks
 			// that we already have in the blockMsgStore, or blocks that
 			// are too far in the past.
-			var msgs []*proto.SignedGossipMessage
+			var msgs []*protoext.SignedGossipMessage
 			var items []*proto.Envelope
 			filteredEnvelopes := []*proto.Envelope{}
 			for _, item := range m.GetDataUpdate().Data {
-				gMsg, err := item.ToGossipMessage()
+				gMsg, err := protoext.EnvelopeToGossipMessage(item)
 				if err != nil {
 					gc.logger.Warningf("Data update contains an invalid message: %+v", errors.WithStack(err))
 					return
@@ -689,7 +690,7 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 		gc.blocksPuller.HandleMessage(msg)
 	}
 
-	if m.IsLeadershipMsg() {
+	if protoext.IsLeadershipMsg(m.GossipMessage){
 		connInfo := msg.GetConnectionInfo()
 		senderOrg := gc.GetOrgOfPeer(connInfo.ID)
 		if !bytes.Equal(gc.selfOrg, senderOrg) {
@@ -713,12 +714,12 @@ func (gc *gossipChannel) HandleMessage(msg proto.ReceivedMessage) {
 func (gc *gossipChannel) handleStateInfSnapshot(m *proto.GossipMessage, sender common.PKIidType) {
 	chanName := string(gc.chainID)
 	for _, envelope := range m.GetStateSnapshot().Elements {
-		stateInf, err := envelope.ToGossipMessage()
+		stateInf, err := protoext.EnvelopeToGossipMessage(envelope)
 		if err != nil {
 			gc.logger.Warningf("Channel %s : StateInfo snapshot contains an invalid message: %+v", chanName, errors.WithStack(err))
 			return
 		}
-		if !stateInf.IsStateInfoMsg() {
+		if !protoext.IsStateInfoMsg(stateInf.GossipMessage) {
 			gc.logger.Warning("Channel", chanName, ": Element of StateInfoSnapshot isn't a StateInfoMessage:",
 				stateInf, "message sent from", sender)
 			return
@@ -760,7 +761,7 @@ func (gc *gossipChannel) handleStateInfSnapshot(m *proto.GossipMessage, sender c
 }
 
 func (gc *gossipChannel) verifyBlock(msg *proto.GossipMessage, sender common.PKIidType) bool {
-	if !msg.IsDataMsg() {
+	if !protoext.IsDataMsg(msg) {
 		gc.logger.Warning("Received from ", sender, "a DataUpdate message that contains a non-block GossipMessage:", msg)
 		return false
 	}
@@ -784,7 +785,7 @@ func (gc *gossipChannel) createStateInfoSnapshot(requestersOrg api.OrgIdentityTy
 	rawElements := gc.stateInfoMsgStore.Get()
 	elements := []*proto.Envelope{}
 	for _, rawEl := range rawElements {
-		msg := rawEl.(*proto.SignedGossipMessage)
+		msg := rawEl.(*protoext.SignedGossipMessage)
 		orgOfCurrentMsg := gc.GetOrgOfPeer(msg.GetStateInfo().PkiId)
 		// If we're in the same org as the requester, or the message belongs to a foreign org
 		// don't do any filtering
@@ -812,7 +813,7 @@ func (gc *gossipChannel) createStateInfoSnapshot(requestersOrg api.OrgIdentityTy
 	}
 }
 
-func (gc *gossipChannel) verifyMsg(msg proto.ReceivedMessage) bool {
+func (gc *gossipChannel) verifyMsg(msg protoext.ReceivedMessage) bool {
 	if msg == nil {
 		gc.logger.Warning("Messsage is nil")
 		return false
@@ -828,7 +829,7 @@ func (gc *gossipChannel) verifyMsg(msg proto.ReceivedMessage) bool {
 		return false
 	}
 
-	if m.IsStateInfoMsg() {
+	if protoext.IsStateInfoMsg(m.GossipMessage) {
 		si := m.GetStateInfo()
 		expectedMAC := GenerateMAC(si.PkiId, gc.chainID)
 		if !bytes.Equal(expectedMAC, si.Channel_MAC) {
@@ -838,7 +839,7 @@ func (gc *gossipChannel) verifyMsg(msg proto.ReceivedMessage) bool {
 		return true
 	}
 
-	if m.IsStateInfoPullRequestMsg() {
+	if protoext.IsStateInfoPullRequestMsg(m.GossipMessage) {
 		sipr := m.GetStateInfoPullReq()
 		expectedMAC := GenerateMAC(msg.GetConnectionInfo().ID, gc.chainID)
 		if !bytes.Equal(expectedMAC, sipr.Channel_MAC) {
@@ -855,8 +856,8 @@ func (gc *gossipChannel) verifyMsg(msg proto.ReceivedMessage) bool {
 	return true
 }
 
-func (gc *gossipChannel) createStateInfoRequest() (*proto.SignedGossipMessage, error) {
-	return (&proto.GossipMessage{
+func (gc *gossipChannel) createStateInfoRequest() (*protoext.SignedGossipMessage, error) {
+	return protoext.NoopSign(&proto.GossipMessage{
 		Tag:   proto.GossipMessage_CHAN_OR_ORG,
 		Nonce: 0,
 		Content: &proto.GossipMessage_StateInfoPullReq{
@@ -864,7 +865,7 @@ func (gc *gossipChannel) createStateInfoRequest() (*proto.SignedGossipMessage, e
 				Channel_MAC: GenerateMAC(gc.pkiID, gc.chainID),
 			},
 		},
-	}).NoopSign()
+	})
 }
 
 // UpdateLedgerHeight updates the ledger height the peer
@@ -899,7 +900,7 @@ func (gc *gossipChannel) UpdateChaincodes(chaincodes []*proto.Chaincode) {
 
 // UpdateStateInfo updates this channel's StateInfo message
 // that is periodically published
-func (gc *gossipChannel) updateStateInfo(msg *proto.SignedGossipMessage) {
+func (gc *gossipChannel) updateStateInfo(msg *protoext.SignedGossipMessage) {
 	gc.stateInfoMsgStore.Add(msg)
 	gc.ledgerHeight = msg.GetStateInfo().Properties.LedgerHeight
 	gc.stateInfoMsg = msg
@@ -938,7 +939,7 @@ func (gc *gossipChannel) updateProperties(ledgerHeight uint64, chaincodes []*pro
 
 func newStateInfoCache(sweepInterval time.Duration, hasExpired func(interface{}) bool, verifyFunc membershipPredicate) *stateInfoCache {
 	membershipStore := util.NewMembershipStore()
-	pol := proto.NewGossipMessageComparator(0)
+	pol := protoext.NewGossipMessageComparator(0)
 
 	s := &stateInfoCache{
 		verify:          verifyFunc,
@@ -946,7 +947,7 @@ func newStateInfoCache(sweepInterval time.Duration, hasExpired func(interface{})
 		stopChan:        make(chan struct{}),
 	}
 	invalidationTrigger := func(m interface{}) {
-		pkiID := m.(*proto.SignedGossipMessage).GetStateInfo().PkiId
+		pkiID := m.(*protoext.SignedGossipMessage).GetStateInfo().PkiId
 		membershipStore.Remove(pkiID)
 	}
 	s.MessageStore = msgstore.NewMessageStore(pol, invalidationTrigger)
@@ -967,7 +968,7 @@ func newStateInfoCache(sweepInterval time.Duration, hasExpired func(interface{})
 // membershipPredicate receives a StateInfoMessage and optionally a slice of organization identifiers
 // and returns whether the peer that signed the given StateInfoMessage is eligible
 // to the channel or not
-type membershipPredicate func(msg *proto.SignedGossipMessage, orgs ...api.OrgIdentityType) bool
+type membershipPredicate func(msg *protoext.SignedGossipMessage, orgs ...api.OrgIdentityType) bool
 
 // stateInfoCache is actually a messageStore
 // that also indexes messages that are added
@@ -981,7 +982,7 @@ type stateInfoCache struct {
 
 func (cache *stateInfoCache) validate(orgs []api.OrgIdentityType) {
 	for _, m := range cache.Get() {
-		msg := m.(*proto.SignedGossipMessage)
+		msg := m.(*protoext.SignedGossipMessage)
 		if !cache.verify(msg, orgs...) {
 			cache.delete(msg)
 		}
@@ -991,7 +992,7 @@ func (cache *stateInfoCache) validate(orgs []api.OrgIdentityType) {
 // Add attempts to add the given message to the stateInfoCache,
 // and if the message was added, also indexes it.
 // Message must be a StateInfo message.
-func (cache *stateInfoCache) Add(msg *proto.SignedGossipMessage) bool {
+func (cache *stateInfoCache) Add(msg *protoext.SignedGossipMessage) bool {
 	if !cache.MessageStore.CheckValid(msg) {
 		return false
 	}
@@ -1006,9 +1007,9 @@ func (cache *stateInfoCache) Add(msg *proto.SignedGossipMessage) bool {
 	return added
 }
 
-func (cache *stateInfoCache) delete(msg *proto.SignedGossipMessage) {
+func (cache *stateInfoCache) delete(msg *protoext.SignedGossipMessage) {
 	cache.Purge(func(o interface{}) bool {
-		pkiID := o.(*proto.SignedGossipMessage).GetStateInfo().PkiId
+		pkiID := o.(*protoext.SignedGossipMessage).GetStateInfo().PkiId
 		return bytes.Equal(pkiID, msg.GetStateInfo().PkiId)
 	})
 	cache.Remove(msg.GetStateInfo().PkiId)
diff --git a/gossip/gossip/channel/channel_test.go b/gossip/gossip/channel/channel_test.go
index daec0aaf0..f6d120244 100644
--- a/gossip/gossip/channel/channel_test.go
+++ b/gossip/gossip/channel/channel_test.go
@@ -26,6 +26,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -155,7 +156,7 @@ func (cs *cryptoService) ValidateIdentity(peerIdentity api.PeerIdentityType) err
 
 type receivedMsg struct {
 	PKIID common.PKIidType
-	msg   *proto.SignedGossipMessage
+	msg   *protoext.SignedGossipMessage
 	mock.Mock
 }
 
@@ -165,7 +166,7 @@ func (m *receivedMsg) GetSourceEnvelope() *proto.Envelope {
 	return m.msg.Envelope
 }
 
-func (m *receivedMsg) GetGossipMessage() *proto.SignedGossipMessage {
+func (m *receivedMsg) GetGossipMessage() *protoext.SignedGossipMessage {
 	return m.msg
 }
 
@@ -178,8 +179,8 @@ func (m *receivedMsg) Ack(err error) {
 
 }
 
-func (m *receivedMsg) GetConnectionInfo() *proto.ConnectionInfo {
-	return &proto.ConnectionInfo{
+func (m *receivedMsg) GetConnectionInfo() *protoext.ConnectionInfo {
+	return &protoext.ConnectionInfo{
 		ID: m.PKIID,
 	}
 }
@@ -188,8 +189,8 @@ type gossipAdapterMock struct {
 	mock.Mock
 }
 
-func (ga *gossipAdapterMock) Sign(msg *proto.GossipMessage) (*proto.SignedGossipMessage, error) {
-	return msg.NoopSign()
+func (ga *gossipAdapterMock) Sign(msg *proto.GossipMessage) (*protoext.SignedGossipMessage, error) {
+	return protoext.NoopSign(msg)
 }
 
 func (ga *gossipAdapterMock) GetConf() Config {
@@ -197,11 +198,11 @@ func (ga *gossipAdapterMock) GetConf() Config {
 	return args.Get(0).(Config)
 }
 
-func (ga *gossipAdapterMock) Gossip(msg *proto.SignedGossipMessage) {
+func (ga *gossipAdapterMock) Gossip(msg *protoext.SignedGossipMessage) {
 	ga.Called(msg)
 }
 
-func (ga *gossipAdapterMock) Forward(msg proto.ReceivedMessage) {
+func (ga *gossipAdapterMock) Forward(msg protoext.ReceivedMessage) {
 	ga.Called(msg)
 }
 
@@ -229,7 +230,7 @@ func (ga *gossipAdapterMock) Lookup(PKIID common.PKIidType) *discovery.NetworkMe
 	return args.Get(0).(*discovery.NetworkMember)
 }
 
-func (ga *gossipAdapterMock) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (ga *gossipAdapterMock) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	// Ensure we have configured Send prior
 	if !ga.wasMocked("Send") {
 		return
@@ -237,7 +238,7 @@ func (ga *gossipAdapterMock) Send(msg *proto.SignedGossipMessage, peers ...*comm
 	ga.Called(msg, peers)
 }
 
-func (ga *gossipAdapterMock) ValidateStateInfoMessage(msg *proto.SignedGossipMessage) error {
+func (ga *gossipAdapterMock) ValidateStateInfoMessage(msg *protoext.SignedGossipMessage) error {
 	args := ga.Called(msg)
 	if args.Get(0) == nil {
 		return nil
@@ -312,7 +313,7 @@ func TestSelf(t *testing.T) {
 	gc.UpdateLedgerHeight(1)
 	gMsg := gc.Self().GossipMessage
 	env := gc.Self().Envelope
-	sMsg, _ := env.ToGossipMessage()
+	sMsg, _ := protoext.EnvelopeToGossipMessage(env)
 	assert.True(t, gproto.Equal(gMsg, sMsg.GossipMessage))
 	assert.Equal(t, gMsg.GetStateInfo().Properties.LedgerHeight, uint64(1))
 	assert.Equal(t, gMsg.GetStateInfo().PkiId, []byte("1"))
@@ -355,17 +356,17 @@ func TestMsgStoreNotExpire(t *testing.T) {
 	gc.HandleMessage(&receivedMsg{PKIID: pkiID2, msg: createStateInfoMsg(1, pkiID2, channelA)})
 	gc.HandleMessage(&receivedMsg{PKIID: pkiID3, msg: createStateInfoMsg(1, pkiID3, channelA)})
 
-	simulateStateInfoRequest := func(pkiID []byte, outChan chan *proto.SignedGossipMessage) {
+	simulateStateInfoRequest := func(pkiID []byte, outChan chan *protoext.SignedGossipMessage) {
 		sentMessages := make(chan *proto.GossipMessage, 1)
 		// Ensure we respond to stateInfoSnapshot requests with valid MAC
-		s, _ := (&proto.GossipMessage{
+		s, _ := protoext.NoopSign(&proto.GossipMessage{
 			Tag: proto.GossipMessage_CHAN_OR_ORG,
 			Content: &proto.GossipMessage_StateInfoPullReq{
 				StateInfoPullReq: &proto.StateInfoPullRequest{
 					Channel_MAC: GenerateMAC(pkiID, channelA),
 				},
 			},
-		}).NoopSign()
+		})
 		snapshotReq := &receivedMsg{
 			PKIID: pkiID,
 			msg:   s,
@@ -380,18 +381,18 @@ func TestMsgStoreNotExpire(t *testing.T) {
 			t.Fatal("Haven't received a state info snapshot on time")
 		case msg := <-sentMessages:
 			for _, el := range msg.GetStateSnapshot().Elements {
-				sMsg, err := el.ToGossipMessage()
+				sMsg, err := protoext.EnvelopeToGossipMessage(el)
 				assert.NoError(t, err)
 				outChan <- sMsg
 			}
 		}
 	}
 
-	c := make(chan *proto.SignedGossipMessage, 3)
+	c := make(chan *protoext.SignedGossipMessage, 3)
 	simulateStateInfoRequest(pkiID2, c)
 	assert.Len(t, c, 3)
 
-	c = make(chan *proto.SignedGossipMessage, 3)
+	c = make(chan *protoext.SignedGossipMessage, 3)
 	simulateStateInfoRequest(pkiID3, c)
 	assert.Len(t, c, 3)
 
@@ -403,11 +404,11 @@ func TestMsgStoreNotExpire(t *testing.T) {
 	// the test
 	time.Sleep(conf.StateInfoCacheSweepInterval * 2)
 
-	c = make(chan *proto.SignedGossipMessage, 3)
+	c = make(chan *protoext.SignedGossipMessage, 3)
 	simulateStateInfoRequest(pkiID2, c)
 	assert.Len(t, c, 2)
 
-	c = make(chan *proto.SignedGossipMessage, 3)
+	c = make(chan *protoext.SignedGossipMessage, 3)
 	simulateStateInfoRequest(pkiID3, c)
 	assert.Len(t, c, 2)
 }
@@ -444,8 +445,8 @@ func TestLeaveChannel(t *testing.T) {
 	configureAdapter(adapter, members...)
 	gc := NewGossipChannel(common.PKIidType("p0"), orgInChannelA, cs, channelA, adapter, jcm, disabledMetrics)
 	adapter.On("Send", mock.Anything, mock.Anything).Run(func(arguments mock.Arguments) {
-		msg := arguments.Get(0).(*proto.SignedGossipMessage)
-		if msg.IsPullMsg() {
+		msg := arguments.Get(0).(*protoext.SignedGossipMessage)
+		if protoext.IsPullMsg(msg.GossipMessage) {
 			helloPullWG.Done()
 			assert.False(t, gc.(*gossipChannel).hasLeftChannel())
 		}
@@ -492,7 +493,7 @@ func TestChannelPeriodicalPublishStateInfo(t *testing.T) {
 	t.Parallel()
 	ledgerHeight := 5
 	receivedMsg := int32(0)
-	stateInfoReceptionChan := make(chan *proto.SignedGossipMessage, 1)
+	stateInfoReceptionChan := make(chan *protoext.SignedGossipMessage, 1)
 
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
@@ -506,7 +507,7 @@ func TestChannelPeriodicalPublishStateInfo(t *testing.T) {
 		}
 
 		atomic.StoreInt32(&receivedMsg, int32(1))
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
 		stateInfoReceptionChan <- msg
 	})
 
@@ -514,7 +515,7 @@ func TestChannelPeriodicalPublishStateInfo(t *testing.T) {
 	gc.UpdateLedgerHeight(uint64(ledgerHeight))
 	defer gc.Stop()
 
-	var msg *proto.SignedGossipMessage
+	var msg *protoext.SignedGossipMessage
 	select {
 	case <-time.After(time.Second * 5):
 		t.Fatal("Haven't sent stateInfo on time")
@@ -557,19 +558,19 @@ func TestChannelMsgStoreEviction(t *testing.T) {
 	wg.Add(int(totalPhases))
 
 	adapter.On("Send", mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
-		msg := args.Get(0).(*proto.SignedGossipMessage)
+		msg := args.Get(0).(*protoext.SignedGossipMessage)
 		// Ignore all other messages sent like StateInfo messages
-		if !msg.IsPullMsg() {
+		if !protoext.IsPullMsg(msg.GossipMessage) {
 			return
 		}
 		// Stop the pull when we reach the final phase
-		if atomic.LoadUint64(&phaseNum) == totalPhases && msg.IsHelloMsg() {
+		if atomic.LoadUint64(&phaseNum) == totalPhases && protoext.IsHelloMsg(msg.GossipMessage) {
 			return
 		}
 
 		start := atomic.LoadUint64(&phaseNum) * msgsPerPhase
 		end := start + msgsPerPhase
-		if msg.IsHelloMsg() {
+		if protoext.IsHelloMsg(msg.GossipMessage) {
 			// Advance phase
 			atomic.AddUint64(&phaseNum, uint64(1))
 		}
@@ -580,7 +581,7 @@ func TestChannelMsgStoreEviction(t *testing.T) {
 		pullPhase(args)
 
 		// If we finished the last phase, save the sequence to be used later for inspection
-		if msg.IsDataReq() && atomic.LoadUint64(&phaseNum) == totalPhases {
+		if protoext.IsDataReq(msg.GossipMessage) && atomic.LoadUint64(&phaseNum) == totalPhases {
 			for _, seq := range currSeq {
 				lastPullPhase <- seq
 			}
@@ -595,7 +596,7 @@ func TestChannelMsgStoreEviction(t *testing.T) {
 	helloMsg := createHelloMsg(pkiIDInOrg1)
 	helloMsg.On("Respond", mock.Anything).Run(func(arg mock.Arguments) {
 		msg := arg.Get(0).(*proto.GossipMessage)
-		if !msg.IsDigestMsg() {
+		if !protoext.IsDigestMsg(msg) {
 			return
 		}
 		msgSentFromPullMediator <- msg
@@ -613,7 +614,7 @@ func TestChannelMsgStoreEviction(t *testing.T) {
 	assert.Len(t, msgSentFromPullMediator, 1)
 	msg := <-msgSentFromPullMediator
 	// It's a digest and not anything else, like an update
-	assert.True(t, msg.IsDigestMsg())
+	assert.True(t, protoext.IsDigestMsg(msg))
 	assert.Len(t, msg.GetDataDig().Digests, adapter.GetConf().MaxBlockCountToStore+1)
 	// Check that the last sequences are kept.
 	// Since we checked the length, it proves that the old blocks were discarded, since we had much more
@@ -627,18 +628,18 @@ func TestChannelPull(t *testing.T) {
 	t.Parallel()
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
-	receivedBlocksChan := make(chan *proto.SignedGossipMessage, 2)
+	receivedBlocksChan := make(chan *protoext.SignedGossipMessage, 2)
 	adapter := new(gossipAdapterMock)
 	configureAdapter(adapter, discovery.NetworkMember{PKIid: pkiIDInOrg1})
 	adapter.On("Gossip", mock.Anything)
 	adapter.On("Forward", mock.Anything)
 	adapter.On("DeMultiplex", mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
-		if !msg.IsDataMsg() {
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
+		if !protoext.IsDataMsg(msg.GossipMessage) {
 			return
 		}
 		// The peer is supposed to de-multiplex 2 ledger blocks
-		assert.True(t, msg.IsDataMsg())
+		assert.True(t, protoext.IsDataMsg(msg.GossipMessage))
 		receivedBlocksChan <- msg
 	})
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
@@ -697,8 +698,8 @@ func TestChannelPullAccessControl(t *testing.T) {
 
 	sentHello := int32(0)
 	adapter.On("Send", mock.Anything, mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
-		if !msg.IsHelloMsg() {
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
+		if !protoext.IsHelloMsg(msg.GossipMessage) {
 			return
 		}
 		atomic.StoreInt32(&sentHello, int32(1))
@@ -906,7 +907,7 @@ func TestChannelAddToMessageStore(t *testing.T) {
 
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
-	demuxedMsgs := make(chan *proto.SignedGossipMessage, 1)
+	demuxedMsgs := make(chan *protoext.SignedGossipMessage, 1)
 	adapter := new(gossipAdapterMock)
 	configureAdapter(adapter)
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
@@ -914,7 +915,7 @@ func TestChannelAddToMessageStore(t *testing.T) {
 	adapter.On("Forward", mock.Anything)
 	adapter.On("Send", mock.Anything, mock.Anything)
 	adapter.On("DeMultiplex", mock.Anything).Run(func(arg mock.Arguments) {
-		demuxedMsgs <- arg.Get(0).(*proto.SignedGossipMessage)
+		demuxedMsgs <- arg.Get(0).(*protoext.SignedGossipMessage)
 	})
 
 	// Check that adding a message of a bad type doesn't crash the program
@@ -959,7 +960,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
-	demuxedMsgs := make(chan *proto.SignedGossipMessage, 1)
+	demuxedMsgs := make(chan *protoext.SignedGossipMessage, 1)
 	adapter := new(gossipAdapterMock)
 	configureAdapter(adapter)
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
@@ -967,7 +968,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 	adapter.On("Forward", mock.Anything)
 	adapter.On("Send", mock.Anything, mock.Anything)
 	adapter.On("DeMultiplex", mock.Anything).Run(func(arg mock.Arguments) {
-		demuxedMsgs <- arg.Get(0).(*proto.SignedGossipMessage)
+		demuxedMsgs <- arg.Get(0).(*protoext.SignedGossipMessage)
 	})
 	respondedChan := make(chan *proto.GossipMessage, 1)
 	messageRelayer := func(arg mock.Arguments) {
@@ -993,7 +994,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 	case <-time.After(time.Second):
 		t.Fatal("Haven't responded to hello message within a time period")
 	case msg := <-respondedChan:
-		if msg.IsDigestMsg() {
+		if protoext.IsDigestMsg(msg) {
 			assert.Equal(t, 1, len(msg.GetDataDig().Digests), "Number of digests returned by channel blockPuller incorrect")
 		} else {
 			t.Fatal("Not correct pull msg type in response - expect digest")
@@ -1037,7 +1038,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 	case <-time.After(time.Second):
 		t.Fatal("Haven't responded to hello message within a time period")
 	case msg := <-respondedChan:
-		if msg.IsDigestMsg() {
+		if protoext.IsDigestMsg(msg) {
 			assert.Equal(t, 1, len(msg.GetDataDig().Digests), "Number of digests returned by channel blockPuller incorrect")
 		} else {
 			t.Fatal("Not correct pull msg type in response - expect digest")
@@ -1049,7 +1050,7 @@ func TestChannelBlockExpiration(t *testing.T) {
 
 func TestChannelBadBlocks(t *testing.T) {
 	t.Parallel()
-	receivedMessages := make(chan *proto.SignedGossipMessage, 1)
+	receivedMessages := make(chan *protoext.SignedGossipMessage, 1)
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
 	adapter := new(gossipAdapterMock)
@@ -1059,7 +1060,7 @@ func TestChannelBadBlocks(t *testing.T) {
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
 
 	adapter.On("DeMultiplex", mock.Anything).Run(func(args mock.Arguments) {
-		receivedMessages <- args.Get(0).(*proto.SignedGossipMessage)
+		receivedMessages <- args.Get(0).(*protoext.SignedGossipMessage)
 	})
 
 	// Send a valid block
@@ -1102,9 +1103,9 @@ func TestChannelPulledBadBlocks(t *testing.T) {
 	wg.Add(1)
 
 	changeChan := func(env *proto.Envelope) {
-		sMsg, _ := env.ToGossipMessage()
+		sMsg, _ := protoext.EnvelopeToGossipMessage(env)
 		sMsg.Channel = []byte("B")
-		sMsg, _ = sMsg.NoopSign()
+		sMsg, _ = protoext.NoopSign(sMsg.GossipMessage)
 		env.Payload = sMsg.Payload
 	}
 
@@ -1150,9 +1151,9 @@ func TestChannelPulledBadBlocks(t *testing.T) {
 	var wg3 sync.WaitGroup
 	wg3.Add(1)
 	emptyBlock := func(env *proto.Envelope) {
-		sMsg, _ := env.ToGossipMessage()
+		sMsg, _ := protoext.EnvelopeToGossipMessage(env)
 		sMsg.GossipMessage.GetDataMsg().Payload = nil
-		sMsg, _ = sMsg.NoopSign()
+		sMsg, _ = protoext.NoopSign(sMsg.GossipMessage)
 		env.Payload = sMsg.Payload
 	}
 	pullPhase3 := simulatePullPhase(gc, t, &wg3, emptyBlock, 10, 11)
@@ -1175,9 +1176,9 @@ func TestChannelPulledBadBlocks(t *testing.T) {
 	var wg4 sync.WaitGroup
 	wg4.Add(1)
 	nonBlockMsg := func(env *proto.Envelope) {
-		sMsg, _ := env.ToGossipMessage()
+		sMsg, _ := protoext.EnvelopeToGossipMessage(env)
 		sMsg.Content = createHelloMsg(pkiIDInOrg1).GetGossipMessage().Content
-		sMsg, _ = sMsg.NoopSign()
+		sMsg, _ = protoext.NoopSign(sMsg.GossipMessage)
 		env.Payload = sMsg.Payload
 	}
 	pullPhase4 := simulatePullPhase(gc, t, &wg4, nonBlockMsg, 10, 11)
@@ -1219,7 +1220,7 @@ func TestChannelStateInfoSnapshot(t *testing.T) {
 	// Ensure we ignore stateInfo snapshots with StateInfo messages with wrong MACs
 	sim := createStateInfoMsg(4, pkiIDInOrg1, channelA)
 	sim.GetStateInfo().Channel_MAC = append(sim.GetStateInfo().Channel_MAC, 1)
-	sim, _ = sim.NoopSign()
+	sim, _ = protoext.NoopSign(sim.GossipMessage)
 	gc.HandleMessage(&receivedMsg{PKIID: pkiIDInOrg1, msg: stateInfoSnapshotForChannel(channelA, sim)})
 	assert.Empty(t, gc.GetPeers())
 
@@ -1233,14 +1234,14 @@ func TestChannelStateInfoSnapshot(t *testing.T) {
 	assert.Equal(t, 4, int(gc.GetPeers()[0].Properties.LedgerHeight))
 
 	// Check we don't respond to stateInfoSnapshot requests with wrong MAC
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfoPullReq{
 			StateInfoPullReq: &proto.StateInfoPullRequest{
 				Channel_MAC: append(GenerateMAC(pkiIDInOrg1, channelA), 1),
 			},
 		},
-	}).NoopSign()
+	})
 	snapshotReq := &receivedMsg{
 		PKIID: pkiIDInOrg1,
 		msg:   sMsg,
@@ -1257,14 +1258,14 @@ func TestChannelStateInfoSnapshot(t *testing.T) {
 	}
 
 	// Ensure we respond to stateInfoSnapshot requests with valid MAC
-	sMsg, _ = (&proto.GossipMessage{
+	sMsg, _ = protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfoPullReq{
 			StateInfoPullReq: &proto.StateInfoPullRequest{
 				Channel_MAC: GenerateMAC(pkiIDInOrg1, channelA),
 			},
 		},
-	}).NoopSign()
+	})
 	snapshotReq = &receivedMsg{
 		PKIID: pkiIDInOrg1,
 		msg:   sMsg,
@@ -1280,7 +1281,7 @@ func TestChannelStateInfoSnapshot(t *testing.T) {
 	case msg := <-sentMessages:
 		elements := msg.GetStateSnapshot().Elements
 		assert.Len(t, elements, 1)
-		sMsg, err := elements[0].ToGossipMessage()
+		sMsg, err := protoext.EnvelopeToGossipMessage(elements[0])
 		assert.NoError(t, err)
 		assert.Equal(t, 4, int(sMsg.GetStateInfo().Properties.LedgerHeight))
 	}
@@ -1327,14 +1328,14 @@ func TestInterOrgExternalEndpointDisclosure(t *testing.T) {
 
 	// Check that we only return StateInfo messages of peers with external endpoints
 	// to peers of other orgs
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfoPullReq{
 			StateInfoPullReq: &proto.StateInfoPullRequest{
 				Channel_MAC: GenerateMAC(pkiID3, channelA),
 			},
 		},
-	}).NoopSign()
+	})
 	snapshotReq := &receivedMsg{
 		PKIID: pkiID3,
 		msg:   sMsg,
@@ -1350,8 +1351,8 @@ func TestInterOrgExternalEndpointDisclosure(t *testing.T) {
 	case msg := <-sentMessages:
 		elements := msg.GetStateSnapshot().Elements
 		assert.Len(t, elements, 2)
-		m1, _ := elements[0].ToGossipMessage()
-		m2, _ := elements[1].ToGossipMessage()
+		m1, _ := protoext.EnvelopeToGossipMessage(elements[0])
+		m2, _ := protoext.EnvelopeToGossipMessage(elements[1])
 		pkiIDs := [][]byte{m1.GetStateInfo().PkiId, m2.GetStateInfo().PkiId}
 		assert.Contains(t, pkiIDs, []byte(pkiID1))
 		assert.Contains(t, pkiIDs, []byte(pkiID3))
@@ -1359,14 +1360,14 @@ func TestInterOrgExternalEndpointDisclosure(t *testing.T) {
 
 	// Check that we return all StateInfo messages to peers in our organization, regardless
 	// if the peers from foreign organizations have external endpoints or not
-	sMsg, _ = (&proto.GossipMessage{
+	sMsg, _ = protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfoPullReq{
 			StateInfoPullReq: &proto.StateInfoPullRequest{
 				Channel_MAC: GenerateMAC(pkiID2, channelA),
 			},
 		},
-	}).NoopSign()
+	})
 	snapshotReq = &receivedMsg{
 		PKIID: pkiID2,
 		msg:   sMsg,
@@ -1382,9 +1383,9 @@ func TestInterOrgExternalEndpointDisclosure(t *testing.T) {
 	case msg := <-sentMessages:
 		elements := msg.GetStateSnapshot().Elements
 		assert.Len(t, elements, 3)
-		m1, _ := elements[0].ToGossipMessage()
-		m2, _ := elements[1].ToGossipMessage()
-		m3, _ := elements[2].ToGossipMessage()
+		m1, _ := protoext.EnvelopeToGossipMessage(elements[0])
+		m2, _ := protoext.EnvelopeToGossipMessage(elements[1])
+		m3, _ := protoext.EnvelopeToGossipMessage(elements[2])
 		pkiIDs := [][]byte{m1.GetStateInfo().PkiId, m2.GetStateInfo().PkiId, m3.GetStateInfo().PkiId}
 		assert.Contains(t, pkiIDs, []byte(pkiID1))
 		assert.Contains(t, pkiIDs, []byte(pkiID2))
@@ -1701,7 +1702,7 @@ func TestChannelGetPeers(t *testing.T) {
 	assert.Equal(t, pkiIDInOrg1, gc.GetPeers()[0].PKIid)
 
 	// Ensure envelope from GetPeers is valid
-	gMsg, _ := gc.GetPeers()[0].Envelope.ToGossipMessage()
+	gMsg, _ := protoext.EnvelopeToGossipMessage(gc.GetPeers()[0].Envelope)
 	assert.Equal(t, []byte(pkiIDInOrg1), gMsg.GetStateInfo().PkiId)
 
 	gc.HandleMessage(&receivedMsg{msg: createStateInfoMsg(10, pkiIDInOrg1ButNotEligible, channelA), PKIID: pkiIDInOrg1ButNotEligible})
@@ -1788,18 +1789,18 @@ func TestChannelPullWithDigestsFilter(t *testing.T) {
 	t.Parallel()
 	cs := &cryptoService{}
 	cs.On("VerifyBlock", mock.Anything).Return(nil)
-	receivedBlocksChan := make(chan *proto.SignedGossipMessage, 2)
+	receivedBlocksChan := make(chan *protoext.SignedGossipMessage, 2)
 	adapter := new(gossipAdapterMock)
 	configureAdapter(adapter, discovery.NetworkMember{PKIid: pkiIDInOrg1})
 	adapter.On("Gossip", mock.Anything)
 	adapter.On("Forward", mock.Anything)
 	adapter.On("DeMultiplex", mock.Anything).Run(func(arg mock.Arguments) {
-		msg := arg.Get(0).(*proto.SignedGossipMessage)
-		if !msg.IsDataMsg() {
+		msg := arg.Get(0).(*protoext.SignedGossipMessage)
+		if !protoext.IsDataMsg(msg.GossipMessage) {
 			return
 		}
 		// The peer is supposed to de-multiplex 1 ledger block
-		assert.True(t, msg.IsDataMsg())
+		assert.True(t, protoext.IsDataMsg(msg.GossipMessage))
 		receivedBlocksChan <- msg
 	})
 	gc := NewGossipChannel(pkiIDInOrg1, orgInChannelA, cs, channelA, adapter, &joinChanMsg{}, disabledMetrics)
@@ -1895,7 +1896,7 @@ func TestFilterForeignOrgLeadershipMessages(t *testing.T) {
 	assertLogged("Received leadership message created by a foreign organization org2")
 }
 
-func createDataUpdateMsg(nonce uint64, seqs ...uint64) *proto.SignedGossipMessage {
+func createDataUpdateMsg(nonce uint64, seqs ...uint64) *protoext.SignedGossipMessage {
 	msg := &proto.GossipMessage{
 		Nonce:   0,
 		Channel: []byte(channelA),
@@ -1911,7 +1912,7 @@ func createDataUpdateMsg(nonce uint64, seqs ...uint64) *proto.SignedGossipMessag
 	for _, seq := range seqs {
 		msg.GetDataUpdate().Data = append(msg.GetDataUpdate().Data, createDataMsg(seq, channelA).Envelope)
 	}
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	return sMsg
 }
 
@@ -1927,12 +1928,12 @@ func createHelloMsg(PKIID common.PKIidType) *receivedMsg {
 			},
 		},
 	}
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	return &receivedMsg{msg: sMsg, PKIID: PKIID}
 }
 
-func dataMsgOfChannel(seqnum uint64, channel common.ChainID) *proto.SignedGossipMessage {
-	sMsg, _ := (&proto.GossipMessage{
+func dataMsgOfChannel(seqnum uint64, channel common.ChainID) *protoext.SignedGossipMessage {
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Channel: []byte(channel),
 		Nonce:   0,
 		Tag:     proto.GossipMessage_CHAN_AND_ORG,
@@ -1944,12 +1945,12 @@ func dataMsgOfChannel(seqnum uint64, channel common.ChainID) *proto.SignedGossip
 				},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
-func createStateInfoMsg(ledgerHeight int, pkiID common.PKIidType, channel common.ChainID) *proto.SignedGossipMessage {
-	sMsg, _ := (&proto.GossipMessage{
+func createStateInfoMsg(ledgerHeight int, pkiID common.PKIidType, channel common.ChainID) *protoext.SignedGossipMessage {
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Tag: proto.GossipMessage_CHAN_OR_ORG,
 		Content: &proto.GossipMessage_StateInfo{
 			StateInfo: &proto.StateInfo{
@@ -1961,16 +1962,16 @@ func createStateInfoMsg(ledgerHeight int, pkiID common.PKIidType, channel common
 				},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
-func stateInfoSnapshotForChannel(chainID common.ChainID, stateInfoMsgs ...*proto.SignedGossipMessage) *proto.SignedGossipMessage {
+func stateInfoSnapshotForChannel(chainID common.ChainID, stateInfoMsgs ...*protoext.SignedGossipMessage) *protoext.SignedGossipMessage {
 	envelopes := make([]*proto.Envelope, len(stateInfoMsgs))
 	for i, sim := range stateInfoMsgs {
 		envelopes[i] = sim.Envelope
 	}
-	sMsg, _ := (&proto.GossipMessage{
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Channel: chainID,
 		Tag:     proto.GossipMessage_CHAN_OR_ORG,
 		Nonce:   0,
@@ -1979,12 +1980,12 @@ func stateInfoSnapshotForChannel(chainID common.ChainID, stateInfoMsgs ...*proto
 				Elements: envelopes,
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
-func createDataMsg(seqnum uint64, channel common.ChainID) *proto.SignedGossipMessage {
-	sMsg, _ := (&proto.GossipMessage{
+func createDataMsg(seqnum uint64, channel common.ChainID) *protoext.SignedGossipMessage {
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Nonce:   0,
 		Tag:     proto.GossipMessage_CHAN_AND_ORG,
 		Channel: []byte(channel),
@@ -1996,7 +1997,7 @@ func createDataMsg(seqnum uint64, channel common.ChainID) *proto.SignedGossipMes
 				},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
@@ -2009,13 +2010,13 @@ func simulatePullPhaseWithVariableDigest(gc GossipChannel, t *testing.T, wg *syn
 	var sentHello bool
 	var sentReq bool
 	return func(args mock.Arguments) {
-		msg := args.Get(0).(*proto.SignedGossipMessage)
+		msg := args.Get(0).(*protoext.SignedGossipMessage)
 		l.Lock()
 		defer l.Unlock()
-		if msg.IsHelloMsg() && !sentHello {
+		if protoext.IsHelloMsg(msg.GossipMessage) && !sentHello {
 			sentHello = true
 			// Simulate a digest message an imaginary peer responds to the hello message sent
-			sMsg, _ := (&proto.GossipMessage{
+			sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 				Tag:     proto.GossipMessage_CHAN_AND_ORG,
 				Channel: []byte(channelA),
 				Content: &proto.GossipMessage_DataDig{
@@ -2025,14 +2026,14 @@ func simulatePullPhaseWithVariableDigest(gc GossipChannel, t *testing.T, wg *syn
 						Nonce:   msg.GetHello().Nonce,
 					},
 				},
-			}).NoopSign()
+			})
 			digestMsg := &receivedMsg{
 				PKIID: pkiIDInOrg1,
 				msg:   sMsg,
 			}
 			go gc.HandleMessage(digestMsg)
 		}
-		if msg.IsDataReq() && !sentReq {
+		if protoext.IsDataReq(msg.GossipMessage) && !sentReq {
 			sentReq = true
 			dataReq := msg.GetDataReq()
 			for _, expectedDigest := range util.StringsToBytes(resultDigestSeqs) {
diff --git a/gossip/gossip/chanstate.go b/gossip/gossip/chanstate.go
index befe8ebe3..ea6b45dc3 100644
--- a/gossip/gossip/chanstate.go
+++ b/gossip/gossip/chanstate.go
@@ -17,6 +17,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/gossip/channel"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
@@ -43,8 +44,8 @@ func (cs *channelState) isStopping() bool {
 	return atomic.LoadInt32(&cs.stopping) == int32(1)
 }
 
-func (cs *channelState) lookupChannelForMsg(msg proto.ReceivedMessage) channel.GossipChannel {
-	if msg.GetGossipMessage().IsStateInfoPullRequestMsg() {
+func (cs *channelState) lookupChannelForMsg(msg protoext.ReceivedMessage) channel.GossipChannel {
+	if protoext.IsStateInfoPullRequestMsg(msg.GetGossipMessage().GossipMessage) {
 		sipr := msg.GetGossipMessage().GetStateInfoPullReq()
 		mac := sipr.Channel_MAC
 		pkiID := msg.GetConnectionInfo().ID
@@ -54,7 +55,7 @@ func (cs *channelState) lookupChannelForMsg(msg proto.ReceivedMessage) channel.G
 }
 
 func (cs *channelState) lookupChannelForGossipMsg(msg *proto.GossipMessage) channel.GossipChannel {
-	if !msg.IsStateInfoMsg() {
+	if !protoext.IsStateInfoMsg(msg) {
 		// If we reached here then the message isn't:
 		// 1) StateInfoPullRequest
 		// 2) StateInfo
@@ -134,25 +135,25 @@ func (ga *gossipAdapterImpl) GetConf() channel.Config {
 	}
 }
 
-func (ga *gossipAdapterImpl) Sign(msg *proto.GossipMessage) (*proto.SignedGossipMessage, error) {
+func (ga *gossipAdapterImpl) Sign(msg *proto.GossipMessage) (*protoext.SignedGossipMessage, error) {
 	signer := func(msg []byte) ([]byte, error) {
 		return ga.mcs.Sign(msg)
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: msg,
 	}
 	e, err := sMsg.Sign(signer)
 	if err != nil {
 		return nil, err
 	}
-	return &proto.SignedGossipMessage{
+	return &protoext.SignedGossipMessage{
 		Envelope:      e,
 		GossipMessage: msg,
 	}, nil
 }
 
 // Gossip gossips a message
-func (ga *gossipAdapterImpl) Gossip(msg *proto.SignedGossipMessage) {
+func (ga *gossipAdapterImpl) Gossip(msg *protoext.SignedGossipMessage) {
 	ga.gossipServiceImpl.emitter.Add(&emittedGossipMessage{
 		SignedGossipMessage: msg,
 		filter: func(_ common.PKIidType) bool {
@@ -162,20 +163,20 @@ func (ga *gossipAdapterImpl) Gossip(msg *proto.SignedGossipMessage) {
 }
 
 // Forward sends message to the next hops
-func (ga *gossipAdapterImpl) Forward(msg proto.ReceivedMessage) {
+func (ga *gossipAdapterImpl) Forward(msg protoext.ReceivedMessage) {
 	ga.gossipServiceImpl.emitter.Add(&emittedGossipMessage{
 		SignedGossipMessage: msg.GetGossipMessage(),
 		filter:              msg.GetConnectionInfo().ID.IsNotSameFilter,
 	})
 }
 
-func (ga *gossipAdapterImpl) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (ga *gossipAdapterImpl) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	ga.gossipServiceImpl.comm.Send(msg, peers...)
 }
 
 // ValidateStateInfoMessage returns error if a message isn't valid
 // nil otherwise
-func (ga *gossipAdapterImpl) ValidateStateInfoMessage(msg *proto.SignedGossipMessage) error {
+func (ga *gossipAdapterImpl) ValidateStateInfoMessage(msg *protoext.SignedGossipMessage) error {
 	return ga.gossipServiceImpl.validateStateInfoMsg(msg)
 }
 
diff --git a/gossip/gossip/gossip.go b/gossip/gossip/gossip.go
index a429a303c..75f5e1702 100644
--- a/gossip/gossip/gossip.go
+++ b/gossip/gossip/gossip.go
@@ -15,6 +15,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/filter"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 )
 
@@ -25,13 +26,13 @@ type Gossip interface {
 	SelfMembershipInfo() discovery.NetworkMember
 
 	// SelfChannelInfo returns the peer's latest StateInfo message of a given channel
-	SelfChannelInfo(common.ChainID) *proto.SignedGossipMessage
+	SelfChannelInfo(common.ChainID) *protoext.SignedGossipMessage
 
 	// Send sends a message to remote peers
 	Send(msg *proto.GossipMessage, peers ...*comm.RemotePeer)
 
 	// SendByCriteria sends a given message to all peers that match the given SendCriteria
-	SendByCriteria(*proto.SignedGossipMessage, SendCriteria) error
+	SendByCriteria(*protoext.SignedGossipMessage, SendCriteria) error
 
 	// GetPeers returns the NetworkMembers considered alive
 	Peers() []discovery.NetworkMember
@@ -63,7 +64,7 @@ type Gossip interface {
 	// If passThrough is false, the messages are processed by the gossip layer beforehand.
 	// If passThrough is true, the gossip layer doesn't intervene and the messages
 	// can be used to send a reply back to the sender
-	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 
 	// JoinChan makes the Gossip instance join a channel
 	JoinChan(joinMsg api.JoinChannelMessage, chainID common.ChainID)
@@ -88,7 +89,7 @@ type Gossip interface {
 // emittedGossipMessage encapsulates signed gossip message to compose
 // with routing filter to be used while message is forwarded
 type emittedGossipMessage struct {
-	*proto.SignedGossipMessage
+	*protoext.SignedGossipMessage
 	filter func(id common.PKIidType) bool
 }
 
diff --git a/gossip/gossip/gossip_impl.go b/gossip/gossip/gossip_impl.go
index 8c4e35ac0..a02f11434 100644
--- a/gossip/gossip/gossip_impl.go
+++ b/gossip/gossip/gossip_impl.go
@@ -27,6 +27,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/pull"
 	"github.com/hyperledger/fabric/gossip/identity"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -147,7 +148,7 @@ func NewGossipService(conf *Config, s *grpc.Server, sa api.SecurityAdvisor,
 }
 
 func (g *gossipServiceImpl) newStateInfoMsgStore() msgstore.MessageStore {
-	pol := proto.NewGossipMessageComparator(0)
+	pol := protoext.NewGossipMessageComparator(0)
 	return msgstore.NewMessageStoreExpirable(pol,
 		msgstore.Noop,
 		g.conf.PublishStateInfoInterval*100,
@@ -301,14 +302,14 @@ func (g *gossipServiceImpl) start() {
 	go g.handlePresumedDead()
 
 	msgSelector := func(msg interface{}) bool {
-		gMsg, isGossipMsg := msg.(proto.ReceivedMessage)
+		gMsg, isGossipMsg := msg.(protoext.ReceivedMessage)
 		if !isGossipMsg {
 			return false
 		}
 
 		isConn := gMsg.GetGossipMessage().GetConn() != nil
 		isEmpty := gMsg.GetGossipMessage().GetEmpty() != nil
-		isPrivateData := gMsg.GetGossipMessage().IsPrivateDataMsg()
+		isPrivateData := protoext.IsPrivateDataMsg(gMsg.GetGossipMessage().GossipMessage)
 
 		return !(isConn || isEmpty || isPrivateData)
 	}
@@ -320,7 +321,7 @@ func (g *gossipServiceImpl) start() {
 	g.logger.Info("Gossip instance", g.conf.ID, "started")
 }
 
-func (g *gossipServiceImpl) acceptMessages(incMsgs <-chan proto.ReceivedMessage) {
+func (g *gossipServiceImpl) acceptMessages(incMsgs <-chan protoext.ReceivedMessage) {
 	defer g.logger.Debug("Exiting")
 	defer g.stopSignal.Done()
 	for {
@@ -334,7 +335,7 @@ func (g *gossipServiceImpl) acceptMessages(incMsgs <-chan proto.ReceivedMessage)
 	}
 }
 
-func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
+func (g *gossipServiceImpl) handleMessage(m protoext.ReceivedMessage) {
 	if g.toDie() {
 		return
 	}
@@ -353,11 +354,11 @@ func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
 		return
 	}
 
-	if msg.IsChannelRestricted() {
+	if protoext.IsChannelRestricted(msg.GossipMessage) {
 		if gc := g.chanState.lookupChannelForMsg(m); gc == nil {
 			// If we're not in the channel, we should still forward to peers of our org
 			// in case it's a StateInfo message
-			if g.isInMyorg(discovery.NetworkMember{PKIid: m.GetConnectionInfo().ID}) && msg.IsStateInfoMsg() {
+			if g.isInMyorg(discovery.NetworkMember{PKIid: m.GetConnectionInfo().ID}) && protoext.IsStateInfoMsg(msg.GossipMessage) {
 				if g.stateInfoMsgStore.Add(msg) {
 					g.emitter.Add(&emittedGossipMessage{
 						SignedGossipMessage: msg,
@@ -369,7 +370,7 @@ func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
 				g.logger.Debug("No such channel", msg.Channel, "discarding message", msg)
 			}
 		} else {
-			if m.GetGossipMessage().IsLeadershipMsg() {
+			if protoext.IsLeadershipMsg(m.GetGossipMessage().GossipMessage) {
 				if err := g.validateLeadershipMessage(m.GetGossipMessage()); err != nil {
 					g.logger.Warningf("Failed validating LeaderElection message: %+v", errors.WithStack(err))
 					return
@@ -384,12 +385,12 @@ func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
 		// It's a membership request, check its self information
 		// matches the sender
 		if m.GetGossipMessage().GetMemReq() != nil {
-			sMsg, err := m.GetGossipMessage().GetMemReq().SelfInformation.ToGossipMessage()
+			sMsg, err := protoext.EnvelopeToGossipMessage(m.GetGossipMessage().GetMemReq().SelfInformation)
 			if err != nil {
 				g.logger.Warningf("Got membership request with invalid selfInfo: %+v", errors.WithStack(err))
 				return
 			}
-			if !sMsg.IsAliveMsg() {
+			if !protoext.IsAliveMsg(sMsg.GossipMessage) {
 				g.logger.Warning("Got membership request with selfInfo that isn't an AliveMessage")
 				return
 			}
@@ -401,12 +402,12 @@ func (g *gossipServiceImpl) handleMessage(m proto.ReceivedMessage) {
 		g.forwardDiscoveryMsg(m)
 	}
 
-	if msg.IsPullMsg() && msg.GetPullMsgType() == proto.PullMsgType_IDENTITY_MSG {
+	if protoext.IsPullMsg(msg.GossipMessage) && protoext.GetPullMsgType(msg.GossipMessage) == proto.PullMsgType_IDENTITY_MSG {
 		g.certStore.handleMessage(m)
 	}
 }
 
-func (g *gossipServiceImpl) forwardDiscoveryMsg(msg proto.ReceivedMessage) {
+func (g *gossipServiceImpl) forwardDiscoveryMsg(msg protoext.ReceivedMessage) {
 	defer func() { // can be closed while shutting down
 		recover()
 	}()
@@ -416,13 +417,13 @@ func (g *gossipServiceImpl) forwardDiscoveryMsg(msg proto.ReceivedMessage) {
 
 // validateMsg checks the signature of the message if exists,
 // and also checks that the tag matches the message type
-func (g *gossipServiceImpl) validateMsg(msg proto.ReceivedMessage) bool {
-	if err := msg.GetGossipMessage().IsTagLegal(); err != nil {
+func (g *gossipServiceImpl) validateMsg(msg protoext.ReceivedMessage) bool {
+	if err := protoext.IsTagLegal(msg.GetGossipMessage().GossipMessage); err != nil {
 		g.logger.Warningf("Tag of %v isn't legal: %v", msg.GetGossipMessage(), errors.WithStack(err))
 		return false
 	}
 
-	if msg.GetGossipMessage().IsStateInfoMsg() {
+	if protoext.IsStateInfoMsg(msg.GetGossipMessage().GossipMessage) {
 		if err := g.validateStateInfoMsg(msg.GetGossipMessage()); err != nil {
 			g.logger.Warningf("StateInfo message %v is found invalid: %v", msg, err)
 			return false
@@ -463,24 +464,24 @@ func (g *gossipServiceImpl) gossipBatch(msgs []*emittedGossipMessage) {
 	var leadershipMsgs []*emittedGossipMessage
 
 	isABlock := func(o interface{}) bool {
-		return o.(*emittedGossipMessage).IsDataMsg()
+		return protoext.IsDataMsg(o.(*emittedGossipMessage).GossipMessage)
 	}
 	isAStateInfoMsg := func(o interface{}) bool {
-		return o.(*emittedGossipMessage).IsStateInfoMsg()
+		return protoext.IsStateInfoMsg(o.(*emittedGossipMessage).GossipMessage)
 	}
 	aliveMsgsWithNoEndpointAndInOurOrg := func(o interface{}) bool {
 		msg := o.(*emittedGossipMessage)
-		if !msg.IsAliveMsg() {
+		if !protoext.IsAliveMsg(msg.GossipMessage) {
 			return false
 		}
 		member := msg.GetAliveMsg().Membership
 		return member.Endpoint == "" && g.isInMyorg(discovery.NetworkMember{PKIid: member.PkiId})
 	}
 	isOrgRestricted := func(o interface{}) bool {
-		return aliveMsgsWithNoEndpointAndInOurOrg(o) || o.(*emittedGossipMessage).IsOrgRestricted()
+		return aliveMsgsWithNoEndpointAndInOurOrg(o) || protoext.IsOrgRestricted(o.(*emittedGossipMessage).GossipMessage)
 	}
 	isLeadershipMsg := func(o interface{}) bool {
-		return o.(*emittedGossipMessage).IsLeadershipMsg()
+		return protoext.IsLeadershipMsg(o.(*emittedGossipMessage).GossipMessage)
 	}
 
 	// Gossip blocks
@@ -521,7 +522,7 @@ func (g *gossipServiceImpl) gossipBatch(msgs []*emittedGossipMessage) {
 
 	// Finally, gossip the remaining messages
 	for _, msg := range msgs {
-		if !msg.IsAliveMsg() {
+		if !protoext.IsAliveMsg(msg.GossipMessage) {
 			g.logger.Error("Unknown message type", msg)
 			continue
 		}
@@ -534,11 +535,11 @@ func (g *gossipServiceImpl) gossipBatch(msgs []*emittedGossipMessage) {
 	}
 }
 
-func (g *gossipServiceImpl) sendAndFilterSecrets(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (g *gossipServiceImpl) sendAndFilterSecrets(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	for _, peer := range peers {
 		// Prevent forwarding alive messages of external organizations
 		// to peers that have no external endpoints
-		aliveMsgFromDiffOrg := msg.IsAliveMsg() && !g.isInMyorg(discovery.NetworkMember{PKIid: msg.GetAliveMsg().Membership.PkiId})
+		aliveMsgFromDiffOrg := protoext.IsAliveMsg(msg.GossipMessage) && !g.isInMyorg(discovery.NetworkMember{PKIid: msg.GetAliveMsg().Membership.PkiId})
 		if aliveMsgFromDiffOrg && !g.hasExternalEndpoint(peer.PKIID) {
 			continue
 		}
@@ -580,7 +581,7 @@ func (g *gossipServiceImpl) gossipInChan(messages []*emittedGossipMessage, chanR
 		// For leadership messages we will select all peers that pass routing factory - e.g. all peers in channel and org
 		membership := g.disc.GetMembership()
 		var peers2Send []*comm.RemotePeer
-		if messagesOfChannel[0].IsLeadershipMsg() {
+		if protoext.IsLeadershipMsg(messagesOfChannel[0].GossipMessage) {
 			peers2Send = filter.SelectPeers(len(membership), membership, chanRoutingFactory(gc))
 		} else {
 			peers2Send = filter.SelectPeers(g.conf.PropagatePeerNum, membership, chanRoutingFactory(gc))
@@ -611,7 +612,7 @@ func (g *gossipServiceImpl) IdentityInfo() api.PeerIdentitySet {
 }
 
 // SendByCriteria sends a given message to all peers that match the given SendCriteria
-func (g *gossipServiceImpl) SendByCriteria(msg *proto.SignedGossipMessage, criteria SendCriteria) error {
+func (g *gossipServiceImpl) SendByCriteria(msg *protoext.SignedGossipMessage, criteria SendCriteria) error {
 	if criteria.MaxPeers == 0 {
 		return nil
 	}
@@ -657,17 +658,17 @@ func (g *gossipServiceImpl) SendByCriteria(msg *proto.SignedGossipMessage, crite
 func (g *gossipServiceImpl) Gossip(msg *proto.GossipMessage) {
 	// Educate developers to Gossip messages with the right tags.
 	// See IsTagLegal() for wanted behavior.
-	if err := msg.IsTagLegal(); err != nil {
+	if err := protoext.IsTagLegal(msg); err != nil {
 		panic(errors.WithStack(err))
 	}
 
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: msg,
 	}
 
 	var err error
-	if sMsg.IsDataMsg() {
-		sMsg, err = sMsg.NoopSign()
+	if protoext.IsDataMsg(sMsg.GossipMessage) {
+		sMsg, err = protoext.NoopSign(sMsg.GossipMessage)
 	} else {
 		_, err = sMsg.Sign(func(msg []byte) ([]byte, error) {
 			return g.mcs.Sign(msg)
@@ -679,13 +680,13 @@ func (g *gossipServiceImpl) Gossip(msg *proto.GossipMessage) {
 		return
 	}
 
-	if msg.IsChannelRestricted() {
+	if protoext.IsChannelRestricted(msg) {
 		gc := g.chanState.getGossipChannelByChainID(msg.Channel)
 		if gc == nil {
 			g.logger.Warning("Failed obtaining gossipChannel of", msg.Channel, "aborting")
 			return
 		}
-		if msg.IsDataMsg() {
+		if protoext.IsDataMsg(msg) {
 			gc.AddToMsgStore(sMsg)
 		}
 	}
@@ -703,7 +704,7 @@ func (g *gossipServiceImpl) Gossip(msg *proto.GossipMessage) {
 
 // Send sends a message to remote peers
 func (g *gossipServiceImpl) Send(msg *proto.GossipMessage, peers ...*comm.RemotePeer) {
-	m, err := msg.NoopSign()
+	m, err := protoext.NoopSign(msg)
 	if err != nil {
 		g.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -734,7 +735,7 @@ func (g *gossipServiceImpl) SelfMembershipInfo() discovery.NetworkMember {
 }
 
 // SelfChannelInfo returns the peer's latest StateInfo message of a given channel
-func (g *gossipServiceImpl) SelfChannelInfo(chain common.ChainID) *proto.SignedGossipMessage {
+func (g *gossipServiceImpl) SelfChannelInfo(chain common.ChainID) *protoext.SignedGossipMessage {
 	ch := g.chanState.getGossipChannelByChainID(chain)
 	if ch == nil {
 		return nil
@@ -801,7 +802,7 @@ func (g *gossipServiceImpl) UpdateChaincodes(chaincodes []*proto.Chaincode, chai
 // If passThrough is false, the messages are processed by the gossip layer beforehand.
 // If passThrough is true, the gossip layer doesn't intervene and the messages
 // can be used to send a reply back to the sender
-func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	if passThrough {
 		return nil, g.comm.Accept(acceptor)
 	}
@@ -809,7 +810,7 @@ func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough
 		if o, isGossipMsg := o.(*proto.GossipMessage); isGossipMsg {
 			return acceptor(o)
 		}
-		if o, isSignedMsg := o.(*proto.SignedGossipMessage); isSignedMsg {
+		if o, isSignedMsg := o.(*protoext.SignedGossipMessage); isSignedMsg {
 			sMsg := o
 			return acceptor(sMsg.GossipMessage)
 		}
@@ -828,7 +829,7 @@ func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough
 				if m == nil {
 					return
 				}
-				outCh <- m.(*proto.SignedGossipMessage).GossipMessage
+				outCh <- m.(*protoext.SignedGossipMessage).GossipMessage
 			}
 		}
 	}()
@@ -836,7 +837,7 @@ func (g *gossipServiceImpl) Accept(acceptor common.MessageAcceptor, passThrough
 }
 
 func selectOnlyDiscoveryMessages(m interface{}) bool {
-	msg, isGossipMsg := m.(proto.ReceivedMessage)
+	msg, isGossipMsg := m.(protoext.ReceivedMessage)
 	if !isGossipMsg {
 		return false
 	}
@@ -853,7 +854,7 @@ func (g *gossipServiceImpl) newDiscoveryAdapter() *discoveryAdapter {
 	return &discoveryAdapter{
 		c:        g.comm,
 		stopping: int32(0),
-		gossipFunc: func(msg *proto.SignedGossipMessage) {
+		gossipFunc: func(msg *protoext.SignedGossipMessage) {
 			if g.conf.PropagateIterations == 0 {
 				return
 			}
@@ -864,7 +865,7 @@ func (g *gossipServiceImpl) newDiscoveryAdapter() *discoveryAdapter {
 				},
 			})
 		},
-		forwardFunc: func(message proto.ReceivedMessage) {
+		forwardFunc: func(message protoext.ReceivedMessage) {
 			if g.conf.PropagateIterations == 0 {
 				return
 			}
@@ -873,7 +874,7 @@ func (g *gossipServiceImpl) newDiscoveryAdapter() *discoveryAdapter {
 				filter:              message.GetConnectionInfo().ID.IsNotSameFilter,
 			})
 		},
-		incChan:          make(chan proto.ReceivedMessage),
+		incChan:          make(chan protoext.ReceivedMessage),
 		presumedDead:     g.presumedDead,
 		disclosurePolicy: g.disclosurePolicy,
 	}
@@ -885,9 +886,9 @@ type discoveryAdapter struct {
 	stopping         int32
 	c                comm.Comm
 	presumedDead     chan common.PKIidType
-	incChan          chan proto.ReceivedMessage
-	gossipFunc       func(message *proto.SignedGossipMessage)
-	forwardFunc      func(message proto.ReceivedMessage)
+	incChan          chan protoext.ReceivedMessage
+	gossipFunc       func(message *protoext.SignedGossipMessage)
+	forwardFunc      func(message protoext.ReceivedMessage)
 	disclosurePolicy discovery.DisclosurePolicy
 }
 
@@ -900,7 +901,7 @@ func (da *discoveryAdapter) toDie() bool {
 	return atomic.LoadInt32(&da.stopping) == int32(1)
 }
 
-func (da *discoveryAdapter) Gossip(msg *proto.SignedGossipMessage) {
+func (da *discoveryAdapter) Gossip(msg *protoext.SignedGossipMessage) {
 	if da.toDie() {
 		return
 	}
@@ -908,7 +909,7 @@ func (da *discoveryAdapter) Gossip(msg *proto.SignedGossipMessage) {
 	da.gossipFunc(msg)
 }
 
-func (da *discoveryAdapter) Forward(msg proto.ReceivedMessage) {
+func (da *discoveryAdapter) Forward(msg protoext.ReceivedMessage) {
 	if da.toDie() {
 		return
 	}
@@ -916,14 +917,14 @@ func (da *discoveryAdapter) Forward(msg proto.ReceivedMessage) {
 	da.forwardFunc(msg)
 }
 
-func (da *discoveryAdapter) SendToPeer(peer *discovery.NetworkMember, msg *proto.SignedGossipMessage) {
+func (da *discoveryAdapter) SendToPeer(peer *discovery.NetworkMember, msg *protoext.SignedGossipMessage) {
 	if da.toDie() {
 		return
 	}
 	// Check membership requests for peers that we know of their PKI-ID.
 	// The only peers we don't know about their PKI-IDs are bootstrap peers.
 	if memReq := msg.GetMemReq(); memReq != nil && len(peer.PKIid) != 0 {
-		selfMsg, err := memReq.SelfInformation.ToGossipMessage()
+		selfMsg, err := protoext.EnvelopeToGossipMessage(memReq.SelfInformation)
 		if err != nil {
 			// Shouldn't happen
 			panic(errors.Wrapf(err, "Tried to send a membership request with a malformed AliveMessage"))
@@ -946,9 +947,7 @@ func (da *discoveryAdapter) SendToPeer(peer *discovery.NetworkMember, msg *proto
 			MemReq: memReq,
 		}
 		// Update the envelope of the outer message, no need to sign (point2point)
-		msg, err = (&proto.SignedGossipMessage{
-			GossipMessage: msgCopy,
-		}).NoopSign()
+		msg, err = protoext.NoopSign(msgCopy)
 
 		if err != nil {
 			return
@@ -964,7 +963,7 @@ func (da *discoveryAdapter) Ping(peer *discovery.NetworkMember) bool {
 	return err == nil
 }
 
-func (da *discoveryAdapter) Accept() <-chan proto.ReceivedMessage {
+func (da *discoveryAdapter) Accept() <-chan protoext.ReceivedMessage {
 	return da.incChan
 }
 
@@ -999,7 +998,7 @@ func (g *gossipServiceImpl) newDiscoverySecurityAdapter() *discoverySecurityAdap
 }
 
 // validateAliveMsg validates that an Alive message is authentic
-func (sa *discoverySecurityAdapter) ValidateAliveMsg(m *proto.SignedGossipMessage) bool {
+func (sa *discoverySecurityAdapter) ValidateAliveMsg(m *protoext.SignedGossipMessage) bool {
 	am := m.GetAliveMsg()
 	if am == nil || am.Membership == nil || am.Membership.PkiId == nil || !m.IsSigned() {
 		sa.logger.Warning("Invalid alive message:", m)
@@ -1037,10 +1036,10 @@ func (sa *discoverySecurityAdapter) SignMessage(m *proto.GossipMessage, internal
 	signer := func(msg []byte) ([]byte, error) {
 		return sa.mcs.Sign(msg)
 	}
-	if m.IsAliveMsg() && time.Now().Before(sa.includeIdentityPeriod) {
+	if protoext.IsAliveMsg(m) && time.Now().Before(sa.includeIdentityPeriod) {
 		m.GetAliveMsg().Identity = sa.identity
 	}
-	sMsg := &proto.SignedGossipMessage{
+	sMsg := &protoext.SignedGossipMessage{
 		GossipMessage: m,
 	}
 	e, err := sMsg.Sign(signer)
@@ -1052,7 +1051,7 @@ func (sa *discoverySecurityAdapter) SignMessage(m *proto.GossipMessage, internal
 	if internalEndpoint == "" {
 		return e
 	}
-	e.SignSecret(signer, &proto.Secret{
+	protoext.SignSecret(e, signer, &proto.Secret{
 		Content: &proto.Secret_InternalEndpoint{
 			InternalEndpoint: internalEndpoint,
 		},
@@ -1060,7 +1059,7 @@ func (sa *discoverySecurityAdapter) SignMessage(m *proto.GossipMessage, internal
 	return e
 }
 
-func (sa *discoverySecurityAdapter) validateAliveMsgSignature(m *proto.SignedGossipMessage, identity api.PeerIdentityType) bool {
+func (sa *discoverySecurityAdapter) validateAliveMsgSignature(m *protoext.SignedGossipMessage, identity api.PeerIdentityType) bool {
 	am := m.GetAliveMsg()
 	// At this point we got the certificate of the peer, proceed to verifying the AliveMessage
 	verifier := func(peerIdentity []byte, signature, message []byte) error {
@@ -1091,14 +1090,14 @@ func (g *gossipServiceImpl) createCertStorePuller() pull.Mediator {
 			ResponseWaitTime: g.conf.ResponseWaitTime,
 		},
 	}
-	pkiIDFromMsg := func(msg *proto.SignedGossipMessage) string {
+	pkiIDFromMsg := func(msg *protoext.SignedGossipMessage) string {
 		identityMsg := msg.GetPeerIdentity()
 		if identityMsg == nil || identityMsg.PkiId == nil {
 			return ""
 		}
 		return fmt.Sprintf("%s", string(identityMsg.PkiId))
 	}
-	certConsumer := func(msg *proto.SignedGossipMessage) {
+	certConsumer := func(msg *protoext.SignedGossipMessage) {
 		idMsg := msg.GetPeerIdentity()
 		if idMsg == nil || idMsg.Cert == nil || idMsg.PkiId == nil {
 			g.logger.Warning("Invalid PeerIdentity:", idMsg)
@@ -1120,7 +1119,7 @@ func (g *gossipServiceImpl) createCertStorePuller() pull.Mediator {
 	return pull.NewPullMediator(conf, adapter)
 }
 
-func (g *gossipServiceImpl) sameOrgOrOurOrgPullFilter(msg proto.ReceivedMessage) func(string) bool {
+func (g *gossipServiceImpl) sameOrgOrOurOrgPullFilter(msg protoext.ReceivedMessage) func(string) bool {
 	peersOrg := g.secAdvisor.OrgByPeerIdentity(msg.GetConnectionInfo().Identity)
 	if len(peersOrg) == 0 {
 		g.logger.Warning("Failed determining organization of", msg.GetConnectionInfo())
@@ -1205,7 +1204,7 @@ func (g *gossipServiceImpl) getOrgOfPeer(PKIID common.PKIidType) api.OrgIdentity
 	return g.secAdvisor.OrgByPeerIdentity(cert)
 }
 
-func (g *gossipServiceImpl) validateLeadershipMessage(msg *proto.SignedGossipMessage) error {
+func (g *gossipServiceImpl) validateLeadershipMessage(msg *protoext.SignedGossipMessage) error {
 	pkiID := msg.GetLeadershipMsg().PkiId
 	if len(pkiID) == 0 {
 		return errors.New("Empty PKI-ID")
@@ -1219,7 +1218,7 @@ func (g *gossipServiceImpl) validateLeadershipMessage(msg *proto.SignedGossipMes
 	})
 }
 
-func (g *gossipServiceImpl) validateStateInfoMsg(msg *proto.SignedGossipMessage) error {
+func (g *gossipServiceImpl) validateStateInfoMsg(msg *protoext.SignedGossipMessage) error {
 	verifier := func(identity []byte, signature, message []byte) error {
 		pkiID := g.idMapper.GetPKIidOfCert(api.PeerIdentityType(identity))
 		if pkiID == nil {
@@ -1239,15 +1238,15 @@ func (g *gossipServiceImpl) disclosurePolicy(remotePeer *discovery.NetworkMember
 
 	if len(remotePeerOrg) == 0 {
 		g.logger.Warning("Cannot determine organization of", remotePeer)
-		return func(msg *proto.SignedGossipMessage) bool {
+		return func(msg *protoext.SignedGossipMessage) bool {
 				return false
-			}, func(msg *proto.SignedGossipMessage) *proto.Envelope {
+			}, func(msg *protoext.SignedGossipMessage) *proto.Envelope {
 				return msg.Envelope
 			}
 	}
 
-	return func(msg *proto.SignedGossipMessage) bool {
-			if !msg.IsAliveMsg() {
+	return func(msg *protoext.SignedGossipMessage) bool {
+			if !protoext.IsAliveMsg(msg.GossipMessage) {
 				g.logger.Panic("Programming error, this should be used only on alive messages")
 			}
 			org := g.getOrgOfPeer(msg.GetAliveMsg().Membership.PkiId)
@@ -1269,7 +1268,7 @@ func (g *gossipServiceImpl) disclosurePolicy(remotePeer *discovery.NetworkMember
 			// Pass the alive message only if the alive message is in the same org as the remote peer
 			// or the message has an external endpoint, and the remote peer also has one
 			return bytes.Equal(org, remotePeerOrg) || msg.GetAliveMsg().Membership.Endpoint != "" && remotePeer.Endpoint != ""
-		}, func(msg *proto.SignedGossipMessage) *proto.Envelope {
+		}, func(msg *protoext.SignedGossipMessage) *proto.Envelope {
 			envelope := protoG.Clone(msg.Envelope).(*proto.Envelope)
 			if !bytes.Equal(g.selfOrg, remotePeerOrg) {
 				envelope.SecretEnvelope = nil
diff --git a/gossip/gossip/gossip_test.go b/gossip/gossip/gossip_test.go
index f2a622939..cdc4c3ae9 100644
--- a/gossip/gossip/gossip_test.go
+++ b/gossip/gossip/gossip_test.go
@@ -31,6 +31,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/channel"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -90,7 +91,7 @@ func acceptData(m interface{}) bool {
 
 func acceptLeadershp(message interface{}) bool {
 	validMsg := message.(*proto.GossipMessage).Tag == proto.GossipMessage_CHAN_AND_ORG &&
-		message.(*proto.GossipMessage).IsLeadershipMsg()
+		protoext.IsLeadershipMsg(message.(*proto.GossipMessage))
 
 	return validMsg
 }
@@ -676,7 +677,7 @@ func TestNoMessagesSelfLoop(t *testing.T) {
 	// Wait until both peers get connected
 	waitUntilOrFail(t, checkPeersMembership(t, []Gossip{peer}, 1))
 	_, commCh := boot.Accept(func(msg interface{}) bool {
-		return msg.(proto.ReceivedMessage).GetGossipMessage().IsDataMsg()
+		return protoext.IsDataMsg(msg.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}, true)
 
 	wg := sync.WaitGroup{}
@@ -684,13 +685,13 @@ func TestNoMessagesSelfLoop(t *testing.T) {
 
 	// Make sure sending peer is not getting his own
 	// message back
-	go func(ch <-chan proto.ReceivedMessage) {
+	go func(ch <-chan protoext.ReceivedMessage) {
 		defer wg.Done()
 		for {
 			select {
 			case msg := <-ch:
 				{
-					if msg.GetGossipMessage().IsDataMsg() {
+					if protoext.IsDataMsg(msg.GetGossipMessage().GossipMessage) {
 						t.Fatal("Should not receive data message back, got", msg)
 					}
 				}
@@ -986,27 +987,27 @@ func TestMembershipRequestSpoofing(t *testing.T) {
 	waitUntilOrFail(t, checkPeersMembership(t, []Gossip{g2, g3}, 1))
 	// Obtain an alive message from p3
 	_, aliveMsgChan := g2.Accept(func(o interface{}) bool {
-		msg := o.(proto.ReceivedMessage).GetGossipMessage()
+		msg := o.(protoext.ReceivedMessage).GetGossipMessage()
 		// Make sure we get an AliveMessage and it's about g3
-		return msg.IsAliveMsg() && bytes.Equal(msg.GetAliveMsg().Membership.PkiId, []byte(endpoint2))
+		return protoext.IsAliveMsg(msg.GossipMessage) && bytes.Equal(msg.GetAliveMsg().Membership.PkiId, []byte(endpoint2))
 	}, true)
 	aliveMsg := <-aliveMsgChan
 
 	// Obtain channel for messages from g1 to g2
 	_, g1ToG2 := g2.Accept(func(o interface{}) bool {
-		connInfo := o.(proto.ReceivedMessage).GetConnectionInfo()
+		connInfo := o.(protoext.ReceivedMessage).GetConnectionInfo()
 		return bytes.Equal([]byte(endpoint0), connInfo.ID)
 	}, true)
 
 	// Obtain channel for messages from g1 to g3
 	_, g1ToG3 := g3.Accept(func(o interface{}) bool {
-		connInfo := o.(proto.ReceivedMessage).GetConnectionInfo()
+		connInfo := o.(protoext.ReceivedMessage).GetConnectionInfo()
 		return bytes.Equal([]byte(endpoint0), connInfo.ID)
 	}, true)
 
 	// Now, create a membership request message
-	memRequestSpoofFactory := func(aliveMsgEnv *proto.Envelope) *proto.SignedGossipMessage {
-		sMsg, _ := (&proto.GossipMessage{
+	memRequestSpoofFactory := func(aliveMsgEnv *proto.Envelope) *protoext.SignedGossipMessage {
+		sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 			Tag:   proto.GossipMessage_EMPTY,
 			Nonce: uint64(0),
 			Content: &proto.GossipMessage_MemReq{
@@ -1015,7 +1016,7 @@ func TestMembershipRequestSpoofing(t *testing.T) {
 					Known:           [][]byte{},
 				},
 			},
-		}).NoopSign()
+		})
 		return sMsg
 	}
 	spoofedMemReq := memRequestSpoofFactory(aliveMsg.GetSourceEnvelope())
@@ -1278,7 +1279,7 @@ func TestSendByCriteria(t *testing.T) {
 		p.UpdateLedgerHeight(1, common.ChainID("A"))
 	}
 	defer stopPeers(peers)
-	msg, _ := createDataMsg(1, []byte{}, common.ChainID("A")).NoopSign()
+	msg, _ := protoext.NoopSign(createDataMsg(1, []byte{}, common.ChainID("A")))
 
 	// We send without specifying maximum peers,
 	// which sets it to the zero value, and
@@ -1335,12 +1336,12 @@ func TestSendByCriteria(t *testing.T) {
 	// We retry the test above, but this time the peers acknowledge
 	// Peers now ack
 	acceptDataMsgs := func(m interface{}) bool {
-		return m.(proto.ReceivedMessage).GetGossipMessage().IsDataMsg()
+		return protoext.IsDataMsg(m.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}
 	_, ackChan2 := g2.Accept(acceptDataMsgs, true)
 	_, ackChan3 := g3.Accept(acceptDataMsgs, true)
 	_, ackChan4 := g4.Accept(acceptDataMsgs, true)
-	ack := func(c <-chan proto.ReceivedMessage) {
+	ack := func(c <-chan protoext.ReceivedMessage) {
 		msg := <-c
 		msg.Ack(nil)
 	}
@@ -1352,7 +1353,7 @@ func TestSendByCriteria(t *testing.T) {
 	assert.NoError(t, err)
 
 	// We send to 3 peers, but 2 out of 3 peers acknowledge with an error
-	nack := func(c <-chan proto.ReceivedMessage) {
+	nack := func(c <-chan protoext.ReceivedMessage) {
 		msg := <-c
 		msg.Ack(fmt.Errorf("uh oh"))
 	}
@@ -1366,7 +1367,7 @@ func TestSendByCriteria(t *testing.T) {
 	// We try to send to either g2 or g3, but neither would ack us, so we would fail.
 	// However - what we actually check in this test is that we send to peers according to the
 	// filter passed in the criteria
-	failOnAckRequest := func(c <-chan proto.ReceivedMessage, peerId int) {
+	failOnAckRequest := func(c <-chan protoext.ReceivedMessage, peerId int) {
 		msg := <-c
 		if msg == nil {
 			return
@@ -1392,7 +1393,7 @@ func TestSendByCriteria(t *testing.T) {
 	// this property is respected - and only 1 peer receives a message, and not both
 	criteria.MaxPeers = 1
 	// invoke f() in case message has been received
-	waitForMessage := func(c <-chan proto.ReceivedMessage, f func()) {
+	waitForMessage := func(c <-chan protoext.ReceivedMessage, f func()) {
 		select {
 		case msg := <-c:
 			if msg == nil {
diff --git a/gossip/gossip/orgs_test.go b/gossip/gossip/orgs_test.go
index c48a85c5d..a0d636be0 100644
--- a/gossip/gossip/orgs_test.go
+++ b/gossip/gossip/orgs_test.go
@@ -23,6 +23,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/gossip/algo"
 	"github.com/hyperledger/fabric/gossip/gossip/channel"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -397,9 +398,9 @@ func TestConfidentiality(t *testing.T) {
 	var wg sync.WaitGroup
 
 	msgSelector := func(o interface{}) bool {
-		msg := o.(proto.ReceivedMessage).GetGossipMessage()
-		identitiesPull := msg.IsPullMsg() && msg.GetPullMsgType() == proto.PullMsgType_IDENTITY_MSG
-		return msg.IsAliveMsg() || msg.IsStateInfoMsg() || msg.IsStateInfoSnapshot() || msg.GetMemRes() != nil || identitiesPull
+		msg := o.(protoext.ReceivedMessage).GetGossipMessage()
+		identitiesPull := protoext.IsPullMsg(msg.GossipMessage) && protoext.GetPullMsgType(msg.GossipMessage) == proto.PullMsgType_IDENTITY_MSG
+		return protoext.IsAliveMsg(msg.GossipMessage) || protoext.IsStateInfoMsg(msg.GossipMessage) || protoext.IsStateInfoSnapshot(msg.GossipMessage) || msg.GetMemRes() != nil || identitiesPull
 	}
 	// Listen to all peers membership messages and forward them to the inspection channel
 	// where they will be inspected, and the test would fail if a confidentiality violation is found
@@ -408,7 +409,7 @@ func TestConfidentiality(t *testing.T) {
 		_, msgs := p.Accept(msgSelector, true)
 		peerNetMember := p.(*gossipGRPC).gossipServiceImpl.selfNetworkMember()
 		targetORg := string(cs.OrgByPeerIdentity(api.PeerIdentityType(peerNetMember.InternalEndpoint)))
-		go func(targetOrg string, msgs <-chan proto.ReceivedMessage) {
+		go func(targetOrg string, msgs <-chan protoext.ReceivedMessage) {
 			defer wg.Done()
 			for receivedMsg := range msgs {
 				m := &msg{
@@ -517,16 +518,16 @@ func expectedMembershipSize(peersInOrg, externalEndpointsInOrg int, org string,
 }
 
 func extractOrgsFromMsg(msg *proto.GossipMessage, sec api.SecurityAdvisor) []string {
-	if msg.IsAliveMsg() {
+	if protoext.IsAliveMsg(msg) {
 		return []string{string(sec.OrgByPeerIdentity(api.PeerIdentityType(msg.GetAliveMsg().Membership.PkiId)))}
 	}
 
 	orgs := map[string]struct{}{}
 
-	if msg.IsPullMsg() {
-		if msg.IsDigestMsg() || msg.IsDataReq() {
+	if protoext.IsPullMsg(msg) {
+		if protoext.IsDigestMsg(msg) || protoext.IsDataReq(msg) {
 			var digests []string
-			if msg.IsDigestMsg() {
+			if protoext.IsDigestMsg(msg) {
 				digests = util.BytesToStrings(msg.GetDataDig().Digests)
 			} else {
 				digests = util.BytesToStrings(msg.GetDataReq().Digests)
@@ -538,9 +539,9 @@ func extractOrgsFromMsg(msg *proto.GossipMessage, sec api.SecurityAdvisor) []str
 			}
 		}
 
-		if msg.IsDataUpdate() {
+		if protoext.IsDataUpdate(msg) {
 			for _, identityMsg := range msg.GetDataUpdate().Data {
-				gMsg, _ := identityMsg.ToGossipMessage()
+				gMsg, _ := protoext.EnvelopeToGossipMessage(identityMsg)
 				id := string(gMsg.GetPeerIdentity().Cert)
 				org := sec.OrgByPeerIdentity(api.PeerIdentityType(id))
 				orgs[string(org)] = struct{}{}
@@ -552,7 +553,7 @@ func extractOrgsFromMsg(msg *proto.GossipMessage, sec api.SecurityAdvisor) []str
 		alive := msg.GetMemRes().Alive
 		dead := msg.GetMemRes().Dead
 		for _, envp := range append(alive, dead...) {
-			msg, _ := envp.ToGossipMessage()
+			msg, _ := protoext.EnvelopeToGossipMessage(envp)
 			orgs[string(sec.OrgByPeerIdentity(api.PeerIdentityType(msg.GetAliveMsg().Membership.PkiId)))] = struct{}{}
 		}
 	}
@@ -571,7 +572,7 @@ func inspectMsgs(t *testing.T, msgChan chan *msg, sec api.SecurityAdvisor, peers
 		if msg.src == msg.dst {
 			continue
 		}
-		if msg.IsStateInfoMsg() || msg.IsStateInfoSnapshot() {
+		if protoext.IsStateInfoMsg(msg.GossipMessage) || protoext.IsStateInfoSnapshot(msg.GossipMessage) {
 			inspectStateInfoMsg(t, msg, peersWithExternalEndpoints)
 			continue
 		}
@@ -594,12 +595,12 @@ func inspectMsgs(t *testing.T, msgChan chan *msg, sec api.SecurityAdvisor, peers
 
 		// If this is an identity snapshot, make sure that only identities of peers
 		// with external endpoints pass between the organizations.
-		isIdentityPull := msg.IsPullMsg() && msg.GetPullMsgType() == proto.PullMsgType_IDENTITY_MSG
-		if !(isIdentityPull && msg.IsDataUpdate()) {
+		isIdentityPull := protoext.IsPullMsg(msg.GossipMessage) && protoext.GetPullMsgType(msg.GossipMessage) == proto.PullMsgType_IDENTITY_MSG
+		if !(isIdentityPull && protoext.IsDataUpdate(msg.GossipMessage)) {
 			continue
 		}
 		for _, envp := range msg.GetDataUpdate().Data {
-			identityMsg, _ := envp.ToGossipMessage()
+			identityMsg, _ := protoext.EnvelopeToGossipMessage(envp)
 			pkiID := identityMsg.GetPeerIdentity().PkiId
 			_, hasExternalEndpoint := peersWithExternalEndpoints[string(pkiID)]
 			assert.True(t, hasExternalEndpoint,
@@ -609,7 +610,7 @@ func inspectMsgs(t *testing.T, msgChan chan *msg, sec api.SecurityAdvisor, peers
 }
 
 func inspectStateInfoMsg(t *testing.T, m *msg, peersWithExternalEndpoints map[string]struct{}) {
-	if m.IsStateInfoMsg() {
+	if protoext.IsStateInfoMsg(m.GossipMessage) {
 		pkiID := m.GetStateInfo().PkiId
 		_, hasExternalEndpoint := peersWithExternalEndpoints[string(pkiID)]
 		assert.True(t, hasExternalEndpoint, "peer %s has no external endpoint but crossed an org", string(pkiID))
@@ -617,7 +618,7 @@ func inspectStateInfoMsg(t *testing.T, m *msg, peersWithExternalEndpoints map[st
 	}
 
 	for _, envp := range m.GetStateSnapshot().Elements {
-		msg, _ := envp.ToGossipMessage()
+		msg, _ := protoext.EnvelopeToGossipMessage(envp)
 		pkiID := msg.GetStateInfo().PkiId
 		_, hasExternalEndpoint := peersWithExternalEndpoints[string(pkiID)]
 		assert.True(t, hasExternalEndpoint, "peer %s has no external endpoint but crossed an org", string(pkiID))
diff --git a/gossip/gossip/pull/pullstore.go b/gossip/gossip/pull/pullstore.go
index 64ef02f21..08cceb7d2 100644
--- a/gossip/gossip/pull/pullstore.go
+++ b/gossip/gossip/pull/pullstore.go
@@ -14,6 +14,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/gossip/algo"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/pkg/errors"
@@ -32,12 +33,12 @@ const (
 type MsgType int
 
 // MessageHook defines a function that will run after a certain pull message is received
-type MessageHook func(itemIDs []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage)
+type MessageHook func(itemIDs []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage)
 
 // Sender sends messages to remote peers
 type Sender interface {
 	// Send sends a message to a list of remote peers
-	Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer)
+	Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer)
 }
 
 // MembershipService obtains membership information of alive peers
@@ -62,13 +63,13 @@ type IngressDigestFilter func(digestMsg *proto.DataDigest) *proto.DataDigest
 
 // EgressDigestFilter filters digests to be sent to a remote peer, that
 // sent a hello with the following message
-type EgressDigestFilter func(helloMsg proto.ReceivedMessage) func(digestItem string) bool
+type EgressDigestFilter func(helloMsg protoext.ReceivedMessage) func(digestItem string) bool
 
 // byContext converts this EgressDigFilter to an algo.DigestFilter
 func (df EgressDigestFilter) byContext() algo.DigestFilter {
 	return func(context interface{}) func(digestItem string) bool {
 		return func(digestItem string) bool {
-			return df(context.(proto.ReceivedMessage))(digestItem)
+			return df(context.(protoext.ReceivedMessage))(digestItem)
 		}
 	}
 }
@@ -78,8 +79,8 @@ func (df EgressDigestFilter) byContext() algo.DigestFilter {
 type PullAdapter struct {
 	Sndr             Sender
 	MemSvc           MembershipService
-	IdExtractor      proto.IdentifierExtractor
-	MsgCons          proto.MsgConsumer
+	IdExtractor      protoext.IdentifierExtractor
+	MsgCons          protoext.MsgConsumer
 	EgressDigFilter  EgressDigestFilter
 	IngressDigFilter IngressDigestFilter
 }
@@ -98,14 +99,14 @@ type Mediator interface {
 	RegisterMsgHook(MsgType, MessageHook)
 
 	// Add adds a GossipMessage to the Mediator
-	Add(*proto.SignedGossipMessage)
+	Add(*protoext.SignedGossipMessage)
 
 	// Remove removes a GossipMessage from the Mediator with a matching digest,
 	// if such a message exits
 	Remove(digest string)
 
 	// HandleMessage handles a message from some remote peer
-	HandleMessage(msg proto.ReceivedMessage)
+	HandleMessage(msg protoext.ReceivedMessage)
 }
 
 // pullMediatorImpl is an implementation of Mediator
@@ -115,7 +116,7 @@ type pullMediatorImpl struct {
 	msgType2Hook map[MsgType][]MessageHook
 	config       Config
 	logger       util.Logger
-	itemID2Msg   map[string]*proto.SignedGossipMessage
+	itemID2Msg   map[string]*protoext.SignedGossipMessage
 	engine       *algo.PullEngine
 }
 
@@ -123,7 +124,7 @@ type pullMediatorImpl struct {
 func NewPullMediator(config Config, adapter *PullAdapter) Mediator {
 	egressDigFilter := adapter.EgressDigFilter
 
-	acceptAllFilter := func(_ proto.ReceivedMessage) func(string) bool {
+	acceptAllFilter := func(_ protoext.ReceivedMessage) func(string) bool {
 		return func(_ string) bool {
 			return true
 		}
@@ -138,7 +139,7 @@ func NewPullMediator(config Config, adapter *PullAdapter) Mediator {
 		msgType2Hook: make(map[MsgType][]MessageHook),
 		config:       config,
 		logger:       util.GetLogger(util.PullLogger, config.ID),
-		itemID2Msg:   make(map[string]*proto.SignedGossipMessage),
+		itemID2Msg:   make(map[string]*protoext.SignedGossipMessage),
 	}
 
 	p.engine = algo.NewPullEngineWithFilter(p, config.PullInterval, egressDigFilter.byContext(), config.PullEngineConfig)
@@ -153,12 +154,12 @@ func NewPullMediator(config Config, adapter *PullAdapter) Mediator {
 
 }
 
-func (p *pullMediatorImpl) HandleMessage(m proto.ReceivedMessage) {
-	if m.GetGossipMessage() == nil || !m.GetGossipMessage().IsPullMsg() {
+func (p *pullMediatorImpl) HandleMessage(m protoext.ReceivedMessage) {
+	if m.GetGossipMessage() == nil || !protoext.IsPullMsg(m.GetGossipMessage().GossipMessage) {
 		return
 	}
 	msg := m.GetGossipMessage()
-	msgType := msg.GetPullMsgType()
+	msgType := protoext.GetPullMsgType(msg.GossipMessage)
 	if msgType != p.config.MsgType {
 		return
 	}
@@ -166,7 +167,7 @@ func (p *pullMediatorImpl) HandleMessage(m proto.ReceivedMessage) {
 	p.logger.Debug(msg)
 
 	itemIDs := []string{}
-	items := []*proto.SignedGossipMessage{}
+	items := []*protoext.SignedGossipMessage{}
 	var pullMsgType MsgType
 
 	if helloMsg := msg.GetHello(); helloMsg != nil {
@@ -186,10 +187,10 @@ func (p *pullMediatorImpl) HandleMessage(m proto.ReceivedMessage) {
 	}
 	if res := msg.GetDataUpdate(); res != nil {
 		itemIDs = make([]string, len(res.Data))
-		items = make([]*proto.SignedGossipMessage, len(res.Data))
+		items = make([]*protoext.SignedGossipMessage, len(res.Data))
 		pullMsgType = ResponseMsgType
 		for i, pulledMsg := range res.Data {
-			msg, err := pulledMsg.ToGossipMessage()
+			msg, err := protoext.EnvelopeToGossipMessage(pulledMsg)
 			if err != nil {
 				p.logger.Warningf("Data update contains an invalid message: %+v", errors.WithStack(err))
 				return
@@ -224,7 +225,7 @@ func (p *pullMediatorImpl) RegisterMsgHook(pullMsgType MsgType, hook MessageHook
 }
 
 // Add adds a GossipMessage to the store
-func (p *pullMediatorImpl) Add(msg *proto.SignedGossipMessage) {
+func (p *pullMediatorImpl) Add(msg *protoext.SignedGossipMessage) {
 	p.Lock()
 	defer p.Unlock()
 	itemID := p.IdExtractor(msg)
@@ -270,7 +271,7 @@ func (p *pullMediatorImpl) Hello(dest string, nonce uint64) {
 	}
 
 	p.logger.Debug("Sending", p.config.MsgType, "hello to", dest)
-	sMsg, err := helloMsg.NoopSign()
+	sMsg, err := protoext.NoopSign(helloMsg)
 	if err != nil {
 		p.logger.Errorf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -293,12 +294,17 @@ func (p *pullMediatorImpl) SendDigest(digest []string, nonce uint64, context int
 			},
 		},
 	}
-	remotePeer := context.(proto.ReceivedMessage).GetConnectionInfo()
+	remotePeer := context.(protoext.ReceivedMessage).GetConnectionInfo()
 	if p.logger.IsEnabledFor(zapcore.DebugLevel) {
-		p.logger.Debug("Sending", p.config.MsgType, "digest:", digMsg.GetDataDig().FormattedDigests(), "to", remotePeer)
+		dr := digMsg.GetDataReq()
+		// log only if DataReq is not nil
+		if dr != nil {
+			p.logger.Debug("Sending", p.config.MsgType, "digest:", protoext.FormattedDigestsFromDataRequest(dr), "to", remotePeer)
+		}
+
 	}
 
-	context.(proto.ReceivedMessage).Respond(digMsg)
+	context.(protoext.ReceivedMessage).Respond(digMsg)
 }
 
 // SendReq sends an array of items to a certain remote PullEngine identified
@@ -317,9 +323,9 @@ func (p *pullMediatorImpl) SendReq(dest string, items []string, nonce uint64) {
 		},
 	}
 	if p.logger.IsEnabledFor(zapcore.DebugLevel) {
-		p.logger.Debug("Sending", req.GetDataReq().FormattedDigests(), "to", dest)
+		p.logger.Debug("Sending", protoext.FormattedDigestsFromDataRequest(req.GetDataReq()), "to", dest)
 	}
-	sMsg, err := req.NoopSign()
+	sMsg, err := protoext.NoopSign(req)
 	if err != nil {
 		p.logger.Warningf("Failed creating SignedGossipMessage: %+v", errors.WithStack(err))
 		return
@@ -349,9 +355,9 @@ func (p *pullMediatorImpl) SendRes(items []string, context interface{}, nonce ui
 			},
 		},
 	}
-	remotePeer := context.(proto.ReceivedMessage).GetConnectionInfo()
+	remotePeer := context.(protoext.ReceivedMessage).GetConnectionInfo()
 	p.logger.Debug("Sending", len(returnedUpdate.GetDataUpdate().Data), p.config.MsgType, "items to", remotePeer)
-	context.(proto.ReceivedMessage).Respond(returnedUpdate)
+	context.(protoext.ReceivedMessage).Respond(returnedUpdate)
 }
 
 func (p *pullMediatorImpl) peersWithEndpoints(endpoints ...string) []*comm.RemotePeer {
diff --git a/gossip/gossip/pull/pullstore_test.go b/gossip/gossip/pull/pullstore_test.go
index 6c158ee30..15bd422e1 100644
--- a/gossip/gossip/pull/pullstore_test.go
+++ b/gossip/gossip/pull/pullstore_test.go
@@ -18,6 +18,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/comm"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/gossip/algo"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
@@ -33,7 +34,7 @@ func init() {
 
 type pullMsg struct {
 	respondChan chan *pullMsg
-	msg         *proto.SignedGossipMessage
+	msg         *protoext.SignedGossipMessage
 }
 
 // GetSourceMessage Returns the SignedGossipMessage the ReceivedMessage was
@@ -43,18 +44,18 @@ func (pm *pullMsg) GetSourceEnvelope() *proto.Envelope {
 }
 
 func (pm *pullMsg) Respond(msg *proto.GossipMessage) {
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	pm.respondChan <- &pullMsg{
 		msg:         sMsg,
 		respondChan: pm.respondChan,
 	}
 }
 
-func (pm *pullMsg) GetGossipMessage() *proto.SignedGossipMessage {
+func (pm *pullMsg) GetGossipMessage() *protoext.SignedGossipMessage {
 	return pm.msg
 }
 
-func (pm *pullMsg) GetConnectionInfo() *proto.ConnectionInfo {
+func (pm *pullMsg) GetConnectionInfo() *protoext.ConnectionInfo {
 	return nil
 }
 
@@ -74,7 +75,7 @@ type pullInstance struct {
 	config        Config
 }
 
-func (p *pullInstance) Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer) {
+func (p *pullInstance) Send(msg *protoext.SignedGossipMessage, peers ...*comm.RemotePeer) {
 	for _, peer := range peers {
 		m := &pullMsg{
 			respondChan: p.msgChan,
@@ -115,7 +116,7 @@ func (p *pullInstance) stop() {
 	p.stopChan <- struct{}{}
 }
 
-func (p *pullInstance) wrapPullMsg(msg *proto.SignedGossipMessage) proto.ReceivedMessage {
+func (p *pullInstance) wrapPullMsg(msg *protoext.SignedGossipMessage) protoext.ReceivedMessage {
 	return &pullMsg{
 		msg:         msg,
 		respondChan: p.msgChan,
@@ -150,7 +151,7 @@ func createPullInstanceWithFilters(endpoint string, peer2PullInst map[string]*pu
 			ResponseWaitTime: time.Duration(300) * time.Millisecond,
 		},
 	}
-	seqNumFromMsg := func(msg *proto.SignedGossipMessage) string {
+	seqNumFromMsg := func(msg *protoext.SignedGossipMessage) string {
 		dataMsg := msg.GetDataMsg()
 		if dataMsg == nil {
 			return ""
@@ -160,7 +161,7 @@ func createPullInstanceWithFilters(endpoint string, peer2PullInst map[string]*pu
 		}
 		return fmt.Sprintf("%d", dataMsg.Payload.SeqNum)
 	}
-	blockConsumer := func(msg *proto.SignedGossipMessage) {
+	blockConsumer := func(msg *protoext.SignedGossipMessage) {
 		inst.items.Add(msg.GetDataMsg().Payload.SeqNum)
 	}
 	inst.pullAdapter = &PullAdapter{
@@ -197,7 +198,7 @@ func TestRegisterMsgHook(t *testing.T) {
 
 	for _, msgType := range []MsgType{HelloMsgType, DigestMsgType, RequestMsgType, ResponseMsgType} {
 		mType := msgType
-		inst1.mediator.RegisterMsgHook(mType, func(_ []string, items []*proto.SignedGossipMessage, _ proto.ReceivedMessage) {
+		inst1.mediator.RegisterMsgHook(mType, func(_ []string, items []*protoext.SignedGossipMessage, _ protoext.ReceivedMessage) {
 			receivedMsgTypes.Add(mType)
 		})
 	}
@@ -217,8 +218,8 @@ func TestFilter(t *testing.T) {
 	eq := func(a interface{}, b interface{}) bool {
 		return a == b
 	}
-	df := func(msg proto.ReceivedMessage) func(string) bool {
-		if msg.GetGossipMessage().IsDataReq() {
+	df := func(msg protoext.ReceivedMessage) func(string) bool {
+		if protoext.IsDataReq(msg.GetGossipMessage().GossipMessage) {
 			req := msg.GetGossipMessage().GetDataReq()
 			return func(item string) bool {
 				return util.IndexInSlice(util.BytesToStrings(req.Digests), item, eq) != -1
@@ -288,22 +289,22 @@ func TestAddAndRemove(t *testing.T) {
 	wg.Add(4)
 
 	// Make sure there is a Hello message
-	inst1.mediator.RegisterMsgHook(HelloMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(HelloMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		wg.Done()
 	})
 
 	// Instance 1 answering with digest
-	inst2.mediator.RegisterMsgHook(DigestMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst2.mediator.RegisterMsgHook(DigestMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		wg.Done()
 	})
 
 	// Instance 2 requesting missing items
-	inst1.mediator.RegisterMsgHook(RequestMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(RequestMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		wg.Done()
 	})
 
 	// Instance 1 sends missing item
-	inst2.mediator.RegisterMsgHook(ResponseMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst2.mediator.RegisterMsgHook(ResponseMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		wg.Done()
 	})
 
@@ -329,7 +330,7 @@ func TestDigestsFilters(t *testing.T) {
 	defer inst1.stop()
 	defer inst2.stop()
 
-	inst1.mediator.RegisterMsgHook(DigestMsgType, func(itemIds []string, _ []*proto.SignedGossipMessage, _ proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(DigestMsgType, func(itemIds []string, _ []*protoext.SignedGossipMessage, _ protoext.ReceivedMessage) {
 		if atomic.LoadInt32(&inst1ReceivedDigest) == int32(1) {
 			return
 		}
@@ -348,7 +349,7 @@ func TestDigestsFilters(t *testing.T) {
 	inst2.mediator.Add(dataMsg(3))
 
 	// inst1 sends hello to inst2
-	sMsg, _ := helloMsg().NoopSign()
+	sMsg, _ := protoext.NoopSign(helloMsg())
 	inst2.mediator.HandleMessage(inst1.wrapPullMsg(sMsg))
 
 	// inst2 is expected to send digest to inst1
@@ -373,7 +374,7 @@ func TestHandleMessage(t *testing.T) {
 	inst1ReceivedDigest := int32(0)
 	inst1ReceivedResponse := int32(0)
 
-	inst1.mediator.RegisterMsgHook(DigestMsgType, func(itemIds []string, _ []*proto.SignedGossipMessage, _ proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(DigestMsgType, func(itemIds []string, _ []*protoext.SignedGossipMessage, _ protoext.ReceivedMessage) {
 		if atomic.LoadInt32(&inst1ReceivedDigest) == int32(1) {
 			return
 		}
@@ -381,7 +382,7 @@ func TestHandleMessage(t *testing.T) {
 		assert.True(t, len(itemIds) == 3)
 	})
 
-	inst1.mediator.RegisterMsgHook(ResponseMsgType, func(_ []string, items []*proto.SignedGossipMessage, msg proto.ReceivedMessage) {
+	inst1.mediator.RegisterMsgHook(ResponseMsgType, func(_ []string, items []*protoext.SignedGossipMessage, msg protoext.ReceivedMessage) {
 		if atomic.LoadInt32(&inst1ReceivedResponse) == int32(1) {
 			return
 		}
@@ -390,14 +391,14 @@ func TestHandleMessage(t *testing.T) {
 	})
 
 	// inst1 sends hello to inst2
-	sMsg, _ := helloMsg().NoopSign()
+	sMsg, _ := protoext.NoopSign(helloMsg())
 	inst2.mediator.HandleMessage(inst1.wrapPullMsg(sMsg))
 
 	// inst2 is expected to send digest to inst1
 	waitUntilOrFail(t, func() bool { return atomic.LoadInt32(&inst1ReceivedDigest) == int32(1) })
 
 	// inst1 sends request to inst2
-	sMsg, _ = reqMsg("0", "1", "2").NoopSign()
+	sMsg, _ = protoext.NoopSign(reqMsg("0", "1", "2"))
 	inst2.mediator.HandleMessage(inst1.wrapPullMsg(sMsg))
 
 	// inst2 is expected to send response to inst1
@@ -420,8 +421,8 @@ func waitUntilOrFail(t *testing.T, pred func() bool) {
 	assert.Fail(t, "Timeout expired!")
 }
 
-func dataMsg(seqNum int) *proto.SignedGossipMessage {
-	sMsg, _ := (&proto.GossipMessage{
+func dataMsg(seqNum int) *protoext.SignedGossipMessage {
+	sMsg, _ := protoext.NoopSign(&proto.GossipMessage{
 		Nonce: 0,
 		Tag:   proto.GossipMessage_EMPTY,
 		Content: &proto.GossipMessage_DataMsg{
@@ -432,7 +433,7 @@ func dataMsg(seqNum int) *proto.SignedGossipMessage {
 				},
 			},
 		},
-	}).NoopSign()
+	})
 	return sMsg
 }
 
diff --git a/gossip/privdata/distributor.go b/gossip/privdata/distributor.go
index 1e7cee785..c68face5b 100644
--- a/gossip/privdata/distributor.go
+++ b/gossip/privdata/distributor.go
@@ -22,6 +22,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/filter"
 	gossip2 "github.com/hyperledger/fabric/gossip/gossip"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	"github.com/hyperledger/fabric/msp"
 	"github.com/hyperledger/fabric/protos/common"
@@ -34,7 +35,7 @@ import (
 // gossipAdapter an adapter for API's required from gossip module
 type gossipAdapter interface {
 	// SendByCriteria sends a given message to all peers that match the given SendCriteria
-	SendByCriteria(message *proto.SignedGossipMessage, criteria gossip2.SendCriteria) error
+	SendByCriteria(message *protoext.SignedGossipMessage, criteria gossip2.SendCriteria) error
 
 	// PeerFilter receives a SubChannelSelectionCriteria and returns a RoutingFilter that selects
 	// only peer identities that match the given criteria, and that they published their channel participation
@@ -126,7 +127,7 @@ func (d *distributorImpl) Distribute(txID string, privData *transientstore.TxPvt
 }
 
 type dissemination struct {
-	msg      *proto.SignedGossipMessage
+	msg      *protoext.SignedGossipMessage
 	criteria gossip2.SendCriteria
 }
 
@@ -189,7 +190,7 @@ func (d *distributorImpl) getCollectionConfig(config *common.CollectionConfigPac
 	return nil, errors.New(fmt.Sprint("no configuration for collection", collection.CollectionName, "found"))
 }
 
-func (d *distributorImpl) disseminationPlanForMsg(colAP privdata.CollectionAccessPolicy, colFilter privdata.Filter, pvtDataMsg *proto.SignedGossipMessage) ([]*dissemination, error) {
+func (d *distributorImpl) disseminationPlanForMsg(colAP privdata.CollectionAccessPolicy, colFilter privdata.Filter, pvtDataMsg *protoext.SignedGossipMessage) ([]*dissemination, error) {
 	var disseminationPlan []*dissemination
 
 	routingFilter, err := d.gossipAdapter.PeerFilter(gossipCommon.ChainID(d.chainID), func(signature api.PeerSignature) bool {
@@ -230,7 +231,7 @@ func (d *distributorImpl) disseminationPlanForMsg(colAP privdata.CollectionAcces
 			}
 			disseminationPlan = append(disseminationPlan, &dissemination{
 				criteria: sc,
-				msg: &proto.SignedGossipMessage{
+				msg: &protoext.SignedGossipMessage{
 					Envelope:      proto2.Clone(pvtDataMsg.Envelope).(*proto.Envelope),
 					GossipMessage: proto2.Clone(pvtDataMsg.GossipMessage).(*proto.GossipMessage),
 				},
@@ -330,7 +331,7 @@ func (d *distributorImpl) reportSendDuration(startTime time.Time) {
 func (d *distributorImpl) createPrivateDataMessage(txID, namespace string,
 	collection *rwset.CollectionPvtReadWriteSet,
 	ccp *common.CollectionConfigPackage,
-	blkHt uint64) (*proto.SignedGossipMessage, error) {
+	blkHt uint64) (*protoext.SignedGossipMessage, error) {
 	msg := &proto.GossipMessage{
 		Channel: []byte(d.chainID),
 		Nonce:   util.RandomUInt64(),
@@ -349,7 +350,7 @@ func (d *distributorImpl) createPrivateDataMessage(txID, namespace string,
 		},
 	}
 
-	pvtDataMsg, err := msg.NoopSign()
+	pvtDataMsg, err := protoext.NoopSign(msg)
 	if err != nil {
 		return nil, err
 	}
diff --git a/gossip/privdata/distributor_test.go b/gossip/privdata/distributor_test.go
index 5629415e8..22f660602 100644
--- a/gossip/privdata/distributor_test.go
+++ b/gossip/privdata/distributor_test.go
@@ -19,6 +19,7 @@ import (
 	gossip2 "github.com/hyperledger/fabric/gossip/gossip"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/transientstore"
@@ -87,7 +88,7 @@ func (g *gossipMock) PeersOfChannel(chainID gcommon.ChainID) []discovery.Network
 	return g.Called(chainID).Get(0).([]discovery.NetworkMember)
 }
 
-func (g *gossipMock) SendByCriteria(message *proto.SignedGossipMessage, criteria gossip2.SendCriteria) error {
+func (g *gossipMock) SendByCriteria(message *protoext.SignedGossipMessage, criteria gossip2.SendCriteria) error {
 	args := g.Called(message, criteria)
 	if args.Get(0) != nil {
 		return args.Get(0).(error)
@@ -137,7 +138,7 @@ func TestDistributor(t *testing.T) {
 	})
 
 	g.On("SendByCriteria", mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
-		msg := args.Get(0).(*proto.SignedGossipMessage)
+		msg := args.Get(0).(*protoext.SignedGossipMessage)
 		sendCriteria := args.Get(1).(gossip2.SendCriteria)
 		sendings <- struct {
 			*proto.PrivatePayload
diff --git a/gossip/privdata/pull.go b/gossip/privdata/pull.go
index 2965d8769..cdbe191e8 100644
--- a/gossip/privdata/pull.go
+++ b/gossip/privdata/pull.go
@@ -22,6 +22,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/filter"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	privdatacommon "github.com/hyperledger/fabric/gossip/privdata/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	fcommon "github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
@@ -62,14 +63,14 @@ type gossip interface {
 	// If passThrough is false, the messages are processed by the gossip layer beforehand.
 	// If passThrough is true, the gossip layer doesn't intervene and the messages
 	// can be used to send a reply back to the sender
-	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 }
 
 type puller struct {
 	metrics       *metrics.PrivdataMetrics
 	pubSub        *util.PubSub
 	stopChan      chan struct{}
-	msgChan       <-chan proto.ReceivedMessage
+	msgChan       <-chan protoext.ReceivedMessage
 	channel       string
 	cs            privdata.CollectionStore
 	btlPullMargin uint64
@@ -93,11 +94,11 @@ func NewPuller(metrics *metrics.PrivdataMetrics, cs privdata.CollectionStore, g
 		CollectionAccessFactory: factory,
 	}
 	_, p.msgChan = p.Accept(func(o interface{}) bool {
-		msg := o.(proto.ReceivedMessage).GetGossipMessage()
+		msg := o.(protoext.ReceivedMessage).GetGossipMessage()
 		if !bytes.Equal(msg.Channel, []byte(p.channel)) {
 			return false
 		}
-		return msg.IsPrivateDataMsg()
+		return protoext.IsPrivateDataMsg(msg.GossipMessage)
 	}, true)
 	go p.listen()
 	return p
@@ -124,7 +125,7 @@ func (p *puller) listen() {
 	}
 }
 
-func (p *puller) handleRequest(message proto.ReceivedMessage) {
+func (p *puller) handleRequest(message protoext.ReceivedMessage) {
 	logger.Debug("Got", message.GetGossipMessage(), "from", message.GetConnectionInfo().Endpoint)
 	message.Respond(&proto.GossipMessage{
 		Channel: []byte(p.channel),
@@ -138,7 +139,7 @@ func (p *puller) handleRequest(message proto.ReceivedMessage) {
 	})
 }
 
-func (p *puller) createResponse(message proto.ReceivedMessage) []*proto.PvtDataElement {
+func (p *puller) createResponse(message protoext.ReceivedMessage) []*proto.PvtDataElement {
 	authInfo := message.GetConnectionInfo().Auth
 	var returned []*proto.PvtDataElement
 	connectionEndpoint := message.GetConnectionInfo().Endpoint
@@ -177,7 +178,7 @@ func groupDigestsByBlockNum(digests []*proto.PvtDataDigest) map[uint64][]*proto.
 	return results
 }
 
-func (p *puller) handleResponse(message proto.ReceivedMessage) {
+func (p *puller) handleResponse(message protoext.ReceivedMessage) {
 	msg := message.GetGossipMessage().GetPrivateRes()
 	logger.Debug("Got", msg, "from", message.GetConnectionInfo().Endpoint)
 	for _, el := range msg.Elements {
@@ -185,7 +186,7 @@ func (p *puller) handleResponse(message proto.ReceivedMessage) {
 			logger.Warning("Got nil digest from", message.GetConnectionInfo().Endpoint, "aborting")
 			return
 		}
-		hash, err := el.Digest.Hash()
+		hash, err := protoext.Hash(el.Digest)
 		if err != nil {
 			logger.Warning("Failed hashing digest from", message.GetConnectionInfo().Endpoint, "aborting")
 			return
@@ -342,7 +343,7 @@ func (p *puller) scatterRequests(peersDigestMapping peer2Digests) []util.Subscri
 
 		// Subscribe to all digests prior to sending them
 		for _, dig := range msg.GetPrivateReq().Digests {
-			hash, err := dig.Hash()
+			hash, err := protoext.Hash(dig)
 			if err != nil {
 				// Shouldn't happen as we just built this message ourselves
 				logger.Warning("Failed creating digest", err)
diff --git a/gossip/privdata/pull_test.go b/gossip/privdata/pull_test.go
index 4091ae4d1..11a57c293 100644
--- a/gossip/privdata/pull_test.go
+++ b/gossip/privdata/pull_test.go
@@ -25,6 +25,7 @@ import (
 	gmetricsmocks "github.com/hyperledger/fabric/gossip/metrics/mocks"
 	privdatacommon "github.com/hyperledger/fabric/gossip/privdata/common"
 	"github.com/hyperledger/fabric/gossip/privdata/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	fcommon "github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
@@ -165,9 +166,9 @@ func (dr *dataRetrieverMock) CollectionRWSet(dig []*proto.PvtDataDigest, blockNu
 }
 
 type receivedMsg struct {
-	responseChan chan proto.ReceivedMessage
+	responseChan chan protoext.ReceivedMessage
 	*comm.RemotePeer
-	*proto.SignedGossipMessage
+	*protoext.SignedGossipMessage
 }
 
 func (msg *receivedMsg) Ack(_ error) {
@@ -175,11 +176,11 @@ func (msg *receivedMsg) Ack(_ error) {
 }
 
 func (msg *receivedMsg) Respond(message *proto.GossipMessage) {
-	m, _ := message.NoopSign()
+	m, _ := protoext.NoopSign(message)
 	msg.responseChan <- &receivedMsg{SignedGossipMessage: m, RemotePeer: &comm.RemotePeer{}}
 }
 
-func (msg *receivedMsg) GetGossipMessage() *proto.SignedGossipMessage {
+func (msg *receivedMsg) GetGossipMessage() *protoext.SignedGossipMessage {
 	return msg.SignedGossipMessage
 }
 
@@ -187,10 +188,10 @@ func (msg *receivedMsg) GetSourceEnvelope() *proto.Envelope {
 	panic("implement me")
 }
 
-func (msg *receivedMsg) GetConnectionInfo() *proto.ConnectionInfo {
-	return &proto.ConnectionInfo{
+func (msg *receivedMsg) GetConnectionInfo() *protoext.ConnectionInfo {
+	return &protoext.ConnectionInfo{
 		Identity: api.PeerIdentityType(msg.RemotePeer.PKIID),
-		Auth: &proto.AuthInfo{
+		Auth: &protoext.AuthInfo{
 			SignedData: []byte{},
 			Signature:  []byte{},
 		},
@@ -199,14 +200,14 @@ func (msg *receivedMsg) GetConnectionInfo() *proto.ConnectionInfo {
 
 type mockGossip struct {
 	mock.Mock
-	msgChan chan proto.ReceivedMessage
+	msgChan chan protoext.ReceivedMessage
 	id      *comm.RemotePeer
 	network *gossipNetwork
 }
 
 func newMockGossip(id *comm.RemotePeer) *mockGossip {
 	return &mockGossip{
-		msgChan: make(chan proto.ReceivedMessage),
+		msgChan: make(chan protoext.ReceivedMessage),
 		id:      id,
 	}
 }
@@ -229,7 +230,7 @@ func (g *mockGossip) PeerFilter(channel common.ChainID, messagePredicate api.Sub
 }
 
 func (g *mockGossip) Send(msg *proto.GossipMessage, peers ...*comm.RemotePeer) {
-	sMsg, _ := msg.NoopSign()
+	sMsg, _ := protoext.NoopSign(msg)
 	for _, peer := range g.network.peers {
 		if bytes.Equal(peer.id.PKIID, peers[0].PKIID) {
 			peer.msgChan <- &receivedMsg{
@@ -246,7 +247,7 @@ func (g *mockGossip) PeersOfChannel(common.ChainID) []discovery.NetworkMember {
 	return g.Called().Get(0).([]discovery.NetworkMember)
 }
 
-func (g *mockGossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (g *mockGossip) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	return nil, g.msgChan
 }
 
diff --git a/protos/gossip/compatibility_test.go b/gossip/protoext/compatibility_test.go
similarity index 73%
rename from protos/gossip/compatibility_test.go
rename to gossip/protoext/compatibility_test.go
index 8afe99eff..6909eff60 100644
--- a/protos/gossip/compatibility_test.go
+++ b/gossip/protoext/compatibility_test.go
@@ -4,20 +4,21 @@ Copyright IBM Corp. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
 */
 
-package gossip
+package protoext
 
 import (
 	"encoding/hex"
 	"testing"
 
 	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
 
-var digestMsg = &GossipMessage{
+var digestMsg = &gossip.GossipMessage{
 	Channel: []byte("mychannel"),
-	Content: &GossipMessage_DataDig{
-		DataDig: &DataDigest{
+	Content: &gossip.GossipMessage_DataDig{
+		DataDig: &gossip.DataDigest{
 			Digests: [][]byte{
 				{255},
 				{255, 255},
@@ -29,10 +30,10 @@ var digestMsg = &GossipMessage{
 	},
 }
 
-var requestMsg = &GossipMessage{
+var requestMsg = &gossip.GossipMessage{
 	Channel: []byte("mychannel"),
-	Content: &GossipMessage_DataReq{
-		DataReq: &DataRequest{
+	Content: &gossip.GossipMessage_DataReq{
+		DataReq: &gossip.DataRequest{
 			Digests: [][]byte{
 				{255},
 				{255, 255},
@@ -52,18 +53,18 @@ const (
 func TestUnmarshalV12Digests(t *testing.T) {
 	// This test ensures that digests of data digest messages and data requests
 	// that originated from fabric v1.3 can be successfully parsed by v1.2
-	for msgBytes, expectedMsg := range map[string]*GossipMessage{
+	for msgBytes, expectedMsg := range map[string]*gossip.GossipMessage{
 		v12DataDigestBytes:  digestMsg,
 		v12DataRequestBytes: requestMsg,
 	} {
 		var err error
-		v13Envelope := &Envelope{}
+		v13Envelope := &gossip.Envelope{}
 		v13Envelope.Payload, err = hex.DecodeString(msgBytes)
 		assert.NoError(t, err)
 		sMsg := &SignedGossipMessage{
 			Envelope: v13Envelope,
 		}
-		v13Digest, err := sMsg.ToGossipMessage()
+		v13Digest, err := EnvelopeToGossipMessage(sMsg.Envelope)
 		assert.NoError(t, err)
 		assert.True(t, proto.Equal(expectedMsg, v13Digest.GossipMessage))
 	}
diff --git a/protos/gossip/extensions.go b/gossip/protoext/extensions.go
similarity index 67%
rename from protos/gossip/extensions.go
rename to gossip/protoext/extensions.go
index 6da770891..d1dd3e225 100644
--- a/protos/gossip/extensions.go
+++ b/gossip/protoext/extensions.go
@@ -4,7 +4,7 @@ Copyright IBM Corp. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
 */
 
-package gossip
+package protoext
 
 import (
 	"bytes"
@@ -16,6 +16,7 @@ import (
 	"github.com/hyperledger/fabric/common/util"
 	"github.com/hyperledger/fabric/gossip/api"
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/protos/gossip"
 )
 
 // NewGossipMessageComparator creates a MessageReplacingPolicy given a maximum number of blocks to hold
@@ -37,37 +38,37 @@ func (mc *msgComparator) invalidationPolicy(this interface{}, that interface{})
 	thisMsg := this.(*SignedGossipMessage)
 	thatMsg := that.(*SignedGossipMessage)
 
-	if thisMsg.IsAliveMsg() && thatMsg.IsAliveMsg() {
+	if IsAliveMsg(thisMsg.GossipMessage) && IsAliveMsg(thatMsg.GossipMessage) {
 		return aliveInvalidationPolicy(thisMsg.GetAliveMsg(), thatMsg.GetAliveMsg())
 	}
 
-	if thisMsg.IsDataMsg() && thatMsg.IsDataMsg() {
+	if IsDataMsg(thisMsg.GossipMessage) && IsDataMsg(thatMsg.GossipMessage) {
 		return mc.dataInvalidationPolicy(thisMsg.GetDataMsg(), thatMsg.GetDataMsg())
 	}
 
-	if thisMsg.IsStateInfoMsg() && thatMsg.IsStateInfoMsg() {
+	if IsStateInfoMsg(thisMsg.GossipMessage) && IsStateInfoMsg(thatMsg.GossipMessage) {
 		return mc.stateInvalidationPolicy(thisMsg.GetStateInfo(), thatMsg.GetStateInfo())
 	}
 
-	if thisMsg.IsIdentityMsg() && thatMsg.IsIdentityMsg() {
+	if IsIdentityMsg(thisMsg.GossipMessage) && IsIdentityMsg(thatMsg.GossipMessage) {
 		return mc.identityInvalidationPolicy(thisMsg.GetPeerIdentity(), thatMsg.GetPeerIdentity())
 	}
 
-	if thisMsg.IsLeadershipMsg() && thatMsg.IsLeadershipMsg() {
+	if IsLeadershipMsg(thisMsg.GossipMessage) && IsLeadershipMsg(thatMsg.GossipMessage) {
 		return leaderInvalidationPolicy(thisMsg.GetLeadershipMsg(), thatMsg.GetLeadershipMsg())
 	}
 
 	return common.MessageNoAction
 }
 
-func (mc *msgComparator) stateInvalidationPolicy(thisStateMsg *StateInfo, thatStateMsg *StateInfo) common.InvalidationResult {
+func (mc *msgComparator) stateInvalidationPolicy(thisStateMsg *gossip.StateInfo, thatStateMsg *gossip.StateInfo) common.InvalidationResult {
 	if !bytes.Equal(thisStateMsg.PkiId, thatStateMsg.PkiId) {
 		return common.MessageNoAction
 	}
 	return compareTimestamps(thisStateMsg.Timestamp, thatStateMsg.Timestamp)
 }
 
-func (mc *msgComparator) identityInvalidationPolicy(thisIdentityMsg *PeerIdentity, thatIdentityMsg *PeerIdentity) common.InvalidationResult {
+func (mc *msgComparator) identityInvalidationPolicy(thisIdentityMsg *gossip.PeerIdentity, thatIdentityMsg *gossip.PeerIdentity) common.InvalidationResult {
 	if bytes.Equal(thisIdentityMsg.PkiId, thatIdentityMsg.PkiId) {
 		return common.MessageInvalidated
 	}
@@ -75,7 +76,7 @@ func (mc *msgComparator) identityInvalidationPolicy(thisIdentityMsg *PeerIdentit
 	return common.MessageNoAction
 }
 
-func (mc *msgComparator) dataInvalidationPolicy(thisDataMsg *DataMessage, thatDataMsg *DataMessage) common.InvalidationResult {
+func (mc *msgComparator) dataInvalidationPolicy(thisDataMsg *gossip.DataMessage, thatDataMsg *gossip.DataMessage) common.InvalidationResult {
 	if thisDataMsg.Payload.SeqNum == thatDataMsg.Payload.SeqNum {
 		return common.MessageInvalidated
 	}
@@ -91,7 +92,7 @@ func (mc *msgComparator) dataInvalidationPolicy(thisDataMsg *DataMessage, thatDa
 	return common.MessageInvalidated
 }
 
-func aliveInvalidationPolicy(thisMsg *AliveMessage, thatMsg *AliveMessage) common.InvalidationResult {
+func aliveInvalidationPolicy(thisMsg *gossip.AliveMessage, thatMsg *gossip.AliveMessage) common.InvalidationResult {
 	if !bytes.Equal(thisMsg.Membership.PkiId, thatMsg.Membership.PkiId) {
 		return common.MessageNoAction
 	}
@@ -99,7 +100,7 @@ func aliveInvalidationPolicy(thisMsg *AliveMessage, thatMsg *AliveMessage) commo
 	return compareTimestamps(thisMsg.Timestamp, thatMsg.Timestamp)
 }
 
-func leaderInvalidationPolicy(thisMsg *LeadershipMessage, thatMsg *LeadershipMessage) common.InvalidationResult {
+func leaderInvalidationPolicy(thisMsg *gossip.LeadershipMessage, thatMsg *gossip.LeadershipMessage) common.InvalidationResult {
 	if !bytes.Equal(thisMsg.PkiId, thatMsg.PkiId) {
 		return common.MessageNoAction
 	}
@@ -107,7 +108,7 @@ func leaderInvalidationPolicy(thisMsg *LeadershipMessage, thatMsg *LeadershipMes
 	return compareTimestamps(thisMsg.Timestamp, thatMsg.Timestamp)
 }
 
-func compareTimestamps(thisTS *PeerTime, thatTS *PeerTime) common.InvalidationResult {
+func compareTimestamps(thisTS *gossip.PeerTime, thatTS *gossip.PeerTime) common.InvalidationResult {
 	if thisTS.IncNum == thatTS.IncNum {
 		if thisTS.SeqNum > thatTS.SeqNum {
 			return common.MessageInvalidates
@@ -122,46 +123,46 @@ func compareTimestamps(thisTS *PeerTime, thatTS *PeerTime) common.InvalidationRe
 }
 
 // IsAliveMsg returns whether this GossipMessage is an AliveMessage
-func (m *GossipMessage) IsAliveMsg() bool {
+func IsAliveMsg(m *gossip.GossipMessage) bool {
 	return m.GetAliveMsg() != nil
 }
 
 // IsDataMsg returns whether this GossipMessage is a data message
-func (m *GossipMessage) IsDataMsg() bool {
+func IsDataMsg(m *gossip.GossipMessage) bool {
 	return m.GetDataMsg() != nil
 }
 
 // IsStateInfoPullRequestMsg returns whether this GossipMessage is a stateInfoPullRequest
-func (m *GossipMessage) IsStateInfoPullRequestMsg() bool {
+func IsStateInfoPullRequestMsg(m *gossip.GossipMessage) bool {
 	return m.GetStateInfoPullReq() != nil
 }
 
 // IsStateInfoSnapshot returns whether this GossipMessage is a stateInfo snapshot
-func (m *GossipMessage) IsStateInfoSnapshot() bool {
+func IsStateInfoSnapshot(m *gossip.GossipMessage) bool {
 	return m.GetStateSnapshot() != nil
 }
 
 // IsStateInfoMsg returns whether this GossipMessage is a stateInfo message
-func (m *GossipMessage) IsStateInfoMsg() bool {
+func IsStateInfoMsg(m *gossip.GossipMessage) bool {
 	return m.GetStateInfo() != nil
 }
 
 // IsPullMsg returns whether this GossipMessage is a message that belongs
 // to the pull mechanism
-func (m *GossipMessage) IsPullMsg() bool {
+func IsPullMsg(m *gossip.GossipMessage) bool {
 	return m.GetDataReq() != nil || m.GetDataUpdate() != nil ||
 		m.GetHello() != nil || m.GetDataDig() != nil
 }
 
 // IsRemoteStateMessage returns whether this GossipMessage is related to state synchronization
-func (m *GossipMessage) IsRemoteStateMessage() bool {
+func IsRemoteStateMessage(m *gossip.GossipMessage) bool {
 	return m.GetStateRequest() != nil || m.GetStateResponse() != nil
 }
 
 // GetPullMsgType returns the phase of the pull mechanism this GossipMessage belongs to
 // for example: Hello, Digest, etc.
 // If this isn't a pull message, PullMsgType_UNDEFINED is returned.
-func (m *GossipMessage) GetPullMsgType() PullMsgType {
+func GetPullMsgType(m *gossip.GossipMessage) gossip.PullMsgType {
 	if helloMsg := m.GetHello(); helloMsg != nil {
 		return helloMsg.MsgType
 	}
@@ -178,58 +179,58 @@ func (m *GossipMessage) GetPullMsgType() PullMsgType {
 		return resMsg.MsgType
 	}
 
-	return PullMsgType_UNDEFINED
+	return gossip.PullMsgType_UNDEFINED
 }
 
 // IsChannelRestricted returns whether this GossipMessage should be routed
 // only in its channel
-func (m *GossipMessage) IsChannelRestricted() bool {
-	return m.Tag == GossipMessage_CHAN_AND_ORG || m.Tag == GossipMessage_CHAN_ONLY || m.Tag == GossipMessage_CHAN_OR_ORG
+func IsChannelRestricted(m *gossip.GossipMessage) bool {
+	return m.Tag == gossip.GossipMessage_CHAN_AND_ORG || m.Tag == gossip.GossipMessage_CHAN_ONLY || m.Tag == gossip.GossipMessage_CHAN_OR_ORG
 }
 
 // IsOrgRestricted returns whether this GossipMessage should be routed only
 // inside the organization
-func (m *GossipMessage) IsOrgRestricted() bool {
-	return m.Tag == GossipMessage_CHAN_AND_ORG || m.Tag == GossipMessage_ORG_ONLY
+func IsOrgRestricted(m *gossip.GossipMessage) bool {
+	return m.Tag == gossip.GossipMessage_CHAN_AND_ORG || m.Tag == gossip.GossipMessage_ORG_ONLY
 }
 
 // IsIdentityMsg returns whether this GossipMessage is an identity message
-func (m *GossipMessage) IsIdentityMsg() bool {
+func IsIdentityMsg(m *gossip.GossipMessage) bool {
 	return m.GetPeerIdentity() != nil
 }
 
 // IsDataReq returns whether this GossipMessage is a data request message
-func (m *GossipMessage) IsDataReq() bool {
+func IsDataReq(m *gossip.GossipMessage) bool {
 	return m.GetDataReq() != nil
 }
 
 // IsPrivateDataMsg returns whether this message is related to private data
-func (m *GossipMessage) IsPrivateDataMsg() bool {
+func IsPrivateDataMsg(m *gossip.GossipMessage) bool {
 	return m.GetPrivateReq() != nil || m.GetPrivateRes() != nil || m.GetPrivateData() != nil
 }
 
 // IsAck returns whether this GossipMessage is an acknowledgement
-func (m *GossipMessage) IsAck() bool {
+func IsAck(m *gossip.GossipMessage) bool {
 	return m.GetAck() != nil
 }
 
 // IsDataUpdate returns whether this GossipMessage is a data update message
-func (m *GossipMessage) IsDataUpdate() bool {
+func IsDataUpdate(m *gossip.GossipMessage) bool {
 	return m.GetDataUpdate() != nil
 }
 
 // IsHelloMsg returns whether this GossipMessage is a hello message
-func (m *GossipMessage) IsHelloMsg() bool {
+func IsHelloMsg(m *gossip.GossipMessage) bool {
 	return m.GetHello() != nil
 }
 
 // IsDigestMsg returns whether this GossipMessage is a digest message
-func (m *GossipMessage) IsDigestMsg() bool {
+func IsDigestMsg(m *gossip.GossipMessage) bool {
 	return m.GetDataDig() != nil
 }
 
 // IsLeadershipMsg returns whether this GossipMessage is a leadership (leader election) message
-func (m *GossipMessage) IsLeadershipMsg() bool {
+func IsLeadershipMsg(m *gossip.GossipMessage) bool {
 	return m.GetLeadershipMsg() != nil
 }
 
@@ -241,58 +242,58 @@ type IdentifierExtractor func(*SignedGossipMessage) string
 
 // IsTagLegal checks the GossipMessage tags and inner type
 // and returns an error if the tag doesn't match the type.
-func (m *GossipMessage) IsTagLegal() error {
-	if m.Tag == GossipMessage_UNDEFINED {
+func IsTagLegal(m *gossip.GossipMessage) error {
+	if m.Tag == gossip.GossipMessage_UNDEFINED {
 		return fmt.Errorf("Undefined tag")
 	}
-	if m.IsDataMsg() {
-		if m.Tag != GossipMessage_CHAN_AND_ORG {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_AND_ORG)])
+	if IsDataMsg(m) {
+		if m.Tag != gossip.GossipMessage_CHAN_AND_ORG {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_AND_ORG)])
 		}
 		return nil
 	}
 
-	if m.IsAliveMsg() || m.GetMemReq() != nil || m.GetMemRes() != nil {
-		if m.Tag != GossipMessage_EMPTY {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_EMPTY)])
+	if IsAliveMsg(m) || m.GetMemReq() != nil || m.GetMemRes() != nil {
+		if m.Tag != gossip.GossipMessage_EMPTY {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_EMPTY)])
 		}
 		return nil
 	}
 
-	if m.IsIdentityMsg() {
-		if m.Tag != GossipMessage_ORG_ONLY {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_ORG_ONLY)])
+	if IsIdentityMsg(m) {
+		if m.Tag != gossip.GossipMessage_ORG_ONLY {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_ORG_ONLY)])
 		}
 		return nil
 	}
 
-	if m.IsPullMsg() {
-		switch m.GetPullMsgType() {
-		case PullMsgType_BLOCK_MSG:
-			if m.Tag != GossipMessage_CHAN_AND_ORG {
-				return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_AND_ORG)])
+	if IsPullMsg(m) {
+		switch GetPullMsgType(m) {
+		case gossip.PullMsgType_BLOCK_MSG:
+			if m.Tag != gossip.GossipMessage_CHAN_AND_ORG {
+				return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_AND_ORG)])
 			}
 			return nil
-		case PullMsgType_IDENTITY_MSG:
-			if m.Tag != GossipMessage_EMPTY {
-				return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_EMPTY)])
+		case gossip.PullMsgType_IDENTITY_MSG:
+			if m.Tag != gossip.GossipMessage_EMPTY {
+				return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_EMPTY)])
 			}
 			return nil
 		default:
-			return fmt.Errorf("Invalid PullMsgType: %s", PullMsgType_name[int32(m.GetPullMsgType())])
+			return fmt.Errorf("Invalid PullMsgType: %s", gossip.PullMsgType_name[int32(GetPullMsgType(m))])
 		}
 	}
 
-	if m.IsStateInfoMsg() || m.IsStateInfoPullRequestMsg() || m.IsStateInfoSnapshot() || m.IsRemoteStateMessage() {
-		if m.Tag != GossipMessage_CHAN_OR_ORG {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_OR_ORG)])
+	if IsStateInfoMsg(m) || IsStateInfoPullRequestMsg(m) || IsStateInfoSnapshot(m) || IsRemoteStateMessage(m) {
+		if m.Tag != gossip.GossipMessage_CHAN_OR_ORG {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_OR_ORG)])
 		}
 		return nil
 	}
 
-	if m.IsLeadershipMsg() {
-		if m.Tag != GossipMessage_CHAN_AND_ORG {
-			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_AND_ORG)])
+	if IsLeadershipMsg(m) {
+		if m.Tag != gossip.GossipMessage_CHAN_AND_ORG {
+			return fmt.Errorf("Tag should be %s", gossip.GossipMessage_Tag_name[int32(gossip.GossipMessage_CHAN_AND_ORG)])
 		}
 		return nil
 	}
@@ -318,14 +319,14 @@ type Signer func(msg []byte) ([]byte, error)
 type ReceivedMessage interface {
 
 	// Respond sends a GossipMessage to the origin from which this ReceivedMessage was sent from
-	Respond(msg *GossipMessage)
+	Respond(msg *gossip.GossipMessage)
 
 	// GetGossipMessage returns the underlying GossipMessage
 	GetGossipMessage() *SignedGossipMessage
 
 	// GetSourceMessage Returns the Envelope the ReceivedMessage was
 	// constructed with
-	GetSourceEnvelope() *Envelope
+	GetSourceEnvelope() *gossip.Envelope
 
 	// GetConnectionInfo returns information about the remote peer
 	// that sent the message
@@ -362,10 +363,10 @@ type AuthInfo struct {
 // Sign signs a GossipMessage with given Signer.
 // Returns an Envelope on success,
 // panics on failure.
-func (m *SignedGossipMessage) Sign(signer Signer) (*Envelope, error) {
+func (m *SignedGossipMessage) Sign(signer Signer) (*gossip.Envelope, error) {
 	// If we have a secretEnvelope, don't override it.
 	// Back it up, and restore it later
-	var secretEnvelope *SecretEnvelope
+	var secretEnvelope *gossip.SecretEnvelope
 	if m.Envelope != nil {
 		secretEnvelope = m.Envelope.SecretEnvelope
 	}
@@ -379,7 +380,7 @@ func (m *SignedGossipMessage) Sign(signer Signer) (*Envelope, error) {
 		return nil, err
 	}
 
-	e := &Envelope{
+	e := &gossip.Envelope{
 		Payload:        payload,
 		Signature:      sig,
 		SecretEnvelope: secretEnvelope,
@@ -389,7 +390,7 @@ func (m *SignedGossipMessage) Sign(signer Signer) (*Envelope, error) {
 }
 
 // NoopSign creates a SignedGossipMessage with a nil signature
-func (m *GossipMessage) NoopSign() (*SignedGossipMessage, error) {
+func NoopSign(m *gossip.GossipMessage) (*SignedGossipMessage, error) {
 	signer := func(msg []byte) ([]byte, error) {
 		return nil, nil
 	}
@@ -436,14 +437,14 @@ func (m *SignedGossipMessage) IsSigned() bool {
 	return m.Envelope != nil && m.Envelope.Payload != nil && m.Envelope.Signature != nil
 }
 
-// ToGossipMessage un-marshals a given envelope and creates a
+// EnvelopeToGossipMessage un-marshals a given envelope and creates a
 // SignedGossipMessage out of it.
 // Returns an error if un-marshaling fails.
-func (e *Envelope) ToGossipMessage() (*SignedGossipMessage, error) {
+func EnvelopeToGossipMessage(e *gossip.Envelope) (*SignedGossipMessage, error) {
 	if e == nil {
 		return nil, errors.New("nil envelope")
 	}
-	msg := &GossipMessage{}
+	msg := &gossip.GossipMessage{}
 	err := proto.Unmarshal(e.Payload, msg)
 	if err != nil {
 		return nil, fmt.Errorf("Failed unmarshaling GossipMessage from envelope: %v", err)
@@ -456,7 +457,7 @@ func (e *Envelope) ToGossipMessage() (*SignedGossipMessage, error) {
 
 // SignSecret signs the secret payload and creates
 // a secret envelope out of it.
-func (e *Envelope) SignSecret(signer Signer, secret *Secret) error {
+func SignSecret(e *gossip.Envelope, signer Signer, secret *gossip.Secret) error {
 	payload, err := proto.Marshal(secret)
 	if err != nil {
 		return err
@@ -465,7 +466,7 @@ func (e *Envelope) SignSecret(signer Signer, secret *Secret) error {
 	if err != nil {
 		return err
 	}
-	e.SecretEnvelope = &SecretEnvelope{
+	e.SecretEnvelope = &gossip.SecretEnvelope{
 		Payload:   payload,
 		Signature: sig,
 	}
@@ -475,11 +476,11 @@ func (e *Envelope) SignSecret(signer Signer, secret *Secret) error {
 // InternalEndpoint returns the internal endpoint
 // in the secret envelope, or an empty string
 // if a failure occurs.
-func (s *SecretEnvelope) InternalEndpoint() string {
+func InternalEndpoint(s *gossip.SecretEnvelope) string {
 	if s == nil {
 		return ""
 	}
-	secret := &Secret{}
+	secret := &gossip.Secret{}
 	if err := proto.Unmarshal(s.Payload, secret); err != nil {
 		return ""
 	}
@@ -489,25 +490,8 @@ func (s *SecretEnvelope) InternalEndpoint() string {
 // SignedGossipMessage contains a GossipMessage
 // and the Envelope from which it came from
 type SignedGossipMessage struct {
-	*Envelope
-	*GossipMessage
-}
-
-func (p *Payload) toString() string {
-	return fmt.Sprintf("Block message: {Data: %d bytes, seq: %d}", len(p.Data), p.SeqNum)
-}
-
-func (du *DataUpdate) toString() string {
-	mType := PullMsgType_name[int32(du.MsgType)]
-	return fmt.Sprintf("Type: %s, items: %d, nonce: %d", mType, len(du.Data), du.Nonce)
-}
-
-func (mr *MembershipResponse) toString() string {
-	return fmt.Sprintf("MembershipResponse with Alive: %d, Dead: %d", len(mr.Alive), len(mr.Dead))
-}
-
-func (sis *StateInfoSnapshot) toString() string {
-	return fmt.Sprintf("StateInfoSnapshot with %d items", len(sis.Elements))
+	*gossip.Envelope
+	*gossip.GossipMessage
 }
 
 // String returns a string representation
@@ -528,46 +512,61 @@ func (m *SignedGossipMessage) String() string {
 		var isSimpleMsg bool
 		if m.GetStateResponse() != nil {
 			gMsg = fmt.Sprintf("StateResponse with %d items", len(m.GetStateResponse().Payloads))
-		} else if m.IsDataMsg() && m.GetDataMsg().Payload != nil {
-			gMsg = m.GetDataMsg().Payload.toString()
-		} else if m.IsDataUpdate() {
+		} else if IsDataMsg(m.GossipMessage) && m.GetDataMsg().Payload != nil {
+			gMsg = PayloadToString(m.GetDataMsg().Payload)
+		} else if IsDataUpdate(m.GossipMessage) {
 			update := m.GetDataUpdate()
-			gMsg = fmt.Sprintf("DataUpdate: %s", update.toString())
+			gMsg = fmt.Sprintf("DataUpdate: %s", DataUpdateToString(update))
 		} else if m.GetMemRes() != nil {
-			gMsg = m.GetMemRes().toString()
-		} else if m.IsStateInfoSnapshot() {
-			gMsg = m.GetStateSnapshot().toString()
+			gMsg = MembershipResponseToString(m.GetMemRes())
+		} else if IsStateInfoSnapshot(m.GossipMessage) {
+			gMsg = StateInfoSnapshotToString(m.GetStateSnapshot())
 		} else if m.GetPrivateRes() != nil {
-			gMsg = m.GetPrivateRes().ToString()
+			gMsg = RemovePvtDataResponseToString(m.GetPrivateRes())
+		} else if m.GetAliveMsg() != nil {
+			gMsg = AliveMessageToString(m.GetAliveMsg())
+		} else if m.GetMemReq() != nil {
+			gMsg = MembershipRequestToString(m.GetMemReq())
+		} else if m.GetStateInfoPullReq() != nil {
+			gMsg = StateInfoPullRequestToString(m.GetStateInfoPullReq())
+		} else if m.GetStateInfo() != nil {
+			gMsg = StateInfoToString(m.GetStateInfo())
+		} else if m.GetDataDig() != nil {
+			gMsg = DataDigestToString(m.GetDataDig())
+		} else if m.GetDataReq() != nil {
+			gMsg = DataRequestToString(m.GetDataReq())
+		} else if m.GetLeadershipMsg() != nil {
+			gMsg = LeadershipMessageToString(m.GetLeadershipMsg())
 		} else {
 			gMsg = m.GossipMessage.String()
 			isSimpleMsg = true
 		}
 		if !isSimpleMsg {
-			desc := fmt.Sprintf("Channel: %s, nonce: %d, tag: %s", string(m.Channel), m.Nonce, GossipMessage_Tag_name[int32(m.Tag)])
+			desc := fmt.Sprintf("Channel: %s, nonce: %d, tag: %s", string(m.Channel), m.Nonce, gossip.GossipMessage_Tag_name[int32(m.Tag)])
 			gMsg = fmt.Sprintf("%s %s", desc, gMsg)
 		}
 	}
 	return fmt.Sprintf("GossipMessage: %v, Envelope: %s", gMsg, env)
 }
 
-func (dd *DataRequest) FormattedDigests() []string {
-	if dd.MsgType == PullMsgType_IDENTITY_MSG {
+func FormattedDigestsFromDataRequest(dd *gossip.DataRequest) []string {
+	if dd.MsgType == gossip.PullMsgType_IDENTITY_MSG {
 		return digestsToHex(dd.Digests)
 	}
 
 	return digestsAsStrings(dd.Digests)
 }
 
-func (dd *DataDigest) FormattedDigests() []string {
-	if dd.MsgType == PullMsgType_IDENTITY_MSG {
+func FormattedDigests(dd *gossip.DataDigest) []string {
+	if dd.MsgType == gossip.PullMsgType_IDENTITY_MSG {
 		return digestsToHex(dd.Digests)
 	}
+
 	return digestsAsStrings(dd.Digests)
 }
 
 // Hash returns the SHA256 representation of the PvtDataDigest's bytes
-func (dig *PvtDataDigest) Hash() (string, error) {
+func Hash(dig *gossip.PvtDataDigest) (string, error) {
 	b, err := proto.Marshal(dig)
 	if err != nil {
 		return "", err
@@ -576,7 +575,7 @@ func (dig *PvtDataDigest) Hash() (string, error) {
 }
 
 // ToString returns a string representation of this RemotePvtDataResponse
-func (res *RemotePvtDataResponse) ToString() string {
+func ToString(res *gossip.RemotePvtDataResponse) string {
 	a := make([]string, len(res.Elements))
 	for i, el := range res.Elements {
 		a[i] = fmt.Sprintf("%s with %d elements", el.Digest.String(), len(el.Payload))
@@ -602,7 +601,7 @@ func digestsToHex(digests [][]byte) []string {
 
 // LedgerHeight returns the ledger height that is specified
 // in the StateInfo message
-func (msg *StateInfo) LedgerHeight() (uint64, error) {
+func LedgerHeight(msg *gossip.StateInfo) (uint64, error) {
 	if msg.Properties != nil {
 		return msg.Properties.LedgerHeight, nil
 	}
diff --git a/gossip/protoext/extensions_test.go b/gossip/protoext/extensions_test.go
new file mode 100644
index 000000000..0e76748d3
--- /dev/null
+++ b/gossip/protoext/extensions_test.go
@@ -0,0 +1,864 @@
+/*
+Copyright IBM Corp. 2017 All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package protoext
+
+import (
+	"errors"
+	"fmt"
+	"testing"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/protos/gossip"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestToGossipMessageNilEnvelope(t *testing.T) {
+	memReq := &gossip.MembershipRequest{}
+	_, err := EnvelopeToGossipMessage(memReq.SelfInformation)
+	assert.EqualError(t, err, "nil envelope")
+}
+
+func TestToString(t *testing.T) {
+	// Ensure we don't print the byte content when we
+	// log messages.
+	// Each payload or signature contains '2' so we would've logged
+	// them if not for the overloading of the String() method in SignedGossipMessage
+
+	// The following line proves that the envelopes constructed in this test
+	// have "2" in them when they are printed
+	assert.Contains(t, fmt.Sprintf("%v", envelopes()[0]), "2")
+	// and the following does the same for payloads:
+	dMsg := &gossip.DataMessage{
+		Payload: &gossip.Payload{
+			SeqNum: 3,
+			Data:   []byte{2, 2, 2, 2, 2},
+		},
+	}
+	assert.Contains(t, fmt.Sprintf("%v", dMsg), "2")
+
+	// Now we construct all types of messages that have envelopes or payloads in them
+	// and see that "2" is not outputted into their formatting even though it is found
+	// as a sub-message of the outer message.
+
+	sMsg := &SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Channel: []byte("A"),
+			Content: &gossip.GossipMessage_DataMsg{
+				DataMsg: &gossip.DataMessage{
+					Payload: &gossip.Payload{
+						SeqNum: 3,
+						Data:   []byte{2, 2, 2, 2, 2},
+					},
+				},
+			},
+		},
+		Envelope: &gossip.Envelope{
+			Payload:   []byte{0, 1, 2, 3, 4, 5, 6},
+			Signature: []byte{0, 1, 2},
+			SecretEnvelope: &gossip.SecretEnvelope{
+				Payload:   []byte{0, 1, 2, 3, 4, 5},
+				Signature: []byte{0, 1, 2},
+			},
+		},
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+	sMsg.GetDataMsg().Payload = nil
+	assert.NotPanics(t, func() {
+		_ = sMsg.String()
+	})
+
+	sMsg = &SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_DataUpdate{
+				DataUpdate: &gossip.DataUpdate{
+					Nonce:   11,
+					MsgType: gossip.PullMsgType_BLOCK_MSG,
+					Data:    envelopes(),
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_MemRes{
+				MemRes: &gossip.MembershipResponse{
+					Alive: envelopes(),
+					Dead:  envelopes(),
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_StateSnapshot{
+				StateSnapshot: &gossip.StateInfoSnapshot{
+					Elements: envelopes(),
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+
+	sMsg = &SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte("A"),
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Content: &gossip.GossipMessage_StateResponse{
+				StateResponse: &gossip.RemoteStateResponse{
+					Payloads: []*gossip.Payload{
+						{Data: []byte{2, 2, 2}},
+					},
+				},
+			},
+		},
+		Envelope: envelopes()[0],
+	}
+	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
+}
+
+func TestAliveMessageNoActionTaken(t *testing.T) {
+	comparator := NewGossipMessageComparator(1)
+
+	sMsg1 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, &gossip.GossipMessage_AliveMsg{
+		AliveMsg: &gossip.AliveMessage{
+			Membership: &gossip.Member{
+				Endpoint: "localhost",
+				Metadata: []byte{1, 2, 3, 4, 5},
+				PkiId:    []byte{17},
+			},
+			Timestamp: &gossip.PeerTime{
+				IncNum: 1,
+				SeqNum: 1,
+			},
+			Identity: []byte("peerID1"),
+		},
+	})
+
+	sMsg2 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, &gossip.GossipMessage_AliveMsg{
+		AliveMsg: &gossip.AliveMessage{
+			Membership: &gossip.Member{
+				Endpoint: "localhost",
+				Metadata: []byte{1, 2, 3, 4, 5},
+				PkiId:    []byte{15},
+			},
+			Timestamp: &gossip.PeerTime{
+				IncNum: 2,
+				SeqNum: 2,
+			},
+			Identity: []byte("peerID1"),
+		},
+	})
+
+	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageNoAction)
+}
+
+func TestStateInfoMessageNoActionTaken(t *testing.T) {
+	comparator := NewGossipMessageComparator(1)
+
+	// msg1 and msg2 have same channel mac, while different pkid, while
+	// msg and msg3 same pkid and different channel mac
+
+	sMsg1 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY,
+		stateInfoMessage(1, 1, []byte{17}, []byte{17, 13}))
+	sMsg2 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY,
+		stateInfoMessage(1, 1, []byte{13}, []byte{17, 13}))
+
+	// We only should compare comparable messages, e.g. message from same peer
+	// In any other cases no invalidation should be taken.
+	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageNoAction)
+}
+
+func TestStateInfoMessagesInvalidation(t *testing.T) {
+	comparator := NewGossipMessageComparator(1)
+
+	sMsg1 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY,
+		stateInfoMessage(1, 1, []byte{17}, []byte{17}))
+	sMsg2 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY,
+		stateInfoMessage(1, 1, []byte{17}, []byte{17}))
+	sMsg3 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY,
+		stateInfoMessage(1, 2, []byte{17}, []byte{17}))
+	sMsg4 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY,
+		stateInfoMessage(2, 1, []byte{17}, []byte{17}))
+
+	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageInvalidated)
+
+	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg3, sMsg1), common.MessageInvalidates)
+
+	assert.Equal(t, comparator(sMsg1, sMsg4), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg4, sMsg1), common.MessageInvalidates)
+
+	assert.Equal(t, comparator(sMsg3, sMsg4), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg4, sMsg3), common.MessageInvalidates)
+}
+
+func TestAliveMessageInvalidation(t *testing.T) {
+	comparator := NewGossipMessageComparator(1)
+
+	sMsg1 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, &gossip.GossipMessage_AliveMsg{
+		AliveMsg: &gossip.AliveMessage{
+			Membership: &gossip.Member{
+				Endpoint: "localhost",
+				Metadata: []byte{1, 2, 3, 4, 5},
+				PkiId:    []byte{17},
+			},
+			Timestamp: &gossip.PeerTime{
+				IncNum: 1,
+				SeqNum: 1,
+			},
+			Identity: []byte("peerID1"),
+		},
+	})
+
+	sMsg2 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, &gossip.GossipMessage_AliveMsg{
+		AliveMsg: &gossip.AliveMessage{
+			Membership: &gossip.Member{
+				Endpoint: "localhost",
+				Metadata: []byte{1, 2, 3, 4, 5},
+				PkiId:    []byte{17},
+			},
+			Timestamp: &gossip.PeerTime{
+				IncNum: 2,
+				SeqNum: 2,
+			},
+			Identity: []byte("peerID1"),
+		},
+	})
+
+	sMsg3 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, &gossip.GossipMessage_AliveMsg{
+		AliveMsg: &gossip.AliveMessage{
+			Membership: &gossip.Member{
+				Endpoint: "localhost",
+				Metadata: []byte{1, 2, 3, 4, 5},
+				PkiId:    []byte{17},
+			},
+			Timestamp: &gossip.PeerTime{
+				IncNum: 1,
+				SeqNum: 2,
+			},
+			Identity: []byte("peerID1"),
+		},
+	})
+
+	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg2, sMsg1), common.MessageInvalidates)
+	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg3, sMsg1), common.MessageInvalidates)
+}
+
+func TestDataMessageInvalidation(t *testing.T) {
+	comparator := NewGossipMessageComparator(5)
+
+	data := []byte{1, 1, 1}
+	sMsg1 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, dataMessage(1, data))
+	sMsg1Clone := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, dataMessage(1, data))
+	sMsg3 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, dataMessage(2, data))
+	sMsg4 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, dataMessage(7, data))
+
+	assert.Equal(t, comparator(sMsg1, sMsg1Clone), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageNoAction)
+	assert.Equal(t, comparator(sMsg1, sMsg4), common.MessageInvalidated)
+	assert.Equal(t, comparator(sMsg4, sMsg1), common.MessageInvalidates)
+}
+
+func TestIdentityMessagesInvalidation(t *testing.T) {
+	comparator := NewGossipMessageComparator(5)
+
+	msg1 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, &gossip.GossipMessage_PeerIdentity{
+		PeerIdentity: &gossip.PeerIdentity{
+			PkiId:    []byte{17},
+			Cert:     []byte{1, 2, 3, 4},
+			Metadata: nil,
+		},
+	})
+
+	msg2 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, &gossip.GossipMessage_PeerIdentity{
+		PeerIdentity: &gossip.PeerIdentity{
+			PkiId:    []byte{17},
+			Cert:     []byte{1, 2, 3, 4},
+			Metadata: nil,
+		},
+	})
+
+	msg3 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, &gossip.GossipMessage_PeerIdentity{
+		PeerIdentity: &gossip.PeerIdentity{
+			PkiId:    []byte{11},
+			Cert:     []byte{11, 21, 31, 41},
+			Metadata: nil,
+		},
+	})
+
+	assert.Equal(t, comparator(msg1, msg2), common.MessageInvalidated)
+	assert.Equal(t, comparator(msg1, msg3), common.MessageNoAction)
+}
+
+func TestLeadershipMessagesNoAction(t *testing.T) {
+	comparator := NewGossipMessageComparator(5)
+
+	msg1 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, leadershipMessage(1, 1, []byte{17}))
+	msg2 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, leadershipMessage(1, 1, []byte{11}))
+
+	// If message with different pkid's no action should be taken
+	assert.Equal(t, comparator(msg1, msg2), common.MessageNoAction)
+}
+
+func TestLeadershipMessagesInvalidation(t *testing.T) {
+	comparator := NewGossipMessageComparator(5)
+
+	pkiID := []byte{17}
+	msg1 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, leadershipMessage(1, 1, pkiID))
+	msg2 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, leadershipMessage(1, 2, pkiID))
+	msg3 := signedGossipMessage("testChannel", gossip.GossipMessage_EMPTY, leadershipMessage(2, 1, pkiID))
+
+	// If message with different pkid's no action should be taken
+	assert.Equal(t, comparator(msg1, msg2), common.MessageInvalidated)
+	assert.Equal(t, comparator(msg2, msg1), common.MessageInvalidates)
+	assert.Equal(t, comparator(msg1, msg3), common.MessageInvalidated)
+	assert.Equal(t, comparator(msg3, msg1), common.MessageInvalidates)
+	assert.Equal(t, comparator(msg2, msg3), common.MessageInvalidated)
+	assert.Equal(t, comparator(msg3, msg2), common.MessageInvalidates)
+}
+
+func TestCheckGossipMessageTypes(t *testing.T) {
+	var msg *SignedGossipMessage
+	channelID := "testID1"
+
+	// Create State info pull request
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_StateInfoPullReq{
+		StateInfoPullReq: &gossip.StateInfoPullRequest{
+			Channel_MAC: []byte{17},
+		},
+	})
+
+	assert.True(t, IsStateInfoPullRequestMsg(msg.GossipMessage))
+
+	// Create alive message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_AliveMsg{
+		AliveMsg: &gossip.AliveMessage{
+			Identity: []byte("peerID"),
+			Membership: &gossip.Member{
+				PkiId:    []byte("pkiID"),
+				Metadata: []byte{17},
+				Endpoint: "localhost",
+			},
+			Timestamp: &gossip.PeerTime{
+				SeqNum: 1,
+				IncNum: 1,
+			},
+		},
+	})
+
+	assert.True(t, IsAliveMsg(msg.GossipMessage))
+
+	// Create gossip data message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, dataMessage(1, []byte{1, 2, 3, 4, 5}))
+	assert.True(t, IsDataMsg(msg.GossipMessage))
+
+	// Create data request message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataReq{
+		DataReq: &gossip.DataRequest{
+			MsgType: gossip.PullMsgType_UNDEFINED,
+			Nonce:   0,
+			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		},
+	})
+	assert.True(t, IsDataReq(msg.GossipMessage))
+	assert.True(t, IsPullMsg(msg.GossipMessage))
+
+	// Create data request message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataDig{
+		DataDig: &gossip.DataDigest{
+			MsgType: gossip.PullMsgType_UNDEFINED,
+			Nonce:   0,
+			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		},
+	})
+	assert.True(t, IsDigestMsg(msg.GossipMessage))
+	assert.True(t, IsPullMsg(msg.GossipMessage))
+
+	// Create data update message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataUpdate{
+		DataUpdate: &gossip.DataUpdate{
+			MsgType: gossip.PullMsgType_UNDEFINED,
+			Nonce:   0,
+			Data:    []*gossip.Envelope{envelopes()[0]},
+		},
+	})
+	assert.True(t, IsDataUpdate(msg.GossipMessage))
+	assert.True(t, IsPullMsg(msg.GossipMessage))
+
+	// Create gossip hello message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_Hello{
+		Hello: &gossip.GossipHello{
+			MsgType: gossip.PullMsgType_UNDEFINED,
+			Nonce:   0,
+		},
+	})
+	assert.True(t, IsHelloMsg(msg.GossipMessage))
+	assert.True(t, IsPullMsg(msg.GossipMessage))
+
+	// Create state request message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_StateRequest{
+		StateRequest: &gossip.RemoteStateRequest{
+			StartSeqNum: 1,
+			EndSeqNum:   10,
+		},
+	})
+	assert.True(t, IsRemoteStateMessage(msg.GossipMessage))
+
+	// Create state response message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_StateResponse{
+		StateResponse: &gossip.RemoteStateResponse{
+			Payloads: []*gossip.Payload{{
+				SeqNum: 1,
+				Data:   []byte{1, 2, 3, 4, 5},
+			}},
+		},
+	})
+	assert.True(t, IsRemoteStateMessage(msg.GossipMessage))
+}
+
+func TestGossipPullMessageType(t *testing.T) {
+	var msg *SignedGossipMessage
+	channelID := "testID1"
+
+	// Create gossip hello message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_Hello{
+		Hello: &gossip.GossipHello{
+			MsgType: gossip.PullMsgType_BLOCK_MSG,
+			Nonce:   0,
+		},
+	})
+
+	assert.True(t, IsHelloMsg(msg.GossipMessage))
+	assert.True(t, IsPullMsg(msg.GossipMessage))
+	assert.Equal(t, GetPullMsgType(msg.GossipMessage), gossip.PullMsgType_BLOCK_MSG)
+
+	// Create data request message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataDig{
+		DataDig: &gossip.DataDigest{
+			MsgType: gossip.PullMsgType_IDENTITY_MSG,
+			Nonce:   0,
+			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		},
+	})
+	assert.True(t, IsDigestMsg(msg.GossipMessage))
+	assert.True(t, IsPullMsg(msg.GossipMessage))
+	assert.Equal(t, GetPullMsgType(msg.GossipMessage), gossip.PullMsgType_IDENTITY_MSG)
+
+	// Create data request message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataReq{
+		DataReq: &gossip.DataRequest{
+			MsgType: gossip.PullMsgType_BLOCK_MSG,
+			Nonce:   0,
+			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		},
+	})
+	assert.True(t, IsDataReq(msg.GossipMessage))
+	assert.True(t, IsPullMsg(msg.GossipMessage))
+	assert.Equal(t, GetPullMsgType(msg.GossipMessage), gossip.PullMsgType_BLOCK_MSG)
+
+	// Create data update message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataUpdate{
+		DataUpdate: &gossip.DataUpdate{
+			MsgType: gossip.PullMsgType_IDENTITY_MSG,
+			Nonce:   0,
+			Data:    []*gossip.Envelope{envelopes()[0]},
+		},
+	})
+	assert.True(t, IsDataUpdate(msg.GossipMessage))
+	assert.True(t, IsPullMsg(msg.GossipMessage))
+	assert.Equal(t, GetPullMsgType(msg.GossipMessage), gossip.PullMsgType_IDENTITY_MSG)
+
+	// Create gossip data message
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, dataMessage(1, []byte{1, 2, 3, 4, 5}))
+	assert.True(t, IsDataMsg(msg.GossipMessage))
+	assert.Equal(t, GetPullMsgType(msg.GossipMessage), gossip.PullMsgType_UNDEFINED)
+}
+
+func TestGossipMessageDataMessageTagType(t *testing.T) {
+	var msg *SignedGossipMessage
+	channelID := "testID1"
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_AND_ORG, dataMessage(1, []byte{1}))
+	assert.True(t, IsChannelRestricted(msg.GossipMessage))
+	assert.True(t, IsOrgRestricted(msg.GossipMessage))
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, dataMessage(1, []byte{1}))
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_UNDEFINED, dataMessage(1, []byte{1}))
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_ORG_ONLY, dataMessage(1, []byte{1}))
+	assert.False(t, IsChannelRestricted(msg.GossipMessage))
+	assert.True(t, IsOrgRestricted(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_OR_ORG, dataMessage(1, []byte{1}))
+	assert.True(t, IsChannelRestricted(msg.GossipMessage))
+	assert.False(t, IsOrgRestricted(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, dataMessage(1, []byte{1}))
+	assert.False(t, IsChannelRestricted(msg.GossipMessage))
+	assert.False(t, IsOrgRestricted(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_UNDEFINED, dataMessage(1, []byte{1}))
+	assert.False(t, IsChannelRestricted(msg.GossipMessage))
+	assert.False(t, IsOrgRestricted(msg.GossipMessage))
+}
+
+func TestGossipMessageAliveMessageTagType(t *testing.T) {
+	var msg *SignedGossipMessage
+	channelID := "testID1"
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_AliveMsg{
+		AliveMsg: &gossip.AliveMessage{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_ORG_ONLY, &gossip.GossipMessage_AliveMsg{
+		AliveMsg: &gossip.AliveMessage{},
+	})
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+}
+
+func TestGossipMessageMembershipMessageTagType(t *testing.T) {
+	var msg *SignedGossipMessage
+	channelID := "testID1"
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_MemReq{
+		MemReq: &gossip.MembershipRequest{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_MemRes{
+		MemRes: &gossip.MembershipResponse{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+}
+
+func TestGossipMessageIdentityMessageTagType(t *testing.T) {
+	var msg *SignedGossipMessage
+	channelID := "testID1"
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_ORG_ONLY, &gossip.GossipMessage_PeerIdentity{
+		PeerIdentity: &gossip.PeerIdentity{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_PeerIdentity{
+		PeerIdentity: &gossip.PeerIdentity{},
+	})
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+}
+
+func TestGossipMessagePullMessageTagType(t *testing.T) {
+	var msg *SignedGossipMessage
+	channelID := "testID1"
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_AND_ORG, &gossip.GossipMessage_DataReq{
+		DataReq: &gossip.DataRequest{
+			MsgType: gossip.PullMsgType_BLOCK_MSG,
+		},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataReq{
+		DataReq: &gossip.DataRequest{
+			MsgType: gossip.PullMsgType_BLOCK_MSG,
+		},
+	})
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataDig{
+		DataDig: &gossip.DataDigest{
+			MsgType: gossip.PullMsgType_IDENTITY_MSG,
+		},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_ORG_ONLY, &gossip.GossipMessage_DataDig{
+		DataDig: &gossip.DataDigest{
+			MsgType: gossip.PullMsgType_IDENTITY_MSG,
+		},
+	})
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_ORG_ONLY, &gossip.GossipMessage_DataDig{
+		DataDig: &gossip.DataDigest{
+			MsgType: gossip.PullMsgType_UNDEFINED,
+		},
+	})
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+}
+
+func TestGossipMessageStateInfoMessageTagType(t *testing.T) {
+	var msg *SignedGossipMessage
+	channelID := "testID1"
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_OR_ORG, &gossip.GossipMessage_StateInfo{
+		StateInfo: &gossip.StateInfo{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_OR_ORG, &gossip.GossipMessage_StateInfoPullReq{
+		StateInfoPullReq: &gossip.StateInfoPullRequest{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_OR_ORG, &gossip.GossipMessage_StateResponse{
+		StateResponse: &gossip.RemoteStateResponse{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_OR_ORG, &gossip.GossipMessage_StateRequest{
+		StateRequest: &gossip.RemoteStateRequest{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_OR_ORG, &gossip.GossipMessage_StateSnapshot{
+		StateSnapshot: &gossip.StateInfoSnapshot{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_StateInfo{
+		StateInfo: &gossip.StateInfo{},
+	})
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+}
+
+func TestGossipMessageLeadershipMessageTagType(t *testing.T) {
+	var msg *SignedGossipMessage
+	channelID := "testID1"
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_AND_ORG, &gossip.GossipMessage_LeadershipMsg{
+		LeadershipMsg: &gossip.LeadershipMessage{},
+	})
+	assert.NoError(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_OR_ORG, &gossip.GossipMessage_LeadershipMsg{
+		LeadershipMsg: &gossip.LeadershipMessage{},
+	})
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_CHAN_OR_ORG, &gossip.GossipMessage_Empty{})
+	assert.Error(t, IsTagLegal(msg.GossipMessage))
+}
+
+func TestGossipMessageSign(t *testing.T) {
+	idSigner := func(msg []byte) ([]byte, error) {
+		return msg, nil
+	}
+
+	errSigner := func(msg []byte) ([]byte, error) {
+		return nil, errors.New("Error")
+	}
+
+	msg := signedGossipMessage("testChannelID", gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataMsg{
+		DataMsg: &gossip.DataMessage{},
+	})
+
+	signedMsg, _ := msg.Sign(idSigner)
+
+	// Since checking the identity signer, signature will be same as the payload
+	assert.Equal(t, signedMsg.Payload, signedMsg.Signature)
+
+	env, err := msg.Sign(errSigner)
+	assert.Error(t, err)
+	assert.Nil(t, env)
+}
+
+func TestEnvelope_NoopSign(t *testing.T) {
+	channelID := "testChannelID"
+	msg := signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataMsg{
+		DataMsg: &gossip.DataMessage{},
+	})
+
+	signedMsg, err := NoopSign(msg.GossipMessage)
+
+	// Since checking the identity signer, signature will be same as the payload
+	assert.Nil(t, signedMsg.Signature)
+	assert.NoError(t, err)
+}
+
+func TestSignedGossipMessage_Verify(t *testing.T) {
+	channelID := "testChannelID"
+	peerID := []byte("peer")
+	msg := signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataMsg{
+		DataMsg: &gossip.DataMessage{},
+	})
+
+	assert.True(t, msg.IsSigned())
+
+	verifier := func(peerIdentity []byte, signature, message []byte) error {
+		return nil
+	}
+
+	res := msg.Verify(peerID, verifier)
+	assert.Nil(t, res)
+
+	msg = signedGossipMessage(channelID, gossip.GossipMessage_EMPTY, &gossip.GossipMessage_DataMsg{
+		DataMsg: &gossip.DataMessage{},
+	})
+
+	env := msg.Envelope
+	msg.Envelope = nil
+	res = msg.Verify(peerID, verifier)
+	assert.Error(t, res)
+
+	msg.Envelope = env
+	payload := msg.Envelope.Payload
+	msg.Envelope.Payload = nil
+	res = msg.Verify(peerID, verifier)
+	assert.Error(t, res)
+
+	msg.Envelope.Payload = payload
+	sig := msg.Signature
+	msg.Signature = nil
+	res = msg.Verify(peerID, verifier)
+	assert.Error(t, res)
+	msg.Signature = sig
+
+	errVerifier := func(peerIdentity []byte, signature, message []byte) error {
+		return errors.New("Test")
+	}
+
+	res = msg.Verify(peerID, errVerifier)
+	assert.Error(t, res)
+}
+
+func TestEnvelope(t *testing.T) {
+	dataMsg := &gossip.GossipMessage{
+		Content: dataMessage(1, []byte("data")),
+	}
+	bytes, err := proto.Marshal(dataMsg)
+	assert.NoError(t, err)
+
+	env := envelopes()[0]
+	env.Payload = bytes
+
+	msg, err := EnvelopeToGossipMessage(env)
+	assert.NoError(t, err)
+	assert.NotNil(t, msg)
+
+	assert.True(t, IsDataMsg(msg.GossipMessage))
+}
+
+func TestEnvelope_SignSecret(t *testing.T) {
+	dataMsg := &gossip.GossipMessage{
+		Content: dataMessage(1, []byte("data")),
+	}
+	bytes, err := proto.Marshal(dataMsg)
+	assert.NoError(t, err)
+
+	env := envelopes()[0]
+	env.Payload = bytes
+	env.SecretEnvelope = nil
+
+	SignSecret(env, func(message []byte) ([]byte, error) {
+		return message, nil
+	}, &gossip.Secret{
+		Content: &gossip.Secret_InternalEndpoint{
+			InternalEndpoint: "localhost:5050",
+		},
+	})
+
+	assert.NotNil(t, env.SecretEnvelope)
+	assert.Equal(t, InternalEndpoint(env.SecretEnvelope), "localhost:5050")
+}
+
+func envelopes() []*gossip.Envelope {
+	return []*gossip.Envelope{
+		{Payload: []byte{2, 2, 2},
+			Signature: []byte{2, 2, 2},
+			SecretEnvelope: &gossip.SecretEnvelope{
+				Payload:   []byte{2, 2, 2},
+				Signature: []byte{2, 2, 2},
+			},
+		},
+	}
+}
+
+func leadershipMessage(incNum uint64, seqNum uint64, pkid []byte) *gossip.GossipMessage_LeadershipMsg {
+	return &gossip.GossipMessage_LeadershipMsg{
+		LeadershipMsg: &gossip.LeadershipMessage{
+			PkiId:         pkid,
+			IsDeclaration: false,
+			Timestamp: &gossip.PeerTime{
+				IncNum: incNum,
+				SeqNum: seqNum,
+			},
+		},
+	}
+}
+
+func stateInfoMessage(incNum uint64, seqNum uint64, pkid []byte, mac []byte) *gossip.GossipMessage_StateInfo {
+	return &gossip.GossipMessage_StateInfo{
+		StateInfo: &gossip.StateInfo{
+			Timestamp: &gossip.PeerTime{
+				IncNum: incNum,
+				SeqNum: seqNum,
+			},
+			PkiId:       pkid,
+			Channel_MAC: mac,
+		},
+	}
+}
+
+func dataMessage(seqNum uint64, data []byte) *gossip.GossipMessage_DataMsg {
+	return &gossip.GossipMessage_DataMsg{
+		DataMsg: &gossip.DataMessage{
+			Payload: &gossip.Payload{
+				SeqNum: seqNum,
+				Data:   data,
+			},
+		},
+	}
+}
+
+func signedGossipMessage(channelID string, tag gossip.GossipMessage_Tag, content gossip.IsGossipMessage_Content) *SignedGossipMessage {
+	return &SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Channel: []byte(channelID),
+			Tag:     tag,
+			Nonce:   0,
+			Content: content,
+		},
+		Envelope: envelopes()[0],
+	}
+}
diff --git a/gossip/protoext/stringers.go b/gossip/protoext/stringers.go
new file mode 100644
index 000000000..80b584cc8
--- /dev/null
+++ b/gossip/protoext/stringers.go
@@ -0,0 +1,124 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext
+
+import (
+	"encoding/hex"
+	"fmt"
+
+	"github.com/gogo/protobuf/proto"
+	"github.com/hyperledger/fabric/protos/gossip"
+	"github.com/hyperledger/fabric/protos/msp"
+)
+
+// MemberToString prints Endpoint and PKI-id
+func MemberToString(m *gossip.Member) string {
+	return fmt.Sprint("Membership: Endpoint:", m.Endpoint, " PKI-id:", hex.EncodeToString(m.PkiId))
+}
+
+// MembershipResponseToString of MembershipResponse prints number of Alive and number of Dead
+func MembershipResponseToString(mr *gossip.MembershipResponse) string {
+	return fmt.Sprintf("MembershipResponse with Alive: %d, Dead: %d", len(mr.Alive), len(mr.Dead))
+}
+
+// AliveMessageToString of AliveMessage prints Alive Message, Identity and Timestamp
+func AliveMessageToString(am *gossip.AliveMessage) string {
+	if am.Membership == nil {
+		return "nil Membership"
+	}
+	var sI string
+	serializeIdentity := &msp.SerializedIdentity{}
+	if err := proto.Unmarshal(am.Identity, serializeIdentity); err == nil {
+		sI = serializeIdentity.Mspid + string(serializeIdentity.IdBytes)
+	}
+	return fmt.Sprint("Alive Message:", MemberToString(am.Membership), "Identity:", sI, "Timestamp:", am.Timestamp)
+}
+
+// PayloadToString prints Block message: Data and seq
+func PayloadToString(p *gossip.Payload) string {
+	return fmt.Sprintf("Block message: {Data: %d bytes, seq: %d}", len(p.Data), p.SeqNum)
+}
+
+// DataUpdateToString prints Type, items and nonce
+func DataUpdateToString(du *gossip.DataUpdate) string {
+	mType := gossip.PullMsgType_name[int32(du.MsgType)]
+	return fmt.Sprintf("Type: %s, items: %d, nonce: %d", mType, len(du.Data), du.Nonce)
+}
+
+// StateInfoSnapshotToString prints items
+func StateInfoSnapshotToString(sis *gossip.StateInfoSnapshot) string {
+	return fmt.Sprintf("StateInfoSnapshot with %d items", len(sis.Elements))
+}
+
+// MembershipRequestToString prints self information
+func MembershipRequestToString(mr *gossip.MembershipRequest) string {
+	if mr.SelfInformation == nil {
+		return ""
+	}
+	signGM, err := EnvelopeToGossipMessage(mr.SelfInformation)
+	if err != nil {
+		return ""
+	}
+	return fmt.Sprintf("Membership Request with self information of %s ", signGM.String())
+}
+
+// StateInfoPullRequestToString prints Channel MAC
+func StateInfoPullRequestToString(sipr *gossip.StateInfoPullRequest) string {
+	return fmt.Sprint("state_info_pull_req: Channel MAC:", hex.EncodeToString(sipr.Channel_MAC))
+}
+
+// StateInfoToString prints Timestamp and PKI-id
+func StateInfoToString(si *gossip.StateInfo) string {
+	return fmt.Sprint("state_info_message: Timestamp:", si.Timestamp, "PKI-id:", hex.EncodeToString(si.PkiId),
+		" channel MAC:", hex.EncodeToString(si.Channel_MAC), " properties:", si.Properties)
+}
+
+// formatDigests formats digest byte arrays into strings depending on the message type
+func formatDigests(msgType gossip.PullMsgType, givenDigests [][]byte) []string {
+	var digests []string
+	switch msgType {
+	case gossip.PullMsgType_BLOCK_MSG:
+		for _, digest := range givenDigests {
+			digests = append(digests, string(digest))
+		}
+	case gossip.PullMsgType_IDENTITY_MSG:
+		for _, digest := range givenDigests {
+			digests = append(digests, hex.EncodeToString(digest))
+		}
+
+	}
+	return digests
+}
+
+// DataDigestToString prints nonce, msg_type and digests
+func DataDigestToString(dig *gossip.DataDigest) string {
+	var digests []string
+	digests = formatDigests(dig.MsgType, dig.Digests)
+	return fmt.Sprintf("data_dig: nonce: %d , Msg_type: %s, digests: %v", dig.Nonce, dig.MsgType, digests)
+}
+
+// DataRequestToString prints nonce, msg_type and digests
+func DataRequestToString(dataReq *gossip.DataRequest) string {
+	var digests []string
+	digests = formatDigests(dataReq.MsgType, dataReq.Digests)
+	return fmt.Sprintf("data request: nonce: %d , Msg_type: %s, digests: %v", dataReq.Nonce, dataReq.MsgType, digests)
+}
+
+// LeadershipMessageToString prints PKI-id, Timestamp and Is Declaration
+func LeadershipMessageToString(lm *gossip.LeadershipMessage) string {
+	return fmt.Sprint("Leadership Message: PKI-id:", hex.EncodeToString(lm.PkiId), " Timestamp:", lm.Timestamp,
+		"Is Declaration ", lm.IsDeclaration)
+}
+
+// RemovePvtDataResponseToString returns a string representation of this RemotePvtDataResponse
+func RemovePvtDataResponseToString(res *gossip.RemotePvtDataResponse) string {
+	a := make([]string, len(res.Elements))
+	for i, el := range res.Elements {
+		a[i] = fmt.Sprintf("%s with %d elements", el.Digest.String(), len(el.Payload))
+	}
+	return fmt.Sprintf("%v", a)
+}
diff --git a/gossip/protoext/stringers_test.go b/gossip/protoext/stringers_test.go
new file mode 100644
index 000000000..cf51a51d4
--- /dev/null
+++ b/gossip/protoext/stringers_test.go
@@ -0,0 +1,210 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+
+package protoext_test
+
+import (
+	"testing"
+
+	"github.com/hyperledger/fabric/gossip/protoext"
+	"github.com/hyperledger/fabric/protos/gossip"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestMembershipResponseToString(t *testing.T) {
+	mr := &gossip.MembershipResponse{
+		Alive: []*gossip.Envelope{{}},
+		Dead:  []*gossip.Envelope{{}},
+	}
+	output := "MembershipResponse with Alive: 1, Dead: 1"
+	assert.Equal(t, output, protoext.MembershipResponseToString(mr))
+}
+
+func TestMembershipRequestToString(t *testing.T) {
+	gossipMessage := &gossip.GossipMessage{
+		Nonce:   5,
+		Channel: []byte("A"),
+		Tag:     0,
+		Content: &gossip.GossipMessage_DataMsg{
+			DataMsg: &gossip.DataMessage{
+				Payload: &gossip.Payload{
+					SeqNum: 3,
+					Data:   []byte{2, 2, 2, 2, 2},
+				},
+			},
+		},
+	}
+	nn, _ := protoext.NoopSign(gossipMessage)
+	sMsg := &protoext.SignedGossipMessage{
+		GossipMessage: &gossip.GossipMessage{
+			Tag:     gossip.GossipMessage_EMPTY,
+			Nonce:   5,
+			Channel: []byte("A"),
+			Content: &gossip.GossipMessage_DataMsg{
+				DataMsg: &gossip.DataMessage{
+					Payload: &gossip.Payload{
+						SeqNum: 3,
+						Data:   []byte{2, 2, 2, 2, 2},
+					},
+				},
+			},
+		},
+		Envelope: &gossip.Envelope{
+			Payload:   nn.Envelope.Payload,
+			Signature: []byte{0, 1, 2},
+			SecretEnvelope: &gossip.SecretEnvelope{
+				Payload:   []byte{0, 1, 2, 3, 4, 5},
+				Signature: []byte{0, 1, 2},
+			},
+		},
+	}
+	mr := &gossip.MembershipRequest{
+		SelfInformation: sMsg.Envelope,
+		Known:           [][]byte{},
+	}
+
+	output := "Membership Request with self information of GossipMessage: Channel: A, nonce: 5, tag: UNDEFINED Block message: {Data: 5 bytes, seq: 3}, Envelope: 18 bytes, Signature: 3 bytes Secret payload: 6 bytes, Secret Signature: 3 bytes "
+	assert.Equal(t, output, protoext.MembershipRequestToString(mr))
+
+	mr1 := &gossip.MembershipRequest{
+		SelfInformation: &gossip.Envelope{
+			Payload:   []byte{1, 2, 3},
+			Signature: []byte{0, 1, 2},
+			SecretEnvelope: &gossip.SecretEnvelope{
+				Payload:   []byte{0, 1, 2, 3, 4, 5},
+				Signature: []byte{0, 1, 2},
+			},
+		},
+		Known: [][]byte{},
+	}
+	assert.Equal(t, "", protoext.MembershipRequestToString(mr1))
+
+	mr2 := &gossip.MembershipRequest{
+		SelfInformation: nil,
+		Known:           [][]byte{},
+	}
+
+	assert.Equal(t, "", protoext.MembershipRequestToString(mr2))
+}
+
+func TestToStringMember(t *testing.T) {
+	member := &gossip.Member{
+		Endpoint: "localhost",
+		Metadata: []byte{1, 2, 3, 4, 5},
+		PkiId:    []byte{15},
+	}
+	output := "Membership: Endpoint:localhost PKI-id:0f"
+	assert.Equal(t, output, protoext.MemberToString(member))
+}
+
+func TestToStringAliveMessage(t *testing.T) {
+	am1 := &gossip.AliveMessage{
+		Membership: &gossip.Member{
+			Endpoint: "localhost",
+			Metadata: []byte{1, 2, 3, 4, 5},
+			PkiId:    []byte{17},
+		},
+		Timestamp: &gossip.PeerTime{
+			IncNum: 1,
+			SeqNum: 1,
+		},
+		Identity: []byte("peerID1"),
+	}
+	output1 := "Alive Message:Membership: Endpoint:localhost PKI-id:11Identity:Timestamp:inc_num:1 seq_num:1 "
+	assert.Equal(t, output1, protoext.AliveMessageToString(am1))
+	am2 := &gossip.AliveMessage{
+		Membership: nil,
+		Timestamp: &gossip.PeerTime{
+			IncNum: 1,
+			SeqNum: 1,
+		},
+		Identity: []byte("peerID1"),
+	}
+	output2 := "nil Membership"
+	assert.Equal(t, output2, protoext.AliveMessageToString(am2))
+}
+
+func TestToStringStateInfoPullRequest(t *testing.T) {
+	// Create State info pull request
+	sipr := &gossip.StateInfoPullRequest{
+		Channel_MAC: []byte{17},
+	}
+
+	output := "state_info_pull_req: Channel MAC:11"
+	assert.Equal(t, output, protoext.StateInfoPullRequestToString(sipr))
+}
+
+func TestToStringStateInfo(t *testing.T) {
+	si := &gossip.StateInfo{
+		Timestamp: &gossip.PeerTime{
+			IncNum: 1,
+			SeqNum: 1,
+		},
+		PkiId:       []byte{17},
+		Channel_MAC: []byte{17},
+		Properties:  nil,
+	}
+	output := "state_info_message: Timestamp:inc_num:1 seq_num:1 PKI-id:11 channel MAC:11 properties:<nil>"
+	assert.Equal(t, output, protoext.StateInfoToString(si))
+}
+
+func TestToStringDataDigest(t *testing.T) {
+	dig1 := &gossip.DataDigest{
+		Nonce:   0,
+		Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		MsgType: gossip.PullMsgType_BLOCK_MSG,
+	}
+	output1 := "data_dig: nonce: 0 , Msg_type: BLOCK_MSG, digests: [msg1 msg2 msg3]"
+	assert.Equal(t, output1, protoext.DataDigestToString(dig1))
+	dig2 := &gossip.DataDigest{
+		Nonce:   0,
+		Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		MsgType: gossip.PullMsgType_IDENTITY_MSG,
+	}
+	output2 := "data_dig: nonce: 0 , Msg_type: IDENTITY_MSG, digests: [6d736731 6d736732 6d736733]"
+	assert.Equal(t, output2, protoext.DataDigestToString(dig2))
+}
+
+func TestToStringDataRequest(t *testing.T) {
+	dataReq1 := &gossip.DataRequest{
+		Nonce:   0,
+		Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		MsgType: gossip.PullMsgType_BLOCK_MSG,
+	}
+	output1 := "data request: nonce: 0 , Msg_type: BLOCK_MSG, digests: [msg1 msg2 msg3]"
+	assert.Equal(t, output1, protoext.DataRequestToString(dataReq1))
+	dataReq2 := &gossip.DataRequest{
+		Nonce:   0,
+		Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
+		MsgType: gossip.PullMsgType_IDENTITY_MSG,
+	}
+	output2 := "data request: nonce: 0 , Msg_type: IDENTITY_MSG, digests: [6d736731 6d736732 6d736733]"
+	assert.Equal(t, output2, protoext.DataRequestToString(dataReq2))
+}
+
+func TestToStringLeadershipMessage(t *testing.T) {
+	lm := &gossip.LeadershipMessage{
+		Timestamp: &gossip.PeerTime{
+			IncNum: 1,
+			SeqNum: 1,
+		},
+		PkiId:         []byte{17},
+		IsDeclaration: true,
+	}
+	output := "Leadership Message: PKI-id:11 Timestamp:inc_num:1 seq_num:1 Is Declaration true"
+	assert.Equal(t, output, protoext.LeadershipMessageToString(lm))
+}
+
+func TestRemotePvtDataResponseToString(t *testing.T) {
+	res := &gossip.RemotePvtDataResponse{
+		Elements: []*gossip.PvtDataElement{
+			{Digest: &gossip.PvtDataDigest{TxId: "tx-id"}, Payload: [][]byte{[]byte("abcde")}},
+		},
+	}
+
+	output := `[tx_id:"tx-id"  with 1 elements]`
+	assert.Equal(t, output, protoext.RemovePvtDataResponseToString(res))
+}
diff --git a/gossip/service/join_test.go b/gossip/service/join_test.go
index 410cbec10..3c19c9d7b 100644
--- a/gossip/service/join_test.go
+++ b/gossip/service/join_test.go
@@ -18,6 +18,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/filter"
 	"github.com/hyperledger/fabric/gossip/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/hyperledger/fabric/protos/peer"
@@ -40,7 +41,7 @@ type gossipMock struct {
 	mock.Mock
 }
 
-func (g *gossipMock) SelfChannelInfo(common.ChainID) *proto.SignedGossipMessage {
+func (g *gossipMock) SelfChannelInfo(common.ChainID) *protoext.SignedGossipMessage {
 	panic("implement me")
 }
 
@@ -88,7 +89,7 @@ func (*gossipMock) Gossip(msg *proto.GossipMessage) {
 	panic("implement me")
 }
 
-func (*gossipMock) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (*gossipMock) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	panic("implement me")
 }
 
@@ -108,7 +109,7 @@ func (*gossipMock) Stop() {
 	panic("implement me")
 }
 
-func (*gossipMock) SendByCriteria(*proto.SignedGossipMessage, gossip.SendCriteria) error {
+func (*gossipMock) SendByCriteria(*protoext.SignedGossipMessage, gossip.SendCriteria) error {
 	panic("implement me")
 }
 
diff --git a/gossip/state/metrics_test.go b/gossip/state/metrics_test.go
index 9124be276..3a57ad924 100644
--- a/gossip/state/metrics_test.go
+++ b/gossip/state/metrics_test.go
@@ -13,6 +13,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
 	gmetricsmocks "github.com/hyperledger/fabric/gossip/metrics/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/state/mocks"
 	pcomm "github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
@@ -30,7 +31,7 @@ func TestMetrics(t *testing.T) {
 	g := &mocks.GossipMock{}
 	g.On("PeersOfChannel", mock.Anything).Return([]discovery.NetworkMember{})
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 
 	heightWG := sync.WaitGroup{}
 	heightWG.Add(1)
diff --git a/gossip/state/mocks/gossip.go b/gossip/state/mocks/gossip.go
index 1aafdbb4c..be8911b92 100644
--- a/gossip/state/mocks/gossip.go
+++ b/gossip/state/mocks/gossip.go
@@ -13,6 +13,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/filter"
 	"github.com/hyperledger/fabric/gossip/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/mock"
 )
@@ -25,7 +26,7 @@ func (g *GossipMock) SelfMembershipInfo() discovery.NetworkMember {
 	panic("implement me")
 }
 
-func (g *GossipMock) SelfChannelInfo(common.ChainID) *proto.SignedGossipMessage {
+func (g *GossipMock) SelfChannelInfo(common.ChainID) *protoext.SignedGossipMessage {
 	panic("implement me")
 }
 
@@ -74,10 +75,10 @@ func (g *GossipMock) Gossip(msg *proto.GossipMessage) {
 	g.Called(msg)
 }
 
-func (g *GossipMock) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage) {
+func (g *GossipMock) Accept(acceptor common.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage) {
 	args := g.Called(acceptor, passThrough)
 	if args.Get(0) == nil {
-		return nil, args.Get(1).(chan proto.ReceivedMessage)
+		return nil, args.Get(1).(chan protoext.ReceivedMessage)
 	}
 	return args.Get(0).(<-chan *proto.GossipMessage), nil
 }
@@ -94,6 +95,6 @@ func (g *GossipMock) Stop() {
 
 }
 
-func (g *GossipMock) SendByCriteria(*proto.SignedGossipMessage, gossip.SendCriteria) error {
+func (g *GossipMock) SendByCriteria(*protoext.SignedGossipMessage, gossip.SendCriteria) error {
 	return nil
 }
diff --git a/gossip/state/state.go b/gossip/state/state.go
index 0b99bdeec..a905a9dfb 100644
--- a/gossip/state/state.go
+++ b/gossip/state/state.go
@@ -19,6 +19,7 @@ import (
 	common2 "github.com/hyperledger/fabric/gossip/common"
 	"github.com/hyperledger/fabric/gossip/discovery"
 	"github.com/hyperledger/fabric/gossip/metrics"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/util"
 	"github.com/hyperledger/fabric/protos/common"
 	proto "github.com/hyperledger/fabric/protos/gossip"
@@ -74,7 +75,7 @@ type GossipAdapter interface {
 	// If passThrough is false, the messages are processed by the gossip layer beforehand.
 	// If passThrough is true, the gossip layer doesn't intervene and the messages
 	// can be used to send a reply back to the sender
-	Accept(acceptor common2.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)
+	Accept(acceptor common2.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan protoext.ReceivedMessage)
 
 	// UpdateLedgerHeight updates the ledger height the peer
 	// publishes to other peers in the channel
@@ -141,16 +142,16 @@ type GossipStateProviderImpl struct {
 	// Channel to read gossip messages from
 	gossipChan <-chan *proto.GossipMessage
 
-	commChan <-chan proto.ReceivedMessage
+	commChan <-chan protoext.ReceivedMessage
 
 	// Queue of payloads which wasn't acquired yet
 	payloads PayloadsBuffer
 
 	ledger ledgerResources
 
-	stateResponseCh chan proto.ReceivedMessage
+	stateResponseCh chan protoext.ReceivedMessage
 
-	stateRequestCh chan proto.ReceivedMessage
+	stateRequestCh chan protoext.ReceivedMessage
 
 	stopCh chan struct{}
 
@@ -192,14 +193,14 @@ func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger l
 
 	gossipChan, _ := services.Accept(func(message interface{}) bool {
 		// Get only data messages
-		return message.(*proto.GossipMessage).IsDataMsg() &&
+		return protoext.IsDataMsg(message.(*proto.GossipMessage)) &&
 			bytes.Equal(message.(*proto.GossipMessage).Channel, []byte(chainID))
 	}, false)
 
 	remoteStateMsgFilter := func(message interface{}) bool {
-		receivedMsg := message.(proto.ReceivedMessage)
+		receivedMsg := message.(protoext.ReceivedMessage)
 		msg := receivedMsg.GetGossipMessage()
-		if !(msg.IsRemoteStateMessage() || msg.GetPrivateData() != nil) {
+		if !(protoext.IsRemoteStateMessage(msg.GossipMessage) || msg.GetPrivateData() != nil) {
 			return false
 		}
 		// Ensure we deal only with messages that belong to this channel
@@ -254,9 +255,9 @@ func NewGossipStateProvider(chainID string, services *ServicesMediator, ledger l
 
 		ledger: ledger,
 
-		stateResponseCh: make(chan proto.ReceivedMessage, config.ChannelBufferSize),
+		stateResponseCh: make(chan protoext.ReceivedMessage, config.ChannelBufferSize),
 
-		stateRequestCh: make(chan proto.ReceivedMessage, config.ChannelBufferSize),
+		stateRequestCh: make(chan protoext.ReceivedMessage, config.ChannelBufferSize),
 
 		stopCh: make(chan struct{}, 1),
 
@@ -310,9 +311,9 @@ func (s *GossipStateProviderImpl) listen() {
 		}
 	}
 }
-func (s *GossipStateProviderImpl) dispatch(msg proto.ReceivedMessage) {
+func (s *GossipStateProviderImpl) dispatch(msg protoext.ReceivedMessage) {
 	// Check type of the message
-	if msg.GetGossipMessage().IsRemoteStateMessage() {
+	if protoext.IsRemoteStateMessage(msg.GetGossipMessage().GossipMessage) {
 		logger.Debug("Handling direct state transfer message")
 		// Got state transfer request response
 		s.directMessage(msg)
@@ -323,7 +324,7 @@ func (s *GossipStateProviderImpl) dispatch(msg proto.ReceivedMessage) {
 	}
 
 }
-func (s *GossipStateProviderImpl) privateDataMessage(msg proto.ReceivedMessage) {
+func (s *GossipStateProviderImpl) privateDataMessage(msg protoext.ReceivedMessage) {
 	if !bytes.Equal(msg.GetGossipMessage().Channel, []byte(s.chainID)) {
 		logger.Warning("Received state transfer request for channel",
 			string(msg.GetGossipMessage().Channel), "while expecting channel", s.chainID, "skipping request...")
@@ -374,7 +375,7 @@ func (s *GossipStateProviderImpl) privateDataMessage(msg proto.ReceivedMessage)
 	logger.Debug("Private data for collection", collectionName, "has been stored")
 }
 
-func (s *GossipStateProviderImpl) directMessage(msg proto.ReceivedMessage) {
+func (s *GossipStateProviderImpl) directMessage(msg protoext.ReceivedMessage) {
 	logger.Debug("[ENTER] -> directMessage")
 	defer logger.Debug("[EXIT] ->  directMessage")
 
@@ -423,7 +424,7 @@ func (s *GossipStateProviderImpl) processStateRequests() {
 
 // handleStateRequest handles state request message, validate batch size, reads current leader state to
 // obtain required blocks, builds response message and send it back
-func (s *GossipStateProviderImpl) handleStateRequest(msg proto.ReceivedMessage) {
+func (s *GossipStateProviderImpl) handleStateRequest(msg protoext.ReceivedMessage) {
 	if msg == nil {
 		return
 	}
@@ -501,7 +502,7 @@ func (s *GossipStateProviderImpl) handleStateRequest(msg proto.ReceivedMessage)
 	})
 }
 
-func (s *GossipStateProviderImpl) handleStateResponse(msg proto.ReceivedMessage) (uint64, error) {
+func (s *GossipStateProviderImpl) handleStateResponse(msg protoext.ReceivedMessage) (uint64, error) {
 	max := uint64(0)
 	// Send signal that response for given nonce has been received
 	response := msg.GetGossipMessage().GetStateResponse()
diff --git a/gossip/state/state_test.go b/gossip/state/state_test.go
index 69bc6c48f..c9b561d75 100644
--- a/gossip/state/state_test.go
+++ b/gossip/state/state_test.go
@@ -40,6 +40,7 @@ import (
 	"github.com/hyperledger/fabric/gossip/metrics"
 	"github.com/hyperledger/fabric/gossip/privdata"
 	capabilitymock "github.com/hyperledger/fabric/gossip/privdata/mocks"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	"github.com/hyperledger/fabric/gossip/state/mocks"
 	gossiputil "github.com/hyperledger/fabric/gossip/util"
 	gutil "github.com/hyperledger/fabric/gossip/util"
@@ -485,12 +486,12 @@ func TestNilDirectMsg(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNodeWithGossip(0, mc, noopPeerIdentityAcceptor, g)
 	defer p.shutdown()
 	p.s.handleStateRequest(nil)
 	p.s.directMessage(nil)
-	sMsg, _ := p.s.stateRequestMessage(uint64(10), uint64(8)).NoopSign()
+	sMsg, _ := protoext.NoopSign(p.s.stateRequestMessage(uint64(10), uint64(8)))
 	req := &comm.ReceivedMessageImpl{
 		SignedGossipMessage: sMsg,
 	}
@@ -503,7 +504,7 @@ func TestNilAddPayload(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNodeWithGossip(0, mc, noopPeerIdentityAcceptor, g)
 	defer p.shutdown()
 	err := p.s.AddPayload(nil)
@@ -517,7 +518,7 @@ func TestAddPayloadLedgerUnavailable(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNodeWithGossip(0, mc, noopPeerIdentityAcceptor, g)
 	defer p.shutdown()
 	// Simulate a problem in the ledger
@@ -549,7 +550,7 @@ func TestLargeBlockGap(t *testing.T) {
 	mc.On("CommitWithPvtData", mock.Anything).Run(func(arg mock.Arguments) {
 		blocksPassedToLedger <- arg.Get(0).(*pcomm.Block).Header.Number
 	})
-	msgsFromPeer := make(chan proto.ReceivedMessage)
+	msgsFromPeer := make(chan protoext.ReceivedMessage)
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(1), nil)
 	mc.On("DoesPvtDataInfoExistInLedger", mock.Anything).Return(false, nil)
 	g := &mocks.GossipMock{}
@@ -587,7 +588,7 @@ func TestLargeBlockGap(t *testing.T) {
 			res.GetStateResponse().Payloads = append(res.GetStateResponse().Payloads, payload)
 		}
 		// Finally, send the response down the channel the peer expects to receive it from
-		sMsg, _ := res.NoopSign()
+		sMsg, _ := protoext.NoopSign(res)
 		msgsFromPeer <- &comm.ReceivedMessageImpl{
 			SignedGossipMessage: sMsg,
 		}
@@ -625,7 +626,7 @@ func TestOverPopulation(t *testing.T) {
 	mc.On("DoesPvtDataInfoExistInLedger", mock.Anything).Return(false, nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNode(0, mc, noopPeerIdentityAcceptor)
 	defer p.shutdown()
 
@@ -689,7 +690,7 @@ func TestBlockingEnqueue(t *testing.T) {
 	mc.On("DoesPvtDataInfoExistInLedger", mock.Anything).Return(false, nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	p := newPeerNode(0, mc, noopPeerIdentityAcceptor)
 	defer p.shutdown()
 
@@ -790,7 +791,7 @@ func TestHaltChainProcessing(t *testing.T) {
 	gossipMsgs := make(chan *proto.GossipMessage)
 
 	g.On("Accept", mock.Anything, false).Return(gossipChannel(gossipMsgs), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	g.On("PeersOfChannel", mock.Anything).Return([]discovery.NetworkMember{})
 
 	v := &validator.MockValidator{}
@@ -811,7 +812,7 @@ func TestFailures(t *testing.T) {
 	mc.On("LedgerHeight", mock.Anything).Return(uint64(0), nil)
 	g := &mocks.GossipMock{}
 	g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	g.On("PeersOfChannel", mock.Anything).Return([]discovery.NetworkMember{})
 	assert.Panics(t, func() {
 		newPeerNodeWithGossip(0, mc, noopPeerIdentityAcceptor, g)
@@ -875,7 +876,7 @@ func TestGossipReception(t *testing.T) {
 	g.On("Accept", mock.Anything, false).Return(rmc, nil).Run(func(_ mock.Arguments) {
 		signalChan <- struct{}{}
 	})
-	g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+	g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 	g.On("PeersOfChannel", mock.Anything).Return([]discovery.NetworkMember{})
 	mc := &mockCommitter{Mock: &mock.Mock{}}
 	receivedChan := make(chan struct{})
@@ -918,7 +919,7 @@ func TestLedgerHeightFromProperties(t *testing.T) {
 			finChan <- struct{}{}
 		})
 		g.On("Accept", mock.Anything, false).Return(make(<-chan *proto.GossipMessage), nil)
-		g.On("Accept", mock.Anything, true).Return(nil, make(chan proto.ReceivedMessage))
+		g.On("Accept", mock.Anything, true).Return(nil, make(chan protoext.ReceivedMessage))
 		defaultPeer := discovery.NetworkMember{
 			InternalEndpoint: "b",
 			PKIid:            common.PKIidType("b"),
@@ -1169,7 +1170,7 @@ func TestGossipStateProvider_TestStateMessages(t *testing.T) {
 	defer peer.shutdown()
 
 	naiveStateMsgPredicate := func(message interface{}) bool {
-		return message.(proto.ReceivedMessage).GetGossipMessage().IsRemoteStateMessage()
+		return protoext.IsRemoteStateMessage(message.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}
 
 	_, bootCh := bootPeer.g.Accept(naiveStateMsgPredicate, true)
@@ -1254,7 +1255,7 @@ func TestNewGossipStateProvider_BatchingOfStateRequest(t *testing.T) {
 	defer peer.shutdown()
 
 	naiveStateMsgPredicate := func(message interface{}) bool {
-		return message.(proto.ReceivedMessage).GetGossipMessage().IsRemoteStateMessage()
+		return protoext.IsRemoteStateMessage(message.(protoext.ReceivedMessage).GetGossipMessage().GossipMessage)
 	}
 	_, peerCh := peer.g.Accept(naiveStateMsgPredicate, true)
 
@@ -1368,9 +1369,9 @@ func (mock *receivedMessageMock) Respond(msg *proto.GossipMessage) {
 	mock.Called(msg)
 }
 
-func (mock *receivedMessageMock) GetGossipMessage() *proto.SignedGossipMessage {
+func (mock *receivedMessageMock) GetGossipMessage() *protoext.SignedGossipMessage {
 	args := mock.Called()
-	return args.Get(0).(*proto.SignedGossipMessage)
+	return args.Get(0).(*protoext.SignedGossipMessage)
 }
 
 func (mock *receivedMessageMock) GetSourceEnvelope() *proto.Envelope {
@@ -1378,9 +1379,9 @@ func (mock *receivedMessageMock) GetSourceEnvelope() *proto.Envelope {
 	return args.Get(0).(*proto.Envelope)
 }
 
-func (mock *receivedMessageMock) GetConnectionInfo() *proto.ConnectionInfo {
+func (mock *receivedMessageMock) GetConnectionInfo() *protoext.ConnectionInfo {
 	args := mock.Called()
-	return args.Get(0).(*proto.ConnectionInfo)
+	return args.Get(0).(*protoext.ConnectionInfo)
 }
 
 type testData struct {
@@ -1397,7 +1398,7 @@ func TestTransferOfPrivateRWSet(t *testing.T) {
 	coord1 := new(coordinatorMock)
 
 	gossipChannel := make(chan *proto.GossipMessage)
-	commChannel := make(chan proto.ReceivedMessage)
+	commChannel := make(chan protoext.ReceivedMessage)
 
 	gossipChannelFactory := func(ch chan *proto.GossipMessage) <-chan *proto.GossipMessage {
 		return ch
@@ -1504,15 +1505,15 @@ func TestTransferOfPrivateRWSet(t *testing.T) {
 		}},
 	}
 
-	msg, _ := requestGossipMsg.NoopSign()
+	msg, _ := protoext.NoopSign(requestGossipMsg)
 
 	requestMsg.On("GetGossipMessage").Return(msg)
-	requestMsg.On("GetConnectionInfo").Return(&proto.ConnectionInfo{
-		Auth: &proto.AuthInfo{},
+	requestMsg.On("GetConnectionInfo").Return(&protoext.ConnectionInfo{
+		Auth: &protoext.AuthInfo{},
 	})
 
 	// Channel to send responses back
-	responseChannel := make(chan proto.ReceivedMessage)
+	responseChannel := make(chan protoext.ReceivedMessage)
 	defer close(responseChannel)
 
 	requestMsg.On("Respond", mock.Anything).Run(func(args mock.Arguments) {
@@ -1521,7 +1522,7 @@ func TestTransferOfPrivateRWSet(t *testing.T) {
 		// Wrap it up into received response
 		receivedMsg := new(receivedMessageMock)
 		// Create sign response
-		msg, _ := response.NoopSign()
+		msg, _ := protoext.NoopSign(response)
 		// Mock to respond
 		receivedMsg.On("GetGossipMessage").Return(msg)
 		// Send response
@@ -1577,7 +1578,7 @@ type testPeer struct {
 	*mocks.GossipMock
 	id            string
 	gossipChannel chan *proto.GossipMessage
-	commChannel   chan proto.ReceivedMessage
+	commChannel   chan protoext.ReceivedMessage
 	coord         *coordinatorMock
 }
 
@@ -1585,7 +1586,7 @@ func (t testPeer) Gossip() <-chan *proto.GossipMessage {
 	return t.gossipChannel
 }
 
-func (t testPeer) Comm() chan proto.ReceivedMessage {
+func (t testPeer) Comm() chan protoext.ReceivedMessage {
 	return t.commChannel
 }
 
@@ -1593,14 +1594,14 @@ var peers = map[string]testPeer{
 	"peer1": {
 		id:            "peer1",
 		gossipChannel: make(chan *proto.GossipMessage),
-		commChannel:   make(chan proto.ReceivedMessage),
+		commChannel:   make(chan protoext.ReceivedMessage),
 		GossipMock:    &mocks.GossipMock{},
 		coord:         new(coordinatorMock),
 	},
 	"peer2": {
 		id:            "peer2",
 		gossipChannel: make(chan *proto.GossipMessage),
-		commChannel:   make(chan proto.ReceivedMessage),
+		commChannel:   make(chan protoext.ReceivedMessage),
 		GossipMock:    &mocks.GossipMock{},
 		coord:         new(coordinatorMock),
 	},
@@ -1626,7 +1627,7 @@ func TestTransferOfPvtDataBetweenPeers(t *testing.T) {
 			Return(nil, peer.Comm()).
 			Once().
 			On("Accept", mock.Anything, true).
-			Return(nil, make(chan proto.ReceivedMessage))
+			Return(nil, make(chan protoext.ReceivedMessage))
 
 		peer.On("UpdateChannelMetadata", mock.Anything, mock.Anything)
 		peer.coord.On("Close")
@@ -1694,16 +1695,16 @@ func TestTransferOfPvtDataBetweenPeers(t *testing.T) {
 	peers["peer2"].On("Send", mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
 		request := args.Get(0).(*proto.GossipMessage)
 		requestMsg := new(receivedMessageMock)
-		msg, _ := request.NoopSign()
+		msg, _ := protoext.NoopSign(request)
 		requestMsg.On("GetGossipMessage").Return(msg)
-		requestMsg.On("GetConnectionInfo").Return(&proto.ConnectionInfo{
-			Auth: &proto.AuthInfo{},
+		requestMsg.On("GetConnectionInfo").Return(&protoext.ConnectionInfo{
+			Auth: &protoext.AuthInfo{},
 		})
 
 		requestMsg.On("Respond", mock.Anything).Run(func(args mock.Arguments) {
 			response := args.Get(0).(*proto.GossipMessage)
 			receivedMsg := new(receivedMessageMock)
-			msg, _ := response.NoopSign()
+			msg, _ := protoext.NoopSign(response)
 			receivedMsg.On("GetGossipMessage").Return(msg)
 			// Send response back to the peer
 			peers["peer2"].commChannel <- receivedMsg
diff --git a/gossip/util/msgs.go b/gossip/util/msgs.go
index 2366da801..0904c8666 100644
--- a/gossip/util/msgs.go
+++ b/gossip/util/msgs.go
@@ -10,24 +10,24 @@ import (
 	"sync"
 
 	"github.com/hyperledger/fabric/gossip/common"
-	proto "github.com/hyperledger/fabric/protos/gossip"
+	"github.com/hyperledger/fabric/gossip/protoext"
 )
 
 // MembershipStore struct which encapsulates
 // membership message store abstraction
 type MembershipStore struct {
-	m map[string]*proto.SignedGossipMessage
+	m map[string]*protoext.SignedGossipMessage
 	sync.RWMutex
 }
 
 // NewMembershipStore creates new membership store instance
 func NewMembershipStore() *MembershipStore {
-	return &MembershipStore{m: make(map[string]*proto.SignedGossipMessage)}
+	return &MembershipStore{m: make(map[string]*protoext.SignedGossipMessage)}
 }
 
 // MsgByID returns a message stored by a certain ID, or nil
 // if such an ID isn't found
-func (m *MembershipStore) MsgByID(pkiID common.PKIidType) *proto.SignedGossipMessage {
+func (m *MembershipStore) MsgByID(pkiID common.PKIidType) *protoext.SignedGossipMessage {
 	m.RLock()
 	defer m.RUnlock()
 	if msg, exists := m.m[string(pkiID)]; exists {
@@ -44,7 +44,7 @@ func (m *MembershipStore) Size() int {
 }
 
 // Put associates msg with the given pkiID
-func (m *MembershipStore) Put(pkiID common.PKIidType, msg *proto.SignedGossipMessage) {
+func (m *MembershipStore) Put(pkiID common.PKIidType, msg *protoext.SignedGossipMessage) {
 	m.Lock()
 	defer m.Unlock()
 	m.m[string(pkiID)] = msg
@@ -59,10 +59,10 @@ func (m *MembershipStore) Remove(pkiID common.PKIidType) {
 
 // ToSlice returns a slice backed by the elements
 // of the MembershipStore
-func (m *MembershipStore) ToSlice() []*proto.SignedGossipMessage {
+func (m *MembershipStore) ToSlice() []*protoext.SignedGossipMessage {
 	m.RLock()
 	defer m.RUnlock()
-	members := make([]*proto.SignedGossipMessage, len(m.m))
+	members := make([]*protoext.SignedGossipMessage, len(m.m))
 	i := 0
 	for _, member := range m.m {
 		members[i] = member
diff --git a/gossip/util/msgs_test.go b/gossip/util/msgs_test.go
index cf4a9dce8..17d7aedfa 100644
--- a/gossip/util/msgs_test.go
+++ b/gossip/util/msgs_test.go
@@ -10,6 +10,7 @@ import (
 	"testing"
 
 	"github.com/hyperledger/fabric/gossip/common"
+	"github.com/hyperledger/fabric/gossip/protoext"
 	proto "github.com/hyperledger/fabric/protos/gossip"
 	"github.com/stretchr/testify/assert"
 )
@@ -24,8 +25,8 @@ func TestMembershipStore(t *testing.T) {
 	id1 := common.PKIidType("id1")
 	id2 := common.PKIidType("id2")
 
-	msg1 := &proto.SignedGossipMessage{}
-	msg2 := &proto.SignedGossipMessage{Envelope: &proto.Envelope{}}
+	msg1 := &protoext.SignedGossipMessage{}
+	msg2 := &protoext.SignedGossipMessage{Envelope: &proto.Envelope{}}
 
 	// Test initially created store is empty
 	assert.Nil(t, membershipStore.MsgByID(id1))
@@ -44,8 +45,8 @@ func TestMembershipStore(t *testing.T) {
 	assert.Nil(t, membershipStore.MsgByID(id1))
 	assert.Equal(t, membershipStore.Size(), 1)
 	// Test returned instance is not a copy
-	msg3 := &proto.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
-	msg3Clone := &proto.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
+	msg3 := &protoext.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
+	msg3Clone := &protoext.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
 	id3 := common.PKIidType("id3")
 	membershipStore.Put(id3, msg3)
 	assert.Equal(t, msg3Clone, msg3)
@@ -60,10 +61,10 @@ func TestToSlice(t *testing.T) {
 	id3 := common.PKIidType("id3")
 	id4 := common.PKIidType("id4")
 
-	msg1 := &proto.SignedGossipMessage{}
-	msg2 := &proto.SignedGossipMessage{Envelope: &proto.Envelope{}}
-	msg3 := &proto.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
-	msg4 := &proto.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}, Envelope: &proto.Envelope{}}
+	msg1 := &protoext.SignedGossipMessage{}
+	msg2 := &protoext.SignedGossipMessage{Envelope: &proto.Envelope{}}
+	msg3 := &protoext.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}}
+	msg4 := &protoext.SignedGossipMessage{GossipMessage: &proto.GossipMessage{}, Envelope: &proto.Envelope{}}
 
 	membershipStore.Put(id1, msg1)
 	membershipStore.Put(id2, msg2)
@@ -72,7 +73,7 @@ func TestToSlice(t *testing.T) {
 
 	assert.Len(t, membershipStore.ToSlice(), 4)
 
-	existsInSlice := func(slice []*proto.SignedGossipMessage, msg *proto.SignedGossipMessage) bool {
+	existsInSlice := func(slice []*protoext.SignedGossipMessage, msg *protoext.SignedGossipMessage) bool {
 		for _, m := range slice {
 			if assert.ObjectsAreEqual(m, msg) {
 				return true
@@ -81,7 +82,7 @@ func TestToSlice(t *testing.T) {
 		return false
 	}
 
-	expectedMsgs := []*proto.SignedGossipMessage{msg1, msg2, msg3, msg4}
+	expectedMsgs := []*protoext.SignedGossipMessage{msg1, msg2, msg3, msg4}
 	for _, msg := range membershipStore.ToSlice() {
 		assert.True(t, existsInSlice(expectedMsgs, msg))
 	}
diff --git a/protos/gossip/extensions_test.go b/protos/gossip/extensions_test.go
deleted file mode 100644
index a23637035..000000000
--- a/protos/gossip/extensions_test.go
+++ /dev/null
@@ -1,863 +0,0 @@
-/*
-Copyright IBM Corp. 2017 All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-		 http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package gossip
-
-import (
-	"errors"
-	"fmt"
-	"testing"
-
-	"github.com/golang/protobuf/proto"
-	"github.com/hyperledger/fabric/gossip/common"
-	"github.com/stretchr/testify/assert"
-)
-
-func TestToGossipMessageNilEnvelope(t *testing.T) {
-	memReq := &MembershipRequest{}
-	_, err := memReq.SelfInformation.ToGossipMessage()
-	assert.EqualError(t, err, "nil envelope")
-}
-
-func TestToString(t *testing.T) {
-	// Ensure we don't print the byte content when we
-	// log messages.
-	// Each payload or signature contains '2' so we would've logged
-	// them if not for the overloading of the String() method in SignedGossipMessage
-
-	// The following line proves that the envelopes constructed in this test
-	// have "2" in them when they are printed
-	assert.Contains(t, fmt.Sprintf("%v", envelopes()[0]), "2")
-	// and the following does the same for payloads:
-	dMsg := &DataMessage{
-		Payload: &Payload{
-			SeqNum: 3,
-			Data:   []byte{2, 2, 2, 2, 2},
-		},
-	}
-	assert.Contains(t, fmt.Sprintf("%v", dMsg), "2")
-
-	// Now we construct all types of messages that have envelopes or payloads in them
-	// and see that "2" is not outputted into their formatting even though it is found
-	// as a sub-message of the outer message.
-
-	sMsg := &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Channel: []byte("A"),
-			Content: &GossipMessage_DataMsg{
-				DataMsg: &DataMessage{
-					Payload: &Payload{
-						SeqNum: 3,
-						Data:   []byte{2, 2, 2, 2, 2},
-					},
-				},
-			},
-		},
-		Envelope: &Envelope{
-			Payload:   []byte{0, 1, 2, 3, 4, 5, 6},
-			Signature: []byte{0, 1, 2},
-			SecretEnvelope: &SecretEnvelope{
-				Payload:   []byte{0, 1, 2, 3, 4, 5},
-				Signature: []byte{0, 1, 2},
-			},
-		},
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-	sMsg.GetDataMsg().Payload = nil
-	assert.NotPanics(t, func() {
-		_ = sMsg.String()
-	})
-
-	sMsg = &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte("A"),
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Content: &GossipMessage_DataUpdate{
-				DataUpdate: &DataUpdate{
-					Nonce:   11,
-					MsgType: PullMsgType_BLOCK_MSG,
-					Data:    envelopes(),
-				},
-			},
-		},
-		Envelope: envelopes()[0],
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-
-	sMsg = &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte("A"),
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Content: &GossipMessage_MemRes{
-				MemRes: &MembershipResponse{
-					Alive: envelopes(),
-					Dead:  envelopes(),
-				},
-			},
-		},
-		Envelope: envelopes()[0],
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-
-	sMsg = &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte("A"),
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Content: &GossipMessage_StateSnapshot{
-				StateSnapshot: &StateInfoSnapshot{
-					Elements: envelopes(),
-				},
-			},
-		},
-		Envelope: envelopes()[0],
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-
-	sMsg = &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte("A"),
-			Tag:     GossipMessage_EMPTY,
-			Nonce:   5,
-			Content: &GossipMessage_StateResponse{
-				StateResponse: &RemoteStateResponse{
-					Payloads: []*Payload{
-						{Data: []byte{2, 2, 2}},
-					},
-				},
-			},
-		},
-		Envelope: envelopes()[0],
-	}
-	assert.NotContains(t, fmt.Sprintf("%v", sMsg), "2")
-}
-
-func TestAliveMessageNoActionTaken(t *testing.T) {
-	comparator := NewGossipMessageComparator(1)
-
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{17},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 1,
-				SeqNum: 1,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	sMsg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{15},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 2,
-				SeqNum: 2,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageNoAction)
-}
-
-func TestStateInfoMessageNoActionTaken(t *testing.T) {
-	comparator := NewGossipMessageComparator(1)
-
-	// msg1 and msg2 have same channel mac, while different pkid, while
-	// msg and msg3 same pkid and different channel mac
-
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 1, []byte{17}, []byte{17, 13}))
-	sMsg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 1, []byte{13}, []byte{17, 13}))
-
-	// We only should compare comparable messages, e.g. message from same peer
-	// In any other cases no invalidation should be taken.
-	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageNoAction)
-}
-
-func TestStateInfoMessagesInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(1)
-
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 1, []byte{17}, []byte{17}))
-	sMsg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 1, []byte{17}, []byte{17}))
-	sMsg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(1, 2, []byte{17}, []byte{17}))
-	sMsg4 := signedGossipMessage("testChannel", GossipMessage_EMPTY,
-		stateInfoMessage(2, 1, []byte{17}, []byte{17}))
-
-	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageInvalidated)
-
-	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg3, sMsg1), common.MessageInvalidates)
-
-	assert.Equal(t, comparator(sMsg1, sMsg4), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg4, sMsg1), common.MessageInvalidates)
-
-	assert.Equal(t, comparator(sMsg3, sMsg4), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg4, sMsg3), common.MessageInvalidates)
-}
-
-func TestAliveMessageInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(1)
-
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{17},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 1,
-				SeqNum: 1,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	sMsg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{17},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 2,
-				SeqNum: 2,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	sMsg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Membership: &Member{
-				Endpoint: "localhost",
-				Metadata: []byte{1, 2, 3, 4, 5},
-				PkiId:    []byte{17},
-			},
-			Timestamp: &PeerTime{
-				IncNum: 1,
-				SeqNum: 2,
-			},
-			Identity: []byte("peerID1"),
-		},
-	})
-
-	assert.Equal(t, comparator(sMsg1, sMsg2), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg2, sMsg1), common.MessageInvalidates)
-	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg3, sMsg1), common.MessageInvalidates)
-}
-
-func TestDataMessageInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(5)
-
-	data := []byte{1, 1, 1}
-	sMsg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, dataMessage(1, data))
-	sMsg1Clone := signedGossipMessage("testChannel", GossipMessage_EMPTY, dataMessage(1, data))
-	sMsg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY, dataMessage(2, data))
-	sMsg4 := signedGossipMessage("testChannel", GossipMessage_EMPTY, dataMessage(7, data))
-
-	assert.Equal(t, comparator(sMsg1, sMsg1Clone), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg1, sMsg3), common.MessageNoAction)
-	assert.Equal(t, comparator(sMsg1, sMsg4), common.MessageInvalidated)
-	assert.Equal(t, comparator(sMsg4, sMsg1), common.MessageInvalidates)
-}
-
-func TestIdentityMessagesInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(5)
-
-	msg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{
-			PkiId:    []byte{17},
-			Cert:     []byte{1, 2, 3, 4},
-			Metadata: nil,
-		},
-	})
-
-	msg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{
-			PkiId:    []byte{17},
-			Cert:     []byte{1, 2, 3, 4},
-			Metadata: nil,
-		},
-	})
-
-	msg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{
-			PkiId:    []byte{11},
-			Cert:     []byte{11, 21, 31, 41},
-			Metadata: nil,
-		},
-	})
-
-	assert.Equal(t, comparator(msg1, msg2), common.MessageInvalidated)
-	assert.Equal(t, comparator(msg1, msg3), common.MessageNoAction)
-}
-
-func TestLeadershipMessagesNoAction(t *testing.T) {
-	comparator := NewGossipMessageComparator(5)
-
-	msg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(1, 1, []byte{17}))
-	msg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(1, 1, []byte{11}))
-
-	// If message with different pkid's no action should be taken
-	assert.Equal(t, comparator(msg1, msg2), common.MessageNoAction)
-}
-
-func TestLeadershipMessagesInvalidation(t *testing.T) {
-	comparator := NewGossipMessageComparator(5)
-
-	pkiID := []byte{17}
-	msg1 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(1, 1, pkiID))
-	msg2 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(1, 2, pkiID))
-	msg3 := signedGossipMessage("testChannel", GossipMessage_EMPTY, leadershipMessage(2, 1, pkiID))
-
-	// If message with different pkid's no action should be taken
-	assert.Equal(t, comparator(msg1, msg2), common.MessageInvalidated)
-	assert.Equal(t, comparator(msg2, msg1), common.MessageInvalidates)
-	assert.Equal(t, comparator(msg1, msg3), common.MessageInvalidated)
-	assert.Equal(t, comparator(msg3, msg1), common.MessageInvalidates)
-	assert.Equal(t, comparator(msg2, msg3), common.MessageInvalidated)
-	assert.Equal(t, comparator(msg3, msg2), common.MessageInvalidates)
-}
-
-func TestCheckGossipMessageTypes(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	// Create State info pull request
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_StateInfoPullReq{
-		StateInfoPullReq: &StateInfoPullRequest{
-			Channel_MAC: []byte{17},
-		},
-	})
-
-	assert.True(t, msg.IsStateInfoPullRequestMsg())
-
-	// Create alive message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{
-			Identity: []byte("peerID"),
-			Membership: &Member{
-				PkiId:    []byte("pkiID"),
-				Metadata: []byte{17},
-				Endpoint: "localhost",
-			},
-			Timestamp: &PeerTime{
-				SeqNum: 1,
-				IncNum: 1,
-			},
-		},
-	})
-
-	assert.True(t, msg.IsAliveMsg())
-
-	// Create gossip data message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, dataMessage(1, []byte{1, 2, 3, 4, 5}))
-	assert.True(t, msg.IsDataMsg())
-
-	// Create data request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataReq{
-		DataReq: &DataRequest{
-			MsgType: PullMsgType_UNDEFINED,
-			Nonce:   0,
-			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
-		},
-	})
-	assert.True(t, msg.IsDataReq())
-	assert.True(t, msg.IsPullMsg())
-
-	// Create data request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_UNDEFINED,
-			Nonce:   0,
-			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
-		},
-	})
-	assert.True(t, msg.IsDigestMsg())
-	assert.True(t, msg.IsPullMsg())
-
-	// Create data update message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataUpdate{
-		DataUpdate: &DataUpdate{
-			MsgType: PullMsgType_UNDEFINED,
-			Nonce:   0,
-			Data:    []*Envelope{envelopes()[0]},
-		},
-	})
-	assert.True(t, msg.IsDataUpdate())
-	assert.True(t, msg.IsPullMsg())
-
-	// Create gossip hello message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_Hello{
-		Hello: &GossipHello{
-			MsgType: PullMsgType_UNDEFINED,
-			Nonce:   0,
-		},
-	})
-	assert.True(t, msg.IsHelloMsg())
-	assert.True(t, msg.IsPullMsg())
-
-	// Create state request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_StateRequest{
-		StateRequest: &RemoteStateRequest{
-			StartSeqNum: 1,
-			EndSeqNum:   10,
-		},
-	})
-	assert.True(t, msg.IsRemoteStateMessage())
-
-	// Create state response message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_StateResponse{
-		StateResponse: &RemoteStateResponse{
-			Payloads: []*Payload{{
-				SeqNum: 1,
-				Data:   []byte{1, 2, 3, 4, 5},
-			}},
-		},
-	})
-	assert.True(t, msg.IsRemoteStateMessage())
-}
-
-func TestGossipPullMessageType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	// Create gossip hello message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_Hello{
-		Hello: &GossipHello{
-			MsgType: PullMsgType_BLOCK_MSG,
-			Nonce:   0,
-		},
-	})
-
-	assert.True(t, msg.IsHelloMsg())
-	assert.True(t, msg.IsPullMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_BLOCK_MSG)
-
-	// Create data request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_IDENTITY_MSG,
-			Nonce:   0,
-			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
-		},
-	})
-	assert.True(t, msg.IsDigestMsg())
-	assert.True(t, msg.IsPullMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_IDENTITY_MSG)
-
-	// Create data request message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataReq{
-		DataReq: &DataRequest{
-			MsgType: PullMsgType_BLOCK_MSG,
-			Nonce:   0,
-			Digests: [][]byte{[]byte("msg1"), []byte("msg2"), []byte("msg3")},
-		},
-	})
-	assert.True(t, msg.IsDataReq())
-	assert.True(t, msg.IsPullMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_BLOCK_MSG)
-
-	// Create data update message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataUpdate{
-		DataUpdate: &DataUpdate{
-			MsgType: PullMsgType_IDENTITY_MSG,
-			Nonce:   0,
-			Data:    []*Envelope{envelopes()[0]},
-		},
-	})
-	assert.True(t, msg.IsDataUpdate())
-	assert.True(t, msg.IsPullMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_IDENTITY_MSG)
-
-	// Create gossip data message
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, dataMessage(1, []byte{1, 2, 3, 4, 5}))
-	assert.True(t, msg.IsDataMsg())
-	assert.Equal(t, msg.GetPullMsgType(), PullMsgType_UNDEFINED)
-}
-
-func TestGossipMessageDataMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_AND_ORG, dataMessage(1, []byte{1}))
-	assert.True(t, msg.IsChannelRestricted())
-	assert.True(t, msg.IsOrgRestricted())
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, dataMessage(1, []byte{1}))
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_UNDEFINED, dataMessage(1, []byte{1}))
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, dataMessage(1, []byte{1}))
-	assert.False(t, msg.IsChannelRestricted())
-	assert.True(t, msg.IsOrgRestricted())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, dataMessage(1, []byte{1}))
-	assert.True(t, msg.IsChannelRestricted())
-	assert.False(t, msg.IsOrgRestricted())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, dataMessage(1, []byte{1}))
-	assert.False(t, msg.IsChannelRestricted())
-	assert.False(t, msg.IsOrgRestricted())
-
-	msg = signedGossipMessage(channelID, GossipMessage_UNDEFINED, dataMessage(1, []byte{1}))
-	assert.False(t, msg.IsChannelRestricted())
-	assert.False(t, msg.IsOrgRestricted())
-}
-
-func TestGossipMessageAliveMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, &GossipMessage_AliveMsg{
-		AliveMsg: &AliveMessage{},
-	})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageMembershipMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_MemReq{
-		MemReq: &MembershipRequest{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_MemRes{
-		MemRes: &MembershipResponse{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageIdentityMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_PeerIdentity{
-		PeerIdentity: &PeerIdentity{},
-	})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessagePullMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_AND_ORG, &GossipMessage_DataReq{
-		DataReq: &DataRequest{
-			MsgType: PullMsgType_BLOCK_MSG,
-		},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataReq{
-		DataReq: &DataRequest{
-			MsgType: PullMsgType_BLOCK_MSG,
-		},
-	})
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_IDENTITY_MSG,
-		},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_IDENTITY_MSG,
-		},
-	})
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_ORG_ONLY, &GossipMessage_DataDig{
-		DataDig: &DataDigest{
-			MsgType: PullMsgType_UNDEFINED,
-		},
-	})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageStateInfoMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateInfo{
-		StateInfo: &StateInfo{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateInfoPullReq{
-		StateInfoPullReq: &StateInfoPullRequest{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateResponse{
-		StateResponse: &RemoteStateResponse{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateRequest{
-		StateRequest: &RemoteStateRequest{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_StateSnapshot{
-		StateSnapshot: &StateInfoSnapshot{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_StateInfo{
-		StateInfo: &StateInfo{},
-	})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageLeadershipMessageTagType(t *testing.T) {
-	var msg *SignedGossipMessage
-	channelID := "testID1"
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_AND_ORG, &GossipMessage_LeadershipMsg{
-		LeadershipMsg: &LeadershipMessage{},
-	})
-	assert.NoError(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_LeadershipMsg{
-		LeadershipMsg: &LeadershipMessage{},
-	})
-	assert.Error(t, msg.IsTagLegal())
-
-	msg = signedGossipMessage(channelID, GossipMessage_CHAN_OR_ORG, &GossipMessage_Empty{})
-	assert.Error(t, msg.IsTagLegal())
-}
-
-func TestGossipMessageSign(t *testing.T) {
-	idSigner := func(msg []byte) ([]byte, error) {
-		return msg, nil
-	}
-
-	errSigner := func(msg []byte) ([]byte, error) {
-		return nil, errors.New("Error")
-	}
-
-	msg := signedGossipMessage("testChannelID", GossipMessage_EMPTY, &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{},
-	})
-
-	signedMsg, _ := msg.Sign(idSigner)
-
-	// Since checking the identity signer, signature will be same as the payload
-	assert.Equal(t, signedMsg.Payload, signedMsg.Signature)
-
-	env, err := msg.Sign(errSigner)
-	assert.Error(t, err)
-	assert.Nil(t, env)
-}
-
-func TestEnvelope_NoopSign(t *testing.T) {
-	channelID := "testChannelID"
-	msg := signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{},
-	})
-
-	signedMsg, err := msg.NoopSign()
-
-	// Since checking the identity signer, signature will be same as the payload
-	assert.Nil(t, signedMsg.Signature)
-	assert.NoError(t, err)
-}
-
-func TestSignedGossipMessage_Verify(t *testing.T) {
-	channelID := "testChannelID"
-	peerID := []byte("peer")
-	msg := signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{},
-	})
-
-	assert.True(t, msg.IsSigned())
-
-	verifier := func(peerIdentity []byte, signature, message []byte) error {
-		return nil
-	}
-
-	res := msg.Verify(peerID, verifier)
-	assert.Nil(t, res)
-
-	msg = signedGossipMessage(channelID, GossipMessage_EMPTY, &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{},
-	})
-
-	env := msg.Envelope
-	msg.Envelope = nil
-	res = msg.Verify(peerID, verifier)
-	assert.Error(t, res)
-
-	msg.Envelope = env
-	payload := msg.Envelope.Payload
-	msg.Envelope.Payload = nil
-	res = msg.Verify(peerID, verifier)
-	assert.Error(t, res)
-
-	msg.Envelope.Payload = payload
-	sig := msg.Signature
-	msg.Signature = nil
-	res = msg.Verify(peerID, verifier)
-	assert.Error(t, res)
-	msg.Signature = sig
-
-	errVerifier := func(peerIdentity []byte, signature, message []byte) error {
-		return errors.New("Test")
-	}
-
-	res = msg.Verify(peerID, errVerifier)
-	assert.Error(t, res)
-}
-
-func TestEnvelope(t *testing.T) {
-	dataMsg := &GossipMessage{
-		Content: dataMessage(1, []byte("data")),
-	}
-	bytes, err := proto.Marshal(dataMsg)
-	assert.NoError(t, err)
-
-	env := envelopes()[0]
-	env.Payload = bytes
-
-	msg, err := env.ToGossipMessage()
-	assert.NoError(t, err)
-	assert.NotNil(t, msg)
-
-	assert.True(t, msg.IsDataMsg())
-}
-
-func TestEnvelope_SignSecret(t *testing.T) {
-	dataMsg := &GossipMessage{
-		Content: dataMessage(1, []byte("data")),
-	}
-	bytes, err := proto.Marshal(dataMsg)
-	assert.NoError(t, err)
-
-	env := envelopes()[0]
-	env.Payload = bytes
-	env.SecretEnvelope = nil
-
-	env.SignSecret(func(message []byte) ([]byte, error) {
-		return message, nil
-	}, &Secret{
-		Content: &Secret_InternalEndpoint{
-			InternalEndpoint: "localhost:5050",
-		},
-	})
-
-	assert.NotNil(t, env.SecretEnvelope)
-	assert.Equal(t, env.SecretEnvelope.InternalEndpoint(), "localhost:5050")
-}
-
-func envelopes() []*Envelope {
-	return []*Envelope{
-		{Payload: []byte{2, 2, 2},
-			Signature: []byte{2, 2, 2},
-			SecretEnvelope: &SecretEnvelope{
-				Payload:   []byte{2, 2, 2},
-				Signature: []byte{2, 2, 2},
-			},
-		},
-	}
-}
-
-func leadershipMessage(incNum uint64, seqNum uint64, pkid []byte) *GossipMessage_LeadershipMsg {
-	return &GossipMessage_LeadershipMsg{
-		LeadershipMsg: &LeadershipMessage{
-			PkiId:         pkid,
-			IsDeclaration: false,
-			Timestamp: &PeerTime{
-				IncNum: incNum,
-				SeqNum: seqNum,
-			},
-		},
-	}
-}
-
-func stateInfoMessage(incNum uint64, seqNum uint64, pkid []byte, mac []byte) *GossipMessage_StateInfo {
-	return &GossipMessage_StateInfo{
-		StateInfo: &StateInfo{
-			Timestamp: &PeerTime{
-				IncNum: incNum,
-				SeqNum: seqNum,
-			},
-			PkiId:       pkid,
-			Channel_MAC: mac,
-		},
-	}
-}
-
-func dataMessage(seqNum uint64, data []byte) *GossipMessage_DataMsg {
-	return &GossipMessage_DataMsg{
-		DataMsg: &DataMessage{
-			Payload: &Payload{
-				SeqNum: seqNum,
-				Data:   data,
-			},
-		},
-	}
-}
-
-func signedGossipMessage(channelID string, tag GossipMessage_Tag, content isGossipMessage_Content) *SignedGossipMessage {
-	return &SignedGossipMessage{
-		GossipMessage: &GossipMessage{
-			Channel: []byte(channelID),
-			Tag:     tag,
-			Nonce:   0,
-			Content: content,
-		},
-		Envelope: envelopes()[0],
-	}
-}
diff --git a/protos/gossip/message.pb.go b/protos/gossip/message.pb.go
index 310eabc12..3d2c7a1b2 100644
--- a/protos/gossip/message.pb.go
+++ b/protos/gossip/message.pb.go
@@ -339,7 +339,7 @@ type GossipMessage struct {
 	//	*GossipMessage_PrivateReq
 	//	*GossipMessage_PrivateRes
 	//	*GossipMessage_PrivateData
-	Content              isGossipMessage_Content `protobuf_oneof:"content"`
+	Content              IsGossipMessage_Content `protobuf_oneof:"content"`
 	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
 	XXX_unrecognized     []byte                  `json:"-"`
 	XXX_sizecache        int32                   `json:"-"`
@@ -390,8 +390,8 @@ func (m *GossipMessage) GetTag() GossipMessage_Tag {
 	return GossipMessage_UNDEFINED
 }
 
-type isGossipMessage_Content interface {
-	isGossipMessage_Content()
+type IsGossipMessage_Content interface {
+	IsGossipMessage_Content()
 }
 
 type GossipMessage_AliveMsg struct {
@@ -478,49 +478,49 @@ type GossipMessage_PrivateData struct {
 	PrivateData *PrivateDataMessage `protobuf:"bytes,25,opt,name=private_data,json=privateData,proto3,oneof"`
 }
 
-func (*GossipMessage_AliveMsg) isGossipMessage_Content() {}
+func (*GossipMessage_AliveMsg) IsGossipMessage_Content() {}
 
-func (*GossipMessage_MemReq) isGossipMessage_Content() {}
+func (*GossipMessage_MemReq) IsGossipMessage_Content() {}
 
-func (*GossipMessage_MemRes) isGossipMessage_Content() {}
+func (*GossipMessage_MemRes) IsGossipMessage_Content() {}
 
-func (*GossipMessage_DataMsg) isGossipMessage_Content() {}
+func (*GossipMessage_DataMsg) IsGossipMessage_Content() {}
 
-func (*GossipMessage_Hello) isGossipMessage_Content() {}
+func (*GossipMessage_Hello) IsGossipMessage_Content() {}
 
-func (*GossipMessage_DataDig) isGossipMessage_Content() {}
+func (*GossipMessage_DataDig) IsGossipMessage_Content() {}
 
-func (*GossipMessage_DataReq) isGossipMessage_Content() {}
+func (*GossipMessage_DataReq) IsGossipMessage_Content() {}
 
-func (*GossipMessage_DataUpdate) isGossipMessage_Content() {}
+func (*GossipMessage_DataUpdate) IsGossipMessage_Content() {}
 
-func (*GossipMessage_Empty) isGossipMessage_Content() {}
+func (*GossipMessage_Empty) IsGossipMessage_Content() {}
 
-func (*GossipMessage_Conn) isGossipMessage_Content() {}
+func (*GossipMessage_Conn) IsGossipMessage_Content() {}
 
-func (*GossipMessage_StateInfo) isGossipMessage_Content() {}
+func (*GossipMessage_StateInfo) IsGossipMessage_Content() {}
 
-func (*GossipMessage_StateSnapshot) isGossipMessage_Content() {}
+func (*GossipMessage_StateSnapshot) IsGossipMessage_Content() {}
 
-func (*GossipMessage_StateInfoPullReq) isGossipMessage_Content() {}
+func (*GossipMessage_StateInfoPullReq) IsGossipMessage_Content() {}
 
-func (*GossipMessage_StateRequest) isGossipMessage_Content() {}
+func (*GossipMessage_StateRequest) IsGossipMessage_Content() {}
 
-func (*GossipMessage_StateResponse) isGossipMessage_Content() {}
+func (*GossipMessage_StateResponse) IsGossipMessage_Content() {}
 
-func (*GossipMessage_LeadershipMsg) isGossipMessage_Content() {}
+func (*GossipMessage_LeadershipMsg) IsGossipMessage_Content() {}
 
-func (*GossipMessage_PeerIdentity) isGossipMessage_Content() {}
+func (*GossipMessage_PeerIdentity) IsGossipMessage_Content() {}
 
-func (*GossipMessage_Ack) isGossipMessage_Content() {}
+func (*GossipMessage_Ack) IsGossipMessage_Content() {}
 
-func (*GossipMessage_PrivateReq) isGossipMessage_Content() {}
+func (*GossipMessage_PrivateReq) IsGossipMessage_Content() {}
 
-func (*GossipMessage_PrivateRes) isGossipMessage_Content() {}
+func (*GossipMessage_PrivateRes) IsGossipMessage_Content() {}
 
-func (*GossipMessage_PrivateData) isGossipMessage_Content() {}
+func (*GossipMessage_PrivateData) IsGossipMessage_Content() {}
 
-func (m *GossipMessage) GetContent() isGossipMessage_Content {
+func (m *GossipMessage) GetContent() IsGossipMessage_Content {
 	if m != nil {
 		return m.Content
 	}
diff --git a/protos/gossip/message_ext.go b/protos/gossip/message_ext.go
new file mode 100644
index 000000000..2e23383e7
--- /dev/null
+++ b/protos/gossip/message_ext.go
@@ -0,0 +1,25 @@
+/*
+Copyright IBM Corp. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+package gossip
+
+import fmt "fmt"
+
+func (p *Payload) toString() string {
+	return fmt.Sprintf("Block message: {Data: %d bytes, seq: %d}", len(p.Data), p.SeqNum)
+}
+
+func (du *DataUpdate) toString() string {
+	mType := PullMsgType_name[int32(du.MsgType)]
+	return fmt.Sprintf("Type: %s, items: %d, nonce: %d", mType, len(du.Data), du.Nonce)
+}
+
+func (mr *MembershipResponse) toString() string {
+	return fmt.Sprintf("MembershipResponse with Alive: %d, Dead: %d", len(mr.Alive), len(mr.Dead))
+}
+
+func (sis *StateInfoSnapshot) toString() string {
+	return fmt.Sprintf("StateInfoSnapshot with %d items", len(sis.Elements))
+}
diff --git a/protos/gossip/message_test.go b/protos/gossip/message_test.go
index 9c4047385..2ab1b2cab 100644
--- a/protos/gossip/message_test.go
+++ b/protos/gossip/message_test.go
@@ -64,7 +64,7 @@ func TestMethods(t *testing.T) {
 
 	}
 
-	contentTypes := []isGossipMessage_Content{
+	contentTypes := []IsGossipMessage_Content{
 		&GossipMessage_AliveMsg{},
 		&GossipMessage_MemReq{},
 		&GossipMessage_MemRes{},
@@ -85,7 +85,7 @@ func TestMethods(t *testing.T) {
 	}
 
 	for _, ct := range contentTypes {
-		ct.isGossipMessage_Content()
+		ct.IsGossipMessage_Content()
 		gMsg := &GossipMessage{
 			Content: ct,
 		}
-- 
2.21.0 (Apple Git-120)

