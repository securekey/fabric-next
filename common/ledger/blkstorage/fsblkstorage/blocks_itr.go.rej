diff a/common/ledger/blkstorage/fsblkstorage/blocks_itr.go b/common/ledger/blkstorage/fsblkstorage/blocks_itr.go	(rejected hunks)
@@ -28,54 +33,30 @@ type blocksItr struct {
 	maxBlockNumAvailable uint64
 	blockNumToRetrieve   uint64
 	stream               *blockStream
-	closeMarker          bool
-	closeMarkerLock      *sync.Mutex
+	streamMtx            sync.Mutex
+	ctx                  context.Context
+	cancel               context.CancelFunc
 }
 
 func newBlockItr(mgr *blockfileMgr, startBlockNum uint64) *blocksItr {
-	return &blocksItr{mgr, mgr.cpInfo.lastBlockNumber, startBlockNum, nil, false, &sync.Mutex{}}
-}
-
-func (itr *blocksItr) waitForBlock(blockNum uint64) uint64 {
-	itr.mgr.cpInfoCond.L.Lock()
-	defer itr.mgr.cpInfoCond.L.Unlock()
-	for itr.mgr.cpInfo.lastBlockNumber < blockNum && !itr.shouldClose() {
-		logger.Debugf("Going to wait for newer blocks. maxAvailaBlockNumber=[%d], waitForBlockNum=[%d]",
-			itr.mgr.cpInfo.lastBlockNumber, blockNum)
-		itr.mgr.cpInfoCond.Wait()
-		logger.Debugf("Came out of wait. maxAvailaBlockNumber=[%d]", itr.mgr.cpInfo.lastBlockNumber)
-	}
-	return itr.mgr.cpInfo.lastBlockNumber
-}
-
-func (itr *blocksItr) initStream() error {
-	var lp *fileLocPointer
-	var err error
-	if lp, err = itr.mgr.index.getBlockLocByBlockNum(itr.blockNumToRetrieve); err != nil {
-		return err
-	}
-	if itr.stream, err = newBlockStream(itr.mgr.rootDir, lp.fileSuffixNum, int64(lp.offset), -1); err != nil {
-		return err
-	}
-	return nil
-}
-
-func (itr *blocksItr) shouldClose() bool {
-	itr.closeMarkerLock.Lock()
-	defer itr.closeMarkerLock.Unlock()
-	return itr.closeMarker
+	ctx, cancel := context.WithCancel(context.Background())
+	return &blocksItr{mgr, mgr.lastBlockNumber(), startBlockNum, nil, sync.Mutex{}, ctx, cancel}
 }
 
 // Next moves the cursor to next block and returns true iff the iterator is not exhausted
 func (itr *blocksItr) Next() (ledger.QueryResult, error) {
 	if itr.maxBlockNumAvailable < itr.blockNumToRetrieve {
-		itr.maxBlockNumAvailable = itr.waitForBlock(itr.blockNumToRetrieve)
+		itr.maxBlockNumAvailable = itr.mgr.waitForBlock(itr.ctx, itr.blockNumToRetrieve)
 	}
-	itr.closeMarkerLock.Lock()
-	defer itr.closeMarkerLock.Unlock()
-	if itr.closeMarker {
-		return nil, nil
+
+	select {
+		case <-itr.ctx.Done():
+			return nil, nil
+		default:
 	}
+
+	itr.streamMtx.Lock()
+	defer itr.streamMtx.Unlock()
 	if itr.stream == nil {
 		logger.Debugf("Initializing block stream for iterator. itr.maxBlockNumAvailable=%d", itr.maxBlockNumAvailable)
 		if err := itr.initStream(); err != nil {
