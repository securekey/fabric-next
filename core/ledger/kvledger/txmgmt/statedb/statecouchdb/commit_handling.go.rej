diff a/core/ledger/kvledger/txmgmt/statedb/statecouchdb/commit_handling.go b/core/ledger/kvledger/txmgmt/statedb/statecouchdb/commit_handling.go	(rejected hunks)
@@ -2,14 +2,13 @@
 Copyright IBM Corp. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
 */
-
 package statecouchdb
 
 import (
-	"errors"
 	"fmt"
 
 	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
+	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/statekeyindex"
 	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
 	"github.com/hyperledger/fabric/core/ledger/util/couchdb"
 )
@@ -129,14 +147,12 @@ func commitUpdates(db *couchdb.CouchDatabase, batchUpdateMap map[string]*batchab
 				logger.Warningf("CouchDB batch document update encountered an problem. Retrying update for document ID:%s", respDoc.ID)
 				// Save the individual document to couchdb
 				// Note that this will do retries as needed
-				_, err = db.SaveDoc(respDoc.ID, "", &batchUpdateDocument.CouchDoc)
+				_, err = db.SaveDoc(respDoc.ID, "", batchUpdateDocument.CouchDoc)
 			}
-
 			// If the single document update or delete returns an error, then throw the error
 			if err != nil {
 				errorString := fmt.Sprintf("Error occurred while saving document ID = %v  Error: %s  Reason: %s\n",
 					respDoc.ID, respDoc.Error, respDoc.Reason)
-
 				logger.Errorf(errorString)
 				return fmt.Errorf(errorString)
 			}
@@ -144,39 +160,32 @@ func commitUpdates(db *couchdb.CouchDatabase, batchUpdateMap map[string]*batchab
 	}
 	return nil
 }
-
-// nsFlusher implements `batch` interface and a batch executes the function `couchdb.EnsureFullCommit()` for the given namespace
-type nsFlusher struct {
-	db *couchdb.CouchDatabase
-}
-
-func (vdb *VersionedDB) ensureFullCommit(dbs []*couchdb.CouchDatabase) error {
-	var flushers []batch
+func (vdb *VersionedDB) warmupAllIndexes(dbs []*couchdb.CouchDatabase) {
 	for _, db := range dbs {
-		flushers = append(flushers, &nsFlusher{db})
-	}
-	return executeBatches(flushers)
-}
-
-func (f *nsFlusher) execute() error {
-	dbResponse, err := f.db.EnsureFullCommit()
-	if err != nil || dbResponse.Ok != true {
-		logger.Errorf("Failed to perform full commit\n")
-		return errors.New("Failed to perform full commit")
+		db.WarmUpAllIndexes()
 	}
-	return nil
 }
-
-func addRevisionsForMissingKeys(revisions map[string]string, db *couchdb.CouchDatabase, nsUpdates map[string]*statedb.VersionedValue) error {
+func addRevisionsForMissingKeys(ns string, keyIndex statekeyindex.StateKeyIndex, revisions map[string]string, db *couchdb.CouchDatabase, nsUpdates map[string]*statedb.VersionedValue) error {
 	var missingKeys []string
 	for key := range nsUpdates {
 		_, ok := revisions[key]
 		if !ok {
-			missingKeys = append(missingKeys, key)
+			logger.Debugf("key %s not found in revisions going to search in keyIndex", key)
+			_, exists, err := keyIndex.GetMetadata(&statekeyindex.CompositeKey{Namespace: ns, Key: key})
+			if err != nil {
+				return err
+			}
+			if !exists {
+				revisions[key] = ""
+			} else {
+				missingKeys = append(missingKeys, key)
+			}
 		}
 	}
-	logger.Debugf("Pulling revisions for the [%d] keys for namsespace [%s] that were not part of the readset", len(missingKeys), db.DBName)
-	retrievedMetadata, err := retrieveNsMetadata(db, missingKeys)
+	if len(missingKeys) > 0 {
+		logger.Warningf("Pulling revisions for the keys [%s] for namsespace [%s] that were not part of the readset", missingKeys, db.DBName)
+	}
+	retrievedMetadata, err := retrieveNsMetadata(db, missingKeys, false)
 	if err != nil {
 		return err
 	}
