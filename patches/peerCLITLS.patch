diff --git a/bddtests/conn.go b/bddtests/conn.go
index 7df13c60..a09a931a 100644
--- a/bddtests/conn.go
+++ b/bddtests/conn.go
@@ -20,6 +20,7 @@ import (
 	"fmt"
 
 	"github.com/hyperledger/fabric/core/comm"
+	"github.com/hyperledger/fabric/core/peer"
 	"google.golang.org/grpc"
 )
 
@@ -28,7 +29,7 @@ func NewGrpcClient(peerAddress string) (*grpc.ClientConn, error) {
 	var tmpConn *grpc.ClientConn
 	var err error
 	if comm.TLSEnabled() {
-		tmpConn, err = comm.NewClientConnectionWithAddress(peerAddress, true, true, comm.InitTLSForPeer())
+		tmpConn, err = comm.NewClientConnectionWithAddress(peerAddress, true, true, peer.InitTLSForPeer())
 	}
 	tmpConn, err = comm.NewClientConnectionWithAddress(peerAddress, true, false, nil)
 	if err != nil {
diff --git a/core/comm/connection.go b/core/comm/connection.go
index 9657fc72..8036f223 100644
--- a/core/comm/connection.go
+++ b/core/comm/connection.go
@@ -19,11 +19,9 @@ import (
 
 	"github.com/hyperledger/fabric/common/flogging"
 	"github.com/hyperledger/fabric/core/config"
-	"github.com/spf13/viper"
 	"golang.org/x/net/context"
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/credentials"
-	"google.golang.org/grpc/grpclog"
 )
 
 const defaultTimeout = time.Second * 3
@@ -217,25 +215,6 @@ func NewClientConnectionWithAddress(peerAddress string, block bool, tslEnabled b
 	return conn, err
 }
 
-// InitTLSForPeer returns TLS credentials for peer
-func InitTLSForPeer() credentials.TransportCredentials {
-	var sn string
-	if viper.GetString("peer.tls.serverhostoverride") != "" {
-		sn = viper.GetString("peer.tls.serverhostoverride")
-	}
-	var creds credentials.TransportCredentials
-	if config.GetPath("peer.tls.rootcert.file") != "" {
-		var err error
-		creds, err = credentials.NewClientTLSFromFile(config.GetPath("peer.tls.rootcert.file"), sn)
-		if err != nil {
-			grpclog.Fatalf("Failed to create TLS credentials %v", err)
-		}
-	} else {
-		logger.Panic("peer.tls.rootcert.file isn't configured")
-	}
-	return creds
-}
-
 func InitTLSForShim(key, certStr string) credentials.TransportCredentials {
 	var sn string
 	priv, err := base64.StdEncoding.DecodeString(key)
diff --git a/core/peer/peer.go b/core/peer/peer.go
index e09f758a..cbecb3d3 100644
--- a/core/peer/peer.go
+++ b/tmp/peer.go
@@ -7,7 +7,10 @@ SPDX-License-Identifier: Apache-2.0
 package peer
 
 import (
+	"crypto/tls"
+	"crypto/x509"
 	"fmt"
+	"io/ioutil"
 	"net"
 	"runtime"
 	"sync"
@@ -30,6 +33,7 @@ import (
 	"github.com/hyperledger/fabric/core/committer"
 	"github.com/hyperledger/fabric/core/committer/txvalidator"
 	"github.com/hyperledger/fabric/core/common/privdata"
+	"github.com/hyperledger/fabric/core/config"
 	"github.com/hyperledger/fabric/core/ledger"
 	"github.com/hyperledger/fabric/core/ledger/customtx"
 	"github.com/hyperledger/fabric/core/ledger/ledgermgmt"
@@ -45,6 +49,8 @@ import (
 	"github.com/spf13/viper"
 	"golang.org/x/sync/semaphore"
 	"google.golang.org/grpc"
+	"google.golang.org/grpc/credentials"
+	"google.golang.org/grpc/grpclog"
 )
 
 var peerLogger = flogging.MustGetLogger("peer")
@@ -671,7 +677,7 @@ func GetLocalIP() string {
 func NewPeerClientConnectionWithAddress(peerAddress string) (*grpc.ClientConn, error) {
 	if comm.TLSEnabled() {
 		return comm.NewClientConnectionWithAddress(peerAddress, true, true,
-			comm.InitTLSForPeer(), nil)
+			InitTLSForPeer(), nil)
 	}
 	return comm.NewClientConnectionWithAddress(peerAddress, true, false,
 		nil, nil)
@@ -809,3 +815,43 @@ func (*configSupport) GetResourceConfig(channel string) cc.Config {
 	}
 	return chain.cs.bundleSource.ConfigtxValidator()
 }
+
+// InitTLSForPeer returns TLS credentials for peer
+func InitTLSForPeer() credentials.TransportCredentials {
+	var sn string
+	if viper.GetString("peer.tls.serverhostoverride") != "" {
+		sn = viper.GetString("peer.tls.serverhostoverride")
+	}
+	var creds credentials.TransportCredentials
+	if config.GetPath("peer.tls.rootcert.file") != "" {
+		var err error
+		var cp *x509.CertPool
+		var cc tls.Certificate
+		cp, err = CertPoolFromFile(config.GetPath("peer.tls.rootcert.file"))
+		if err != nil {
+			grpclog.Fatalf("Failed to create TLS credentials %v", err)
+		}
+		cc, err = GetClientCertificate()
+		if err != nil {
+			grpclog.Fatalf("Failed to create client TLS certificate %v", err)
+		}
+		tlsConfig := &tls.Config{RootCAs: cp, Certificates: []tls.Certificate{cc}, ServerName: sn}
+		creds = credentials.NewTLS(tlsConfig)
+	} else {
+		creds = credentials.NewClientTLSFromCert(nil, sn)
+	}
+	return creds
+}
+
+// CertPoolFromFile reads cert pool from file
+func CertPoolFromFile(certFile string) (*x509.CertPool, error) {
+	b, err := ioutil.ReadFile(certFile)
+	if err != nil {
+		return nil, err
+	}
+	cp := x509.NewCertPool()
+	if !cp.AppendCertsFromPEM(b) {
+		return nil, fmt.Errorf("credentials: failed to append certificates")
+	}
+	return cp, nil
+}
-- 
2.14.3 (Apple Git-98)

